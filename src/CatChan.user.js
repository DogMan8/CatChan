// ==UserScript==
// @name CatChan
// @version 2018.12.16.0
// @description Cross domain catalog for imageboards
// @include http*://*krautchan.net/*
// @include http*://boards.4chan.org/*
// @include http*://boards.4channel.org/*
// @include http*://i.4cdn.org/*
// @include http*://8chan.co/*
// @include http*://8ch.net/*
// @include http*://lainchan.org/*
// @include http*://lainchan.jp/*
// @include http*://*meguca.org/*
// @include http://localhost/*
// @require https://cdnjs.cloudflare.com/ajax/libs/Chart.js/1.0.1-beta.4/Chart.min.js
// @updateURL https://raw.github.com/Dogman8/CatChan/master/CatChan.meta.js
// @grant unsafeWindow
// @grant GM_xmlhttpRequest
// ==/UserScript==
//
//    Copyright 2014 DogMan8
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU Affero General Public License as published by
//    the Free Software Foundation, version 3 of the License.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU Affero General Public License for more details.
//
//    You should have received a copy of the GNU Affero General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//


(function (){
//  if (window.top != window.self) return; //don't run on frames or iframes
//if (window.top != window.self && window.name!='KC' && window.name!='4chan' && window.name!='8chan') return; //don't run on frames or iframes
if (window.top != window.self && window.name==='') return; //don't run on frames or iframes
if (window.name==='post_tgt' && window.location.href.indexOf('localhost')!=-1) return;




//  http://stackoverflow.com/questions/9791489/greasemonkey-require-does-not-work-in-chrome
//  http://stackoverflow.com/questions/2246901/how-can-i-use-jquery-in-greasemonkey-scripts-in-google-chrome
//  http://stackoverflow.com/questions/17341122/link-and-execute-external-javascript-file-hosted-on-github

  var brwsr = {
    ff: (navigator.userAgent.indexOf("Firefox") != -1),
    sw_cache: true,
    JSON_parse: function(val){ // patch for Tampermonkey.
                       var retval = JSON.parse(val);
//                       if (GM_setValue)
//                       if (typeof(retval)==='object')
//                       for (var i in retval) if (typeof(retval[i])==='string' && retval[i].startsWith('[') && retval[i].endsWith(']')) retval[i] = brwsr.JSON_parse(retval[i]);}
                       for (var i in retval) if (typeof(retval[i])==='string' && retval[i].search(/^\[.*\]$/)!=-1) retval[i] = brwsr.JSON_parse(retval[i]);
                       return retval;
                     },
  };
  brwsr.innerText  = (!brwsr.ff)? 'innerText' : 'textContent';
  brwsr.Date_parse = (!brwsr.ff)? Date.parse : function(str){
    var time = Date.parse(str);
    if (isNaN(time)) {
      var idx = str.lastIndexOf('.');
      time = Date.parse(str.substr(0,idx)) + parseInt(str.substr(idx+1,3));
    }
    return time;
  };
//  brwsr.Date_parse = (!brwsr.ff)? Date.parse : function(str){return Date.parse(str.replace(/ /,'T'));};
  brwsr.document_body = (!brwsr.ff)? document.body : document.documentElement;
  brwsr.mousewheel = (!brwsr.ff)? 'mousewheel' : 'DOMMouseScroll';

  var DelayBuffer = function(tgt, delay){
    this.tgt = tgt;
    this.delay = delay;
    this.id = null;
    this.do_tgt = this.do_tgt.bind(this);
  };
  DelayBuffer.prototype = {
//    constructor: DelayBuffer,
    do_tgt: function(){this.id = null; this.tgt();}, 
    delayed_do: function(delay){
      if (this.id===null) {
        if (delay===undefined) delay = this.delay;
        this.id = setTimeout(this.do_tgt,
                             (typeof(delay)==='number')? delay : (this.hasFocus)? delay.fg : delay.bg);
      }
    },
    cancel: function(){if (this.id!==null) {clearTimeout(this.id);this.id=null;}},
    get_binded_delayed_do: function(){return this.delayed_do.bind(this);},
    hasFocus: true
  };
 
  var Watchdog = function(tgt, delay){
    DelayBuffer.call(this, tgt, delay);
  };
  Watchdog.prototype = {
//    constructor: Watchdog,
    start: function(delay){this.delayed_do(delay);},
    stop: function(){this.cancel();},
    restart: function(delay){this.cancel();this.delayed_do(delay);},
    __proto__: DelayBuffer.prototype
  };

////  var MutexWatchdog = function(name){ // watchdog for 8chan's unstability. // working code, @safe1069
////    this.mutex = true;
////    this.req = false;
////    this.name = name;
////    this.abort_req = false;
////    this.wdg = new Watchdog(this.fire.bind(this), 30000);
//////    this.wdg = new DelayBuffer(function(){ // working code.
//////      this.mutex = true;
//////      if (pref.debug_mode['7']) console.log('watchdog: '+this.name);}.bind(this), 30000);
////  }
////  MutexWatchdog.prototype = {
////    get: function(){
////      if (this.mutex && !this.abort_req) {
////        this.mutex = false;
////        this.wdg.start();
////        if (pref.debug_mode['5']) console.log('mutex: get: '+this.name);
////        this.req = false;
////        return true;
////      } else {
////        if (!this.abort_req) this.req = true;
////        if (pref.debug_mode['5']) console.log('mutex: fail: '+this.name);
////        this.abort_req = false;
////        return false;
////      }
////    },
////    restart: function(delay){
////      this.wdg.restart(delay);
////    },
////    stop: function(){
////      this.wdg.stop();
////      this.mutex = true;
////      if (pref.debug_mode['5']) console.log('mutex: release: '+this.name);
////    },
////    fire: function(){
////      this.mutex = true;
////      cataLog.scan_boards.scan_abort(this.name);
////      if (pref.debug_mode['7']) console.log('watchdog: '+this.name);
////    },
////    abort: function(){
////      this.abort_req = true;
////      this.stop();
////    },
////    query_req: function(){
////      return this.req;
////    }
////  }

  var common_func = {
    Object_modifyDescriptor: function(obj,prop,desc){
      desc.__proto__ = Object.getOwnPropertyDescriptor(obj,prop);
      Object.defineProperty(obj,prop,desc);
    },
  };

  var site0 = (function(){ // for less memory consumption and faster execution if background
    var href = window.location.href;
    var domain = null;
    var pref_default = null;
    var pref_default2 = null;
    var href = window.location.href;
    if (href.indexOf('/meguca.org/')!=-1) {
      domain = 'meguca';
      pref_default = {
        pref2:{ meguca:{utilize_boards_json:false, utilize_boards_json_domain:false}},
      // overwritten by easy2 default.
        thread:{ env:{ disp_offset:3}},
        scan:{max:100},
        proto:{env:{event_dynamic:true,}},
        style:{zIndex:300},
        tooltips:{zIndex:302},
      };
      pref_default2 = true;
    } else if (href.search(/(4chan(nel)*|4cdn).org/)!=-1) {
      domain = '4chan';
      pref_default = {
        catalog_expand_with_hr: true,
        page:{env:{disp_filler:'<hr>'}},
        patch: {delayed_invoke: {use: brwsr.ff}},
        catalog: {t2h_sel:'N', thumbnail:{hover:{popup_zIndex:100001}}},
        proto:{
          env:{
            event_dynamic: true,
          }
        },
        easy2:{limits:2},
      };
    } else if (href.indexOf('lainchan.org')!==-1) {
      domain = 'lain';
      pref_default = {
        page:{ env:{ disp_offset:1}},
        catalog:{image_hover:true, board:{all_boards:true}, env:{disp_offset:1, disp_filler:'                                        '}},
        proto:{ env:{ localtime_native:false,
                      colorID_native: false}},
        stats:{ time_unit:3, patch_tm:true},
        chart: {inst:{show: {p:true}, time_sel:3}},
        easy2:{limits:1},
        thread_reader:{own_posts_tracker:true},
      };
    } else if (href.indexOf('lainchan.jp')!=-1) {
      domain = 'lainjp';
      pref_default = {
        page:{ env:{ disp_offset:1}},
        proto:{ env:{ localtime_native:false,
                      colorID_native: false}},
        stats:{ time_unit:3, patch_tm:true},
        chart: {inst:{show: {p:true}, time_sel:3}},
      // overwritten by easy2 default.
        catalog:{image_hover:true, board:{all_boards:true}, env:{disp_offset:1, disp_filler:' '},},
        thread: {auto_update:true},
        thread_reader:{own_posts_tracker:true},
        scan:{max:100},
        liveTag:{style_urtm_str:'color:lime !important;font-weight:bold !important',
                 style_ur_str:'color:limegreen !important;font-weight:bold !important',
                 style_in_str:'color:red !important'},
        virtualBoard:{scanDelay:1},
        easy2:{limits:1},
        style:{post_new:'border:2px solid red !important'},
      };
      pref_default2 = true;
    } else if (href.search(/8chan.co|8ch.net/)!=-1) {
      domain = '8chan';
      pref_default = {
        catalog_expand_with_hr: true,
        page:{ env:{ disp_offset:1, disp_filler:'<hr>'}}};
    } else if (href.search(/krautchan.net/)!=-1) {
      domain = 'KC';
      pref_default = {
        thread_reader:{own_posts_tracker:true, check_num_of_children: false},
        proto:{
          env:{
            popup_native:false,
            expand_thumbnail_inline_native:false,
            image_hover_native:false,
            colorID_native:false,
            backlink_native:false,
            localtime_native:false,
            auto_update_native:false,
          },
        },
        page:{use_expander_always:true},
      };
    }
    var domains = ['meguca', '4chan', 'lain', 'lainjp', '8chan', 'KC'];
    if (domain) domains.unshift(domains.splice(domains.indexOf(domain),1)[0]);
    var domains_all = ['CatChan_tgt','8chan','8chan_live','vichan','KC','4chan_i','4chan','meguca','imeguca','lain','lainjp'];
    if (pref_default2) {
      pref_default2 = {// new default patch
        catalog:{auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true},
        liveTag: {use:false, from:'op'},
        virtualBoard:{max:100, scan:true, scan_domains:{}}, 
        network:{fetch_actively:false},
        easy2:{presets:1,VB:{local:1},catalog:{auto_update:false},page:{auto_update:false}},
      };
      pref_default2.virtualBoard.scan_domains[domain] = 'board';
    }
    return {
      domain: domain,
      domains: domains,
      pref_default: pref_default,
      pref_default2: pref_default2,
      domains_obj: function(val, protect){
        var obj={};
        for (var i=0;i<domains.length;i++) obj[domains[i]] = val;
        if (protect) common_func.Object_modifyDescriptor(obj,domain,{writable:false});
        return obj;
      },
      isStep: window.opener && domains_all.indexOf(window.name)!=-1,
    };
  })();

  var pref4 = { // dynamic, but not auto sync objects.
    funcs:{
      set_options_to_selector: function(sel,options){
        sel.length = options.length;
        for (var i=0;i<options.length;i++) sel.options[i].text = options[i];
      },
    },
    archive: {
      IDB_board_sel_gfunc_pre:function(p,k,v,n,f){
        pref4.funcs.set_options_to_selector(f,pref4.archive.IDB_board_sel_options || ['Wait...']);
      },
      IDB_board_sel_options: null,
      IDB_thread_sel_gfunc_pre:function(p,k,v,n,f){
        pref4.funcs.set_options_to_selector(f,pref4.archive.IDB_thread_sel_options || ['Wait...']);
      },
      IDB_thread_sel_options: null,
    },
    refresh:{ count:0},
    search_posts_active_once: false,
    scan: {
      get loosen(){return pref4.search_posts_active_once && pref.proto.searchAc.loosen;},
      get max(){return this.loosen? pref.proto.searchAc.max : pref.scan.max;},
      get max_threads(){return this.loosen? pref.proto.searchAc.max_threads : pref.scan.max_threads;},
      get max_threads_at_refresh(){return this.loosen? pref.proto.searchAc.max_threads_at_refresh : pref.catalog.max_threads_at_refresh;},
    }
  };
  
  function pref_default(for_save) {
    var proto = {
      image_hover:false,
      image_prefetch:false,
      click: 'none',
      click_area: 'thumbnail',
      format: {show:  {style:  true, contents:  true, layout:  true, posts: false, fileinfo: false, images_2nd: true},
               hover: {style:  true, contents: false, layout: false, posts:  true, fileinfo:  true, images_2nd: true},
               search:{style: false, contents: false, layout: false, posts:  true, fileinfo:  true, images_2nd: true},
               thumb: {resize: false},
      },
      footer: {use:true, nrtm:true, nr:true, rp:true, im:true, domain:false, board:true, no:false, flag:false, tag:true, page:true, design:'native',
               custom_str: '(ar )(nm/)(nr/)(lp/)(rp)(+dp)(/im)(/pg) (ni/nf) (ct )(cT )(bt )(bT )(pt )(pT )(pr )(dn)(bd)(no) ',
               ctime:false, btime:false, ptime:false, rctime:false, rbtime:false, rptime:false, br:true, prate:false, archived:true, nd:false, nl:false, nf:false, nid:false},
      draw_on_demand: true,
      load_on_demand: false,
      t2h_sel: 'page',
      t2h_L: 100,
      t2h_M: 50,
      get t2h_N(){return this.t2h_num_of_posts},
      t2h_num_of_posts : 5,
      save_board_list_sel: false,
      board_list_sel: 0,
      mark_new_posts: true,
      auto_update : false,
      auto_update_period : 10,
      auto_update_countdown : true,
      storePosts:'auto', sourceOfSP:'auto', searchAs:true, searchAsA:false, searchAc:{loosen:true, max:1000, max_threads:10000, max_threads_at_refresh:10000},

      popup:true, colorID:true, backlink:true, popup_truncated:true, popup_zIndex:100,
      popup_hlt:true, bl_ec:false, bl_rm:true,  // popup_highlight, backlink_explicit_cross, baclink_remove_if_OP
      popup_delay:50, popdown_delay:500, popdown:'delay', popup_mMove:true,
      link_show_op:true, link_show_cross:true,
      expand_thumbnail_inline:true, localtime:true,
      expand_thumbnail_inline_all_after:false,
      expand_thumbnail_initial:false,
      hide_posts_without_images:false,
      thumbnail:{
        inline:{limit_width: true, limit_height:false, margin_width: 40, margin_height: 0, webm: true, webm_mute:false, webm_loop:false, ondemand:true, ref_height:400},
        hover: {limit_width: true, limit_height: true, margin_width: 40, margin_height: 0, webm:false, webm_mute: true, webm_loop:false,
                popup_delay:50, popdown_delay:500, popdown:'delay', popup_mMove:true, popup_zIndex:101,
                dragfloat:true, df_dblC:true, df_mW:true, df_cV:true, zoom:false},
      },
      open_spoiler_text: false,
      open_spoiler_image: false,
      merge: false, merge_list: true, merge_list_str: '', merge_list_obj6: null, merge_first: true,
      merge_lv:true, merge_lv_str:'', merge_lv_obj6:null,
      lazyDraw: {merge: true, merge_step: 256, step: 16},
      scroll_lock: false,
      use_expander_always: false,
      popup2:'sr',
      popup2_sel:'auto', popup2_sel_tolerance:10, popup2_resize:false, popup2_resize_bw:8, popup2_resize_cw:20,
      popup3: {ww:'no', wn:'no', nw:'no', nn:'no', popup_delay:300, popdown_delay:500, popdown:'delay', popup_mMove:true, popup_zIndex:100},
      posts_search_op: 'opaque',
      posts_search_op_opacity: 40,
      deleted_posts: {detect:'acc', store:'LS', merge:true, auto_clean:true},
//      auto_config_posts_search: true,
      imagesearch: {
        use: true,
        google: true,
        iqdb: true,
        saucenao: true,
        whatAnime: true,
        desustorage: true,
        exhentai: true,
      },

      env: {
        disp_offset:0,
        disp_filler:null,
        popup_native:true,
        expand_thumbnail_inline_native:true,
        image_hover_native:false,
        colorID_native:true,
        backlink_native:true,
        localtime_native:true,
        auto_update_native:false,
        event_dynamic:false,
        popup_native_kill:true,
      },
    };
    var pref_new = {
      script_prefix: 'CatChan',
      features: {
        page: true, graph: true, setting: true, setting2: true, postform: true, catalog: true, listener : true, uip_tracker: true, thread_reader: true, debug: false,
        notify:{desktop:true, sound:true, favicon:true},
        recovery: true,
        domains: site0.domains_obj(true, true),
      },
      max_capture: 576,
      interval_found: 10,
      write_to_ls: true,
      aggregator: 'true', // radiobutton
      server: true,
      load_pref: true,
      load_data: true,
      check_page: false,
      check_post: false,
      check_thread: false,
      import_format: 'obj', // radiobutton
      max_graph: 576, // radiobutton
      scale_thread: 10,
      auto_start: true,
//      workaround_for_dollchan: false,
      prevent_redirection: false,
      graph_animation: false,
      autoconf: 'auto',
      info_server: false,
      info_client: false,
      wafd_tb: 'tb',
      wafd_open_spoiler: false,
      show_page_fraction : true,
      catalog_max_page: 5,
      catalog_max_page_auto: true,
      catalog_max_page_select: 'auto',
      catalog_snoop_refresh: true,
      catalog_auto_rollup_when_moving: true,
      catalog_size_width: 240,
      catalog_size_height: 350,
      catalog_size_text_width: 400,
      catalog_size_text_height: 16,
      catalog_size_tn1_width: 240,
      catalog_size_tn1_height: 240,
      catalog_size_tn2_width: 80,
      catalog_size_tn2_height: 80,
      catalog_size_frame0_width: 30,
      catalog_size_frame1_width: 69,
//      catalog_enable_cross_board: true,
//      catalog_enable_cross_domain: true,
      catalog_load_on_demand_timeout: 10,
      catalog_2nd_images_show: false,
      catalog_2nd_images_hover: true,
      catalog_2nd_images_search: true,
      catalog_posts_on_demand: true,
      catalog_refresh_clear: true,
//      catalog_checkbox_deletion_show: false,
//      catalog_checkbox_deletion_hover: true,
//      catalog_checkbox_deletion_search: true,
//      catalog_popup: true,
      catalog_popdown: 'delay',
      catalog_popup_delay: 300,
      catalog_popdown_delay: 500,
      catalog_popup_size_fix: true,
      catalog_open_last50: 'exist_watch',
      catalog_board_list_str: '//sample of board group\n' +
//        '//board_name[,nickname+board_name[+thread No.] | \'*\'+up to X page | \'^\'+style]...\n'+
        '//board_name[,nickname+board_name[+thread No.][\'*\'+up to X page]]..., [#Tag|##Tag]..., [!stats]\n'+
        'Global/int/,8chan/int/,KC/int/,4chan/int/\n'+
        'Global/b/,8chan/b/,KC/b/,4chan/b/\n'+
        'v+gg,8chan/v/,8chan/gamergatehq/,4chan/v/\n'+
        'Inter/pol/,8chan/pol/,4chan/pol/\n'+
        'JapanShoppingMall,8chan/jpck/,8chan/japan2/\n'+
        'tech,meguca/g/,lain/tech/,8chan/tech/,4chan/g/,KC/t/\n',
//        'ScriptHome,8chan/scriptcdc/,KC/jp/35003\n',
//        'script_home,8chan/scriptcdc/,KC/jp/35003,KC/kc/41434\n',
      catalog_board_list_obj: [],
      catalog_promiscuous: false,
//      catalog_board_list_sel: 0,
      get catalog_board_list_sel() {return (cataLog && cataLog.embed_mode && this[cataLog.embed_mode])? this[cataLog.embed_mode].board_list_sel : 0;},
      set catalog_board_list_sel(val) {if (cataLog && cataLog.embed_mode && this[cataLog.embed_mode]) this[cataLog.embed_mode].board_list_sel = val;},
//      catalog_sw_domain: 'https://8chan.co',
      localtime_offset : -(new Date().getTimezoneOffset()/60),
//      catalog_localtime : true,
//      catalog_border_show : false,
//      catalog_border : '1px solid',
//      catalog_enable_background : false,
      catalog_footer_ignore_my_own_posts : true,
      catalog_footer_tag_letters : 3,
      catalog_no_popup_at_expanded : true,
      catalog_open_in_new_tab : true,
      catalog_open_where : 'named',
      catalog_open_where_click : true,
//      catalog_use_named_window : true,
      catalog_triage : true,
      catalog_triage_place : 'topLeft',
      catalog_triage_hist : 16,
      triage:{ show_always:false, popdown_delay:2000, hide_toggle:true},
//      catalog_triage_str : '["background:#e5ecf9","background:#c3dcf9","background:#b8efc2",'+
//        '"background:#efedbe","background:#fbd5fb","background:#fac2c5"]// defalut\n' +
//        '//["background:#e5ecf9;border:none","background:#c3dcf9;border:1px solid #a3bcd9",'+
//        '"background:#b8efc2;border:1px solid #98cfa2","background:#efedbe;border:1px solid #cfcd9e",' +
//        '"background:#fbd5fb;border:1px solid #ebb5db","background:#fac2c5;border:1px solid #daa2a5"]// backgroud+border',
      catalog_triage_str: 'KILL,X,,TIME,v,,WATCH,W,,UNWATCH,UW,,UNDO,U,',
//      catalog_triage_str : '//default\n'+
//        'KILL,X,,KILL,X,background:#c3dcf9,KILL,X,background:#b8efc2,'+
//        'KILL,X,background:#efedbe,KILL,X,background:#fbd5fb,KILL,X,background:#fac2c5\n'+
//        'TIME,v,,TIME,v,background:#c3dcf9,TIME,v,background:#b8efc2,'+
//        'TIME,v,background:#efedbe,TIME,v,background:#fbd5fb,TIME,v,background:#fac2c5\n'+
//        'NONE,O,,NONE,O,background:#c3dcf9,NONE,O,background:#b8efc2,'+
//        'NONE,O,background:#efedbe,NONE,O,background:#fbd5fb,NONE,O,background:#fac2c5\n'+
//        'UNDO,U,,WATCH,Watch,,UNWATCH,UnWatch,\n'+
//        '// sample\n'+
//        '//KILL,back_to_default,,NONE,border,background:#c3dcf9;border:3px solid blue,NONE,transparent,background:,NONE,shrink,width:100px;height:100px\n'+
//        '//\n'+
//        '// 1st column :\n'+
//        '//   KILL : delete forever.\n'+
//        '//   TIME : delete until the thread gets new replies.\n'+
//        '//   NONE : just change its appearance.\n'+
//        '// 2nd column : strings in the button.\n'+
//        '// 3rd column : style in HTML.\n'+
//        '// Repeat these as you wish.\n',
//        'KILL,'\u2715',,TIME,'\u2713',,NONE,'O',
//      catalog_auto_update : false,
//      catalog_auto_update_period : 10,
      catalog_auto_update_countdown : true,
//      catalog_show_setting : false,
      catalog_expand_at_initial : false,
      catalog_expand_at_initial_embed : true,
      catalog_expand_with_hr : false,
      overwrite_site2_json_str:
        '//{"site2":{"KC":{"time_offset":2}}} // summer time for KC.\n'+
        '//{"site2":{"4chan":{"protocol":"https:"}}} // use https to 4chan.\n'+
        '//{"pref":{"patch":{"rm_404_blacklist":["8chan"]}}} // 8chan sends corrupted data.\n',
      overwrite_site2_eval_str: '',
//      show_tooltip : true,
      tooltips: {help: {show: true, popup_delay:2000, popdown_delay:1000},
                 info: {show: true, popup_delay:300,  popdown_delay:500},
                 zIndex:100},
      catalog: {
        indexing: 0,
//        max_threads : 512,
        max_threads_at_refresh : 500,
        filter: {
//          show : false,
          kwd : {use: false, str: '', re: false, ci: true, match: 0, op: true, post: false,
                 sub: true, name: true, trip: false, com: true, file: false, meta:false, sentence:false,    rexps:null},
          tag      : false,
//          tag_list_str : '',
//          tag_scan_auto : false,
          tag_ci   : false,
          time     : false,
          time_creation : false,
          time_str : new Date(Date.now()-86400000).toLocaleString(),
          time_obj : true,
//          time_ago_str : '24:00',
          time_ago_str : '0:00',
          time_ago_str_sync_at_refresh : false,
          time_track : false,
//          time_mark : false,
          desktopime_mark_str : '',
          time_watch : false,
          time_watch_creation : false,
          list_time_scroll: true,
          list : true,
//          list_mark_time : true,
          list_str : '',
//          list_obj : [],
          list_obj2 : {},
          attr_list : true,
          attr_list_str : '',
          attr_list_obj2 : {},
          bookmark_list : true,
          bookmark_list_str : '',
          bookmark_list_obj2 : {},
          watch_list_str : '',
          watch_list_obj2 : {},
//          watch_list_mark_time : true,
//          tag_scansite : true,
          tag_search: {str:'', re:false, show_nof_boards:false,   get ci(){return pref.liveTag.ci;}, sentence:false, rexps:null},
          tag2bList: {label:'', by:'tag'},
        },
        bookmark_list_rm404 : true,
        auto_load_filter : false,
        auto_save_filter : false,
        auto_save_filter_at_refresh : false,
        tag : {ignore:12, max:12},
        board: {recommendation: true, all_boards:false, board_tags: false, ex_list: false, ex_list_str: '', ex_list_obj2: {}, board_tags_same: false},
        style_general_list : true,
        style_general_list_str : 
          '//^background:#e5ecf9\n'+
          '//^border:1px solid black\n'+
          '//8chan^background:#eef2ff;border:1px solid #d6daf0\n'+
          '//8chan^background:#eef2ff\n'+
          '//KC^background:#e0e0fc;border:1px solid #aaaacc\n'+
          '//4chan^background:#ffffee;border:1px solid #f0e0d6\n',
        style_general_list_obj2 : {},
        refresh : {initial : true, except_bt : true, at_switch: true},
        design : 'auto',
        catalog_json : true,
        embed : true,
        embed_page: true,
        embed_frame : true,
//        order : {reply_to_me: true, reply: true, watch: 'dont_care', sticky:'dont_care', find_sage_in_8chan: false},
        order : {reply_to_me: true, reply: true, watch: 'dont_care', sticky:'dont_care'},
//        health_indicator: {on: true, max:10},
        auto_watch: true,
        unmark_on_hover: true,
        mimic_base_site: true,
        text_mode: {mode:'graphic', sub:true, name:false, com:true},
        appearance: {
          titleBar: {filter: true, settings: true, refresh: true, num_of_pages: true, boards_selector: true},
          initial: {state: 'max', width: 400, height: 400}
        },

        t2h_sel: 'no',
        click: 'open',
        env:Object.create(proto.env),
        __proto__: proto},
      filter: {disable_list_when_kwd_active:true},
      page: {
        get embed(){return pref.catalog.embed_page;},
        infinite: false, 
//        scan_tag:true,
        format: {show:{style:false, contents:false, layout:false, posts:true, fileinfo:true, images_2nd:true},
                 __proto__:proto.format},
        image_hover:true,
        footer: {br:false, __proto__:proto.footer},
        load_on_demand: true,
        env:Object.create(proto.env),
        __proto__: proto},
      thread: {
        embed: false,
        format: {show:{style:false, contents:false, layout:false, posts:true, fileinfo:true, images_2nd:true},
                 __proto__:proto.format},
        image_hover:true,
        footer: {br:false, __proto__:proto.footer},
        env:{auto_update_native:true, __proto__:proto.env},
        t2h_num_of_posts : -1,
        auto_update: false,
        __proto__: proto},
      float: {
        click: 'open',
        format: {thumb: {resize: true},
                 __proto__:proto.format},
        save_board_list_sel: true,
        env:Object.create(proto.env),
        __proto__: proto},
      common: {
        clear_at_manual_scan : false,
      },

//      graph : {key: null, pipe: null},
      uip_tracker: {on : false, posts: true, deletion: true, interval: 10, adaptive: true, highlight_str:'color:red', annotate:true,
                    auto_open:false, auto_open_th:300, auto_open_kwd:'',
                    deletion: {show:true, link:true, name:true, name_str:'color:red', addName:true, addName_str:'DELETED_', post:false, post_str:'opacity:0.4'},
                    sage: {detect:true, name:true, name_str:'color:blue', addName:false, addName_str:'SAGE_', post:false, post_str:'opacity:0.4', tolerance:1,
                           patch_bug:false, patch_bug2:false, patch_bug2nth:8, patch_bug3:true}},
      thread_reader: {use: true, sync: true, triage: true, triage_close: true, check_num_of_children: true,
        own_posts_tracker: false, show_own_post_by: 'anchor', show_reply_to_me_by: 'anchor', clean_up_own_posts: true},
      settings: {indexing: 0},
      tag : {gen: false, gen_str:''}, // dummy for checkbox and textarea.
      cloudflare: {auto_reload: true, auto_reload_time: 5},
      scan: {max:10000, lifetime:20, crawler:50, max_threads:1000, crawler_adaptive:true, crawler_idle_time_to_spawn:100},
      notify : {sound: {notify: false, src:'beep', beep_freq:1000, beep_length_f:0.2, beep_volume_f:1, reply_to_me: true, reply: true, new_thread: true, appear: true, supp_init:true},
                desktop: {notify: true, reply_to_me: true, reply: true, new_thread:true, appear:true, lifetime:30, show_last:false, supp_init:true,
                          limit:(brwsr.ff)? 10 : 30, delay:(brwsr.ff)? 500 : 0},
                favicon: true,
                title: {notify:true, hide_zero: true},
               },
      liveTag: {
        use: true, max: 12, maxstr: 25, from:'post', lock_tags_in_op: true, ci: true,
        inherit_board_name: true, lock_board_name: true, inherit_board_tags: true, lock_board_tags: true,
        info: true, style: true,
        style_urtm_str:'color:lime;font-weight:bold', style_ur_str:'color:limegreen;font-weight:bold', style_in_str:'color:red', style_ex_str:'color:blue',
//        style_urtm_obj4:{},                           style_ur_obj4:{},                                style_in_obj4:{},
        pickup_interval: 10, rm_404_immediately: true, disp_delay:{fg:500, bg:5000}, click_func: 'in', click_func_bl: 'pkin',
        watch_all: true, lazy_each:150, lazy_delay:100,
        ex_list: true, ex_list_str:'8chan:#selection\n', ex_list_obj5:[],
        rm_list: true, rm_list_str:'http*\n', rm_list_obj5:[]},
      virtualBoard: {
        show: true, max:20, scan: false, scanDelay: 5, p_board: 'replace', p_remove: false, v_remove:true,
        scan_domains: site0.domains_obj('none'),
//        scan_domains: {meguca:'none', lain:'none', '8chan':'none', '4chan':'none', KC:'none', lainjp:'none'},
        instant_scan: true,
        search: {show: true,  str:'', re:false,    get ci(){return pref.liveTag.ci;}, sentence:false, rexps:null},
      },
      style:{
        sel: 'fix', zIndex:1,
        fix:{
          titleBar_str:'background:#b5ccf9;border:1px solid blue;font-weight:normal',
          window_str:'background:#e5ecf9;color:#000000;font-weight:normal',
          popUp_str:'background:#e5f4f9;color:#000000;border:2px solid blue;font-weight:normal'
        },
        copy:{titleBar_str:'body', window_str:'body', popUp_str:''},
        post_editing: 'background:#cec952 !important',
        post_new: 'border:2px solid red',
        userCSS: {use:false, str:'',
          sample:'.CatChan_titleBar button[name^="op"]{display:none} /* remove transparency buttons in titleBar */\n'+
            '.CatChan_merge1::before{float:left;content:">";} /* levelized merge */\n'+
            '.CatChan_merge2::before{float:left;content:">>";}\n'+
            '.CatChan_merge3::before{float:left;content:">>>";}\n'+
            '.CatChan_merge4::before{float:left;content:">>>>";}\n'+
            '.CatChan_merge5::before{float:left;content:">>>>>";}\n'+
            '.CatChan_merge1{border-left:10px solid red;} /* colored merge */\n'+
            '.CatChan_merge2{border-left:10px solid orange;}\n'+
            '.CatChan_merge2{border-left:10px solid yellow;}\n'+
            '.CatChan_merge2{border-left:10px solid green;}\n'+
            '.CatChan_merge3{border-left:10px solid blue;}\n'+
            '.CatChan_titleBar button[name="roll_toggle"]{display:none} /* remove toggle button in titleBar */\n'+
            '.CatChan_titleBar button[name="max"]{display:none} /* remove maximize button in titleBar */\n'+
            '.CatChan_titleBar button[name="top"]{display:none} /* remove embed to top button in titleBar */\n'+
            '.CatChan_titleBar button[name="bottom"]{display:none} /* remove embed to bottom button in titleBar */\n'
        },
      },
      recovery:{comment:true, interval:10, auto_clean:true},
      healthIndicator: {show:true, max:10, expand_running:false, dont_retire_running:true, cancel:true},
      network: {cross_domain:'indirect', fetch_actively:true, adaptive:true, th100:5, th100_delay:500, th20:10, th20_delay:100, timeout:15, overXFO:true, overCSPF:true},
      stats: {use:false, retain_404:true, draw_delay:10, estimate_posts:true,
              save:true, load:true, len_capture:1440, auto_acquisition:true, auto_acquisition_scan:true, auto_acquisition_scan_delay:120, auto_acquisition_all:false, 
              tolerant:true, tolerance:90, patch_tm:false},  // patch_tm is a patch for thread moving in lainchan or 4chan/bant/.
      chart: {off_anime_blur:true, window_width:400, window_height:400, instant_scan:true, load_on_demand:false,
              inst:{len:120, scale_thread:10, time_sel:1, board_sel:0, show_legend:true, // separate:false, 
                    show: {np:true, p:false, ep:false, nt:false, t:true, et:false}, clip_np:false, clip_np_val:0,
                    options: {bezierCurve: false, animation:false, pointDot:true, pointDotRadius:4}}},
      archive:{load_img:true, restore_auto:true, clear_threads:true, clear_files:false, format:'auto', domain:0, board:'',
               src:'shown', store_auto:false, dir_dled:null, open_local:false, fix_inconsistency: true,
               oneshot: {post:true, tn:true, img:true,  webm:true , post_idb:true, tn_idb:true, img_idb:true,  webm_idb:true},
               live:    {post:true, tn:true, img:false, webm:false, post_idb:true, tn_idb:true, img_idb:false, webm_idb:false},
               deleted: {post:true, tn:true, img:false, webm:false, post_idb:true, tn_idb:true, img_idb:false, webm_idb:false},
               IDB:     {auto_clean:true, auto_clean_init:true, prune:168, prune_flush:false, nof_tr:10, nof_cl:20, nof_cl_max:80, auto_restore:false, auto_restore_remove:true, watchdog:120}, // check_every:1, },
               kwd: {use:true, str:'', re:false, ci:true, match:0, op:true, post:false, sub:true, name:true, trip:false, com:true, file:false, meta:false, sentence:false,    rexps:null},
               list:true,
               list_str:'', list_obj6:null, list_inherit:false,
               tar: true, tarsize: 100, sub_in_filename:true,
//               get list_str(){return pref3.archive.list_str_get();},
//               set list_str(val){pref3.archive.list_str_set(val);},
               files_sel:0,
               IDB_board_sel:0,  IDB_board_sel_gfunc_pre:pref4.archive.IDB_board_sel_gfunc_pre,
               IDB_thread_sel:0, IDB_thread_sel_gfunc_pre:pref4.archive.IDB_thread_sel_gfunc_pre,
               IDB_select_multiple: true,
               editing_timeout: true,
              },
      threadStats: {use:false, full:true},
      debug_mode : {unread_count:'', parse_error:false, site2func:'', site2func_expand:true, pfunc:'', pfunc_expand: true, pfunc_all:'', pfunc_all_expand: true,
                    pfunc_comp:'', pfunc_comp_expand_same:true, pfunc_comp_expand_diff:true, pfunc_comp_proto:'',},
      test_mode: {tips:false, num:0, num_f:0, test_str:''},
      patch: {
        delayed_invoke: {use: false, sec: 10},
        rm_404_blacklist: [], //['8chan'], // 8chan sends corrupted data.
      },
      pref2: {
        KC: {summer_time: false},
        meguca: {
//          get remove_history_class(){return pref.catalog_open_where!=='_self';},
          historyAPI: true,
          utilize_boards_json:true, utilize_boards_json_domain:true,},
        '8chan': {utilize_boards_json:true,},
      },
      easy: {posts_ago:24, threads_ago:24, max_boards:50,},
      easy2: {
        reset: true, presets: 0, time_post:24, time_op:24, basics:true, // easy2 local parameters.
        auto_update:false, auto_update_period:10, // easy2 local parameters.
        VB: {local:0, global:0}, LTfrom: 0, limits:0, // easy2 local parameters.
        virtualBoard: {show:true, scan:true, max:100},
        liveTag: {use:false, from:'op'},
        catalog: {embed:true, embed_page:true, max_threads_at_refresh:500,
                  auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true, auto_update:true, auto_update_period:10,
                  filter: {time_watch:false, time_watch_creation:false},
                 },
        page:{auto_update:true, auto_update_period:10},
        thread: {embed:false, auto_update:true, auto_update_period:10},
        notify:{desktop:{notify:true}},
        stats: {use:false},
        scan:{max:100, max_threads:1000},
        network:{fetch_actively:false},
        healthIndicator:{expand_running:false},
      },
      proto: proto, // for overwrite from pref_default.
    };
    for (var i=0;i<40;i++) pref_new.debug_mode[i] = false;
    for (var i=0;i<120;i++) pref_new.test_mode[i] = false;
    if (site0.pref_default2) pref_func.pref_overwrite(pref_new,site0.pref_default2);
    if (site0.pref_default ) pref_func.pref_overwrite(pref_new,site0.pref_default);
//    if (site) if (site2[site.nickname].pref_default) pref_func.pref_overwrite(pref_new,site2[site.nickname].pref_default);
    if (for_save) pref_func.delete_null(pref_new);
    common_func.Object_modifyDescriptor(pref_new.style.userCSS,'sample',{writable:false});
    return pref_new;
  }

  var pref_func = {
      delete_null: function(dst){
        for (var i in dst) {
          if (dst[i]===null) delete dst[i];
          else if (typeof(dst[i])==='object' && !Array.isArray(dst[i])) pref_func.delete_null(dst[i]);
        }
      },
      pref_overwrite: function(dst,src,strict){
        for (var i in src)
          if (dst[i]!==undefined) {
            if (strict && typeof(src[i])!==typeof(dst[i])) continue;
            if (typeof(src[i])==='object' && !Array.isArray(src[i])) pref_func.pref_overwrite(dst[i],src[i],strict);
//            else dst[i] = src[i];
            else if (dst[i]!==src[i]) dst[i] = src[i]; // utilize prototype
          }
      },
      site2_json: function(query, dumb, enables){
        var pn_out = document.getElementsByName('JSON_result')[0];
        if (pn_out) pn_out.style = {};
        try { 
          if (pref.overwrite_site2_json_str!=='') {
            var fields = pref.overwrite_site2_json_str.split('"');
            var i=0;
            while (i<fields.length) {
              if (fields[i].search(/\/\/.*/)!=-1) {
                while (i+1<fields.length && fields[i].search(/\/\/[^\n]*\n/)==-1) fields[i] += fields.splice(i+1,1);
                fields[i] = fields[i].replace(/\/\/[^\n]*(\n|$)/,'');
              } else i+=2;
            }
            var str = fields.join('"');
            var ex_count = 0;
            var str_out = '';
            var count = 0;
            var start = 0;
            for (var j=0;j<str.length;j++) { // can handle multiple JSON.
              if (count==0 && str[j]!=='{' && str[j]!==' ' && str[j]!=='\n') ex_count++;
              if (str[j]==='{') count++;
              if (str[j]==='}' && --count==0) {
                var obj = JSON.parse(str.substr(start,j-start+1))
                for (var i in obj)
                  if (i==='site2' || i==='pref' || i==='pref_func' || i=='liveTag' || i==='site3')
                    if (!enables || enables.indexOf(i)!=-1)
//                  if ((!disable_others && (i==='site2' || i==='pref' || i==='pref_func' || i=='liveTag')) || (!disable_site3 && i==='site3'))
                      if (!query) pref_func.pref_overwrite(eval(i),obj[i]);
                      else str_out = '{"' + i + '":' + pref_func.pref_query(eval(i),obj[i]) + '}';
                start = j+1;
              }
            }

//            if (str!=='') { // working code.
//            if (str.indexOf('{')!=-1) {
//              var obj = JSON.parse(str);
//              for (var i in obj)
//                if (i==='site2' || i==='pref' || i==='pref_func') pref_func.pref_overwrite(eval(i),obj[i]);
//            }
////          if (pref.overwrite_site2_json_str!=='') { // working code
//////            var str = pref.overwrite_site2_json_str.replace(/\/\/.*/mg,'').replace(/\n/g,'');
////            var fields = pref.overwrite_site2_json_str.split('"');
////            for (var i=0;i<fields.length;i+=2) {
////              if (fields[i].search(/\/\/.*/)!=-1) {
////                if (fields[i].search(/\n/)!=-1 || i+1==fields.length) fields[i] = fields[i].replace(/\/\/[^\n]*(\n|$)/,'');
////                else {
//////                  while (i+1<fields.length && fields[i].search(/\n/)==-1) fields[i++]='';
////                  while (i+1<fields.length && fields[i].search(/\n/)==-1) fields.splice(i,1);
////                  if (i<fields.length) fields[i] = fields[i].replace(/[^\n]*(\n|$)/,'');
////                }
////              }
////            }
////            var str = fields.join('"');
////            var count = 0;
////            var start = 0;
////            for (var j=0;j<str.length;j++) {
////              if (str[j]==='{') count++;
////              if (str[j]==='}') {
////                count--;
////                if (count==0) {
////                  var str_tmp = str.substr(start,j-start+1);
////                  if (str_tmp!=='') {
////                    var obj = JSON.parse(str_tmp);
////                    for (var i in obj)
////                      if (i==='site2' || i==='pref' || i==='pref_func') pref_func.pref_overwrite(eval(i),obj[i]);
////                  }
////                  start = j+1;
////                }
////              }
////            }
//////            if (str!=='') pref_func.pref_overwrite(site2,JSON.parse(str));
//////            if (str!=='') {
//////              var obj = JSON.parse(str);
//////              for (var i in obj)
//////                if (i==='site2' || i==='pref' || i==='pref_func') pref_func.pref_overwrite(eval(i),obj[i]);
//////            }
            if (pn_out) {
              pn_out.textContent = ((ex_count!=0)? 'OK, but there are extra useless strings, ' :
                                    (count!=0)? 'OK, but there are non-closed brackets, ' :
                                    'OK, ') + new Date().toLocaleString();
              pn_out.style.color = '';
              if (str_out!=='') {
                document.getElementsByName('overwrite_site2_json_str')[0].value = str_out;
                pref.overwrite_site2_json_str = str_out;
              }
            }
          }
        } catch (e) {
          if (pn_out) {
            pn_out.textContent = 'ERROR!!!, ' + new Date().toLocaleString();
            pn_out.style.color = 'red';
          }
          console.log('ERROR in overwtite strings:');
          console.log(pref.overwrite_site2_json_str);
          console.log(e);
        }
      },
  };

  var pref = pref_default(); // pref_default is loaded.
  if (  localStorage &&   localStorage[pref.script_prefix+'.pref']) pref_func.pref_overwrite(pref,JSON.parse(  localStorage[pref.script_prefix+'.pref']),true);
  for (var i in {catalog:null, page:null, float:null, thread:null}) if (!pref[i].save_board_list_sel) pref[i].board_list_sel = 0;
  if (sessionStorage && sessionStorage[pref.script_prefix+'.pref']) pref_func.pref_overwrite(pref,JSON.parse(sessionStorage[pref.script_prefix+'.pref']),true);
  if (window.name) for (var i in {catalog:null, page:null, float:null, thread:null}) pref[i].board_list_sel = 0;
  pref_func.site2_json(false,true,['pref']);
  if (site0.isStep) {
//    for (var i in site.features) site.features[i] = false;
    for (var i in pref.features) if (i!=='domains') pref.features[i] = false;
    for (var i in pref.features.domains) if (i!==site0.domain) pref.features.domains[i] = false;
    brwsr.sw_cache = null;
    pref_func.pref_overwrite(pref,{
      catalog:{auto_update:false},
      thread:{auto_update:false},
      page:{auto_update:false},
      float:{auto_update:false},
      virtualBoard:{scan:false},
      stats:{auto_acquisition_scan:false},
      cloudflare:{auto_reload:false},
    });
  }

  var styleSheet = (site0.isStep)? {} : (function(){
    var ss;
    function replace_rule(rule_str,idx){
      if (ss.cssRules[idx]) ss.deleteRule(idx);
      ss.insertRule(rule_str,idx);
    }
    function make_rule_click_area(){
      replace_rule('.'+pref.script_prefix+((pref.catalog.click_area==='entire')? '_thread' : '_thumbnail')+' {cursor: pointer}',2);
    }
    function make_styles(){
      var rules = [pref.style.fix.titleBar_str, pref.style.fix.window_str, pref.style.fix.popUp_str];
      if (pref.style.sel==='copy') {
        var rules_str = [pref.style.copy.titleBar_str, pref.style.copy.window_str, pref.style.copy.popUp_str];
        for (var i=document.styleSheets.length-1;i>=0;i--) {
          var doc_rules = document.styleSheets[i].cssRules;
          if (!doc_rules) continue;
          for (var j=doc_rules.length-1;j>=0;j--) {
            for (var k=0;k<3;k++) {
              if (rules_str[k] && doc_rules[j].selectorText===rules_str[k]) {
                rules[k] = trim_rules(doc_rules[j].cssText);
                rules_str[k] = null;
              }
            }
            if (!rules[0] && !rules[1] && !rules[2]) break;
          }
          if (!rules[0] && !rules[1] && !rules[2]) break;
        }
      }
      replace_rule('.'+pref.script_prefix+'_titleBar'+' {' + rules[0] + '}',4);
      replace_rule('.'+pref.script_prefix+'_window'  +' {' + rules[1] + '}',5);
      replace_rule('.'+pref.script_prefix+'_popUp'   +' {' + rules[2] + '}',6);
    }
    function trim_rules(str){
      var rules = str.replace(/.*\{/,'').replace(/\}.*/,'').split(';');
      for (var i=rules.length-1;i>=0;i--) if (rules[i].split(':')[0].search(/\s*(background|color)/)==-1) rules.splice(i,1);
      return rules.join(';');
    }
    function add_to_watch(elem){ // http://stackoverflow.com/questions/2635814/javascript-capturing-load-event-on-link
//      elem.addEventListener('change', dummy_add, false); // doesn't work.
      new MutationObserver(dummy_add).observe(elem, {attributes:true});
    }
    function dummy_add(){
      if (!ss) return;
      var dummy = document.createElement('img');
      dummy.src = this.href;
      dummy.onerror = dummy_remove;
      document.getElementsByTagName('body')[0].appendChild(dummy);
    }
    function dummy_remove(){
      this.parentNode.removeChild(this);
      make_styles();
    }
    var spoiler_org = null;
    var spoiler_open = null;
    function open_spoiler_text(){
      if (!cataLog.embed_mode) return;
      var desc = site2[site.nickname].spoiler_text;
      if (desc.spoiler) {
        if (!spoiler_org && !spoiler_open) {
          if (desc && pref[cataLog.embed_mode].open_spoiler_text) {
            for (var j=0;j<document.styleSheets.length;j++)
              if (document.styleSheets[j].cssRules)
                for (var i=0;i<document.styleSheets[j].cssRules.length;i++) {
                  var sText = document.styleSheets[j].cssRules[i].selectorText;
                  if (sText) {
                    if (sText.search(desc.spoiler)!=-1) spoiler_org  = [j,i,document.styleSheets[j].cssRules[i].style.cssText];
                    if (sText.search(desc.open   )!=-1) spoiler_open = [j,i,document.styleSheets[j].cssRules[i].style.cssText];
                  }
                }
          }
        }
        if (spoiler_org && spoiler_open)
          document.styleSheets[spoiler_org[0]].cssRules[spoiler_org[1]].style.cssText = spoiler_org[2] + ((pref[cataLog.embed_mode].open_spoiler_text)? spoiler_open[2] : '');
      } else { // cssRules is null when stylesheet is placed in other domain. http://hakuhin.jp/js/style_sheet.html#STYLE_SHEET_04
        if (pref[cataLog.embed_mode].open_spoiler_text) {
          spoiler_open = [document.styleSheets.length-1, document.styleSheets[document.styleSheets.length-1].cssRules.length, desc.open_rule];
          document.styleSheets[spoiler_open[0]].insertRule(spoiler_open[2],spoiler_open[1]);
        } else if (spoiler_open) document.styleSheets[spoiler_open[0]].deleteRule(spoiler_open[1]);
      }
    }
    var registry = ['dummy','dummy','dummy','dummy','dummy','dummy','dummy'];
    function register(selector, rule){
      var idx = registry.indexOf(selector);
      if (idx!=-1) ss.deleteRule(idx);
      if (rule===null || rule==='') {
        if (idx!=-1) registry.splice(idx,1);
      } else {
        if (idx===-1) {
          idx = registry.length;
          registry[idx] = selector;
        }
        ss.insertRule(selector+' {'+rule+'}', idx); // (rule[0]===':'? rule : ' {'+rule+'}'), idx);
      }
    }
    var cpf = '.'+pref.script_prefix+'_';
    var uss = null;
    function userCSS_changed(){
      var pf = pref.style.userCSS;
      if (pf.use) {
        var s = uss || document.createElement('style');
        s.textContent = pf.str;
        if (!uss) uss = document.head.appendChild(s);
      } else {
        if (uss) {
          document.head.removeChild(uss);
          uss = null;
        }
      }
    }
    userCSS_changed(); // init
    return {
      init: function(embed_mode){
        ss = document.head.insertBefore(document.createElement('style'),uss).sheet;
        ss.insertRule('.catalog_triage_parent {pointer-events: none;}',0); 
        ss.insertRule('.catalog_triage_button {pointer-events: auto;}',1);
        make_rule_click_area(); // rule 2.
        ss.insertRule('.'+pref.script_prefix+'_tag {cursor:pointer;}',3);
        make_styles(); // rule4,5,6
        pref_func.settings.onchange_funcs['*.posts_search_op'](null,embed_mode);
        pref_func.settings.onchange_funcs['style.post_editing']();
        register(cpf+'autoTp:hover', 'opacity:1;');
        register(cpf+'autoTp', 'opacity:0;');
        var styles = site2[site.nickname].styles;
        if (styles) for (var i=0;i<styles.length;i++) register(styles[i][0], styles[i][1]);
//        register(cpf+'hMenu', 'display:inline-block;');
//        register(cpf+'hMCnt button', 'display:block;width:100%');
//        register(cpf+'hMenu '+cpf+'hMCnt', 'display:none;');
//        register(cpf+'hMenu:hover '+cpf+'hMCnt', 'display:block;position:absolute;');
      },
      make_rule_click_area: function(){if (ss) make_rule_click_area();},
      styles_changed: function(){if (ss) make_styles();},
      add_to_watch: add_to_watch,
      open_spoiler_text: open_spoiler_text,
      register: register,
      userCSS_changed: userCSS_changed,
    }
  })();

  var pref3 = { // auto sync objects.
    stats: {use:null, estimate_posts:null},
    reload_required: false,
    catalog: {
      indexing_old: 0,
      filter: {
        time_str: function(parent,key,val){parent[key.replace(/str$/,'obj')] = Date.parse(val);},
        time_obj: 0,
        kwd: {
          str: function(e){if (this.obj) this.obj[(this.obj[0]===e.target)? 1 : 0].value = pref.catalog.filter.kwd.str;},
          obj: null,
          clear: function(){ // non-enumerable
//            if (!this.obj) return; // patch for obj_init_hier
            this.obj[1].value = '';
            this.obj[1].oninput({target:this.obj[1],currentTarget:this.obj[1]});
          },
          init: function(search, pn_filter){ // non-enumerable
            var search2;
            if (!this.obj) { // for multientry in meguca.
              search2 = search.cloneNode(false);
              search2.name = 'catalog.filter.kwd.str';
              search2.oninput = cataLog.event_func;
              this.obj = [pn_filter.getElementsByTagName('input')['catalog.filter.kwd.str'], search2];
            } else search2 = this.obj[1];
            search.setAttribute('style','display:none');
            search.parentNode.insertBefore(search2,search.nextSibling);
            this.clear();
            return search2;
          },
        },
      },
    },
    notify:{sound:{file:null}},
    archive: {
      working: false,
      list_str: function(parent,key,val){pref_func.str2obj2(parent,key.replace(/str$/,'obj2'),val);},
      list_obj2: null,
      list_obj3: null,
      jsons: null,
      imgs: null,
      dir: null,
//      list_str_set: function(val){
//        pref3.archive.list_str = val;
//        pref_func.str2obj2(pref3.archive,'list_obj2',val);
//      },
//      list_str_get: function(){
//        var lm = liveTag.mems;
//        for (var name in pref3.archive.list_obj2) {
//          var dbt = common_func.name2domainboardthread(name);
//          if (!dbt[2]) continue;
//          if (lm[dbt[0]] && lm[dbt[0]][dbt[1]]) var lth = lm[dbt[0]][dbt[1]][dbt[2]];
//          if (lth && lth.archived && lth.time_checked !== pref3.archive.list_obj2[name].time) pref3.archive.list_str = list_func_1(pref3.archive.list_str, name, lth.time_checked); // BUG. NOT implemented yet.
//        }
//        return pref3.archive.list_str;
//        function list_func_1(str,name,datetime){ // refer 'triage_exe'
//          var key = new RegExp('(^|,)'+name.replace(/\+/,'\\+')+'([\\^@!][^,\n]*)*(,|\n|$)','mg');
////          var millisec = datetime%1000;
////          var time_str = '@' + new Date(datetime).toLocaleString() + ((datetime%1000==0)? '' : '.'+millisec);
////          str = str.value.replace(key,',') + ',' + name + time_str + '\n';
//          str = str.value.replace(key,',') + ',' + name + '\n'; // remove time_str
//          return str.replace(/,,+/g,',').replace(/^,/g,'').replace(/\n,/g,'\n').replace(/\n\n+/g,'\n').replace(/^\n/,'');
//        }
//      },
    },
    proto: {
      merge_list_str: function(parent,key,val){
        if (!this.merge_list_obj2_old) this.merge_list_obj2_old = this.merge_list_obj2;
        var name_prev = null;
        pref_func.str2obj2(parent,'merge_list_obj2',val.replace(/\s*\+/g,',+'), null, null, function(field, tgt){
          var add = field.search(/^\s*\+\s*/)!=-1;
          var name = field.replace(/^\s*\+\s*/,'') || 'DEFAULT';
          if (add && name_prev) {
            tgt[name] = tgt[name_prev];
            tgt[name][tgt[name].length] = name;
          } else {
            tgt[name] = [name];
            name_prev = name;
          }
        });
      },
      merge_list_obj2: null,
      merge_list_obj2_old: null,
      merge_lv_str: function(parent,key,val){
        if (!this.merge_lv_obj2_old) this.merge_lv_obj2_old = this.merge_lv_obj2;
        pref_func.str2obj2(parent,'merge_lv_obj2',val, null, null, pref_func.str2obj2_func_for_val);
      },
      merge_lv_obj2: null,
      merge_lv_obj2_old: null,
      merge_lv_obj3: null,
    },
    test_mode: {js_file:null},
  };
  Object.defineProperties(pref3.catalog.filter.kwd, {
    'clear': {value:pref3.catalog.filter.kwd.clear, configurable:true, enumerable:false, writable:true},
    'init':  {value:pref3.catalog.filter.kwd.init,  configurable:true, enumerable:false, writable:true}});

  var cataLog = {
    threads: null,
//    insert_footer3: null,
    scan_boards: null,
    scan_init: null,
    catalog_filter_query: null,
    embed_mode: null,
////    catalog_refresh_watch: null,
    format_html: null,
    show_catalog: null,
    show_catalog_cont: null,
    get_ref_height: null,
    catalog_obj2: null,
    healthIndicator: null,
    parent: null, // triage_parent
    open_spoiler_text: null,
    show_catalog_scroll_lock: null,
    general_event_handler: null,
    catalog_refresh_1: null,
    catalog_refresh_end: null,
    catalog_filter_changed: null,
    image_hover_reentry: null,
    image_hover_remove: null,
    scan_boards_keyword_callback2: null,
    scan_boards_keyword_callback2_default_args: null,
    catalog_clear_threads: null,
    catalog_filter_query_keyword: null,
    set_watch_time_thread: null,
    get_watch_time_of_a_thread: null,
    remove_thread: null,
    event_func: null,
    restore_th_from_IDB: null,
    components: null,
    triage: null,
    GEH: null,
    insert_myself: null,
    DIH: null,
    pop_up_set_contents: null,
  }

  pref_func = (function(){
//    var tooltip = document.createElement('div');
//    var tooltip_txt = tooltip.appendChild(document.createTextNode('help'));
////    var tooltip_txt = tooltip.appendChild(document.createElement('textarea'));
//    tooltip.style.position = 'fixed';
//    tooltip.style.background = '#e5f4f9';
//    tooltip.style.color = '#000000';
//    tooltip.style.border = '2px solid blue';
//    tooltip.style.fontWeight = 'normal';
//    var tooltip_on = false;
    return {
      __proto__: pref_func,
      mirror_targets: {
        pn12_0_2: null,
        pn12_0_4: null,
        pn13_1: null,
        boardlist: null,
      },
////////      style_sheet: null,
      apply_prep: function(pn,set,propagate, mirror, make_obj){
        if (!pn) return; // reject mirroring to null, // patch for attr_changed.
        var fm;
        if (!mirror) {
          if (Array.isArray(pn)) fm = pn;
          else {
            var query_str = 'input,textarea,select'+ ((set)? '' : ',span[data-class=show_value]');
            fm = Array.prototype.slice.call(pn.querySelectorAll(query_str));
            if (fm.length==0) fm = [pn];
          }
////          if (!set)
////            for (var j in this.mirror_targets)
////              if (this.mirror_targets[j])
////                fm = fm.concat(Array.prototype.slice.call(this.mirror_targets[j].querySelectorAll(query_str)));
//          fm = Array.prototype.slice.call(pn.getElementsByTagName('input')); // working code.
//          fm = fm.concat(Array.prototype.slice.call(pn.getElementsByTagName('textarea')));
//          fm = fm.concat(Array.prototype.slice.call(pn.getElementsByTagName('select')));
//          if (!set) fm = fm.concat(Array.prototype.slice.call(pn.querySelectorAll('span[data-class=show_value]')));
////          var fm = pn.getElementsByTagName('*'); // this doesn't work because a select contains its options in it.
//          if (fm.length==0) fm = [pn];
        } else {
          fm = [];
          for (var j in this.mirror_targets) {
            if (this.mirror_targets[j]) {
              var fm_tmp = this.mirror_targets[j].getElementsByTagName('input')[pn.name];
              if (fm_tmp)
                if (Array.isArray(fm_tmp)) fm = fm.concat(Array.prototype.slice.call(fm_tmp));
                else fm[fm.length] = fm_tmp;
            }
          }
          for (var j=fm.length-1;j>=0;j--) if (fm[j]===pn) fm.splice(j,1);
          if (fm.length==0) return;
        }
        this.apply_prep_2(fm,set,propagate, mirror, make_obj);
      },
      apply_prep_2: function(fms,set,propagate, mirror, make_obj){
        for (var i=0;i<fms.length;i++) {
          var fm = fms[i];
          var name = fm.getAttribute('name');
          if (!name) continue; // for <span> //  if (!fm.name) continue;
          if (fm.type=='button') continue;
          var target_hier = pref_func.get_tgt(name, fm.type==='file'? pref3 : null); // null for #tags2
          var parent = target_hier[0];
          var tgt    = target_hier[1];
          var tagName = fm.tagName;
          if (tagName==='INPUT') {
            if (fm.type==='file') {
              if (!set && parent[tgt] && parent[tgt]!==fm) fm.parentNode.replaceChild(parent[tgt],fm);
              else parent[tgt] = fm; // set also when set===false, keep tracking the DomNode.
            } else if (set) {
              if (parent[tgt+'_old']!==undefined) parent[tgt+'_old'] = parent[tgt];
              this.apply_prep_set(parent, tgt, fm, name);
              if (!mirror && fm.type!=='radio') this.apply_prep(fm,false,false,true); // !mirror for cutting infinite loop. // radio has multiple elements.
            } else this.apply_prep_load(fm, parent, tgt);
            if (set || make_obj)
              if (typeof(parent[tgt])==='string' )
                if (fm.type==='text') {
//                  if (tgt.substr(-3,3)==='str' && parent[tgt.substr(0,tgt.length-3)+'obj4']) pref_func.str2obj4(parent,tgt.substr(0,tgt.length-3)+'obj4',fm.value);
                  if (tgt.substr(-3,3)==='str' && parent[tgt.substr(0,tgt.length-3)+'obj']) pref_func.str2obj6(parent,tgt,fm.value,name);
                }
          } else if (tagName==='TEXTAREA') {
            if (set) parent[tgt] = fm.value;
            else fm.value = parent[tgt];
            if (set || make_obj) {
              if (tgt.search(/str$/)!=-1 && parent[tgt.replace(/str$/,'obj')]) pref_func.str2obj(tgt);
              if (tgt.search(/str$/)!=-1 && parent[tgt.replace(/str$/,'obj2')]) pref_func.str2obj2(parent,tgt.replace(/str$/,'obj2'),fm.value);
//              if (tgt.substr(-3,3)==='str' && parent[tgt.substr(0,tgt.length-3)+'obj4']) pref_func.str2obj4(parent,tgt.substr(0,tgt.length-3)+'obj4',fm.value);
              if (tgt.substr(-3,3)==='str' && parent[tgt.substr(0,tgt.length-3)+'obj5']) pref_func.str2obj5(parent,tgt.substr(0,tgt.length-3)+'obj5',fm.value);
              if (tgt.substr(-3,3)==='str' && parent[tgt.substr(0,tgt.length-3)+'obj6']===null) pref_func.str2obj6(parent,tgt,fm.value,name);
            }
          } else if (tagName==='SELECT') {
            if (set) this.apply_prep_set(parent, tgt, fm, name); // if (parent[tgt]!==undefined) parent[tgt] = fm.selectedIndex;,
            else {
//              var tgt_obj = (tgt.search(/sel/)!=-1)? tgt.replace(/sel/,'obj') : null;
//              if (parent[tgt_obj]) {
//                fm.length=0;
//                for (var j=0;j<parent[tgt_obj].length;j++) {
//                  fm.length++;
//                  fm.options[fm.length-1].text = parent[tgt_obj][j][0]['key'];
//                }
//              }
              if (parent[tgt+'_gfunc_pre']) parent[tgt+'_gfunc_pre'](parent,tgt,parent[tgt],name,fm);
              this.apply_prep_load(fm, parent, tgt);
//              if (parent[tgt]>=fm.length) parent[tgt] = 0;
//              fm.selectedIndex = parent[tgt];
            }
          } else if (tagName==='SPAN') {
            if (!set && fm.getAttribute('data-class')==='show_value') {
              var val = parent[tgt];
              var func_str = this.apply_prep_2_str[tgt+':'+parent[tgt]];
              if (func_str) val = (typeof(func_str)==='string')? func_str : func_str(parent);
//              if (fm.getAttribute('name').substr(-7,7)==='t2h_sel' && ['L','M','N'].indexOf(parent[tgt])!=-1) val = parent['t2h_'+parent[tgt]];
              fm.textContent = val.toString().replace(/^./,function(v){return v.toUpperCase();});
            }
          }
          if (propagate) {
            if (fm.oninput)  fm.oninput.call(fm, {currentTarget:fm, target:fm}, true);
            if (fm.onchange) fm.onchange.call(fm, {currentTarget:fm, target:fm}, true);
          }
        }
        if (sessionStorage && (set||make_obj)) sessionStorage[pref.script_prefix+'.pref'] = JSON.stringify(pref);
      },
      apply_prep_set: function(parent, tgt, fm, name){ // don't set if parent[tgt]===undefined, ex.time_quick_sel
        var type = typeof(parent[tgt]);
        if (type==='number') {
          var val;
          parent[tgt] = (fm.tagName==='SELECT')? fm.selectedIndex
                      : (val = (name && name.substr(-2)==='_f')? parseFloat(fm.value) : parseInt(fm.value,10), isNaN(val)? 0 : val)
        } else if (type==='boolean') parent[tgt] = fm.checked;
        else if (type==='string') if (fm.type==='text'|| fm.checked) parent[tgt] = fm.value;
      },
      apply_prep_load: function(fm, parent, tgt){
        var val = parent[tgt];
        if (fm.tagName==='SELECT') {
          if (val>=fm.length) parent[tgt] = 0;
          fm.selectedIndex = parent[tgt];
        } else { // INPUT
          var type = typeof(val);
          if      (type=='number' ) fm.value = val;
          else if (type=='boolean') fm.checked = val;
          else if (type=='string' ) if (fm.type==='text') fm.value = val;
          else if (val === fm.value) fm.checked = true;
        }
      },
      apply_prep_2_str: {
        't2h_sel:L': function(parent){return parent['t2h_L'];},
        't2h_sel:M': function(parent){return parent['t2h_M'];},
        't2h_sel:N': function(parent){return parent['t2h_N'];},
        't2h_sel:N_unread': function(parent){return parent['t2h_N']+'+unread';},
        't2h_sel:unread': 'All unread',
        'posts_search_op:opaque': function(parent){return 'opaque '+parent['posts_search_op_opacity']+'%';},
        'popup2:sr': 'SearchResult',
        'popup2:srpv': 'SearchResult/Preview',
        'popup2:pv': 'Preview',
        'popup2:chart': 'PostRateChart',
        'popup2:dp': 'DeletedPosts',
      },
//      make_pref_obj : function(name){ // copy of part of apply_prep.
//        var target_hier = pref_func.get_tgt(name);
//        var parent = target_hier[0];
//        var tgt    = target_hier[1];
//        if (tgt.search(/str$/)!=-1 && parent[tgt.replace(/str$/,'obj')]) pref_func.str2obj(tgt);
//        if (tgt.search(/str$/)!=-1 && parent[tgt.replace(/str$/,'obj2')]) pref_func.str2obj2(parent,tgt.replace(/str$/,'obj2'),parent[tgt]);
//      },
      catalog_board_list_str_or: '',
      catalog_board_list_str_bt: '',
      catalog_board_list_str_bt_same: '',
      add_onchange: function(pn,func_obj, func_obj2){ // obj2 for oninput
        return this.set_event_target(pn, this.add_onchange_entry_func.bind(func_obj), func_obj2);
      },
      add_onchange_entry_func: function(e, propagate){ // always used after binded.
        var pn_name = e.currentTarget.getAttribute('name'); // for <span>
        if (!propagate && ['INPUT','TEXTAREA','SELECT'].indexOf(e.currentTarget.tagName)!=-1) pref_func.apply_prep(e.currentTarget,true);
        if (this[pn_name]) this[pn_name].call(e.currentTarget,e);
        else {
          var idx = pn_name.indexOf('.');
          if (idx!=-1) {
            var name = '*'+pn_name.substr(idx); // *.XXX
            if (this[name]) this[name].call(e.currentTarget,e);
            else {
              var idx_l = pn_name.lastIndexOf('.');
              if (idx_l!=-1) {
                var name = pn_name.substr(0,idx_l+1)+'*'; // XXX.YYY.*
                if (this[name]) this[name].call(e.currentTarget,e);
                else if (idx!=-1) {
                  var name_0 = pn_name.substr(0,idx); // XXX.YYY
                  var name_1 = pn_name.substr(idx+1);
                  if (this[name_0] && this[name_0][name_1]) this[name_0][name_1](e); // NO THIS EMULATION.
                }
              }
            }
          }
        }
//        var pn = e.target.parentNode; // 'Filter' doesn't have stopper.
//        while (pn && pn!==site.script_body) {
//          if (pn.getAttribute('name')==='SUB') this['SUB'].call(pn,{currentTarget:pn});
//          pn = pn.parentNode;
//        }
      },
      add_onchange_format: function(func_obj){
        var keys = Object.keys(func_obj);
        for (var i=0;i<keys.length;i++) if (typeof(func_obj[keys[i]])==='string') func_obj[keys[i]] = func_obj[func_obj[keys[i]]];
        return func_obj;
      },
////      add_onchange: function(pn,func_obj, func_obj2){ // obj2 for oninput // working code.
////        var call_tgt = func_obj;
////        if (typeof(func_obj)!=='function') { // object
////          for (var i in func_obj) if (typeof(func_obj[i])==='string') func_obj[i] = func_obj[func_obj[i]];
////          if (func_obj2) for (var i in func_obj2) if (typeof(func_obj2[i])==='string') func_obj2[i] = func_obj2[func_obj2[i]];
//////          func_obj.func_default = function(){ // cause EventListener leak.
//////            pref_func.apply_prep(this,true);
//////            if (func_obj[this.name]) func_obj[this.name](this);
//////          };
//////          call_tgt = func_obj.func_default;
////          call_tgt = func_obj.entry_func;
////        }
////        this.set_event_target(pn,call_tgt, func_obj2);
////      },
      set_event_target: (function(){
        var inst_while_input = null;
        function prep_beforeunload(e){
          inst_while_input = (e)? e.target : null;
        }
        function set_val_beforeunload(){
          if (inst_while_input) pref_func.apply_prep(inst_while_input,true);
        }
        window.addEventListener('beforeunload', set_val_beforeunload, false);
        return function(pn,tgt, func_obj2){
          var tgt_wrapped = function(e, propagate){inst_while_input=null;tgt.call(this,e, propagate);};
          var fm = pn.getElementsByTagName('*');
          if (fm.length==0) fm = [pn];
          for (var i=0;i<fm.length;i++) {
            var name = fm[i].getAttribute('name');
            if (!name) continue; // for span // if (!fm[i].name) continue;
            var tagName = fm[i].tagName;
            if (tagName==='INPUT' || tagName==='TEXTAREA' || tagName==='SELECT') {
              if (func_obj2 && func_obj2[fm[i].name]) fm[i].oninput = tgt_wrapped;
              else {
                fm[i].onchange = tgt_wrapped;
                if ((tagName==='INPUT' && fm[i].type==='text') || tagName==='TEXTAREA') fm[i].oninput = prep_beforeunload;
              }
            } else if (tagName==='BUTTON') fm[i].onclick = tgt_wrapped; // OK.
            else if (tagName==='A') {
              if (name==='SHOW' || name==='SHOWALL' || name==='HIDEALL' || name==='SHOW2' || name==='SHOW3' || name==='HIDE3') fm[i].onclick = tgt;
            } else if (tagName==='SPAN' || tagName==='DIV') {
//              if (name==='NEXT') fm[i].onclick = tgt;
              if (name==='SUB') fm[i].onchange = tgt; // called twice times when INPUT in SUB is changed.
              if (name==='SHOW2_I') fm[i].onclick = tgt;
            }
          }
          return tgt_wrapped;
        };
      })(),
//      remove_onchange: function(pn){this.set_event_target(pn,null);},
//      invoke_onchange: function(pn){
//        var evt = document.createEvent('UIEvents');
//        evt.initUIEvent('change', false, true, window, 1);
//        pn.dispatchEvent(evt);
//      },
      str2obj: function(key) {
//        var tgt = key+'_obj';
        var tgt = key.replace(/str$/,'obj');
        pref[tgt] = [];
        tgt = pref[tgt];
        var bg_str = (site.whereami==='boards')? site2[site.nickname].boards_sel_from_tags() :
                     site.board + ((site.whereami==='thread')? site.no : '');
        if (bg_str==='//') bg_str = '/ROOT_DUMMY/';
        bg_str += ',' + bg_str + '\n' + pref[key] + '\n';
        if (pref.catalog.board.recommendation) {
//          var blotter = document.getElementsByClassName('blotter')[0];
//          if (blotter) {
//            or_str = document.getElementsByClassName('blotter')[0][brwsr.innerText];
//            var kwd = 'Recommendation: ';
//            var idx = or_str.indexOf(kwd);
//            if (idx!=-1) {
//              var or = or_str.substr(idx+kwd.length);
//              pref_func.catalog_board_list_str_or = or;
//              lines.push(or);
//            }
//          }
          var or = site2[site.nickname].get_owners_recommendation();
          pref_func.catalog_board_list_str_or = or;
//          lines.push(or);
          bg_str = bg_str + or + '\n';
        }
//        if (pref.catalog.board.board_tags && pref_func.catalog_board_list_str_bt!=='') lines.push(pref_func.catalog_board_list_str_bt);
//        if (pref.catalog.board.board_tags_same && pref_func.catalog_board_list_str_bt_same!=='') lines.push(pref_func.catalog_board_list_str_bt_same);
        if (pref.catalog.board.board_tags && pref_func.catalog_board_list_str_bt!=='') bg_str = bg_str + pref_func.catalog_board_list_str_bt + '\n';
        if (pref.catalog.board.board_tags_same && pref_func.catalog_board_list_str_bt_same!=='') bg_str = bg_str + pref_func.catalog_board_list_str_bt_same + '\n';
        var lines = bg_str.split('\n');
        var bn = -1;
        for (var i=0;i<lines.length;i++) {
          var fields = lines[i].replace(/\s*\/\/.*/,'').replace(/, +/g,',').split(',');
          var j=0;
          while (j<fields.length && fields[j]=='') j++;
          if (fields[j]) {
            tgt[++bn] = [];
            tgt[bn][0] = {};
            tgt[bn][0].key = fields[j++];
            var idx=0;
            while (j<fields.length) {
              if (fields[j]!==''){
                if (fields[j].search(/^\s*#/)!==-1) {
                  if (!tgt[bn][0].tags) tgt[bn][0].tags=[];
                  tgt[bn][0].tags[tgt[bn][0].tags.length] = fields[j].replace(/\s/g,'');
                } else if (fields[j].search(/^\s*!/)!==-1) {
                  if (!tgt[bn][0].cmds) tgt[bn][0].cmds=[];
                  tgt[bn][0].cmds[tgt[bn][0].cmds.length] = fields[j].replace(/\s/g,'').substr(1);
                } else {
                  tgt[bn][++idx] = {};
                  tgt[bn][idx].key = fields[j].replace(/[\*\^!].*/,'').replace(/\s/g,'')
                  if (fields[j].search(/\*/)!=-1) tgt[bn][idx].max_page  = parseInt(fields[j].replace(/[^\*\^!]*[\*\^!]/,'').replace(/[\^!].*/,''),10);
                  if (fields[j].search(/\^/)!=-1) tgt[bn][idx]['style' ] = fields[j].replace(/[^\*\^!]*[\*\^!]/,'').replace(/[\*!].*/,'');
//                  if (fields[j].search(/\!/)!=-1) tgt[bn][idx]['search'] = fields[j].replace(/[^\*\^!]*[\*\^!]/,'').replace(/[\*\^].*/,'');
//                  tgt[bn][idx].key = fields[j].replace(/[\*%!].*/,''); // working code..., but '%' is used in URL...
//                  if (fields[j].search(/\*/)!=-1) tgt[bn][idx]['num'   ] = fields[j].replace(/[^\*%!]*[\*%!]/,'').replace(/[%!].*/,'');
//                  if (fields[j].search(/\%/)!=-1) tgt[bn][idx]['style' ] = fields[j].replace(/[^\*%!]*[\*%!]/,'').replace(/[\*!].*/,'');
//                  if (fields[j].search(/\!/)!=-1) tgt[bn][idx]['search'] = fields[j].replace(/[^\*%!]*[\*%!]/,'').replace(/[\*%].*/,'');
                }
              }
              j++;
            }
          }
        }
        if (pref.catalog.board.all_boards) tgt[tgt.length] = [{key:'ALL'},{key:site.nickname}];
        for (var i=0;i<tgt.length;i++) {
          for (var j=1;j<tgt[i].length;j++) {
            var dm = tgt[i][j].key.replace(/\/.*/,'');
            if (dm=='') dm=site.nickname;
            var bd = '/'+ tgt[i][j].key.replace(/[^\/]*\//,'').replace(/\/.*/,'') +'/';
            if (j==1) {
              tgt[i][0]['domain']= dm;
              tgt[i][0]['board' ]= bd;
            } else {
              if (tgt[i][0]['domain']!=dm) tgt[i][0]['domain']=null;
              if (tgt[i][0]['board' ]!=bd) tgt[i][0]['board' ]=null;
            }
          }
        }
        for (var i=0;i<tgt.length;i++)
          for (var j=1;j<tgt[i].length;j++) {
            var dbt = common_func.name2domainboardthread(tgt[i][j].key,false);
            tgt[i][j].key = common_func.name2domainboardthread(tgt[i][j].key,true).join(''); // patch
            if (dbt[1]==='' && dbt[2]==='') {
              if (!tgt[i][0].domains_for_all_boards) tgt[i][0].domains_for_all_boards = [];
              tgt[i][0].domains_for_all_boards[tgt[i][0].domains_for_all_boards.length] = dbt[0];
              tgt[i].splice(j--,1);
            }
          }
      },
      get_tgt: function(name, parent, exact){
        if (!parent) parent = (name[0]==='#')? liveTag.tags : pref;
        var tgts = name.split('.');
        for (var j=0;j<tgts.length;j++)
          if (!exact || parent[tgts[j]]!==undefined) {
            if (j!=tgts.length-1) parent = parent[tgts[j]];
            else return [parent,tgts[j]];
          } else return null;
      },
      str2obj2: (function(){
        function set_vals(tgt,key,vals_in,completion){
          if (vals_in) {
            if (!tgt[key]) tgt[key] = {};
            var vals = vals_in[0].substr(1).split(';');
            for (var j=0;j<vals.length;j++) {
              var val = vals[j].split(':');
              if (completion) {
                if (val.length===1 || val[1]==='true') val[1] = true;
                else if (val[1]==='false') val[1] = false;
              }
              tgt[key][val[0]] = val[1];
            }
          }
        }
        function func_org(field, tgt){
          var name = field.replace(/[@\^!].*/,'') || 'DEFAULT';
          if (tgt[name]===undefined) tgt[name] = {};
//          var time = field.match(/@[^\^!]*/);
//          if (time) tgt[name].time = Date.parse(time[0].replace(/@/,''));
          var time = field.match(/@([^\^!]*)/);
          if (time) tgt[name].time = (time[1]==0)? 0 : brwsr.Date_parse(time[1]); // Date.parse(0) returns 2000/1/1 0:00. '==0' is intended, 0 is string in this case.
          set_vals(tgt[name],'style',field.match(/\^[^@!]*/));
          set_vals(tgt[name],'cmd'  ,field.match(/![^@\^]*/),true);
        }
        return function(parent,key,str, keep, obj2_only, func){
          if (!keep) parent[key] = {};
          var tgt = parent[key];
          var fields = str.replace(/\s*\/\/.*/mg,'').replace(/\n/g,',').split(/\s*,\s*/);
          if (!func) func = func_org;
          for (var i=0;i<fields.length;i++) if (fields[i]) func(fields[i],tgt);
          if (obj2_only) return tgt;
          var key3 = key.replace(/_obj2/,'_obj3');
          parent[key3] = {};
          var tgt3 = parent[key3];
          for (var i in tgt) tgt3[i.replace(/\/[0-9]+$/,'/')] = true;
        }
      })(),
      str2obj2_func_for_val: function(field, tgt){
        field = field.replace(/\s*/g,'');
        var idx = field.indexOf(':');
        var name = (idx>=1)? field.substr(0,idx) : 'DEFAULT';
        tgt[name] = field.substr(idx+1);
      },
////      str2obj2: function(parent,key,str){ // working code.
////        parent[key] = {};
////        tgt = parent[key];
////        var fields = str.replace(/\/\/.*/mg,'').replace(/\n/g,',').split(',');
////        for (var i=0;i<fields.length;i++) {
////          if (fields[i]=='') continue;
////          var name  = fields[i].replace(/[@%].*/,'');
////          if (name=='') name = 'DEFAULT';
////          var attr  = fields[i].match(/[@%].*/);
////          var time  = (attr!=null)? attr[0].replace(/%[^@]*(@|$)/,'').replace(/@/,'') : null;
////          var style = (attr!=null)? attr[0].replace(/@[^%]*(%|$)/,'').replace(/%/,'') : null;
////          if (tgt[name]===undefined) tgt[name] = {};
////          if (time ) tgt[name]['time']  = Date.parse(time);
//////          if (style) tgt[name]['style'] = style;
////          if (style) {
////            if (!tgt[name].style) tgt[name].style = {};
////            var styles = style.split(';');
////            for (var j=0;j<styles.length;j++) {
////              var stl = styles[j].split(':');
////              tgt[name].style[stl[0]] = stl[1];
////            }
//////            tgt[name]['style'] = true;
//////            var styles = style.split(';');
//////            for (var j=0;j<styles.length;j++) {
//////              var stl = styles[j].split(':');
//////              tgt[name]['style.'+stl[0]] = stl[1];
//////            }
////          }
////        }
////        var key3 = key.replace(/_obj2/,'_obj3');
////        parent[key3] = {};
////        var tgt3 = parent[key3];
////        for (var i in tgt) tgt3[i.replace(/\/[0-9]+$/,'/')] = true;
////      },
//      str2obj4: function(parent,key,str) {
//        parent[key] = this.style2obj(str);
//      },
//      style2obj: function(str) {
//        var fields  = str.split(';');
//        for (var i=fields.length-1;i>=0;i--) {
//          if (fields[i]) {
//            var coms = fields[i].replace(/\s/g,'').split(':');
//            fields[i] = '"'+coms[0]+'":"'+coms[1]+'"';
//          } else fields.splice(i,1);
//        }
//        return JSON.parse('{' + fields.join(',') + '}');
//      },
      str2obj5: function(parent,key,str){
        parent[key] = {};
        tgt = parent[key];
        var fields = str.replace(/\s*\/\/.*/mg,'').replace(/\n/g,',').split(',');
        for (var i=0;i<fields.length;i++) {
          if (fields[i]=='') continue;
          var idx = fields[i].indexOf(':'); // tags never contains ':'
          var name = (idx!=-1)? fields[i].substr(0,idx) : 'DEFAULT';
          if (tgt[name]===undefined) tgt[name] = [];
          tgt[name][tgt[name].length] = (fields[i][idx+1]==='/')? new RegExp(fields[i].substr(idx+2,fields[i].lastIndexOf('/')-idx-2),fields[i].substr(fields[i].lastIndexOf('/')+1)) :
                                        (key==='ex_list_obj5')? new RegExp(fields[i].substr(idx+1).replace(/\*/g,'.*')) :
                                                                new RegExp(fields[i].substr(idx+1).replace(/\*/g,'\\S*(\\s|$)'),'g');
//          tgt[name][tgt[name].length] = new RegExp('#'+(fields[i][idx]==='/')? fields[i].substr(idx+1) :
//                                                                               fields[i].substr(idx+1).replace(/\*/,'.*'));
        }
      },
      merge_obj5: function(name,obj,val){
        return this.merge_obj5_all(name,obj,val,this.merge_obj5_1);
      },
      merge_obj5a: function(name,obj,val){
        return this.merge_obj5_all(name,obj,val,this.merge_obj5_1a);
      },
      merge_obj5a_sc: function(name,obj,val){ // short cut logic.
        if (!obj) return val;
        var dbt = common_func.fullname2dbt(name);
        return obj[name] ||
               obj[dbt[1]+dbt[2]] || // board+thread
               obj[dbt[0]+dbt[2]] || // domain+thread
               obj[dbt[2]] || // thread
               obj[dbt[0]+dbt[1]] || // domain+board
               obj[dbt[1]] || // board
               obj[dbt[0]] || // domain
               obj['DEFAULT'] || val;
      },
      merge_obj5_all: function(name,obj,val,func){
        var dbt = common_func.fullname2dbt(name);
        val = func(val,obj,'DEFAULT');
        val = func(val,obj,dbt[0]); // domain
        val = func(val,obj,dbt[1]); // board
        val = func(val,obj,dbt[0]+dbt[1]); // domain+board
        val = func(val,obj,dbt[2]); // thread
        val = func(val,obj,dbt[0]+dbt[2]); // domain+thread
        val = func(val,obj,dbt[1]+dbt[2]); // board+thread
        val = func(val,obj,name);
        return val;
      },
      merge_obj5_1: function(val,obj,key){
        if (obj[key]) {
          var obj_key = obj[key];
//          if (Array.isArray(obj_key)) return obj_key.concat(val || []);
          if (!val) val = {};
          if (val.hit!==undefined) val.hit = true;
          for (var i in obj_key)
            if (typeof(obj_key[i])!=='object') val[i] = obj_key[i];
            else {
              if (val[i]===undefined) val[i]={};
              for (var j in obj_key[i]) val[i][j] = obj_key[i][j]; // 2nd level.
            }
        }
        return val;
      },
      merge_obj5_1a: function(val,obj,key){
        return (obj[key])? obj[key].concat(val || []) : val;
      },
      str2obj6: function(parent,key,val,name){
        var obj_hier  = pref_func.get_tgt(name, pref3);
        obj_hier[0][obj_hier[1]](obj_hier[0],key,val);
      },
      obj_init_hier: function(dst, src){
        for (var i in dst) {
          if (typeof(dst[i])==='object' && src[i]) this.obj_init_hier(dst[i], src[i]); // stopped by null.
          else if (typeof(dst[i])==='function') dst[i](dst, i, src[i]);
        }
      },
      obj_init: function(){
        pref_func.str2obj('catalog_board_list_str');
        pref_func.str2obj2(pref.catalog,'style_general_list_obj2',pref.catalog.style_general_list_str);
        pref_func.str2obj2(pref.catalog.board,'ex_list_obj2',pref.catalog.board.ex_list_str);
//        pref_func.str2obj4(pref.liveTag, 'style_urtm_obj4', pref.liveTag.style_urtm_str);
//        pref_func.str2obj4(pref.liveTag, 'style_ur_obj4',   pref.liveTag.style_ur_str);
//        pref_func.str2obj4(pref.liveTag, 'style_in_obj4',   pref.liveTag.style_in_str);
        pref_func.str2obj5(pref.liveTag, 'ex_list_obj5',    pref.liveTag.ex_list_str);
        pref_func.str2obj5(pref.liveTag, 'rm_list_obj5',    pref.liveTag.rm_list_str);
        pref_func.settings.onchange_funcs.archive['kwd.*'](); // archiver.event_funcs['kwd.*'](); can't use this because it doesn't exist at this time.
        this.obj_init_hier(pref3, pref);
      },
      obj_elim_the_same: function(dst,src, no_copy,not_root){
        var flag = true;
        for (var i in dst) {
          if (typeof(dst[i])==='object' && src[i] && typeof(src[i])==='object') { // eliminates objects made by program automatically because original object are vacant.
            if (pref_func.obj_elim_the_same(dst[i],src[i], no_copy,true)) delete dst[i];
            else {
              flag = false;
              if (!no_copy) if (Array.isArray(dst[i]) || Array.isArray(src[i])) dst[i] = src[i];
            }
          } else {
            if (dst[i]===src[i]) delete dst[i];
            else {
              flag = false;
              if (!no_copy) dst[i]=src[i];
            }
          }
        }
        if ((Array.isArray(dst) || Array.isArray(src)) && dst.length!==src.length) flag = false;
        return (not_root)? flag : dst;
      },
      site2_json_ex_remove: function(){
        var pref_test = pref_default(true);
        delete pref_test.catalog_board_list_obj;
        delete pref_test.catalog.style_general_list_obj2;
        delete pref_test.catalog.board.ex_list_obj2;
//        delete pref_test.liveTag.style_urtm_obj4;
//        delete pref_test.liveTag.style_ur_obj4;
//        delete pref_test.liveTag.style_in_obj4;
        delete pref_test.liveTag.ex_list_obj5;
        delete pref_test.liveTag.rm_list_obj5;
        if (pref_test.settings) delete pref_test.settings;
//        if (pref_test.graph) delete pref_test.graph;
        pref_func.obj_elim_the_same(pref_test,pref);
        pref_func.obj_elim_the_same(pref_test.catalog, pref_test.proto, true);
        pref_func.obj_elim_the_same(pref_test.page,    pref_test.proto, true);
        pref_func.obj_elim_the_same(pref_test.thread,  pref_test.proto, true);
        pref_func.obj_elim_the_same(pref_test.float,   pref_test.proto, true);
        return pref_test;
      },
      site2_json_ex: function(full, filter){
        var pref_test = this.site2_json_ex_remove();
        if (!filter) if (pref_test.catalog.filter) delete pref_test.catalog.filter;
        if (!full) if (pref_test.catalog_board_list_str) delete pref_test.catalog_board_list_str;
        if (pref_test.overwrite_site2_json_str) delete pref_test.overwrite_site2_json_str;
        if (!filter) pref.overwrite_site2_json_str = '{"pref":' + JSON.stringify(pref_test) + '}';
        else pref.overwrite_site2_json_str = '{"pref":{"catalog":{"filter":' + JSON.stringify(pref_test.catalog.filter) + '}}}';
      },
      pref_query: function(ref,src){
        var str = '';
        for (var i in src) {
          if (ref[i]!==undefined) {
            str += '"' + i + '":' +
                   ((typeof(src[i])==='object' && !Array.isArray(src[i]))? pref_func.pref_query(ref[i],src[i]) :
                                                                           JSON.stringify(ref[i]))
                 + ',';
          }
        }
        return '{' + str.substr(0,str.length-1) + '}';
      },
      site2_eval: function(){
//        try { 
//          if (pref.overwrite_site2_eval_str!=='') eval(pref.overwrite_site2_eval_str);
//        } catch (e) {
//          console.log('ERROR in overwtite strings:');
//          console.log(pref.overwrite_site2_eval_str);
//          console.log(e);
//        }
      },
      tooltips: (site0.isStep)? null : (function(){
        var tooltip = document.createElement('div');
        tooltip.style.position = 'fixed';
////        tooltip.style.background = '#e5f4f9';
////        tooltip.style.color = '#000000';
////        tooltip.style.border = '2px solid blue';
//          tooltip.style.fontWeight = 'normal';
        tooltip.setAttribute('class', pref.script_prefix+'_popUp');
        tooltip.style.zIndex = pref.tooltips.zIndex;
        var tooltip_on = null;
//        var tooltip_shown = false;
        var tooltip_kind = 'help';
//        var func = {};
        var show_timer = null;
        var hide_timer = null;
//        var str_tooltip = '';

//        function add_hier(pn){ // working code
//          var all = pn.getElementsByTagName('*');
////          if (pref.test_mode.tips) for (var i=0;i<all.length;i++) if (!str[all[i].name]) str[all[i].name] = 'Name: ' + all[i].name;
////          for (var i=0;i<all.length;i++) if (all[i].name) add(all[i]); // span can't return if .name
//          for (var i=0;i<all.length;i++) {
//            var name = all[i].getAttribute('name');
//            if (name && (str[name] || (str[name]!==false && pref.test_mode.tips))) add(all[i]);
//          }
//        }
//        function remove_hier(pn){
//          var all = pn.getElementsByTagName('*');
////          for (var i=0;i<all.length;i++) if (all[i].name) remove(all[i]);
//          for (var i=0;i<all.length;i++) if (all[i].hasAttribute('name')) remove(all[i]);
//        }
//        function add(elem){
//////          if (str.hasOwnProperty(elem.name)) {
//            if (!func.hasOwnProperty(elem.name)) func[elem.name] = [];
//            func[elem.name].push(elem);
//            elem.addEventListener('mouseover', show, false);
//////          }
//        }
//        function remove(elem){
//          if (func.hasOwnProperty(elem.name)) {
//            var elems = func[elem.name];
//            for (var i=0;i<elems.length;i++) {
//              if (elem===elems[i]) {
//                elem.removeEventListener('mouseover', show, false);
//                elems.splice(i,1);
//                if (elems.length==0) delete func[elem.name];
//                break;
//              }
//            }
////            for (var i=0;i<elems.length;i++) {
////              var elem = func[elem.name][i];
////              elem.removeEventListener('mouseover', show, false);
////            }
////            delete func[elem.name];
//          }
//        }
        function show(e){
//          if (!pref.tooltips.help.show) return;
          var name = e && (e.target.name || e.target.getAttribute('name')) || this.name;
          if (name && e && e.target.type==='radio') name += ', '+e.target.value;
          if (!name && e.target.tagName==='LABEL') name = e.target.childNodes[0].name + (e.target.childNodes[0].type==='radio'? ', '+e.target.childNodes[0].value : '');
          if (name==='SHOW2_I') name = e.target.previousSibling.childNodes[1].getAttribute('name');
          if (name==='SHOW2') name = e.target.childNodes[1].getAttribute('name');
          if (!name) return; // for add_root
//          var name = this.name || this.getAttribute('name')); // for add_hier
////          for (var i in str_func) if (this.name.indexOf(i)==0) {
////            str_tooltip = str_func[i](this,e);
////            break;
////          }
          var str_tooltip = (typeof(str[name])==='function')? str[name]() : str[name];
//            if (!str_tooltip) str_tooltip = str[this.parentNode.name];
          if (!str_tooltip) str_tooltip = str[name.substr(0,name.lastIndexOf('.')+1)+'*'];
          if (!str_tooltip) str_tooltip = str_hier(str,name,'') || '';
          if (pref.test_mode.tips) str_tooltip = 'Name: ' + name + '\n' + str_tooltip;
          str_tooltip = str_tooltip.replace(/\n/mg,'<br>').replace(/  /g,'&emsp;');

          if (name[0]==='#') return str['#*'](e, str_tooltip);
//          if (name[0]==='#') {str['#*'](e, str_tooltip);return;}
//          if (str_tooltip) show_1.call(this,e,str_tooltip);
          return str_tooltip;
        }
//        function show_1(e,str_func, callback, info_tips){ // working code
//          tooltip_kind = (info_tips)? 'info' : 'help';
//          if (!pref.tooltips[tooltip_kind].show) return;
//          tooltip.innerHTML = str_func;
//          if (callback) callback(tooltip);
//          if (hide_timer!==null) {clearTimeout(hide_timer);hide_timer=null;} // test
//          if (!e || tooltip_on===e.target) return;
//          tooltip.style.left = e.clientX + 20 + 'px';
//          tooltip.style.top  = e.clientY + 20 + 'px';
////          if (hide_timer!==null) {clearTimeout(hide_timer);hide_timer=null;}
//          if (tooltip_on) tooltip_on.removeEventListener('mouseout' ,hide, false);
//          else {
//            if (show_timer!==null) clearTimeout(show_timer);
//            show_timer = setTimeout(show_exe,pref.tooltips[tooltip_kind].popup_delay);
//          }
//          tooltip_on = e.target;
//          tooltip_on.addEventListener('mouseout' , hide, false);
//        }
//        function show_exe(){
//          show_timer = null;
////          tooltip_set(tooltip_contents.str_func, tooltip_contents.e, tooltip_contents.callback);
//          site.script_body.appendChild(tooltip);
//          tooltip_shown = true;
//        }
//        function hide(){ // called from both event and external function.
//          if (hide_timer===null) hide_timer = setTimeout(hide_exe,pref.tooltips[tooltip_kind].popdown_delay);
//        }
//        function hide_exe(){
//          hide_timer = null;
//          if (tooltip_shown) {
//            tooltip.parentNode.removeChild(tooltip);
//            tooltip_shown = false;
//          }
//          if (show_timer!==null) {clearTimeout(show_timer);show_timer=null;}
//          if (tooltip_on) {
//            tooltip_on.removeEventListener('mouseout' ,hide, false);
//            tooltip_on = null;
//          }
//        }

        var tooltip_e = null;
        var tooltip_func = null;
        function show_0(e){
          var name = e.target.getAttribute('name');
          var kind = (name && name[0]==='#')? 'info' : 'help'
          if (pref.tooltips[kind].show) req_show(kind, e, show);
        }
        function req_show(kind, e, func){
          tooltip_kind = kind;
          var e_obj = {target:e.target, currentTarget:e.currentTarget, clientX:e.clientX, clientY:e.clientY};
          if (!tooltip_on) {
            if (show_timer!==null) clearTimeout(show_timer);
            show_timer = setTimeout(show_exe2,pref.tooltips[kind].popup_delay);
            tooltip_e = e_obj; // e;
            tooltip_func = func;
          } else if (show_2(e, func(e))) tooltip_e = e_obj;
        }
        function show_exe2(){
          show_timer = null;
          if (show_2(tooltip_e, tooltip_func(tooltip_e))) site.script_body.appendChild(tooltip);
          else tooltip_e = null;
          tooltip_func = null;
        }
        function show_2(e,contents){
          if (!contents) {hide2();return false;}
          if (typeof(contents)==='string') tooltip.innerHTML = contents;
          else {
            tooltip.innerHTML = contents.html;
            if (contents.callback) contents.callback(tooltip);
          }
          if (hide_timer!==null) {clearTimeout(hide_timer);hide_timer=null;}
          if (e && tooltip_on!==e.target) {
            tooltip.style.left = e.clientX + 20 + 'px';
            tooltip.style.top  = e.clientY + 20 + 'px';
            tooltip_on = e.target;
          }
          return true;
        }
//        function hide3(e){
//          if (e.target===e.currentTarget) hide2(); // out from root
//        }
        function hide_if(pn){
          if (tooltip_e && tooltip_e.currentTarget===pn) hide2();
        }
        function hide2(){ // called from both event and external function.
          if (tooltip_e && hide_timer===null) {
//          if ((tooltip_on || tooltip_e) && hide_timer===null) {
            if (show_timer!==null) {clearTimeout(show_timer);show_timer=null;}
            hide_timer = setTimeout(hide_exe2,pref.tooltips[tooltip_kind].popdown_delay);
          }
        }
        function hide_exe2(){
          hide_timer = null;
          if (tooltip_on) {
            tooltip.parentNode.removeChild(tooltip);
            tooltip_on = null;
            tooltip_e = null;
          }
        }
        
        function str_hier(root,name){
          if (!root) return null; // cancel if miss
          var idx = name.indexOf('.');
          return (idx==-1)? root[name] || root['*'] || null :
                            str_hier(root[name.substr(0,idx)],name.substr(idx+1));
        }
//        function str_hier(root,name,str){ // working code.
//          if (!root) return null; // cancel if miss
//          var idx = name.indexOf('.');
//          if (idx==-1 || root['*']) {
//            var val = root[name] || root['*'];
//            return (val)? str + name + ': ' + val : null; // cancel if miss
//          } else {
//            var pfx = name.substr(0,idx);
//            return str_hier(root[pfx],name.substr(idx+1),str+pfx+'.');
//          }
//        }
        var str = {
//          'pn_catalog_triage': 'hide forever, hide until new replies, watch, unwatch, undo.\n'+
//                               'You can customize this in settings -> Catalog: Appearance (in top selector) -> Style:',
////          'pn_catalog_triage': '1st row: Hide it forever.\n2nd row: Hide it now, but it will appear again when the thread gets new replies,\n' +
////            '  and new replies are marked.\n3rd row: Don\'t hide it, just change its appearance.\n' +
////            'Each column shows appearance the thread will get.\n' +
////            'Don\'t forget checking \'Exclusive list\' and \'Attribute list\' for using this function.\n' +
////            'In other words, you can appear it again by unckecking them.\nAnd you can configure these appearance in \'Attribute list\' and \'Triage styles\'.',
          'catalog_refresh_clear': 'Clear all threads at update.',
          'catalog_promiscuous': 'Gather information whatever.',
          catalog: {
            filter: {
              kwd: {
                re: 'Regular Expression.',
                ci: 'Case insensitive. Don\'t distinguish upper and lower case.',
                sentence: '"XXXX YYYY" matches itself as a whole instead of matching "XXXX" and/or "YYYY"',
              },
              time: 'Time : Hide threads which have no posts after the time.',
              time_creation: 'Time(Creation Time) : Hide threads which were created before the time.',
              time_watch: 'Watch: watch threads which have posts after the time.',
              time_watch_creation: 'Watch(Creation Time): watch threads which were created after the time.',
            }
          },
//          'catalog.filter.time_mark': 'Mark: mark newer posts and scrool to them when it\'s opened.',
          'catalog.filter.tag_search.str': 'String for searching tags.\n[CAUTION] this function is very heavy, keep blank here when you don\'t use.',
          'catalog.filter.tag_list': false,
          'network.cross_domain': 'Use \'direct\' if you could, because it\'s quite light, but it doesn\'t work in almost of all environments.\n\'indirect\' usually works well and gives full functionality.\n\Or you can use \'GreaseMonkeyM\'s extension if your browser tend to close steps for cross domain when you connect over X-Frame-Options, but this doesn\'t provide localStorage/IDB features in remote domains.',
          'debug_mode' : 'Debug mode.',
          'show_tooltip' : 'Show this tooltip.',
          'liveTag.rm_list_str': function(){return this.TagExLists();},
          'liveTag.ex_list_str': function(){return this.TagExLists();},
          'TagExLists': function(){return 'String, ...  or\n/RegularExpression/, ... or \nIdentifier:String, ... or \nIdentifier:/RegularExpression/, ...\n'+
            '\nRegularExpression must be embraced by shashes.\n'+
            'String list is applied BEFORE extraction, so it costs more than tag list which is applied AFTER extraction. Regular expression in string list accepts flags, so don\'t forgot to add \'g\' flag for usual work, like /some_regexp/g, or it removes the first match only. You can remove both cases using \'i\' flag.\n'+this.GeneralRules;},
          'catalog_board_list_str': function(){return 'How to write \'Board groups\'.\n'+
            '\nName,Identifier, ...\n\n'+
            'First column is a name of board group. The name is shown on the top right corner of catalog and become a key when you store its filter setting to local Storage.\n'+
            'Second or later columns are members. Each member is expressed by \'Identifier\'. Each line becomes each board group.\n'+
            'You can add tags for filtering or picking up threads. Single # means filter, double #(##) means pick up and filter. For example,\n\n'+
            'CC, lain/\u03bb/, #CatChan // load lain/\u03bb/ and filter by #CatChan, then shows a thread for CatChan in lain/\u03bb/.\n'+
            'lain#lainchan, lain, #lainchan // load all boards of lain and filter by #lainchan, then show all threads which have the tag(#lainchan).\n'+
            '#tech, ##tech // load all boards which have #tech from sites which are set in VirtualBoard, and filter by #tech, then show all threads which have the tag(#tech) from sites.\n'+
            'And you can add commands to the last of each line. \'!stats\' takes statistics if the function is enabled.\n'+
            this.GeneralRules;},
          'GeneralRules': 'Double slash(//) is a beginning of comment.\n\n'+
            'Identifier:\n'+
            'Identifier is a string which contains domain, board and/or thread. You can omit some of them. When some identifiers are dropped, it\'ll be interpreted as follows. Upper case has the priority.\n'+
            '\n'+
            'domain/board/thread\n'+
            '/board/thread\n'+
            'domain/thread\n'+
            'thread\n'+
            'domain/board/\n'+
            '/board/\n'+
            'domain\n'+
            '\n'+
            '\'Board identifier\' must be expressed in a couple of slashes, like /int/. \'Thread identifier\' must be numeric. If the identifier is a word, it\'ll be treated as a \'Thread identifier\' if it is numeric, or it\'ll be a \'Domain identifier\'. '+
            'Domain identifiers must be one of meguca, lain, 4chan, 8chan or KC',
          'catalog.style_general_list_str' : function(){return 'Identifier^Style_string\n'+
            'Style_string is a string and set to its object.style.XXXX. Therefore you can use all of styles in CSS, which ranges from \'background\' or \'border\' to \'fontSize\', \'width\' or \'height\'\n'+ this.GeneralRules;},
//            'About Identifier, see \'board group\'.',
          'catalog.board.recommendation' : 'Scans \'board announcement\' and gets owner\'s recommendation. This recommendation must be start \'Recommendation: \', and the following part of the line is treated as a line of board groups. The recommendation can be seen in a last line of board groups.',
          'catalog_triage_str': '// 1st column :\n'+
            '//   KILL : delete forever, and set its style.\n'+
            '//   TIME : delete until the thread gets new replies, and set its style.\n'+
            '//   NONE : Don\'t hide the thread and set its style.\n'+
            '//   KILL_N : delete forever.\n'+
            '//   TIME_N : delete until the thread gets new replies.\n'+
            '//   ATTR : Set its style additionally.\n'+
            '//   UNDO : undo the last modification.\n'+
            '//   WATCH : watch this thread, or I\'ve read all replies in this thread.\n'+
            '//   UNWATCH : unwatch this thread.\n'+
            '//   STICKY : sticky this thread.\n'+
            '//   UNSTICKY : unsticky this thread.\n'+
            '//   SHOW : show this thread always without regard to filter setteings.\n'+
            '//   UNSHOW : remove \'show\' mark.\n'+
            '// 2nd column : strings in the button.\n'+
            '// 3rd column : style in HTML.\n'+
            '// Repeat these as you wish.',
          'overwrite_site2_eval_str' : 'For developers. This function is killed by security reason. If you want to use, you must uncomment the function \'pref_func.site2_eval\' by yourself.',
          'thread_reader.buttons.B' : 'Bookmark this thread to current catalog.',
          'thread_reader.buttons.UB': 'Unbookmark this thread from current catalog.',
          'thread_reader.buttons.X' : function(){return 'Kill this thread from parent catalog' + ((pref.thread_reader.triage_close)? ', and close.' : '.');},
          'thread_reader.buttons.v' : function(){return 'Hide this thread from parent catalog untill it gets new posts' + ((pref.thread_reader.triage_close)? ', and close.' : '.');},
          'catalog_open_where' : 'this tab: open the thread in this tab, and catalog will be closed.\nnew tab always: this enables you to open a thread in multiple tabs.\nnamed tab: this prevents you from opening a thread in multiple tabs.\na fixed tab: this enables you to use a catalog window as a dashboard.',
          'virtualBoard.scan_domains.*': 'None: Don\'t scan.\nBoard: Read boards.json and set them to boardlist, not scan threads at startup. Threads are scanned when you read them.\nThread: Scan all threads at startup.',
          'scanBoard': 'Scan selected virtual boards.\nScan this physical board if no virtual board is selected.',
          'scanSite': 'Scan all virtual boards.\nScan all boards in this site if no virtual board is selected.',
          'style.fix.*': 'Write style strings.',
          'style.copy.*': 'Write exact selectorText in CSS, then its styles are copied.',
          debug_mode:['pipe','','removed threads from catalog'],
          dummy: '',
          archive: {kwd: null},
          '#*': function(e, str){return liveTag.tooltip(e, str);},
        };
        str.archive.kwd = str.catalog.filter.kwd;
        str['catalog.filter.tag_search.re'] = str.catalog.filter.kwd.re;
        Object.defineProperty(str,'catalog_triage_str',{value:str['catalog_triage_str'], enumerable:true, configurable:true, writable:false});
        return {
          add_root: function(elem){
            elem.addEventListener('mouseover', show_0, false);
            elem.addEventListener('mouseleave', hide2, false);
          },
          remove_root: function(elem){
            elem.removeEventListener('mouseover', show_0, false);
            elem.removeEventListener('mouseleave', hide2, false);
          },
          show: show,
//          show_1: show_1,
//          hide: hide,
          str: str,
          req_show:req_show,
          hide2: hide2,
          show_2: show_2,
          hide: hide2,
          hide_if: hide_if,
        }
      })(),
      pref_samples: (site0.isStep)? null : {
        simple: {
          catalog_triage_str: 'KILL,X,',
          catalog : {style_general_list_str:'%border:4px solid #d6daf0\n%margin:4px',
                     format : {show:{posts:true}}},
        },
        backwash: {
          catalog_triage_str :
            'NONE,O,width:;height:,NONE,O,border:4px solid #ff0000;width:100px;height:100px,NONE,O,border:4px solid #00ff00;width:100px;height:100px,'+
            'NONE,O,border:4px solid #0000ff;width:100px;height:100px,NONE,O,border:4px solid #ffff00;width:100px;height:100px,'+
            'NONE,O,border:4px solid #ff00ff;width:100px;height:100px,NONE,O,border:4px solid #00ffff;width:100px;height:100px',
          catalog_expand_at_initial : true,
          page:{click:'expand'},
          catalog:{format: {show:  {style:  true, contents:  true, layout:  true, posts: true, fileinfo: true, images_2nd: true}}},
        },
        recommend: {
          max_threads_at_refresh : 500,
          catalog: {
            auto_load_filter: true,
            auto_save_filter: true,
            auto_save_filter_at_refresh: true,
            order: {
              sticky:'first',
//              find_sage_in_8chan: true
            },
            board: {board_tags_same: true},
            auto_update : true,
            auto_update_period : 1,
          },
          page:{auto_update:true, auto_update_period:1},
          float:{auto_update:true, auto_update_period:1},
        },
        get easy2(){return pref.easy2;},
        'easy2.presets': (function(){
          var presets = [
            {liveTag: {use:false}, virtualBoard:{scan:false}, LTfrom:0, VB:{local:0, global:0}, network:{fetch_actively:false}},
            {liveTag: {use:false}, virtualBoard:{scan:true }, LTfrom:0, VB:{local:1, global:0}, network:{fetch_actively:false}},
            {liveTag: {use:false}, virtualBoard:{scan:true }, LTfrom:0, VB:{local:1, global:1}, network:{fetch_actively:false}},
            {liveTag: {use:true }, virtualBoard:{scan:true }, LTfrom:0, VB:{local:2, global:0}, network:{fetch_actively:true }},
            {liveTag: {use:true }, virtualBoard:{scan:true }, LTfrom:0, VB:{local:2, global:1}, network:{fetch_actively:true }},
            {liveTag: {use:true }, virtualBoard:{scan:true }, LTfrom:0, VB:{local:2, global:2}, network:{fetch_actively:true }},
            {liveTag: {use:true }, virtualBoard:{scan:true }, LTfrom:1, VB:{local:2, global:0}, network:{fetch_actively:true }},
            {liveTag: {use:true }, virtualBoard:{scan:true }, LTfrom:1, VB:{local:2, global:1}, network:{fetch_actively:true }},
            {liveTag: {use:true }, virtualBoard:{scan:true }, LTfrom:1, VB:{local:2, global:2}, network:{fetch_actively:true }},
          ];
          var vb_kwd = ['none','board','thread'];
          var basics = {
            catalog:{auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true},
            page:{load_on_demand:true},
          };
          return function(idx){
            var easy2 = pref.easy2;
            if (idx!==undefined) pref_func.pref_overwrite(easy2, presets[idx]);
            easy2.virtualBoard.scan_domains = {};
            for (var i in pref.virtualBoard.scan_domains) easy2.virtualBoard.scan_domains[i] = vb_kwd[((i===site.nickname)? easy2.VB.local : easy2.VB.global)];
            easy2.liveTag.from = (easy2.LTfrom===0)? 'op' : 'post';
            var auto_update = {auto_update:pref.easy2.auto_update, auto_update_period:pref.easy2.auto_update_period};
            if (easy2.catalog.embed)      pref_func.pref_overwrite(easy2,{catalog:auto_update});
            if (easy2.catalog.embed_page) pref_func.pref_overwrite(easy2,{page:   auto_update});
            if (easy2.thread.embed)       pref_func.pref_overwrite(easy2,{thread: auto_update});
            if (easy2.catalog.filter.time_watch || easy2.catalog.filter.time_watch_creation)
              easy2.catalog.filter.time_str = new Date(Date.now()-((easy2.catalog.filter.time_watch)?easy2.time_post:easy2.time_op)*3600000).toLocaleString();
            if (pref.easy2.basics) pref_func.pref_overwrite(easy2, basics);
            return easy2;
          };
        })(),
        'easy2.limits': (function(){
          var limits = [
            {virtualBoard:{max:100}, scan:{max:  100, max_threads:  1000}, catalog:{max_threads_at_refresh:  500}}, // general
            {virtualBoard:{max: 50}, scan:{max:  100, max_threads:  1500}, catalog:{max_threads_at_refresh: 1500}}, // lain, meguca
            {virtualBoard:{max:150}, scan:{max:  100, max_threads: 15000}, catalog:{max_threads_at_refresh:15000}}, // 4chan
            {virtualBoard:{max:100}, scan:{max:   50, max_threads: 15000}, catalog:{max_threads_at_refresh:15000}}, // 8chan, top 50
            {virtualBoard:{max:150}, scan:{max:  100, max_threads: 30000}, catalog:{max_threads_at_refresh:15000}}, // 8chan, top 100
            {virtualBoard:{max:200}, scan:{max:  500, max_threads:100000}, catalog:{max_threads_at_refresh:15000}}, // 8chan, top 500
            {virtualBoard:{max:200}, scan:{max:10000, max_threads:100000}, catalog:{max_threads_at_refresh:15000}}, // 8chan, all
            {virtualBoard:{max:150}, scan:{max:  100, max_threads: 15000}, catalog:{max_threads_at_refresh:15000}}, // KC
          ];
          return function(){
            pref_func.pref_overwrite(pref.easy2, limits[pref.easy2.limits]);
          }
        })(),
        'easy.virtualBoard_10_passive': {
          virtualBoard: {show: true, scan: true, max:20},
          catalog: {auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true, auto_update:true, auto_update_period:10},
          page:{auto_update:true, auto_update_period:10},
          float:{auto_update:true, auto_update_period:10},
          func: function(){for (var i in pref.virtualBoard.scan_domains) pref.virtualBoard.scan_domains[i] = (i===site.nickname)? 'board' : 'none';},
        },
        'easy.virtualBoard_10': {
          virtualBoard: {show: true, scan: true, max:20},
          catalog: {auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true, auto_update:true, auto_update_period:10},
          page:{auto_update:true, auto_update_period:10},
          float:{auto_update:true, auto_update_period:10},
          func: function(){for (var i in pref.virtualBoard.scan_domains) pref.virtualBoard.scan_domains[i] = (i===site.nickname)? 'thread' : 'none';},
        },
        'easy.virtualBoard_1': {
          virtualBoard: {show: true, scan: true, max:100, scanDelay: 20},
          catalog: {auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true, auto_update:true, auto_update_period:1},
          page:{auto_update:true, auto_update_period:1},
          float:{auto_update:true, auto_update_period:1},
          func: function(){for (var i in pref.virtualBoard.scan_domains) pref.virtualBoard.scan_domains[i] = (i===site.nickname)? 'thread' : 'none';},
        },
        'easy.virtualBoard_8_50': {
          virtualBoard: {show: true, scan: true, max:100, scanDelay: 20},
//          scan:{max:50},
          catalog: {auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true, auto_update:true, auto_update_period:5},
          page:{auto_update:true, auto_update_period:5},
          float:{auto_update:true, auto_update_period:5},
          func: function(){
            pref.scan.max = pref.easy.max_boards;
            for (var i in pref.virtualBoard.scan_domains) pref.virtualBoard.scan_domains[i] = (i===site.nickname)? 'thread' : 'none';
          },
        },
////        'easy.virtualBoard_8_100': {
////          catalog_auto_update : true,
////          catalog_auto_update_period : 5,
////          virtualBoard: {show: true, scan: true, max:100, scanDelay: 20},
////          scan:{max:100},
////          catalog: {auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true},
////          func: function(){for (var i in pref.virtualBoard.scan_domains) pref.virtualBoard.scan_domains[i] = (i===site.nickname)? 'thread' : 'none';},
////        },
////        'easy.virtualBoard_8_500': {
////          catalog_auto_update : true,
////          catalog_auto_update_period : 5,
////          virtualBoard: {show: true, scan: true, max:100, scanDelay: 20},
////          scan:{max:500},
////          catalog: {auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true},
////          func: function(){for (var i in pref.virtualBoard.scan_domains) pref.virtualBoard.scan_domains[i] = (i===site.nickname)? 'thread' : 'none';},
////        },
        'easy.virtualBoard_8_all': {
          virtualBoard: {show: true, scan: true, max:100, scanDelay: 20},
          scan:{max:10000},
          catalog: {auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true, auto_update:true, auto_update_period:5},
          page:{auto_update:true, auto_update_period:5},
          float:{auto_update:true, auto_update_period:5},
          func: function(){for (var i in pref.virtualBoard.scan_domains) pref.virtualBoard.scan_domains[i] = (i===site.nickname)? 'thread' : 'none';},
        },
        'easy.virtualBoard_interSite': {
          virtualBoard: {show: true, scan: true, max:100, scanDelay: 20},
          catalog: {auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true, auto_update:true, auto_update_period:10},
          page:{auto_update:true, auto_update_period:10},
          float:{auto_update:true, auto_update_period:10},
          func: function(){for (var i in pref.virtualBoard.scan_domains) pref.virtualBoard.scan_domains[i] = (i===site.nickname)? 'thread' : 'board';},
//          func: function(){for (var i in pref.virtualBoard.scan_domains) if (i!==site.nickname && pref.virtualBoard.scan_domains[i]==='none') pref.virtualBoard.scan_domains[i] = 'board';},
        },
        'easy.posts_0h': {
          catalog:{filter:{time_str:null, time_watch:true}},
          func: function(){pref_func.pref_samples['easy.posts_0h'].catalog.filter.time_str = new Date().toLocaleString();}
        },
        'easy.posts_24h': {
          catalog:{filter:{time_str:null, time_watch:true}},
          func: function(){pref_func.pref_samples['easy.posts_24h'].catalog.filter.time_str = new Date(Date.now()-pref.easy.posts_ago*3600000).toLocaleString();}
        },
        'easy.threads_24h': {
          catalog:{filter:{time_str:null, time_watch_creation:true}},
          func: function(){pref_func.pref_samples['easy.threads_24h'].catalog.filter.time_str = new Date(Date.now()-pref.easy.threads_ago*3600000).toLocaleString();}
        },
////        'easy.posts_48h': {
////          catalog:{filter:{time_str:null, time_watch:true}},
////          func: function(){pref_func.pref_samples['easy.posts_48h'].catalog.filter.time_str = new Date(Date.now()-48*3600000).toLocaleString();}
////        },
        'easy.embed_index': {
          catalog:{embed_page:true, auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true},
        },
        'easy.embed_index_lazy': {
          catalog:{embed_page:true, auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true, auto_watch:false},
          liveTag:{use:false},
          notify:{desktop:{notify:false}},
          network:{fetch_actively:false},
//          page:{scan_tag:false},
        },
        'easy.light': {
          catalog:{embed_page:true, auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true,
                   filter:{time_watch:false, time_watch_creation:false},
                  },
          liveTag:{use:false},
          stats:{use:false},
          network:{fetch_actively:false},
//          page:{scan_tag:false},
        },
        'easy.embed_index_infinite': {
          catalog_max_page_auto:true,
          catalog:{embed_page:true, auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true},
        },
        'easy.embed_index_backwash': {
          catalog_max_page_auto:true,
          catalog:{embed_page:true, auto_load_filter:true, auto_save_filter:true, auto_save_filter_at_refresh:true, auto_update:true, auto_update_period:0},
          page:{auto_update:true, auto_update_period:0},
          float:{auto_update:true, auto_update_period:0},
        },
        'easy.stat_activate': {
          stats:{use:true},
          virtualBoard:{scan:true, scan_domains:{}},
          liveTag:{use:true, from:'post'},
          func: function(){this.virtualBoard.scan_domains[site.nickname] = 'board';},
        },
        triage_simple_kill: {
          catalog_triage_str: 'KILL,X,',
//          'pn_catalog_triage': 'hide forever.'
        },
        triage_simple: {
          catalog_triage_str: 'KILL,X,,TIME,v,,WATCH,W,,UNWATCH,UW,,UNDO,U,',
//          'pn_catalog_triage': 'hide forever, hide until new replies, watch, unwatch, undo.'
        },
        triage_basic: {
          catalog_triage_str: 'KILL,X,,TIME,v,,WATCH,W,,UNWATCH,UW,,SHOW,\u2605,,UNSHOW,\u2606,,STICKY,S,,UNSTICKY,US,,UNDO,U,',
        },
        triage_basic_color: {
          catalog_triage_str: 'KILL_N,X,,TIME_N,v,,WATCH,W,,UNWATCH,UW,,SHOW,\u2605,,UNSHOW,\u2606,,STICKY,S,,UNSTICKY,US,,UNDO,U,\n'+
            'NONE,O,,ATTR,O,background:#c3dcf9,ATTR,O,background:#b8efc2,'+
            'ATTR,O,background:#efedbe,ATTR,O,background:#fbd5fb,ATTR,O,background:#fac2c5\n'+
            'ATTR,O,border:3px solid blue,ATTR,O,border:3px solid lime,'+
            'ATTR,O,border:3px solid yellow,ATTR,O,border:3px solid orange,ATTR,O,border:3px solid red\n',
        },
        triage_colorful: {
          catalog_triage_str:
            'KILL,X,,KILL,X,background:#c3dcf9,KILL,X,background:#b8efc2,'+
            'KILL,X,background:#efedbe,KILL,X,background:#fbd5fb,KILL,X,background:#fac2c5\n'+
            'TIME,v,,TIME,v,background:#c3dcf9,TIME,v,background:#b8efc2,'+
            'TIME,v,background:#efedbe,TIME,v,background:#fbd5fb,TIME,v,background:#fac2c5\n'+
            'NONE,O,,NONE,O,background:#c3dcf9,NONE,O,background:#b8efc2,'+
            'NONE,O,background:#efedbe,NONE,O,background:#fbd5fb,NONE,O,background:#fac2c5\n'+
            'UNDO,U,,WATCH,W,,UNWATCH,UW,,GO,G,\n',
//          'pn_catalog_triage': '1st row: Hide it forever.\n'+
//            '2nd row: Hide until new replies\n' +
//            '3rd row: Change its appearance.\n' +
//            'Undo, Watch, UnWatch.\n'
        },
        triage_borders: {
          catalog_triage_str:
            'KILL,X,,KILL,X,border:3px solid blue,KILL,X,border:3px solid lime,'+
            'KILL,X,border:3px solid yellow,KILL,X,border:3px solid orange,KILL,X,border:3px solid red\n'+
            'TIME,v,,TIME,v,border:3px solid blue,TIME,v,border:3px solid lime,'+
            'TIME,v,border:3px solid yellow,TIME,v,border:3px solid orange,TIME,v,border:3px solid red\n'+
            'NONE,O,,NONE,O,border:3px solid blue,NONE,O,border:3px solid lime,'+
            'NONE,O,border:3px solid yellow,NONE,O,border:3px solid orange,NONE,O,border:3px solid red\n'+
            'UNDO,U,,WATCH,W,,UNWATCH,UW,,GO,G,\n',
//          'pn_catalog_triage': '1st row: Hide it forever.\n'+
//            '2nd row: Hide until new replies\n' +
//            '3rd row: Change its appearance.\n' +
//            'Undo, Watch, UnWatch.\n'
        },
        triage_samples: {
          catalog_triage_str: 
            'KILL,delete forever,\n'+
            'TIME,hide until new replies,\n'+
            'NONE,back to default design,background:;border:;\n'+
            'NONE,border and background,background:#c3dcf9;border:3px solid blue\n'+
            'NONE,border 3px,border:3px solid blue\n'+
            'NONE,background,background:#c3dcf9\n'+
            'NONE,border 5px,border:5px solid blue\n'+
            'NONE,border 1px,border:1px solid blue\n'+
            'NONE,transparent,background:\n'+
            'NONE,shrink,width:100px;height:100px\n'+
            'GO,open this thread,\n',
//          'pn_catalog_triage': 'samples\n'
        },
        triage_test: {
          catalog_triage_str: 'KILL,X,,TIME,v,,WATCH,W,,UNWATCH,UW,,SHOW,\u2605,,UNSHOW,\u2606,,STICKY,S,,UNSTICKY,US,,UNDO,U,,ARC,A+,,ARC1,A1,,UARC,A-,',
        },
        pn_samples : null,
        init : function(){
          if (pref_func.pref_samples.pn_samples) return;
          var html = 'General samples:<br>'+
                     '<button name="simple">simple</button><br>'+
                     '<button name="backwash">backwash</button><br>'+
                     '<button name="recommend">recommend for desktop/note</button><br>'+
                     'Triages:<br>'+
                     '<button name="triage_simple_kill">simple_kill</button><br>'+
                     '<button name="triage_simple">simple</button><br>'+
                     '<button name="triage_basic">basic</button><br>'+
                     '<button name="triage_basic_color">basic_color</button><br>'+
                     '<button name="triage_colorful">colorful</button><br>'+
                     '<button name="triage_borders">borders</button><br>'+
                     '<button name="triage_samples">samples</button><br>'+
                     '<button name="triage_test">test</button><br>';
          cnst.make_popup(pref_func.pref_samples,'pn_samples',html,pref_func.pref_samples.onclick_event);
//          pref_func.pref_samples.pn_samples = cnst.init('left:0px:tile:get:bottom:Show:tb',cnst.void_func,cnst.void_func,pref_func.pref_samples.destroy,cnst.void_func)[0];
//          var pn_smpl = pref_func.pref_samples.pn_samples;
//          pn_smpl.childNodes[1].innerHTML = '<button name="backwash">backwash</button>';
//          var buttons = pn_smpl.childNodes[1].getElementsByTagName('BUTTON');
//          for (var i=0;i<buttons.length;i++) buttons[i].onclick = pref_func.pref_samples.onclick_event;
        },
//        destroy : function() {
//          pref_func.pref_samples.pn_samples = cnst.div_destroy(pref_func.pref_samples.pn_samples, true);
//        },
        get_name: function(src,names,str){
          for (var i in src) {
            if (typeof(src[i])!=='object') names.push(str+i);
            else pref_func.pref_samples.get_name(src[i],names,str+i+'.');
          }
          return names;
        },
        onclick_event : function(e, src) {
          if (!src) src = pref_func.pref_samples[this.name];
          if (src.func && typeof(src.func)==='function') src.func();
          pref_func.pref_overwrite(pref,src);
          pref_func.pref_overwrite(pref_func.tooltips.str,src);
          var names = pref_func.pref_samples.get_name(src,[],'');
          var pns = Array.prototype.slice.call(document.querySelectorAll('*[name]'));
          for (var i=pns.length-1;i>=0;i--) if (names.indexOf(pns[i].name)==-1) pns.splice(i,1);
          if (pns.length>0) pref_func.apply_prep(pns, false, true, null, true);  // refresh appearance, make object, trigger event.
//          for (var i=0;i<names.length;i++) { // worknig code, but has a bug...
//            var pn = document.getElementsByName(names[i])[0];
//            if (pn) pref_func.apply_prep(document.getElementsByName(names[i])[0], false, true, null, true);  // refresh appearance, make object, trigger event.
//          }
////          for (var i=0;i<names.length;i++) { // working code.
////            var pn = document.getElementsByName(names[i])[0];
////            if (pn) {
////              pref_func.apply_prep(pn,false);  // refresh appearance.
//////            pref_func.apply_prep(pn,true);   // make obj.
//////              pref_func.invoke_onchange(pn,true);   // make obj.
////            }
////            pref_func.make_pref_obj(names[i]); // make obj.
//////            if (pref_func.settings.onchange_funcs[names[i]]) pref_func.settings.onchange_funcs[names[i]].call(pn);
////            if (pn && pref_func.settings.onchange_funcs[names[i]]) pref_func.settings.onchange_funcs[names[i]].call(pn);
////          }
////          if (sessionStorage) sessionStorage.pref = JSON.stringify(pref);
        }
      },
      settings: {
        pn13 : null,
        show_hide : function(e){
          if (pref_func.settings.pn13===null) {
            var pos = ((e.clientX*2>window.innerWidth)? 'right':'left') + ':0px:' + ((e.clientY*2>window.innerHeight)? 'bottom:0':'top:'+site.header_height())+'px';
            var pn13 = cnst.init(pos+':Show:tb',cnst.void_func,cnst.void_func,pref_func.settings.show_hide,cnst.void_func);
            var pn13_0_2 = cnst.add_to_tb(pn13,
              '<select name="settings.indexing">'+
                '<option>' + pref_func.settings.options.join('</option><option>') + '</option>'+
              '</select>');
            pn13_0_2.getElementsByTagName('select')['settings.indexing'].selectedIndex = pref.settings.indexing;
            pref_func.settings.pn13 = pn13; // for onchange func.
            pref_func.mirror_targets.pn13_1 = pn13.childNodes[1]; // for mirror.
            pref_func.settings.onchange_funcs['settings.indexing']();
            pref_func.add_onchange(pn13_0_2,pref_func.settings.onchange_funcs_formatted);
            pref_func.tooltips.add_root(pref_func.mirror_targets.pn13_1);
            cnst.bottom_top(pn13);
          } else {
            pref_func.tooltips.remove_root(pref_func.mirror_targets.pn13_1);
            pref_func.settings.files_store();
            pref_func.mirror_targets.pn13_1 = null;
            pref_func.settings.pn13 = cnst.div_destroy(pref_func.settings.pn13, true); // returns null
          }
        },
////        show_hide : function(){cnst.make_destroy(pref_func.settings,'pn13',pref_func.settings.prep_pn13,pref_func.settings.destroy_pn13);}, // working code.
////        prep_pn13 : function(){
////          var pn13 = cnst.init('left:0px:tile:get:bottom:Show:tb',cnst.void_func,cnst.void_func,pref_func.settings.show_hide,cnst.void_func)[0];
////          var pn13_0_2 = cnst.add_to_tb(pn13,
////            '<select name="settings.indexing">'+
////              pref_func.settings.options.join('') + 
////////              '<option>Catalog: General 0</option>'+
////////              '<option>Catalog: General 1</option>'+
////////              '<option>Catalog: Board Group</option>'+
////////              '<option>Catalog: Appearance</option>'+
////////              '<option>Catalog: Design</option>'+
////////              '<option>Catalog: Footer/PopUp</option>'+
////////              '<option>Watcher / Notifiers</option>'+
//////////              '<option>Statistics:</option>'+
////////              '<option>UIP tracker for 4chan</option>'+
////////              '<option>Command Line Interface</option>'+
//////////              '<option>Workaround for dollchan</option>'+
////////              '<option>General</option>'+
////////              '<option>About</option>'+
////            '</select>');
////          pn13_0_2.getElementsByTagName('*')['settings.indexing'].selectedIndex = pref.settings.indexing;
////          pref_func.settings.pn13 = pn13; // for onchange func.
////          pref_func.mirror_targets.pn13_1 = pn13.childNodes[1]; // for mirror.
////          pref_func.settings.onchange_funcs['settings.indexing'](); // leaks 1 EventLister, but call add_onchange in this.
////          pref_func.add_onchange(pn13_0_2,pref_func.settings.onchange_funcs); // leaks 1.
////          cnst.bottom_top(pn13);
////          return pn13;
////        },
////        destroy_pn13 : function(){
////          pref_func.mirror_targets.pn13_1 = null;
////          pref_func.settings.files_store();
////          pref_func.settings.pn13 = cnst.div_destroy(pref_func.settings.pn13, true); // returns null
////        },
        apply_pn13_1: function(set,propagate){
          pref_func.apply_prep(pref_func.settings.pn13.childNodes[1],set,propagate);
          pref_func.settings.onchange_funcs['pn13_1_warning']();
        },
        files_store: function(){
          var files_archive = pref_func.mirror_targets.pn13_1.querySelectorAll('span[name="FILES_ARCHIVE0"]')[0]; // out of w3c, but works in chrome and FF.
          if (files_archive) site.script_body.firstChild.appendChild(files_archive); // called also at initial. // firstChild is 'display:none'.
//          if (files_archive) site.script_body.appendChild(files_archive); // called also at initial.
          var files = pref_func.settings.pn13.querySelectorAll('input[type=file]');
          if (files.length>0) pref_func.apply_prep_2(files,true);
        },
        insert_menu: function(menu,html){
          var idx = pref_func.settings.options.length-1;
          pref_func.settings.options.splice(idx,0,menu);
          pref_func.settings.htmls.splice(idx,0,html);
        },
        html_funcs: {
          show_hide_all_to_header: function(str){
            return '<span>' + str + '<a name="SHOWALL" style="float:right;cursor:pointer" data-str="[all\u25b2]">[all\u25bc]</a></span>';
          },
//          show_hide_all_to_header: function(str){
//            return '<span>' + str + '<span style="float:right">' + this.show_hide_all('all\u25bc', 'all\u25b2') + '</span></span>';
//          },
          show_hide_all: function(str_show, str_hide){
            return '<a name="SHOWALL" style="cursor:pointer">[' +str_show+ ']</a><a name="HIDEALL" style="cursor:pointer">[' +str_hide+ ']</a>';
          },
          show_hide: function(show, hide, inner, header){
            return '<a name="SHOW" style="cursor:pointer" data-str="' +hide+ '">' +show+ '</a><span style="display:none" name="SUB">' +(header||'')+ '<br>' +inner+ '</span>';
          },
//          show_hide: function(str_show, str_hide, str_inner){
//            return '<a name="SHOW" style="cursor:pointer">[' +str_show+ ']</a><a name="HIDE" style="cursor:pointer;display:none">[' +str_hide+ ']</a><span style="display:none" name="SUB"><br>' +str_inner+ '</span>';
//          },
          popup: function(mode){
            return '2,<ICBX"'+mode+'.popup"> Pop up reply' + this.rollup(
              this.popup_delay('proto.')+'<br>'+
              '3,<IC"proto.popup_hlt">Highlight the post if it is visible')+'<br>';
          },
          popup_delay: function(pf, imm_down){
            return '4,<IR"'+pf+'popdown,imm">immediately<br>'+
              '4,<IR"'+pf+'popdown,delay">delayed: <ITB4"'+pf+'popup_delay">'+(imm_down? '':'<ITB4"'+pf+'popdown_delay">')+' ms<br>'+
              '5,<IC"'+pf+'popup_mMove">Don\'t popup while mouse is moving<br>'+
              '4,zIndex: <ITB3"'+pf+'popup_zIndex">';
          },
          expand_thumbnail_inline: function(mode){
            var pf = mode+'.thumbnail.inline.';
            return '2,<IC"' +mode+ '.expand_thumbnail_inline">Image expansion at click'+ this.rollup(
              this.limit_webm(pf)+
              '3,<IC"' +mode+ '.expand_thumbnail_initial">Expand all images at initial<br>'+
              '3,<IC"' +mode+ '.expand_thumbnail_inline_all_after">Expand all images after clicked one<br>'+
              '4,<IC"' +pf+ 'ondemand">On demand loading: '+
              '<ITB3"' +pf+ 'ref_height"> % of browser')+ '<br>';
          },
          expand_thumbnail_hover: function(mode){
            var pf = mode+'.thumbnail.hover.';
            return '2,<IC"' +mode+ '.image_hover">Image hover'+ this.rollup(
              this.popup_delay(pf, true)+'<br>'+
              this.limit_webm(pf)+
              '3,<IC"' +mode+ '.image_prefetch">Prefetch next image<br>'+
              '3,<IC"' +pf+ 'dragfloat">Drag thumbnail to make it window<br>'+
              '4,<IC"' +pf+ 'df_dblC">Double click to close<br>'+
              '4,<IC"' +pf+ 'df_mW">Wheel to scroll<br>'+
              '4,<IC"' +pf+ 'df_cV">Continue playing video<br>'+
              '3,<IC"' +pf+ 'zoom">Click to zoom mode if limited')+'<br>';
          },
          limit_webm: function(pf){
            return '4,<IC"' +pf+ 'limit_width">Limit to browser\'s width - <ITB3"' +pf+ 'margin_width"> px<br>'+
              '4,<IC"' +pf+ 'limit_height">Limit to browser\'s height - <ITB3"' +pf+ 'margin_height"> px<br>'+
              '4,<IC"' +pf+ 'webm">Play webm<br>'+
              '5,<IC"' +pf+ 'webm_loop">Loop<br>'+
              '5,<IC"' +pf+ 'webm_mute">Mute<br>';
//              '3,<ICBX"' +pref+ 'limit_width"> Limit to browser\'s width - <ITB3"' +pref+ 'margin_width"> px<br>'+
//              '3,<ICBX"' +pref+ 'limit_height"> Limit to browser\'s height - <ITB3"' +pref+ 'margin_height"> px';
          },
          env: function(mode, str_inner){
            return '1,Environment values:(advanced option)'+ this.rollup(
              '2,You are using native function of:<br>'+
              '3,<IC"' +mode+ '.popup_native">Pop up reply<br>'+
              '3,<IC"' +mode+ '.expand_thumbnail_inline_native">Image expansion<br>'+
              '3,<IC"' +mode+ '.image_hover_native">Image hover<br>'+
              '3,<IC"' +mode+ '.colorID_native">Color ID<br>'+
              '3,<IC"' +mode+ '.backlink_native">Backlink<br>'+
              '3,<IC"' +mode+ '.localtime_native">Local time'+
              str_inner + '<br>'+
              '2,<IC"' +mode+ '.popup_native_kill">Suppress native static popup') + '<br>';
          },
          posts_for_search: function(mode){
            return '2,'+ this.rollup_radio(mode+'.storePosts',' :Num of posts to store for search', 3, '',
              ['no:No additional posts are stored for search.<br>5,Search will be done only from posts for preview.',
               'ALL:All posts are stored always.<br>5,Search will be done from all posts without preparation scan.',
               'auto:All posts in all scanned threads are stored after the first activation of search.<br>5,Need (automatic) scans prior to search. (usual usage)',
               'ALL_agg:All posts in all scanned threads are stored.<br>5,Search will be done from all scanned threads.<br>5,This is an option for search from entire domains.<br>'+
               '3,<IC"proto.searchAc.loosen">Auto loosen limits at the first activation'+this.rollup(
                 '6,Max boards of a scan: <ITB6"proto.searchAc.max"><br>'+
                 '6,Max threads of a scan: <ITB6"proto.searchAc.max_threads"><br>'+
                 '6,Max threads at refresh (auto deletion): <ITB6"proto.searchAc.max_threads_at_refresh"><br>'+
                 '5,<BTN"tighten_loosed_limits,Tighten loosed limits">')+'<br>'+
               '3,<IC"proto.searchAs">Auto scan from this (virtual) board if needed <BTN"scanBoardIf,Scan"><BTN"scanBoard,Rescan"><br>'+
               '3,<IC"proto.searchAsA">Auto scan from all (virtual) boards if needed <BTN"scanSiteIf,Scan"><BTN"scanSite,Rescan">']) +'<br>'+
              '2,'+ this.rollup_radio(mode+'.sourceOfSP',' :Posts to be used for search', 3,
              '3,Posts may be stored also by function of deleted posts detection.<br>'+
              '3,Number of stored posts can be shown in footer.<br>',
              ['auto:All stored posts.(usual usage)',
              'pv:Posts for preview only.<br>5,Search will be done only from recent or newer posts,<br>5,which depends on preview settings.']) +'<br>';
          },
          op_in_search_result: function(mode){
            return '2,' + this.rollup_radio(mode+'.posts_search_op', ' :Unmatched OP in search result', 3, '',
              ['show:Show', 'opaque:Opaque: <ITB3"' +mode+ '.posts_search_op_opacity"> %','hide:Hide']) + '<br>';
//              '2,<ICBX"' + mode + '.auto_config_posts_search"> Auto config and scan at searching posts(WILL BE REPLACED)<br>';

          },
          deleted_posts_detection: function(mode){
            return '2,' + this.rollup_radio(mode+'.deleted_posts.detect', ' :Detect deleted posts', 4, '3,Detection:<br>',
                ['no:No', 'passive:Passive detection. Don\'t make any request',
                 'acc:Best effort without any additional requests', 'full:Full detection, read all posts at first', 'full_IDB:Full detection with IndexedDB'],
              '<br>'+
              '3,<ICBX"' + mode + '.deleted_posts.merge"> Merge deleted posts with live posts'
//              this.radios(mode+'.deleted_posts.store',4,
//                ['LS:Store to LocalStorage to share with other tabs<br>5,<ICBX"' + mode + '.deleted_posts.auto_clean"> Clean up automatically',
//                 'SS:Store to SessionStorage to get higher security', 'MC:Use ChannelMessage for security'])
              );

          },
//          show_val_rollup: function(pref, inner){
//            return '<SSV"' +pref+ '">'+ '&emsp;' + this.show_hide('change...', 'hide', '', inner);
//          },
          radios: function(pref, indent, args, pref2){
            var r_str = indent+',<IR"'+pref+',$1">' + (pref2? pref2.map(function(v){return '<IR"'+v+',$1">';}).join('') : '');
            return args.map(function(v){return v.replace(/([^:]*):/, r_str);}).join('<br>');
          },
          rollup_radio: function(pref, header, indent, middler, args, trailer, pref2){
            return '<a name="SHOW2" style="cursor:pointer" data-str="\u25b2]">[<SSV"' +pref+ '"></span>\u25bc]</a>'+
              '<span name="SHOW2_I">' + header + '</span><span style="display:none" name="SUB"><br>' +middler + this.radios(pref,indent,args,pref2)+ (trailer || '') + '</span>';
//            return '<span name="NEXT" style="cursor:pointer">[<SSV"' +pref+ '"></span>' + this.show_hide('\u25bc]', '\u25b2]', header, middler + args.join('<br>'));
//            return '<SSV"' +pref+ '">'+ header + '&emsp;' + this.show_hide('change...', 'hide', '', middler + args.join('<br>'));
          },
          rollup: function(inner, header){
            return '&emsp;' + this.show_hide('[\u25bc]', '[\u25b2]', inner, header);
          },
          format_posts: function(mode, html_funcs){
            return '2,<ICBX"' +mode+ '.open_spoiler_text"> Open text spoiler<br>'+
              '2,<ICBX"' +mode+ '.colorID"> Color ID<br>'+
              '2,<ICBX"' +mode+ '.backlink"> Backlink'+ this.rollup(
                '3,<ICBX"proto.bl_ec"> Explicit cross backlink<br>'+
                '3,<ICBX"proto.bl_rm"> Don\'t retain backlinks to OP') + '<br>'+
              '2,<ICBX"' +mode+ '.localtime"> Local time<br>'+
              html_funcs.deleted_posts_detection(mode)+'<br>'+
              '2,<ICBX"' +mode+ '.mark_new_posts"> Mark new posts<br>';
          },
          updates: function(mode){
            return '2,<IC"' +mode+ '.auto_update">Auto update, every <ITB2"' +mode+ '.auto_update_period">min.<br>'+
              '2,<IC"' +mode+ '.hide_posts_without_images">Hide posts without images<br>'+
              '2,<IC"' +mode+ '.merge">Merge all threads'+ this.rollup(
                '2,<IC"' +mode+ '.merge_list">Merge listed threads<br>'+
                '3,<TA"proto.merge_list_str,40,1" placeholder="4chan/c/2887897 + 4chan/c/2880944 + 4chan/c/2888255,"><br>'+
                '2,<IC"' +mode+ '.merge_lv">Merge with level (use user CSS to style)<br>'+
                '3,<TA"proto.merge_lv_str,40,1">'+
                this.rollup(this.userCSS(2)))+'<br>';
          },
          userCSS: function(indent){
            return indent+',<IC"style.userCSS.use">User CSS<br>'+
              (indent+1)+',<TA"style.userCSS.str,50,1"><br>'+
              (indent+1)+',Sample user CSS:<br>'+
              (indent+1)+',<TA"style.userCSS.sample,50,1" disabled>';},
//            '<div>'+
//              '<div style="float:left">&emsp;&emsp;</div>'+
//              '<div style="float:left">'+
//                '<TA"style.userCSS.str,50,1">'+
//                '<div style="overflow:scroll;resize:both;">'+this.userCSS_samples.replace(/\n/g,'<br>')+'</div>'+
//              '</div>'+
//            '</div>';},
//          userCSS_samples: 'Samples:\n'+
//            '.CatChan_titleBar button[name^="op"]{display:none} /* remove transparency buttons in titleBar */\n',
          vb_domains: function(){
//            var str = '<span name="virtualBoard.scan_domains">'+
            var str = '2,Scan targets:<br>'+
                      '3,None/Board/Thread(No/Passive/Active)<br>';
            var sites = site0.domains;
            for (var i=0;i<sites.length;i++) {
              str += '3,<input type="radio" name="virtualBoard.scan_domains.'+sites[i]+'" value="none">'+  // 'apply_prep' can't recognize ['domain'] notation.
                     '<input type="radio" name="virtualBoard.scan_domains.'+sites[i]+'" value="board">'+
                     '<input type="radio" name="virtualBoard.scan_domains.'+sites[i]+'" value="thread"> '+ sites[i] +'<br>';
            }
            return str;
          },
//          get_domains: function(){
//            var sites = Object.keys(pref.virtualBoard.scan_domains);
//            sites.unshift(sites.splice(sites.indexOf(site.nickname),1)[0]);
//            return sites;
//          },
          make_sel: function(pref,args){
            var str = '<select name="' + pref + '" style="float:none">';
            for (var i=0;i<args.length;i++) str += '<option>' + args[i] + '</option>';
            return str + '</select>';
          },
          features_domains: function(){
            var str = ''
            for (var i=0;i<site0.domains.length;i++) str += '1,<ICBX"features.domains.'+site0.domains[i]+'"> '+ site0.domains[i] +'<br>';
            return str;
          },
          cb_block: function(pf,start){
            var str = '';
            var i=start-1;
            while (pref[pf][++i]!==undefined) str += '<ICBX"'+pf+'.'+i+'">' + ((i%10===4)? '&emsp;' : (i%50===49)? '<br><br>' : (i%10===9)? '<br>' : '');
            return str;
          },
        },
////        options: [
////          '<option>Easy Setting:</option>',
////          '<option>Virtual board:</option>',
////          '<option>Initialization:</option>',
////          '<option>Catalog: General 1</option>',
////          '<option>Catalog: Board Group</option>',
////          '<option>Catalog: Live Tag</option>',
////          '<option>Catalog: Appearance</option>',
////          '<option>Catalog: Design</option>',
////          '<option>Catalog: Footer/PopUp</option>',
////          '<option>Watcher</option>',
////          '<option>Notifiers</option>',
//////          '<option>Statistics:</option>',
////          '<option>UIP tracker for 4chan</option>',
////          '<option>Command Line Interface</option>',
//////          '<option>Workaround for dollchan</option>',
////          '<option>Networking</option>',
////          '<option>General</option>',
////          '<option>About</option>'
        ////        ],
        options: [
          'Easy Setting2:',
          'Easy Setting:',
          'Virtual Board:',
          'Catalog:',
          'Index Page:',
          'Thread:',
          'Floating Catalog:',
          'Gerenal 0',
          'General 1',
          'Board Group',
          'Live Tag',
          'Statistics',
          'Design of FC',
          'Footer',
          'Watcher',
          'Notifiers',
          'JSON Archiver: Store',
          'JSON Archiver: Restore', // 'pref.settings.indexing===17' are used twice for FILES_ARCHIVE in 'settings.indexing'.
          'UIP tracker for 4chan',
          'Command Line Interface',
//          'Workaround for dollchan',
          'Networking',
          'General 2',
          'Styles',
          'Features',
          'About'
        ],
        htmls: [
          'Easy Setting2: --- Welcome to CatChan! ---<br>'+
          '<br>'+
          '1,0. <button name="easy2.beginner">I\'m a beginner and I just want to try</button>, click this.<br>'+
          '2,Then a reload will be occur after loading settings for beginner.<br>'+
          '2,(This will be default after a certain period of test.)<br>'+
          '2,Or follow next steps to choose your favorite settings.<br>'+
          '<br>'+
          '1,1. <input type="checkbox" name="easy2.reset"> Reset all settings before loading new one if you prefer.<br>'+
          '1,2. Select a preset: '+
          '<select name="easy2.presets" style="float:none">'+
            '<option>Safe default</option>'+
            '<option>Silent inter-board operability (for beginner)</option>'+ // passive/No/No. works silently.
            '<option>Silent inter-site operability</option>'+  // passive/passive/No, works silently.
//            '<option>Silent in-board operability with tags from OP</option>'+    // active/No/liveTag-OP
            '<option>Active inter-board operability</option>'+ // active/No/LiveTag-OP, scans all catalogs.
            '<option>Active inter-site ondemand operability</option>'+ // active/passive/LiveTag-OP, scans all catalogs, but ondemand for other site.
            '<option>Active inter-site operability</option>'+ // active/active/LiveTag-OP, scans all catalogs.
            '<option>Active in-board operability with LiveTag</option>'+    // active/No/liveTag-Post, scans all threads.
            '<option>Active inter-board operability with LiveTag</option>'+ // active/passive/liveTag-Post, scans all threads.
            '<option>Active inter-site operability with LiveTag</option>'+ // active/active/liveTag-Post, scans all threads.
          '</select><br>'+
          '1,3. Select limits for safe: '+
          '<select name="easy2.limits" style="float:none">'+
            '<option>General</option>'+
            '<option>/all/ for lain, meguca</option>'+
            '<option>/all/ for 4chan</option>'+
            '<option>8chan with top 50 boards</option>'+
            '<option>8chan with top 100 boards</option>'+
            '<option>8chan with top 500 boards</option>'+
            '<option>8chan with all boards</option>'+
            '<option>/all/ for KC</option>'+
          '</select><br>'+
          '1,4. Modify details if you want.<br>'+
          '2,<input type="checkbox" name="easy2.virtualBoard.show"> VirtualBoards, shows '+
          '<input type="text" name="easy2.virtualBoard.max" size="3" style="text-align: right;"> virtual boards<br>'+
          '4,Local: <select name="easy2.VB.local" style="float:none">'+
            '<option>No</option>'+
            '<option>Passive</option>'+
            '<option>Active</option>'+
          '</select>'+
          '&emsp;Global: <select name="easy2.VB.global" style="float:none">'+
            '<option>No</option>'+
            '<option>Passive</option>'+
            '<option>Active</option>'+
          '</select><br>'+
          '2,<input type="checkbox" name="easy2.liveTag.use"> LiveTag, '+
          'from: <select name="easy2.LTfrom" style="float:none">'+
            '<option>OP</option>'+
            '<option>Posts</option>'+
          '</select><br>'+
          '2,<input type="checkbox" name="easy2.catalog.embed"> Use CatChan in catalog<br>'+
          '2,<input type="checkbox" name="easy2.catalog.embed_page"> Use CatChan in index page<br>'+
          '2,<input type="checkbox" name="easy2.thread.embed"> Use CatChan in thread<br>'+
          '2,<input type="checkbox" name="easy2.auto_update"> Auto update, every '+
          '<input type="text" name="easy2.auto_update_period" size="2" style="text-align: right;"> min.<br>'+
          '2,<input type="checkbox" name="easy2.notify.desktop.notify"> Desktop notification<br>'+
          '2,<input type="checkbox" name="easy2.catalog.filter.time_watch"> Hide all threads which have no posts in recent '+
          '<input type="text" name="easy2.time_post" size="3" style="text-align: right;"> hours<br>'+
          '2,<input type="checkbox" name="easy2.catalog.filter.time_watch_creation"> Hide all threads which are created before '+
          '<input type="text" name="easy2.time_op" size="3" style="text-align: right;"> hours ago<br>'+
          '2,<input type="checkbox" name="easy2.stats.use"> Statistics<br>'+
          '2,<input type="checkbox" name="easy2.healthIndicator.expand_running"> Show details of running indicators<br>'+
          '2,<input type="checkbox" name="easy2.network.fetch_actively"> Fetch missing info actively<br>'+
//          '2,<input type="checkbox" name="easy2.basics"> Other basic settings, which depends on preset<br>'+
          '2,<input type="checkbox" name="easy2.basics"> Other basic settings<br>'+
          '2,Limits for safe: <br>'+
          '3,At scan: <ITB6"easy2.scan.max"> boards, <ITB6"easy2.scan.max_threads"> threads.<br>'+
          '3,In a catalog: <ITB6"easy2.catalog.max_threads_at_refresh"> threads.<br>'+
          '1,5. Click <button name="easy2.apply">Apply</button><br>'+
          '1,6. Click <button name="save">Save</button> if you want to save your settings to localStorage<br>'+
          '1,7. Click <button name="reload">Reload</button>, because some setting may need<br>'+
          '',
          'Easy Setting:<br>'+
          '&emsp;VBs: virtual boards<br>'+
          '&emsp;AU: auto update every X min<br>'+
          '&emsp;<button name="easy.virtualBoard_10_passive">Click</button> 20 VBs / AU 10 min. / passive scan. (for all)<br>'+
          '&emsp;<button name="easy.virtualBoard_10">Click</button> 20 VBs / AU 10 min. (for lainchan and meguca)<br>'+
          '&emsp;<button name="easy.virtualBoard_1">Click</button> 100 VBs / AU 1 min. (for 4chan)<br>'+
          '&emsp;<button name="easy.virtualBoard_8_50">Click</button> 100 VBs / AU 5 min from top '+
          '<input type="text" name="easy.max_boards" size="3" style="text-align: right;">'+
          ' boards. (for 8chan)<br>'+
//          '&emsp;<button name="easy.virtualBoard_8_100">Click</button> 100 VBs / AU 5 min from top 100 boards. (for 8chan)<br>'+
//          '&emsp;<button name="easy.virtualBoard_8_500">Click</button> 100 VBs / AU 5 min from top 500 boards. (for 8chan)<br>'+
          '&emsp;<button name="easy.virtualBoard_8_all">Click</button> 100 VBs / AU 5 min from all boards. (for 8chan)<br>'+
          '&emsp;<button name="easy.virtualBoard_interSite">Click</button> 100 VBs / AU 10 min from all sites. / passive scan. (for all)<br>'+
          '<br>'+
          '&emsp;<button name="easy.posts_0h">Click</button> I want to check all new posts from now.<br>'+
          '&emsp;<button name="easy.posts_24h">Click</button> I want to check all posts from '+
          '<input type="text" name="easy.posts_ago" size="3" style="text-align: right;">'+
          ' hours ago.<br>'+
          '&emsp;<button name="easy.threads_24h">Click</button> I want to check all new threads from '+
          '<input type="text" name="easy.threads_ago" size="3" style="text-align: right;">'+
          ' hours ago.<br>'+
          '<br>'+
//          '&emsp;<button name="easy.embed_index">Click</button> Use CatChan in index page without infinite scroll.<br>'+
          '&emsp;<button name="easy.embed_index_lazy">Click</button> Setup for narrow band.<br>'+
          '&emsp;<button name="easy.embed_index_infinite">Click</button> Setup for infinite scroll.<br>'+
          '&emsp;<button name="easy.embed_index_backwash">Click</button> Backwash style. (infinite scroll/quick auto update)<br>'+
          '<br>'+
          '&emsp;<button name="easy.light">Click</button> Setup for light start up.<br>'+
          '',
          function(html_funcs){return 'Virtual Board:<br>'+
            '&emsp;<input type="checkbox" name="virtualBoard.show"> Show virtual boards'+
            ', up to: <input type="text" name="virtualBoard.max" size="3" style="text-align: right;"><br>'+
            '2,<ICBX"virtualBoard.search.show"> Show search bar in boardlist<br>'+
//            '3,<ICBX"virtualBoard.search.re"> Regular Expression<br>'+
            '&emsp;<input type="checkbox" name="virtualBoard.scan"> Scan at start up'+
            ', delay: <input type="text" name="virtualBoard.scanDelay" size="2" style="text-align: right;">s<br>'+
            '&emsp;&emsp;&emsp;Scan: <button name="virtualBoard.scanStart">Start</button>'+
            '&emsp;<button name="virtualBoard.scanStop">Stop</button><br>'+
            html_funcs.vb_domains()+
            '&emsp;&emsp;<input type="checkbox" name="virtualBoard.instant_scan"> Instant scan<br>'+
            '&emsp;Physical boards in boardlist:<br>'+
            '&emsp;&emsp;<input type="radio" name="virtualBoard.p_board" value="both"> Show as they are<br>'+
            '&emsp;&emsp;&emsp;<input type="checkbox" name="virtualBoard.p_remove"> Remove virtual boards of the same name<br>'+
            '&emsp;&emsp;<input type="radio" name="virtualBoard.p_board" value="replace"> Replace with virtual boards<br>'+
//            '3,<ICBX"virtualBoard.v_remove"> Remove filtered virtual boards<br>'+
            '1,<ICBX"liveTag.info"> Show infomation on hover<br>'+
            '1,Styles:<br>'+
            '2,Selected:<ITBL30"liveTag.style_in_str"><br>'+
            '2,Excluded:<ITBL30"liveTag.style_ex_str"><br>'+
            '2,<ICBX"liveTag.style"> Add style:<br>'+
  //          '&emsp;&emsp;Unread replies to me:<textarea rows="1" cols="20" name="liveTag.style_urtm_str"></textarea><br>'+
  //          '&emsp;&emsp;Unread replies:<textarea rows="1" cols="20" name="liveTag.style_ur_str"></textarea><br>'+
            '3,Unread replies to me:<ITBL30"liveTag.style_urtm_str"><br>'+
            '3,Unread replies:<ITBL30"liveTag.style_ur_str"><br>'+
            '';},
          function(html_funcs){
            return html_funcs.show_hide_all_to_header('Catalog:') + '<br>'+
              '&emsp;<input type="checkbox" name="catalog.embed"> Use CatChan in catalog<br>'+
              html_funcs.expand_thumbnail_hover('catalog')+
              '&emsp;&emsp;<input type="checkbox" name="catalog.open_spoiler_text"> Open text spoiler<br>'+
              '&emsp;&emsp;<input type="checkbox" name="catalog.auto_update"> Auto update, every '+
              '<input type="text" name="catalog.auto_update_period" size="2" style="text-align: right;"> min.<br>'+
              '&emsp;&emsp;<input type="checkbox" name="page.mark_new_posts"> Mark new posts when you open a thread<br>'+
              '&emsp;&emsp;<input type="checkbox" name="catalog.save_board_list_sel"> Save board group index<br>'+
              '2,'+ html_funcs.rollup_radio('catalog.click_area', ' :Click to open the thread', 3, '',
                ['thumbnail:Thumbnail','entire:Entire thread card'])+ '<br>'+
              '2,'+ html_funcs.rollup_radio(!pref.test_mode['110']? 'catalog.popup3.ww':'catalog.popup2',' :Pop up', 3,
                '3,WW/WN/NW/NN (Wider/Narrower) side:'+html_funcs.rollup(html_funcs.popup_delay('proto.popup3.'))+'<br>',
                ['no:No','sr:Search result','srpv:Search result or preview','pv:Preview','chart:Post rate chart (statistics must be activated)','dp:Deleted posts'], '',['catalog.popup3.wn','catalog.popup3.nw','catalog.popup3.nn'])+ '<br>'+
              '2,'+ html_funcs.rollup_radio('catalog.t2h_sel',' :Num of posts to store for preview', 3, '',
                ['no:No','N:Last <ITB3"catalog.t2h_num_of_posts"> posts (N posts)',
                 'N_unread:N + all unread posts', 'unread:All unread posts', 'ALL:All posts' //, ALL_agg:All posts from all scanned threads'
                ]) +'<br>'+
              html_funcs.posts_for_search('catalog')+
              html_funcs.op_in_search_result('catalog')+
              html_funcs.deleted_posts_detection('catalog')+'<br>'+
              '<br>'+
              '1,Environment values:(advanced option)'+ html_funcs.rollup(
                '2,Native has:<br>'+
                '3,<ICBX"catalog.env.image_hover_native"> Image hover')+'<br>';},
          function(html_funcs){
            return html_funcs.show_hide_all_to_header('Index Page:') + '<br>'+
              '&emsp;<input type="checkbox" name="catalog.embed_page"> Use CatChan in index page' + html_funcs.rollup(
                '3,Refresh up to:<br>'+
                '4,<IR"catalog_max_page_select,manual"> <ITB2"catalog_max_page"> pages<br>'+
                '4,<IR"catalog_max_page_select,auto"> Max pages<br>'+
                '5,<ICBX"catalog_max_page_auto"> Update automatically') +'<br>'+
    //          '&emsp;&emsp;<input type="checkbox" name="page.infinite"> Infinite scroll<br>'+
              html_funcs.popup('page')+
              html_funcs.expand_thumbnail_inline('page')+
              html_funcs.expand_thumbnail_hover('page')+
              html_funcs.format_posts('page', html_funcs)+
    //          '&emsp;&emsp;<input type="checkbox" name="page.scan_tag"> Scan tags at initial<br>'+
    //          '&emsp;&emsp;<input type="checkbox" name="page.format.show.posts"> Show posts<br>'+
              '2,<ICBX"page.use_expander_always"> Use CatChan\'s expander always<br>'+
              '2,' + html_funcs.rollup_radio('page.t2h_sel', ' :Num of posts to show', 3, '',
                ['page:Inherit from index page',
                 'L: <ITB3"page.t2h_L"> posts(L posts)',
                 'M: <ITB3"page.t2h_M"> posts(M posts)',
                 'N: <ITB3"page.t2h_num_of_posts"> posts(N posts)',
                 'N_unread:N + all unread posts',
                 'unread:All unread posts',
                 'ALL:All posts',
//                 'ALL_agg:All posts (for incremental posts search)',
                ]) +'<br>'+
              html_funcs.posts_for_search('page')+
              html_funcs.op_in_search_result('page')+
              html_funcs.updates('page')+
              '&emsp;&emsp;<input type="checkbox" name="page.scroll_lock"> Don\'t scroll at update<br>'+
              '&emsp;<input type="checkbox" name="page.save_board_list_sel"> Save board group index<br>'+
              '<br>'+
              html_funcs.env('page.env','');},
          function(html_funcs){
            return html_funcs.show_hide_all_to_header('Thread:') + '<br>'+
              '&emsp;<input type="checkbox" name="thread.embed"> Use CatChan in thread<br>'+
              html_funcs.popup('thread')+
              html_funcs.expand_thumbnail_inline('thread')+
              html_funcs.expand_thumbnail_hover('thread')+
              html_funcs.format_posts('thread', html_funcs)+
              html_funcs.updates('thread')+
    //          '&emsp;<input type="checkbox" name="thread.save_board_list_sel"> Save board group index<br>'+
              '<br>'+
              html_funcs.env('thread.env', '<br>3,<input type="checkbox" name="thread.env.auto_update_native"> Auto update');},
          'Floating Catalog:<br>'+
          '&emsp;&emsp;<input type="checkbox" name="float.auto_update"> Auto update, every '+
          '<input type="text" name="float.auto_update_period" size="2" style="text-align: right;"> min.<br>'+
          '&emsp;Click to:<br>'+
          '&emsp;&emsp;<input type="radio" name="float.click" value="open">Go to/open the thread<br>'+
          '&emsp;&emsp;<input type="radio" name="float.click" value="expand">Expand/shrink the OP in catalog<br>'+
          '&emsp;&emsp;&emsp;&emsp;<input type="checkbox" name="catalog_expand_at_initial"> Expand at initial<br>'+
          '&emsp;&emsp;&emsp;&emsp;<input type="checkbox" name="catalog_expand_at_initial_embed"> Expand at initial in index.<br>'+
          '&emsp;&emsp;&emsp;&emsp;<input type="checkbox" name="catalog_expand_with_hr"> Insert horizontal splitter when it is expanded<br>'+
          '&emsp;&emsp;&emsp;<input type="checkbox" name="catalog_no_popup_at_expanded"> Don\'t popup when the catalog is expanded<br>'+
          '&emsp;&emsp;<input type="radio" name="float.click" value="none">None<br>'+
          '&emsp;Click area:<br>'+
          '&emsp;&emsp;<input type="radio" name="float.click_area" value="thumbnail">Thumbnail<br>'+
          '&emsp;&emsp;<input type="radio" name="float.click_area" value="entire">Entire thread card<br>'+
          '&emsp;<input type="checkbox" name="float.popup2"> Use pop-up window<br>'+
          '2,appear/disappear:<br>'+
          '3,<IR"catalog_popdown,imm">immediately<br>'+
          '3,<IR"catalog_popdown,delay">delayed: <ITB4"catalog_popup_delay"><ITB4"catalog_popdown_delay"> ms<br>'+
          '2,grab to move / select text:<br>'+
          '3,<IR"proto.popup2_sel,move">Move always<br>'+
          '3,<IR"proto.popup2_sel,auto">Auto, padding-x:<ITB4"proto.popup2_sel_tolerance"> px<br>'+
          '3,<IR"proto.popup2_sel,sel">Select always<br>'+
          '3,<ICBX"catalog_popup_size_fix"> Fix size when you move it<br>'+
          '2,<IC"proto.popup2_resize">Resize on borders of <ITB4"proto.popup2_resize_bw"> px<br>'+
          '3,Size of corner angle: <ITB4"proto.popup2_resize_cw"> px<br>'+
//          '&emsp;&emsp;<input type="checkbox" name="catalog_localtime"> Localtime<br>'+
          '&emsp;At initial:<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog.appearance.initial.state" value="max">Maximized<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog.appearance.initial.state" value="float">Floating '+
          '<input type="text" name="catalog.appearance.initial.width" size="4" style="text-align: right;"> x '+
          '<input type="text" name="catalog.appearance.initial.height" size="4" style="text-align: right;"><br>'+
          '&emsp;&emsp;<input type="radio" name="catalog.appearance.initial.state" value="top">Embed to top<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog.appearance.initial.state" value="bottom">Embed to bottom<br>'+
          '&emsp;<input type="checkbox" name="float.save_board_list_sel"> Save board group index<br>'+
          '',
          'General 0:<br>'+
          '&emsp; Open short link<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog_open_last50" value="no">No. Open entire thread<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog_open_last50" value="exist">If it exists<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog_open_last50" value="exist_watch">If it exists and all unread posts are in it<br>'+
////          '&emsp;&emsp;<input type="radio" name="catalog_open_last50" value="speculative">If it is estimated to exist<br>'+
////          '&emsp;&emsp;<input type="radio" name="catalog_open_last50" value="spec_watch">If it is estimated to exist and unread posts are less than 50<br>'+
          '&emsp; Open the thread in<br>'+
//          '&emsp;&emsp;&emsp;<input type="checkbox" name="catalog_open_where_click"> Apply to reply links in index page<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog_open_where" value="_self">this tab<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog_open_where" value="_blank">new tab always<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog_open_where" value="named">named tab<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog_open_where" value="CatChan_tgt">a fixed tab<br>'+
//          '&emsp;&emsp;<input type="checkbox" name="catalog_use_named_window"> Prevent opening a thread in multiple tabs<br>'+
          '2,<ICBX"pref2.meguca.historyAPI"> Use historyAPI in meguca'+
          '<br>'+
          '&emsp;<input type="checkbox" name="catalog_triage"> Enable triage pop-up<br>'+
          '2,Where to show:<br>'+
          '3,<span style="display:inline-block">'+
            '<IR"catalog_triage_place,topLeft">Top left<br>'+
            '<IR"catalog_triage_place,bottomLeft">Bottom left'+
          '</span>'+
          '<span style="display:inline-block">'+
            '<IR"catalog_triage_place,topRight">Top right<br>'+
            '<IR"catalog_triage_place,bottomRight">Bottom right'+
          '</span><br>'+
          '&emsp;&emsp;pop down delay: <input type="text" name="triage.popdown_delay" size="4" style="text-align: right;">ms<br>'+
          '&emsp;&emsp;&emsp;<input type="checkbox" name="triage.show_always"> Don\'t pop down while the mouse is on the thread<br>'+
          '&emsp;&emsp;<input type="checkbox" name="triage.hide_toggle"> Hide useless toggle buttons<br>'+
          '&emsp;&emsp;Style:<br>'+
          '&emsp;&emsp;&emsp;<textarea style="height:1em" cols="40" name="catalog_triage_str"></textarea><br>'+
          '<!-- &emsp;<input type="checkbox" name="catalog_enable_cross_board"> Enable cross-board catalog<br> -->'+
          '<!-- &emsp;<input type="checkbox" name="catalog_enable_cross_domain"> Enable cross-domain catalog<br> -->'+
          '<!-- &emsp;&emsp; Cache working in <textarea style="height:1em" cols="20" name="catalog_sw_domain"></textarea><br> -->'+
          '&emsp;&emsp;Sample triage:<br>'+
          '&emsp;&emsp;&emsp;<button name="triage_simple_kill">simple_kill</button>'+
          '&emsp;<button name="triage_simple">simple</button>'+
          '&emsp;<button name="triage_basic">basic</button>'+
          '&emsp;<button name="triage_basic_color">basic_color</button><br>'+
          '&emsp;&emsp;&emsp;<button name="triage_colorful">colorful</button>'+
          '&emsp;<button name="triage_borders">borders</button>'+
          '&emsp;<button name="triage_samples">samples</button>'+
          '&emsp;<button name="triage_test">test</button>'+
          '<br>'+
          '',
          'General 1:<br>'+
          '&emsp;Shows in title bar:<br>'+
          '&emsp;&emsp;<input type="checkbox" name="catalog.appearance.titleBar.filter">Checkbox to show filter<br>'+
          '&emsp;&emsp;<input type="checkbox" name="catalog.appearance.titleBar.settings">Checkbox to show settings<br>'+
          '&emsp;&emsp;<input type="checkbox" name="catalog.appearance.titleBar.refresh">Refresh button<br>'+
          '&emsp;&emsp;<input type="checkbox" name="catalog.appearance.titleBar.num_of_pages">Num of pages to refresh<br>'+
          '&emsp;&emsp;<input type="checkbox" name="catalog.appearance.titleBar.boards_selector">Boards selector<br>'+
          '<br>'+
          '&emsp;<input type="checkbox" name="catalog.embed_frame"> Embed to frame<br>'+
          '&emsp;&emsp;Frame size : '+
          '&emsp;&emsp;<input type="text" name="catalog_size_frame0_width" size="4" style="text-align: right;">%, '+
          '&emsp;&emsp;<input type="text" name="catalog_size_frame1_width" size="4" style="text-align: right;">%<br>'+
//          '&emsp;Max threads in catalog: <input type="text" name="catalog.max_threads" size="4" style="text-align: right;"><br>'+
          '&emsp;<input type="checkbox" name="catalog.refresh.initial"> Refresh at initial<br>'+
          '&emsp;&emsp;<input type="checkbox" name="catalog.refresh.except_bt"> Except the page of selecting boards\' tag.<br>'+
          '&emsp;<input type="checkbox" name="catalog.refresh.at_switch"> Clear and refresh when boards are switched<br>'+
          '&emsp;<input type="checkbox" name="common.clear_at_manual_scan"> Clear all threads at manual scan<br>'+
          '&emsp;<input type="checkbox" name="liveTag.rm_404_immediately"> Remove 404 threads immediately<br>'+
          '&emsp;<input type="checkbox" name="catalog.bookmark_list_rm404"> Remove 404 threads from bookmark<br>'+
          '&emsp;<input type="checkbox" name="pref2.8chan.utilize_boards_json"> Utilize boards.json in 8chan<br>'+
          '1,<ICBX"pref2.meguca.utilize_boards_json"> Utilize boardTimestamps in meguca<br>'+
          '2,<ICBX"pref2.meguca.utilize_boards_json_domain"> Utilize boardTimestamps at refresh in meguca<br>'+
          '&emsp;<input type="checkbox" name="filter.disable_list_when_kwd_active"> Disable list filter when keyword filter is active<br>'+
          '',
          'Board Group:<br>'+
          '&emsp;configuration:<br>'+
          '&emsp;&emsp;<textarea rows="1" cols="60" name="catalog_board_list_str"></textarea><br>'+
          '&emsp;&emsp;<input type="checkbox" name="catalog.board.recommendation"> Read owner\'s recommendation '+
          '&emsp;&emsp;<button name="tag.recommendation_add">Add to list</button><br>'+
          '2,<IC"catalog.board.all_boards">Add all boards group to the last<br>'+
//          '&emsp;&emsp;<input type="button" value="Scan"> Scan board tags<br>'+
//          '&emsp;&emsp;<input type="button" value="Generate" name="tag.generate"> Generate board groups from tags <br>'+
          '&emsp;&emsp;<input type="checkbox" name="catalog.board.board_tags"> Generate board groups from tags '+
          '&emsp;&emsp;<button name="tag.scan">Scan</button><br>'+
          '&emsp;&emsp;<input type="checkbox" name="catalog.board.board_tags_same"> Pick up boards which have the same tag'+
          '&emsp;&emsp;<button name="tag.same_tag_refresh">Refresh</button><br>'+
          '&emsp;<input type="checkbox" name="catalog.board.ex_list"> Use exclusive list<br>'+
          '&emsp;&emsp;<textarea rows="1" cols="40" name="catalog.board.ex_list_str"></textarea><br>'+
          '&emsp;<input type="checkbox" name="catalog.style_general_list"> Use general style<br>'+
          '&emsp;&emsp;<textarea rows="1" cols="40" name="catalog.style_general_list_str"></textarea><br>'+
          '&emsp;<input type="checkbox" name="catalog.mimic_base_site"> Mimic base site<br>'+
////////          '&emsp;Tagging:<br>'+
////////          '&emsp;&emsp;Ignore tags latter than <input type="text" name="catalog.tag.ignore" size="2" style="text-align: right;">th in a board/thread<br>'+
////////          '&emsp;&emsp;Ignore boards/threads which have more than <input type="text" name="catalog.tag.max" size="2" style="text-align: right;"> tags<br>'+
          '&emsp;Scan:<br>'+
          '&emsp;&emsp;Max scan boards <input type="text" name="scan.max" size="6" style="text-align: right;"><br>'+
          '&emsp;&emsp;Max found threads <input type="text" name="scan.max_threads" size="6" style="text-align: right;"><br>'+
////////          '&emsp;&emsp;Reload older than <input type="text" name="scan.lifetime" size="6" style="text-align: right;"> minutes old<br>'+
          '&emsp;&emsp;Num of crawler: <input type="text" name="scan.crawler" size="2" style="text-align: right;"><br>'+
          '&emsp;&emsp;&emsp;<input type="checkbox" name="scan.crawler_adaptive"> Spawn adaptively at idle' + 
          '<input type="text" name="scan.crawler_idle_time_to_spawn" size="2" style="text-align: right;">ms<br>'+
          '',
          'Live Tag:<br>'+
          '1,From:<br>'+
          '2,<IR"liveTag.from,op">OP<br>'+
          '2,<IR"liveTag.from,post">All posts<br>'+
          '1,<ICBX"liveTag.use"> Live<br>'+
//          '4,<ICBX"stats.use"> Take statistics<br>'+
          '1,max: <ITB2"liveTag.max">'+
          ', max string length: <ITB2"liveTag.maxstr"><br>'+
          '1,<ICBX"liveTag.ci"> Case insensitive<br>'+
          '1,<ICBX"liveTag.inherit_board_name"> Inherits board\'s name as a tag<br>'+
          '2,<ICBX"liveTag.lock_board_name"> Lock & sticky<br>'+
          '1,<ICBX"liveTag.inherit_board_tags"> Inherits board\'s tags<br>'+
          '2,<ICBX"liveTag.lock_board_tags"> Lock & sticky<br>'+
          '1,<ICBX"liveTag.lock_tags_in_op"> Lock & sticky tags in OP<br>'+
          '1,<ICBX"liveTag.ex_list"> Use exclusive list<br>'+
          '2,String list to remove before extracting tags<br>'+
          '3,<textarea rows="1" cols="40" name="liveTag.rm_list_str"></textarea><br>'+
          '2,Tag list to remove after extracting tags<br>'+
          '3,<textarea rows="1" cols="40" name="liveTag.ex_list_str"></textarea><br>'+
          '1,Click function: tags in <br>'+
          '2,boardlist / threads<br>'+
          '2,<IR"liveTag.click_func_bl,pkin"><IR"liveTag.click_func,pkin">None -> Fetch/In -> None<br>'+
          '2,<IR"liveTag.click_func_bl,in"><IR"liveTag.click_func,in">None -> In -> None<br>'+
          '2,<IR"liveTag.click_func_bl,inex"><IR"liveTag.click_func,inex">None -> In -> Out -> None<br>'+
          '2,<IR"liveTag.click_func_bl,ex"><IR"liveTag.click_func,ex">None -> Out -> None<br>'+
          '1,Update intervals:<br>'+
          '2,Foreground: <ITB4"liveTag.disp_delay.fg">ms<br>'+
          '2,Background: <ITB4"liveTag.disp_delay.bg">ms<br>'+
          '2,Lazy draw of incremental search:<br>'+
          '3,every <ITB4"liveTag.lazy_each"> tags with <ITB4"liveTag.lazy_delay"> ms delay<br>',
          function(html_funcs){
            return 'Statistics:<br>'+
////            '&emsp;&emsp;Statistics is a subfunction of the LiveTag,<br>'+
////            '&emsp;&emsp;You must activate it beforehand and RELOAD to start.<br>'+
////            '&emsp;&emsp;Then, the "Graph" button will appear in the setting button([CC])<br>'+
//////            '&emsp;&emsp;And this function uses both local and server timestamps,<br>'+
//////            '&emsp;&emsp;your local clock must be accurate.<br>'+
////            '<span style="float:left">&emsp;&emsp;<button name="easy.stat_activate">Activate</button></span>'+
////            '<span>'+
////              '&emsp;<input type="checkbox" name="stats.use"> Take statistics<br>'+
////              '&emsp;<input type="checkbox" name="stats.estimate_posts"> Estimate num of posts from posts\' No.<br>'+
////            '</span>'+
////            '<br>'+
            '1,<ICBX"stats.use"> Take statistics<br>'+
            '3,<ICBX"stats.estimate_posts"> Estimate num of posts from posts\' No.<br>'+
            '4,<ICBX"stats.patch_tm"> Patch for thread move<br>'+
            '2,Default settings:<br>'+
            '3,Time unit: '+ chart_obj.time_unit_sel_html + '<br>' +
            '3,' + chart_obj.chart_options_str.join('&emsp;&emsp;&emsp;') +
            '3,Size of window: <ITB4"chart.window_width"> x <ITB4"chart.window_height"><br>'+
            '<br>'+
//            '&emsp;Data of pruned threads:<br>'+
//            '&emsp;&emsp;<input type="checkbox" name="stats.retain_404"> Retain values of pruned thread<br>'+
            '2,Accumulation:<br>'+
            '3,<ICBX"stats.load"> Load data<br>'+
            '4,<ICBX"stats.save"> Save data: <ITB4"stats.len_capture"> points<br>'+
            '4,Auto acquisition of data:<br>'+
            '5,<ICBX"stats.auto_acquisition_all"> All board groups which you saw once<br>'+
            '5,<ICBX"stats.auto_acquisition"> Board groups with \'!stats\'<br>'+
            '6,<ICBX"stats.auto_acquisition_scan"> Scan all targets at startup with '+
            '<ITB2"stats.auto_acquisition_scan_delay"> secs delay<br>'+
            '5,(Targets are colored <span style="background:#b5fbda">green</span> in board selector)<br>'+
            '<br>'+
            '2,<ICBX"chart.instant_scan"> Instant scan at switching board group<br>'+
            '2,Delay to draw: <ITB2"stats.draw_delay"> sec.<br>'+
            '2,<ICBX"chart.off_anime_blur"> Off animation in background<br>'+
            '2,<ICBX"stats.tolerant"> Tolerant of inaccuracy of server and local clocks<br>'+
            '5,up to <input type="text" name="stats.tolerance" size="2" style="text-align: right;"> min<br>'+
            '';
          },
          'Design of Floating Catalog:<br>'+
          '<input type="radio" name="catalog.text_mode.mode" value="graphic"> Graphical mode: '+
          '<input type="text" name="catalog_size_width" size="4" style="text-align: right;"> x '+
          '<input type="text" name="catalog_size_height" size="4" style="text-align: right;"><br>'+
          '&emsp;&emsp;<input type="checkbox" name="catalog.format.thumb.resize">Resize thumbnails in embed catalog<br>'+
          '&emsp;&emsp;<input type="checkbox" name="page.format.thumb.resize">Resize thumbnails in embed page<br>'+
          '&emsp;&emsp;<input type="checkbox" name="float.format.thumb.resize">Resize thumbnails in float catalog<br>'+
          '&emsp;&emsp;&emsp;1st thumbnail: '+
          '<input type="text" name="catalog_size_tn1_width" size="4" style="text-align: right;"> x '+
          '<input type="text" name="catalog_size_tn1_height" size="4" style="text-align: right;"><br>'+
          '&emsp;&emsp;&emsp;2nd and later: '+
          '<input type="text" name="catalog_size_tn2_width" size="4" style="text-align: right;"> x '+
          '<input type="text" name="catalog_size_tn2_height" size="4" style="text-align: right;"><br>'+
          '&emsp;Catalog/Pop-up/Search<br>'+
          '<!-- &emsp;&emsp;<input type="checkbox" name="float.format.show.images_2nd">'+
          '<input type="checkbox" name="float.format.hover.images_2nd">'+
          '<input type="checkbox" name="float.format.search.images_2nd"> 2nd or more images in OP<br> -->'+
          '&emsp;&emsp;<input type="checkbox" name="float.format.show.posts">'+
          '<input type="checkbox" name="float.format.hover.posts">'+
          '<input type="checkbox" name="float.format.search.posts"> Posts<br>'+
          '&emsp;&emsp;<input type="checkbox" name="float.format.show.fileinfo">'+
          '<input type="checkbox" name="float.format.hover.fileinfo">'+
          '<input type="checkbox" name="float.format.search.fileinfo"> File information<br>'+
          '<!--&emsp;&emsp;<input type="checkbox" name="catalog_checkbox_deletion_show">'+
          '<input type="checkbox" name="catalog_checkbox_deletion_hover">'+
          '<input type="checkbox" name="catalog_checkbox_deletion_search"> Checkbox for deletion<br> -->'+
          '&emsp;&emsp;<input type="checkbox" name="float.format.show.contents">'+
          '<input type="checkbox" name="float.format.hover.contents">'+
          '<input type="checkbox" name="float.format.search.contents"> Format contents<br>'+
          '&emsp;&emsp;<input type="checkbox" name="float.format.show.layout">'+
          '<input type="checkbox" name="float.format.hover.layout">'+
          '<input type="checkbox" name="float.format.search.layout"> Format layout<br>'+
          '&emsp;&emsp;<input type="checkbox" name="float.format.show.style">'+
          '<input type="checkbox" name="float.format.hover.style">'+
          '<input type="checkbox" name="float.format.search.style"> Format style<br>'+
          '<!-- &emsp;&emsp;<input type="checkbox" name="catalog_border_show">&emsp;&emsp;&emsp; Show border<br> -->'+
          '<!-- &emsp;&emsp;<input type="checkbox" name="catalog_enable_background">&emsp;&emsp;&emsp; Use backgfound color<br> -->'+
          '&emsp;Num of posts in thread headline: <input type="text" name="float.t2h_num_of_posts" size="3" style="text-align: right;"><br>'+
          '<input type="radio" name="catalog.text_mode.mode" value="text"> Text mode: '+
          '<input type="text" name="catalog_size_text_width" size="4" style="text-align: right;"> x '+
          '<input type="text" name="catalog_size_text_height" size="4" style="text-align: right;"><br>'+
          '&emsp;<input type="checkbox" name="catalog.text_mode.sub"> Show title<br>'+
          '&emsp;<input type="checkbox" name="catalog.text_mode.name"> Show op\'s name<br>'+
          '&emsp;<input type="checkbox" name="catalog.text_mode.com"> Show op\'s comment<br>'+
          '',
          function(html_funcs){
            return 'Footer:<br>'+
              '1,<ICBX"catalog.footer.use"> Show information footer'+html_funcs.rollup(
                '3,<ICBX"catalog.footer.br"> Always over/under the image') +'<br>'+
              '2,<ICBX"catalog.footer.nr"> Show num of new replies (nr)<br>'+
              '3,<ICBX"catalog.footer.nrtm"> Show num of new replies to me (nm)<br>'+
              '2,<ICBX"catalog.footer.rp"> Show num of replies (rp)<br>'+
              '2,<ICBX"catalog.footer.im"> Show num of images (im)<br>'+
              '2,<ICBX"catalog.footer.nl"> Show num of stored live posts (lp)<br>'+
              '2,<ICBX"catalog.footer.nd"> Show num of deleted posts (dp)<br>'+
              '2,<ICBX"catalog.footer.page"> Show page No. (pg)<br>'+
              '2,<ICBX"threadStats.use"> Take statistics of each thread'+html_funcs.rollup(
                '4,<ICBX"threadStats.full"> Issue additional fetchs if required') + '<br>'+
              '3,<ICBX"catalog.footer.nid"> Show num of IDs (ni)<br>'+
              '3,<ICBX"catalog.footer.nf"> Show num of flags (nf)<br>'+
              '2,<ICBX"catalog.footer.ctime"> <ICBX"catalog.footer.rctime"> Show created time (ct), relative (cT)<br>'+
              '2,<ICBX"catalog.footer.btime"> <ICBX"catalog.footer.rbtime"> Show bumped time (bt), relative (bT)<br>'+
              '2,<ICBX"catalog.footer.ptime"> <ICBX"catalog.footer.rptime"> Show last posted time (pt), relative (pT)<br>'+
              '2,<ICBX"catalog.footer.prate"> Show post rate (pr)<br>'+
              '2,<ICBX"catalog.footer.domain"> Show domain\'s name (dn)<br>'+
              '2,<ICBX"catalog.footer.board"> Show board\'s name (bd)<br>'+
              '2,<ICBX"catalog.footer.no"> Show thread\'s no (no)<br>'+
              '2,<ICBX"catalog.footer.archived"> Show archived (ar)<br>'+
              '2,<ICBX"catalog.footer.tag"> Show tags (tg)<br>'+
    //          ', in <input type="text" name="catalog_footer_tag_letters" size="2" style="text-align: right;"> letters'+
              '2,<ICBX"catalog.footer.flag"> Show recent flags (rf)<br>'+
              '2,Design:<br>'+
              '3,<IR"catalog.footer.design,native"> U: */* / R: * / I: * / P: *<br>'+
              '3,<IR"catalog.footer.design,condensed"> */*/*/*/*<br>'+
              '3,<IR"catalog.footer.design,custom"> <ITBL40"catalog.footer.custom_str"><br>';},
          'Watcher:<br>'+
          '&emsp;<input type="checkbox" name="liveTag.watch_all"> Watch all boards<br>'+
          '&emsp;<input type="checkbox" name="catalog.auto_watch"> Auto add to watch list<br>'+
//          '&emsp;<input type="checkbox" name="catalog.order.find_sage_in_8chan"> Find sage post in native catalog in 8chan<br>'+
          '&emsp;<input type="checkbox" name="catalog.unmark_on_hover"> Unmark post on hover<br>'+
          '&emsp;<input type="checkbox" name="thread_reader.use"> Thread reader<br>'+
          '&emsp;&emsp;<input type="checkbox" name="thread_reader.own_posts_tracker"> Own posts tracker<br>'+
          '&emsp;&emsp;&emsp;&emsp;>> (You)<br>'+
          '&emsp;&emsp;&emsp;&emsp;<input type="radio" name="thread_reader.show_reply_to_me_by" value="anchor"> anchor text<br>'+
          '&emsp;&emsp;&emsp;&emsp;<input type="radio" name="thread_reader.show_reply_to_me_by" value="plain"> plain text (for dollchan)<br>'+
          '&emsp;&emsp;&emsp;&emsp;(You) in name field<br>'+
          '&emsp;&emsp;&emsp;&emsp;<input type="radio" name="thread_reader.show_own_post_by" value="anchor"> name string<br>'+
          '&emsp;&emsp;&emsp;&emsp;<input type="radio" name="thread_reader.show_own_post_by" value="plain"> plain text<br>'+
          '&emsp;&emsp;&emsp;<input type="checkbox" name="thread_reader.clean_up_own_posts"> Clean up localStorage at loading embed native catalog<br>'+
          '&emsp;&emsp;<input type="checkbox" name="thread_reader.sync"> Sync with parent catalog<br>'+
          '&emsp;&emsp;&emsp;<input type="checkbox" name="thread_reader.triage"> Show triage to parent catalog<br>'+
          '&emsp;&emsp;&emsp;<input type="checkbox" name="thread_reader.triage_close"> Close window when triage is clicked<br>',
          function(html_funcs){return 'Notifiers:<br>'+
            '1,<ICBX"notify.desktop.notify"> Desktop'+ html_funcs.rollup(
            '4,<ICBX"notify.desktop.supp_init"> Suppressed at initial')+ '<br>'+
            '3,<ITB3"notify.desktop.lifetime"> secs (0 means permanent)<br>'+
            '3,max: <ITB3"notify.desktop.limit">, '+
              'delay: <ITB3"notify.desktop.delay">ms<br>'+
            '3,<ICBX"notify.desktop.show_last"> Show the last post only<br>'+
            '2,<ICBX"notify.desktop.reply_to_me"> New replies to me<br>'+
            '2,<ICBX"notify.desktop.reply"> New replies<br>'+
            '2,<ICBX"notify.desktop.new_thread"> New threads<br>'+
            '2,<ICBX"notify.desktop.appear"> Appear threads<br>'+
            '1,<ICBX"notify.favicon"> Favicon<br>'+
            '1,<ICBX"notify.title.notify"> Show number of unread replies in title<br>'+
            '2,<ICBX"notify.title.hide_zero"> Hide unread count in title bar when it is zero<br>'+
            '1,<ICBX"notify.sound.notify"> Sound'+ 
              '&emsp;&emsp;<BTN"notify.sound.pause,Pause">'+html_funcs.rollup(
            '4,<ICBX"notify.sound.supp_init"> Suppressed at initial')+ '<br>'+
            '3,<IR"notify.sound.src,beep">Beep '+
              '&emsp;freq:<ITB4"notify.sound.beep_freq"> '+
              'length:<ITB4"notify.sound.beep_length_f"> '+
              'volume:<ITB4"notify.sound.beep_volume_f"><br>'+
            '3,<IR"notify.sound.src,file">File '+
              '&emsp;<input type="file" accept="audio/*" name="notify.sound.file"><br>'+
            '2,<ICBX"notify.sound.reply_to_me"> New replies to me<br>'+
            '2,<ICBX"notify.sound.reply"> New replies<br>'+
            '2,<ICBX"notify.sound.new_thread"> New threads<br>'+
            '2,<ICBX"notify.sound.appear"> Appear threads<br>';},
          function(html_funcs){
            archiver.event_funcs['queryQuota']();
            return 'JSON Archiver: Store<br>'+
//            '1,Store:<br>'+
            '<br>'+
            '1,1. Make sure DOWNLOAD DIRECTORY to be set correctly.'+html_funcs.rollup(
              '3,All files will be into the directory.<br>'+
              '3,And also, make sure each download doesn\'t ask you anything.<br>'+
              '3,So many files will be downloaded.<br>'+
              '2,<ICBX"archive.editing_timeout"> Timeout for editing posts (patch for meguca)') +'<br>'+
            '1,2. Select sources for each target:<br>'+
            '2,File: Manual/Auto<br>'+
            '3,<ICBX"archive.oneshot.post"><ICBX"archive.live.post"> Posts<br>'+
            '3,<ICBX"archive.oneshot.tn"><ICBX"archive.live.tn"> Thumbnails<br>'+
            '3,<ICBX"archive.oneshot.img"><ICBX"archive.live.img"> Images (original size)<br>'+
            '3,<ICBX"archive.oneshot.webm"><ICBX"archive.live.webm"> Webms<br>'+
            '2,IndexedDB: Manual/Auto'+html_funcs.rollup(
              '4,<ICBX"archive.IDB.auto_clean"> Automatic clean up<br>'+
              '4,<ICBX"archive.IDB.auto_clean_init"> Automatic clean up at start up<br>'+
              '4,Delayed pruning: <ITB3"archive.IDB.prune"> hours<br>'+
              '5,<ICBX"archive.IDB.prune_flush"> Archive to file at pruning<br>'+
              '4,num of transactions: <ITB3"archive.IDB.nof_tr"><br>'+
              '4,num of requests in a cluster: <ITB3"archive.IDB.nof_cl"> - <ITB3"archive.IDB.nof_cl_max"><br>'+
              '4,watchdog timer: <ITB3"archive.IDB.watchdog">s')+'<br>'+
            '4,used / limit: <span name="SHOW_QUOTA"></span><button name="archive.queryQuota"><img src="' + cnst.icons.refresh + '" style="width:1em;height:1em"></button><br>'+
            '3,<ICBX"archive.oneshot.post_idb"><ICBX"archive.live.post_idb"> Posts<br>'+
            '3,<ICBX"archive.oneshot.tn_idb"><ICBX"archive.live.tn_idb"> Thumbnails<br>'+
            '3,<ICBX"archive.oneshot.img_idb"><ICBX"archive.live.img_idb"> Images (original size)<br>'+
            '3,<ICBX"archive.oneshot.webm_idb"><ICBX"archive.live.webm_idb"> Webms<br>'+
//            '2,3. Select files which will be skipped downloading<br>'+
//            '3,Downloaded files: <IF"archive.dir_dled" multiple directory><br>'+
            '1,3. <ICBX"archive.list_inherit"> Inherit previous archiving list<br>'+
            '1,4a. <ICBX"archive.store_auto"> Auto archiving if OP matches:<br>'+
            '2,Keyword: <input type="text" name="archive.kwd.str" size="25">'+
            pref_func.settings.html_funcs.make_sel('archive.kwd.match', ['match all','match any','unmatch all','unmatch any'])+ '<br>'+
            '3,<ICBX"archive.kwd.sub">Subject '+
            '<ICBX"archive.kwd.name">Name '+
            '<ICBX"archive.kwd.com">Comment <br>'+
            '3,<ICBX"archive.kwd.ci">CI'+
            ' <ICBX"archive.kwd.sentence">Sentence'+
            ' <ICBX"archive.kwd.re">RE<br>'+
            '1,4b. <ICBX"archive.list"> List picker<br>'+
            '2,<textarea rows="1" cols="40" name="archive.list_str" placeholder="lain  // whole lainchan\n/tech/  // whole /tech/\n/q/1234  // thread /q/1234"></textarea><br>'+
            '1,4c. <BTN"archive.oneshot,OneShotArchive"> or <BTN"archive.start,StartArchiving"><br>'+
            '3,<IR"archive.src,shown"> All shown threads<br>'+
            '3,<IR"archive.src,watched"> All watched threads<br>'+
            '3,<IR"archive.src,stored"> All stored threads<br>'+
//            '3,<IR"archive.src""scanned"> All scanned threads for automatic archiving<br>'+
            '1,4d. You can select target threads individually using triage<br>';},
          function(html_funcs){
            if (pref.archive.files_sel===2) archiver.event_funcs['queryList']();
            return 'JSON Archiver: Restore<br>'+
//            '1,Restore:<br>'+
            '<br>'+
            '1,1. Open a live catalog, index page or thread to be overriden.<br>'+
            '2,CatChan must be working in it.<br>'+
            '1,2. Select where to extract<br>'+
            '2,<IR"archive.format,auto">Select from filename: Domain-Board-No_Sub.json<br>'+
            '2,<IR"archive.format,manual">Set manually: '+ html_funcs.make_sel('archive.domain',site0.domains) + '/<ITB5"archive.board">/No.<br>'+
            '1,3a. <ICBX"archive.IDB.auto_restore"> Automatic restore from IndexedDB<br>'+
            '3,<ICBX"archive.IDB.auto_restore_remove"> Remove deleted thread from display<br>'+
            '1,3b. Select source from: '+ html_funcs.make_sel('archive.files_sel',['Dir','Files','IndexedDB'])+ '<br>'+
            '<span name="FILES_ARCHIVE0"' +((pref.archive.files_sel===0)? '' : ' style="display:none"') +'>'+
              '&emsp;&emsp;<span><IF"archive.dir" multiple webkitdirectory directory><BTN"archive.files_clear,X"></span><br>'+
            '</span>'+
            '<span name="FILES_ARCHIVE1"' +((pref.archive.files_sel===1)? '' : ' style="display:none"') +'>'+
              '&emsp;&emsp;JSONs/HTMLs: <IF"archive.jsons" multiple accept=".html,.json,text/*"><br>'+
              '2,<ICBX"archive.load_img"> Images: <IF"archive.imgs" multiple webkitdirectory directory><br>'+
            '</span>'+
            '<span name="FILES_ARCHIVE2"' +((pref.archive.files_sel===2)? '' : ' style="display:none"') +'>'+
              '&emsp;&emsp;<span><select name="archive.IDB_board_sel"' + ((pref.archive.IDB_select_multiple)? ' multiple':'') + ' style="float:none"></select>'+
              '<select name="archive.IDB_thread_sel" style="float:none' + ((pref4.archive.IDB_thread_sel_options)? '"' : ';display:none"')
                                                      + ((pref.archive.IDB_select_multiple)? ' multiple':'') +'></select></span>'+
                html_funcs.rollup('&emsp;&emsp;<ICBX"archive.IDB_select_multiple"> Multiple select<br>'+
                                  '&emsp;&emsp;Export selected &emsp;&emsp;&emsp;&emsp;<BTN"archive.IDB.export_thread,Threads"><br>'+
                                  '&emsp;&emsp;Reset archived time of selected <BTN"archive.IDB.reset_time,Threads">')+
                html_funcs.rollup('&emsp;&emsp;Delete selected <BTN"archive.IDB.delete_board,Boards"><BTN"archive.IDB.delete_thread,Threads"><BTN"archive.IDB.delete_imgs,Images">')+'<br>'+
            '</span>'+
            '&emsp;&emsp;<BTN"archive.restore_button,Restore"> <ICBX"archive.restore_auto"> Auto restore after selection<br>'+
            '3,<ICBX"archive.clear_threads"> Clear all threads at opening an archive<br>'+
            '3,<ICBX"archive.fix_inconsistency"> Fix inconsistencies at open<br>';
            '3,<ICBX"archive.open_local"> Open remote archive in local environment<br>';
//            '1,5. <BTN"archive.clear_files_button,Clear Files"> <ICBX"archive.clear_files"> Auto clear after open<br>';
          },
          'UIP tracker for 4chan:<br>'+
          '1,<ICBX"uip_tracker.on"> Show num of unique IPs after post No.<br>'+
          '3, Check interval: <ITB3"uip_tracker.interval">sec, <ICBX"uip_tracker.adaptive"> Adaptive<br>'+
          '3, Style of changes: <ITBL30"uip_tracker.highlight_str"><br>'+
          '2,<ICBX"uip_tracker.posts"> Show num of posts<br>'+
          '2,<ICBX"uip_tracker.deletion.show"> Show deleted posts\' No.<br>'+
          '3,<ICBX"uip_tracker.deletion.link"> as links<br>'+
          '2, Apply style to deleted post:<br>'+
          '3,<ICBX"uip_tracker.deletion.name"> Add style to name: <ITBL30"uip_tracker.deletion.name_str"><br>'+
          '3,<ICBX"uip_tracker.deletion.addName"> Add <ITBL30"uip_tracker.deletion.addName_str"> to name<br>'+
          '3,<ICBX"uip_tracker.deletion.post"> Add style to post: <ITBL30"uip_tracker.deletion.post_str"><br>'+
          '2,<ICBX"uip_tracker.annotate"> Annotate history of UIP from catalog<br>'+
          '2,<ICBX"uip_tracker.auto_open"> Open next thread automatically<br>'+
          '3,Conditions:<br>'+
          '4,After <input type="text" name="uip_tracker.auto_open_th" size="3" style="text-align: right;">th post<br>'+
          '4,OP contains <textarea style="height:1em" cols="20" name="uip_tracker.auto_open_kwd"></textarea><br>'+
          '2,<ICBX"uip_tracker.sage.detect"> Sage detection, tolerance: <ITB2"uip_tracker.sage.tolerance"> sec<br>'+
          '3,<ICBX"uip_tracker.sage.name"> Add style to name: <ITBL30"uip_tracker.sage.name_str"><br>'+
          '3,<ICBX"uip_tracker.sage.addName"> Add <ITBL30"uip_tracker.sage.addName_str"> to name<br>'+
          '3,<ICBX"uip_tracker.sage.post"> Add style to post: <ITBL30"uip_tracker.sage.post_str"><br>'+
          '3,Bug patch for corrupted data<br>'+
          '4,<ICBX"uip_tracker.sage.patch_bug3"> Ignore corrupted data at head by history<br>'+
          '4,<ICBX"uip_tracker.sage.patch_bug2"> Loose detection, to <ITB2"uip_tracker.sage.patch_bug2nth">th thread<br>'+
          '4,<ICBX"uip_tracker.sage.patch_bug"> Re-evaluate and recover<br>',
          'Command interface for overwriting preference<br>'+
          '&emsp;<textarea style="height:1em" cols="40" name="overwrite_site2_json_str"></textarea><br>'+
          '&emsp;<button name="JSON_ex">extract</button>'+
          '<button name="JSON_ex_full">extract_full</button>'+
          '<button name="JSON_ex_filter">extract_current_filter</button>'+
          '&emsp;<button name="JSON_query">query</button>'+
          '&emsp;<button name="JSON_query_boards">query_boards</button>'+
          '&emsp;&emsp;<button name="JSON">JSON</button>'+
          '<span name="JSON_result"></span><br>'+
          '&emsp;<textarea style="height:1em" cols="40" name="overwrite_site2_eval_str"></textarea><br>'+
          '&emsp;<button name="EVAL">EVAL</button><br>',
//          '5',
          function(html_funcs){
            return 'Networking:<br>'+
          '1,Timeout: <ITB3"network.timeout"> sec.<br>'+
          '&emsp;Cross domain connection:<br>'+
          html_funcs.radios('network.cross_domain',2, ['direct: Direct connection',
          'indirect: Indirect connection<br>'+
            '3,<ICBX"network.overXFO"> Over X-Frame-Options<br>'+
            '3,<ICBX"network.overCSPF"> Over Content Security Policy frame',
          'GM: GreaseMonkey\'s extension'])+ '<br>'+
//          '&emsp;&emsp;<input type="checkbox" name="catalog_fake_access"> Fake access made by human to avoid poor administration<br>'+
//          '&emsp;&emsp;&emsp;(This causes heavier network traffic and server load,<br>'+
//          '&emsp;&emsp;&emsp;but administrators can\'t see what script you are using)<br>'+
//          '&emsp;Configuration:<br>'+
//          '&emsp;&emsp;(To get faster feeling, you should check them all.)<br>'+
          '&emsp;Data source:<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog.design" value="page">Page<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog.design" value="auto">Auto<br>'+
          '&emsp;&emsp;<input type="radio" name="catalog.design" value="catalog">Catalog<br>'+
          '&emsp;&emsp;&emsp;<input type="checkbox" name="catalog.catalog_json"> From json file<br>'+
          '1,Lazy load/draw<br>'+
          '2,Catalog/IndexPage/Float <br>'+
          '3,<IC"catalog.lazyDraw.merge" style="visibility:hidden"><IC"page.lazyDraw.merge">'+
            '<IC"float.lazyDraw.merge" style="visibility:hidden">Lazy draw posts, step:<ITB3"proto.lazyDraw.merge_step">(at merge)<br>'+
          '3,<IC"catalog.draw_on_demand"><IC"page.draw_on_demand"><IC"float.draw_on_demand">Lazy draw threads, step:<ITB3"proto.lazyDraw.step"><br>'+
          '3,<IC"catalog.load_on_demand"><IC"page.load_on_demand"><IC"float.load_on_demand">Lazy load HTMLs/JSONs<br>'+
          '2,<input type="checkbox" name="network.adaptive"> Adaptive<br>'+
          '3,100%: new <input type="text" name="network.th100" size="3" style="text-align: right;"> threads, '+
          '<input type="text" name="network.th100_delay" size="4" style="text-align: right;"> ms delay<br>'+
          '3,20%: new <input type="text" name="network.th20" size="3" style="text-align: right;"> threads, '+
          '<input type="text" name="network.th20_delay" size="4" style="text-align: right;"> ms delay<br>'+
          '1,<ICBX"catalog_auto_update_countdown"> Show countdown to auto update<br>'+
          '1,<ICBX"healthIndicator.show"> Health indicator, history: <ITB3"healthIndicator.max"><br>'+
          '2,<ICBX"healthIndicator.expand_running"> Show details of running indicators<br>'+
          '2,<ICBX"healthIndicator.dont_retire_running"> Don\'t retire running indicators<br>'+
          '2,<ICBX"healthIndicator.cancel"> Cancel scan when it is clicked<br>'+
          '1,<ICBX"network.fetch_actively"> Fetch missing info actively<br>';},
          'General 2:<br>'+
          '&emsp;Localtime offset<input type="text" name="localtime_offset" size="2" style="text-align: right;"><br>'+
          'Share loaded html with other tabs to update<br>'+
          '&emsp;<input type="checkbox" name="info_server"> Broadcast loaded html to other tabs (server)<br>'+
          '&emsp;<input type="checkbox" name="info_client"> Listen other tab\'s broadcasting (client)<br>'+
          'Cloudflare<br>'+
          '&emsp;<input type="checkbox" name="cloudflare.auto_reload"> Auto reload at server error<br>'+
          '&emsp;&emsp;<input type="text" name="cloudflare.auto_reload_time" size="2" style="text-align: right;"> minutes after<br>'+
          '<br>'+
          '<input type="checkbox" name="tooltips.info.show"> Show infotips<br>'+
          '&emsp;pop up delay: <input type="text" name="tooltips.info.popup_delay" size="4" style="text-align: right;"> ms<br>'+
          '&emsp;pop down delay: <input type="text" name="tooltips.info.popdown_delay" size="4" style="text-align: right;"> ms<br>'+
          '<input type="checkbox" name="tooltips.help.show"> Show tooltips<br>'+
          '&emsp;pop up delay: <input type="text" name="tooltips.help.popup_delay" size="4" style="text-align: right;"> ms<br>'+
          '&emsp;pop down delay: <input type="text" name="tooltips.help.popdown_delay" size="4" style="text-align: right;"> ms<br>'+
          'Z-Index of tooptips: <ITB4"tooltips.zIndex"><br>'+
          'Misc.<br>'+
          '<input type="checkbox" name="recovery.comment"> Recover comment when browser was crashed<br>'+
          '<input type="checkbox" name="catalog_footer_ignore_my_own_posts"> Ignore my own posts at counting unread posts<br>'+
          '<input type="checkbox" name="pref2.KC.summer_time"> Summer time in KC<br>'+
          '<br>'+
          'Patches<br>'+
          '<input type="checkbox" name="patch.delayed_invoke.use"> Delayed invoke for 4chan on FF, '+
          '<input type="text" name="patch.delayed_invoke.sec" size="2" style="text-align: right;">sec.<br>'+
//          '<input type="checkbox" name="pref2.meguca.remove_history_class"> Remove history class in meguca'+
          '',
      function(html_funcs){
        return 'Styles:<br>'+
          '1,Windows and popups:<br>'+
          '2,Z-Index: <ITB4"style.zIndex"><br>'+
          '2,<IR"style.sel,fix"> Fixed <BTN"style.reset.fix,reset"><br>'+
          '3,Title bar:<ITBL30"style.fix.titleBar_str"><br>'+
          '3,Window:<ITBL30"style.fix.window_str"><br>'+
          '3,Pop up:<ITBL30"style.fix.popUp_str"><br>'+
          '2,<IR"style.sel,copy"> Copy from CSS <BTN"style.reset.copy,reset"><br>'+
          '3,Title bar:<ITBL30"style.copy.titleBar_str"><br>'+
          '3,Window:<ITBL30"style.copy.window_str"><br>'+
          '3,Pop up:<ITBL30"style.copy.popUp_str"><br>'+
          '1,Others:<br>'+
          '2,New post:<ITBL30"style.post_new"><br>'+
          '2,Editing post:<ITBL30"style.post_editing"><br>'+
          html_funcs.userCSS(1);},
      function(html_funcs){
        return 'Features:<br>'+
          '1,<ICBX"features.page"> Page<br>'+
          '1,<ICBX"features.graph"> Graph<br>'+
//          '1,<ICBX"features.setting"> Setting<br>'+
          '1,<ICBX"features.setting2"> Setting2<br>'+
          '1,<ICBX"features.postform"> Postform<br>'+
          '1,<ICBX"features.catalog"> Catalog<br>'+
          '1,<ICBX"features.listener"> Listener<br>'+
          '1,<ICBX"features.uip_tracker"> UIP_tracker<br>'+
          '1,<ICBX"features.thread_reader"> Thread Reader<br>'+
          '1,<ICBX"features.recovery"> Recovery comment<br>'+
//          '<input type="checkbox" name="features.debug"> Debug<br>'+
          'Notifications:<br>'+
          '1,<ICBX"features.notify.desktop"> DesktopNotification<br>'+
          '1,<ICBX"features.notify.sound"> Sound<br>'+
          '1,<ICBX"features.notify.favicon"> Favicon<br>'+
          'Sites:<br>'+
          html_funcs.features_domains();},
      function(html_funcs){
        return 'CatChan<br>'+
          'Version 2018.12.16.0<br>'+
          '<a href="https://github.com/DogMan8/CatChan">GitHub</a><br>'+
          '<a href="https://github.com/DogMan8/CatChan/raw/master/CatChan.user.js">Get stable release</a><br>'+
          '<a href="https://github.com/DogMan8/CatChan/raw/develop/CatChan.user.js">Get BETA release</a><br>'+
          '<br><br>'+
          'Debug mode<br>'+
          '<input type="checkbox" name="debug_mode.0">'+
          '<input type="text" name="debug_mode.unread_count" size="30" style="text-align: right;">'+
          '<input type="checkbox" name="debug_mode.2">'+
          '<input type="checkbox" name="debug_mode.3">'+
          '<input type="checkbox" name="debug_mode.4">&emsp;'+
          '<input type="checkbox" name="debug_mode.5">'+
          '<input type="checkbox" name="debug_mode.parse_error">'+
          '<input type="checkbox" name="debug_mode.7"><br>'+
          '<input type="text" name="debug_mode.site2func" size="15" style="text-align: right;" placeholder="catalog_json2html3">'+
          '<button name="debug_site2">dump_site2</button>'+
          '<input type="checkbox" name="debug_mode.site2func_expand">func<br>'+
          '<input type="text" name="debug_mode.pfunc" size="15" style="text-align: right;" placeholder="4chan:catalog_json">'+
          '<button name="debug_pfunc">dump_parse_funcs</button>'+
          '<input type="checkbox" name="debug_mode.pfunc_expand">func<br>'+
          '<input type="text" name="debug_mode.pfunc_comp" size="15" style="text-align: right;" placeholder="4chan:catalog_json">'+
          '<button name="debug_pfunc_comp">compare_parse_funcs</button>'+
          '<input type="checkbox" name="debug_mode.pfunc_comp_expand_same"><input type="checkbox" name="debug_mode.pfunc_comp_expand_diff">func <br>'+
          '1,<input type="text" name="debug_mode.pfunc_comp_proto" size="40" style="text-align: right;" placeholder="temporal prototype, DEFAULT:catalog_json"><br>'+
          '<input type="text" name="debug_mode.pfunc_all" size="15" style="text-align: right;"  placeholder="op_img_url">'+
          '<button name="debug_pfunc_all">find_parse_funcs</button>'+
          '<input type="checkbox" name="debug_mode.pfunc_all_expand">func<br>'+
          '<input type="checkbox" name="debug_mode.9"><br>'+
          html_funcs.cb_block('debug_mode',10)+
          'Test mode'+html_funcs.rollup(html_funcs.cb_block('test_mode',0)+'<br>'+
          '<IC"test_mode.tips">'+
          '<ITB6"test_mode.num">'+
          '<ITBL30"test_mode.test_str">'+
          '<ITB6"test_mode.num_f">'+
          '&emsp;<button name="button_test">test</button><br>'+
          '&emsp;<button name="load_samples">setting_samples</button><br>'+
          '<IF"test_mode.js_file" accept=".js,text/*"><BTN"test_mode.js_load,JS_load">')+'<br>';}
        ],
        html_common:
          '<span name="reload_recommended" style="display:none;background:yellow">&emsp;&emsp;RELOAD IS REQUIRED TO GET LIGHT FEELING&emsp;&emsp;<br></span>'+
          '<span name="reload_required" style="display:none;background:red;color:white">&emsp;&emsp;RELOAD IS REQUIRED&emsp;&emsp;</span>'+
          '<br><button name="close">close</button>'+
          '&emsp;<button name="save">save</button>'+
          '<button name="load_default">load_default</button>'+
          '<button name="load_default_of_this_page">load_default_of_this_page</button>',
//        onchange_event : function(){
//          pref_func.apply_prep(this,true);
//          if (pref_func.settings.onchange_funcs[this.name]) pref_func.settings.onchange_funcs[this.name]();
//        },
        tag_gen: null,
//        health_indicator: null,
        get onchange_funcs_formatted(){
          Object.defineProperty(this,'onchange_funcs_formatted',{value:pref_func.add_onchange_format(this.onchange_funcs), writable:true, enumerable:true, configurable:true});
          pref_func.add_onchange_format(this.onchange_funcs.archive);
          return this.onchange_funcs_formatted;
        },
        oninput_funcs: null,
        onchange_funcs : {
          __proto__: {
            __proto__: {
              SHOWALL: function(e){ // bound later.
                this.TOGGLE(e.target,'HIDEALL','',null,'no');
                Array.prototype.slice.call(e.target.parentNode.parentNode.querySelectorAll('[name=SHOW],[name=SHOW2],[name=SHOW3]')).forEach(function(v){v.onclick({target:v, currentTarget:v});});
  //              Array.prototype.slice.call(e.target.parentNode.parentNode.parentNode.querySelectorAll('[name=SHOW],[name=SHOW2]')).forEach(function(v){v.onclick({target:v});});
              },
              HIDEALL: function(e){ // bound later.
                this.TOGGLE(e.target,'SHOWALL','',null,'no');
                Array.prototype.slice.call(e.target.parentNode.parentNode.querySelectorAll('[name=HIDE],[name=HIDE2],[name=HIDE3]')).forEach(function(v){v.onclick({target:v, currentTarget:v});});
  //              Array.prototype.slice.call(e.target.parentNode.parentNode.parentNode.querySelectorAll('[name=HIDE],[name=HIDE2]')).forEach(function(v){v.onclick({target:v});});
              },
              SHOW: function(e){this.TOGGLE(e.target,'HIDE','');}, // bound later.
              HIDE: function(e){this.TOGGLE(e.target,'SHOW','none');}, // bound later.
              TOGGLE: function(et,name,disp, dst_dom, tgt_dom){
                if (!dst_dom) dst_dom = et;
                var str = et.getAttribute('data-str');
                et.setAttribute('data-str',dst_dom.textContent);
                dst_dom.textContent = str;
                et.setAttribute('name',name);
                if (tgt_dom==='no') return;
                if (!tgt_dom) tgt_dom = et.nextSibling;
                tgt_dom.style.display = disp;
              },
  //            NEXT: function(e){e.currentTarget.nextSibling.onclick({target:e.currentTarget.nextSibling});},
              SHOW2: function(e){this.TOGGLE2(e.target,'HIDE2','');}, // bound later.
              HIDE2: function(e){this.TOGGLE2(e.target,'SHOW2','none');}, // bound later.
              TOGGLE2: function(et,name,disp){ // bound later.
                if (et.tagName!=='A') et = et.parentNode;
                this.TOGGLE(et,name,disp,et.childNodes[2], et.nextSibling.nextSibling);
              },
  //            SHOW3: function(e){ // bound later.
  //              if (e.target.previousSibling) {
  //                var div = document.createElement('div');
  //                div.setAttribute('style','clear:both');
  //                e.target.parentNode.insertBefore(div,e.target);
  //              }
  //              e.target.nextSibling.style.display = '';
  //              e.target.style.display = 'none';
  //            },
  //            HIDE3: function(e){ // bound later.
  //              e.target.parentNode.previousSibling.style.display = '';
  //              e.target.parentNode.style.display = 'none';
  //              var etPpp = e.target.parentNode.previousSibling.previousSibling;
  //              if (etPpp) e.target.parentNode.parentNode.removeChild(etPpp);
  //            },
              SHOW3: function(e){ // bound later.
                var label = e.target.getAttribute('data-show3');
                var tgt = e.target.previousSibling;
                while (tgt.getAttribute('data-show3')!==label) tgt = tgt.previousSibling;
                tgt.style.display = '';
                e.target.style.display = 'none';
              },
              HIDE3: function(e){ // bound later.
                var label = e.target.parentNode.getAttribute('data-show3');
                var tgt = e.target.parentNode.nextSibling;
                while (tgt.getAttribute('data-show3')!==label) tgt = tgt.nextSibling;
                tgt.style.display = '';
                e.target.parentNode.style.display = 'none';
              },
              SHOW2_I: function(e){var etp = e.target.previousSibling; etp.onclick({target:etp, currentTarget:etp});},
  //            SHOW: function(e){
  //              e.target.style.display = 'none';
  //              e.target.nextSibling.style.display = '';
  //              e.target.nextSibling.nextSibling.style.display = '';
  //            },
  //            HIDE: function(e){
  //              e.target.style.display = 'none';
  //              e.target.nextSibling.style.display = 'none';
  //              e.target.previousSibling.style.display = '';
  //            },
              SUB: function(e){
  //              var pns = e.currentTarget.parentNode.querySelectorAll('span[name="' +e.target.getAttribute('name')+ '"]');
                var pn = e.currentTarget.previousSibling.previousSibling;
                if (pn && pn.querySelectorAll) {
                  var pns = pn.querySelectorAll('span[data-class=show_value]');
                  if (pns.length>0) pref_func.apply_prep_2(pns, false);
                }
              },
              'virtualBoard.search.str': function(){liveTag.filter_onchange(pref.virtualBoard.search);},
            }
          },
          'uip_tracker.on' : uip_tracker_init,
          'healthIndicator.show' : function(){cataLog.healthIndicator.show();},
          'healthIndicator.expand_running' : function(){cataLog.healthIndicator.shrink_running();},
          'settings.indexing' : function(e){
            var this_obj = pref_func.settings;
            var pn13_1 = pref_func.settings.pn13.childNodes[1];
//            if (pn13_1.innerHTML) pref_func.tooltips.remove_hier(pn13_1);
            pref_func.settings.files_store();
            var files_archive;
            if (pref.settings.indexing===17) files_archive = site.script_body.querySelectorAll('span[name="FILES_ARCHIVE0"]')[0]; // out of w3c, but works in chrome and FF.
            var html = (((typeof(this_obj.htmls[pref.settings.indexing])==='function')? this_obj.htmls[pref.settings.indexing](this_obj.html_funcs) :
                                                                                        this_obj.htmls[pref.settings.indexing]   )+
                       this_obj.html_common);
            pn13_1.innerHTML = pref_func.format_html_str(html);
            if (files_archive) {
              var ref = pn13_1.querySelectorAll('span[name="FILES_ARCHIVE0"]')[0]; // out of w3c, but works in chrome and FF.
              ref.parentNode.insertBefore(files_archive,ref);
              ref.parentNode.removeChild(ref);
            }
            pref_func.add_onchange(pn13_1,pref_func.settings.onchange_funcs_formatted);
            pref_func.settings.apply_pn13_1();
//            pref_func.tooltips.add_hier(pn13_1);
          },
          'pn13_1_warning_reload': function(){
            pref3.reload_required = true;
            pref_func.settings.onchange_funcs['pn13_1_warning']();
          },
          'pn13_1_warning': function(){
            var pn13_1 = pref_func.settings.pn13.childNodes[1];
            var pn = pn13_1.getElementsByTagName('span')['reload_required'];
            pn.style.display = (pref3.reload_required || pref3.stats.use!==pref.stats.use || pref.stats.estimate_posts && !pref3.stats.estimate_posts)? '' : 'none';
            var pn = pn13_1.getElementsByTagName('span')['reload_recommended'];
            pn.style.display = (!pref.stats.estimate_posts && pref3.stats.estimate_posts)? '' : 'none';
          },
          'tag.scan' : function(){
            pref.catalog.board.board_tags = true;
            pref_func.settings.onchange_funcs['tag.generate_caller']('tag.scan');
            liveTag.popup_filter.popup();
          },
          'tag.same_tag_refresh' : function(){
            pref.catalog.board.board_tags_same = true;
            pref_func.settings.onchange_funcs['tag.generate_caller']('tag.same_tag_refresh');
          },
          'tag.generate_caller' : function(src){
            site2[site.nickname].get_boards_json('manual_refresh_boards_json', null, null, true); // ,pref_func.settings.onchange_funcs['tag.generate_callback']);
            if (pref.test_mode['112']) {
              http_req.get('tag','8chan','https://'+site2['8chan'].domain_url+'/boards.json',pref_func.settings.onchange_funcs['tag.generate_callback'],false,false,src);
              if (pref_func.settings.pn13) pref_func.settings.apply_pn13_1();
            }
          },
          'tag.generate_callback' : function(key,value,arg){
            site3['8chan'].boards = ('response' in value)? value.response : JSON.parse(value.responseText);
            pref_func.settings.onchange_funcs['tag.re_generate'](arg);
          },
          'tag.re_generate' : function(arg){
            var str = catalog_obj.scan_tags_common(site3['8chan'].boards,'name="tag.gen"');
            if (!pref_func.settings['tag_gen']) {
              if (arg!=='tag.same_tag_refresh') {
                var html = '<div><button name="tag.scan">Refresh</button><br>'+
                  '<textarea style="height:1em" cols="20" name="tag.gen_str"></textarea>'+
                  '<button name="tag.gen_add">Add to list</button></div><div>' + str +'</div>';
                cnst.make_popup(pref_func.settings,'tag_gen',html,pref_func.settings.onchange_funcs);
                var pn = pref_func.settings['tag_gen'].childNodes[1];
//                pn.getElementsByTagName('textarea')[0].value='board_group_name';
                pn.style.height = '200px';
                pn.style.width  = '200px';
                pn.style.overflow = 'auto';
                pn.style.resize = 'both';
                cnst.bottom_top(pn);
              }
            } else pref_func.settings['tag_gen'].childNodes[1].childNodes[1].innerHTML = str;
            if (pref_func.settings['tag_gen']) pref_func.add_onchange(pref_func.settings['tag_gen'].childNodes[1].childNodes[1],pref_func.settings.onchange_funcs_formatted);

            var str = ''
            var obj = site3['8chan'].boards;
            var myself = 0;
            while (myself<obj.length-1 && site.board!=='/'+obj[myself].uri+'/') myself++;
            for (var i=0;i<obj[myself].tags.length;i++) {
              var key = obj[myself].tags[i];
              str = str + '#' + key;
              for (var j=0;j<obj.length;j++)
                for (var m=0;m<obj[j].tags.length;m++)
                  if (obj[j].tags[m]===key) str = str + ',8chan/' + obj[j].uri + '/';
              str = str + '\n';
            }
            pref_func.catalog_board_list_str_bt_same = str;

            pref_func.catalog_board_list_str_bt = '';
            pref_func.settings.onchange_funcs['board_sel_refresh']();
          },
//          'catalog.tag.ignore' : function(){pref_func.settings.onchange_funcs['tag.re_generate']();},
//          'catalog.tag.max' : function(){pref_func.settings.onchange_funcs['tag.re_generate']();},
//          'tag.gen_str' : function(){pref_func.settings.onchange_funcs['tag.gen']();},
          'tag.gen' : function(){
            var cbxes = pref_func.settings['tag_gen'].childNodes[1].getElementsByTagName('input');
            var str = '';
            var str_name = pref_func.settings['tag_gen'].childNodes[1].getElementsByTagName('textarea')[0].value;
            var obj = site3['8chan'].boards;
            for (var i=0;i<cbxes.length;i++)
              if (cbxes[i].checked) {
                var key = cbxes[i].nextSibling.textContent.replace(/ [0-9]*: /,'');
                if (str_name==='') str_name = '#' + key;
                for (var j=0;j<obj.length;j++)
                  for (var m=0;m<obj[j].tags.length;m++)
                    if (obj[j].tags[m]==key) str = str + '8chan/' + obj[j].uri + '/,';
              }
            pref_func.catalog_board_list_str_bt = str_name + ',' + str;
            pref_func.settings.onchange_funcs['board_sel_refresh']();
//            pref_func.str2obj('catalog_board_list_str');
//            if (pref_func.board_sel) pref_func.apply_prep(pref_func.board_sel,false);
          },
          'tag.gen_add' : function(){
            pref_func.settings.onchange_funcs['tag.gen']();
            pref_func.settings.onchange_funcs['tag.add_to_list'](pref_func.catalog_board_list_str_bt);
          },
          'tag.recommendation_add' : function(){
            pref_func.settings.onchange_funcs['tag.add_to_list'](pref_func.catalog_board_list_str_or);
          },
          'tag.add_to_list' : function(str){
            if (str!=='') {
              if (pref.catalog_board_list_str.search(/\n$/)==-1) pref.catalog_board_list_str = pref.catalog_board_list_str + '\n';
              pref.catalog_board_list_str = pref.catalog_board_list_str + str + '\n';
              if (pref_func.settings.pn13) pref_func.settings.apply_pn13_1();
//              pref_func.str2obj('catalog_board_list_str');
//              if (pref_func.board_sel) pref_func.apply_prep(pref_func.board_sel,false);
              pref_func.settings.onchange_funcs['board_sel_refresh']();
            }
          },
          'board_sel_refresh' : function(){
            pref_func.str2obj('catalog_board_list_str');
            cnst.auto_shrink_board_selector.str_changed();
          },
          'stats.use' : 'pn13_1_warning',
          'stats.estimate_posts' : 'pn13_1_warning',
          'stats.auto_acquisition' : function(){cnst.auto_shrink_board_selector.color();},
          'stats.auto_acquisition_all' : 'stats.auto_acquisition',
          'catalog.board.recommendation': 'board_sel_refresh',
          'catalog.board.board_tags': 'board_sel_refresh',
          'catalog_board_list_str': 'board_sel_refresh',
          'catalog.board.all_boards': 'board_sel_refresh',
          'JSON' : function() {
//          pref_func.apply_prep(pref_func.settings.pn13.getElementsByTagName('TEXTAREA')['overwrite_site2_json_str'],true);
            pref_func.site2_json();
          },
          'JSON_query_boards' : function() {
            pref.overwrite_site2_json_str = '{"site2":{"'+site.nickname+'":{"boards_json":""}}}';
            pref_func.site2_json(true);
          },
          'JSON_query' : function() {
            pref_func.site2_json(true);
          },
          'JSON_ex' : function() {
            pref_func.site2_json_ex(false);
            pref_func.settings.apply_pn13_1();
          },
          'JSON_ex_full' : function() {
            pref_func.site2_json_ex(true);
            pref_func.settings.apply_pn13_1();
          },
          'JSON_ex_filter' : function() {
            pref_func.site2_json_ex(false, true);
            pref_func.settings.apply_pn13_1();
          },
          'EVAL' : function() {
//            pref_func.apply_prep(pref_func.settings.pn13.getElementsByTagName('TEXTAREA')['overwrite_site2_eval_str'],true);
            pref_func.site2_eval();
          },
          'close': function(){pref_func.settings.show_hide();},
//          'save' : function(){if (localStorage) localStorage[pref.script_prefix+'.pref']=JSON.stringify(pref);},
          'save' : function(){
            if (localStorage) localStorage[pref.script_prefix+'.pref']=JSON.stringify(pref_func.site2_json_ex_remove());
          },
          'load_default' : function(e){
            var pref_def = pref_default();
            delete pref_def.settings.indexing;
            delete pref_def.catalog_board_list_sel;
            delete pref_def.catalog.filter;
            if (e.target.name==='load_default_of_this_page') {
              var nodes = e.target.parentNode.getElementsByTagName('*');
              for (var i=0;i<nodes.length;i++)
                if (nodes[i].name) {
                  var src = pref_func.get_tgt(nodes[i].name, pref_def, true);
                  if (src) {
                    var dst = pref_func.get_tgt(nodes[i].name);
                    dst[0][dst[1]] = src[0][src[1]];
                  }
                }
            } else {
              if (e.target.name.indexOf('easy2')===0) delete pref_def.easy2;
              pref_func.pref_overwrite(pref,pref_def);
              pref3.reload_required = true;
            }
//            var idx = pref.settings.indexing;
//            pref = pref_default();
            pref_func.obj_init();
//            pref.settings.indexing = idx;
//            pref_func.settings.onchange_funcs['settings.indexing']();
            pref_func.settings.apply_pn13_1();
            pref_func.settings.apply_pn13_1(true, e.target.name==='load_default_of_this_page' && cataLog.threads);  // writing to sessionStrage.
          },
          'load_default_of_this_page' : 'load_default',
          'load_samples' : function(){pref_func.pref_samples.init();},
          'catalog_triage_str' : function(){
            if (catalog_obj && catalog_obj.catalog_func()!==null) catalog_obj.catalog_func().remake_triage();
          },
          'triage.hide_toggle': 'catalog_triage_str',
          'catalog.footer.*': function(){if (cataLog.Footer) cataLog.Footer.update_all_force();},
          'thread_reader.use' : thread_reader_init,
          'catalog.appearance.titleBar.settings'        : 'catalog.appearance.titleBar.filter',
          'catalog.appearance.titleBar.refresh'         : 'catalog.appearance.titleBar.filter',
          'catalog.appearance.titleBar.num_of_pages'    : 'catalog.appearance.titleBar.filter',
          'catalog.appearance.titleBar.boards_selector' : 'catalog.appearance.titleBar.filter',
          'catalog.appearance.titleBar.filter' : function(){
            if (catalog_obj && catalog_obj.catalog_func()!==null) catalog_obj.catalog_func().pn12_0_2.getElementsByTagName('*')[this.name.substr(this.name.lastIndexOf('.')+1)].style.display = (this.checked)? '' : 'none';
          },
          'catalog_size_text_height': 'catalog_size_width', 
          'catalog_size_text_width': 'catalog_size_width',
          'catalog_size_height': 'catalog_size_width',
          'catalog_size_width': function(){
            if (catalog_obj && catalog_obj.catalog_func()!==null) catalog_obj.catalog_func().catalog_resized(this);
          },
          'catalog.click_area': styleSheet.make_rule_click_area,
          'style.sel': styleSheet.styles_changed,
          'style.fix.*': 'style.sel',
          'style.copy.*': 'style.sel',
          'style.reset.*': function(){
            var pref_def = pref_default();
            var tgt = this.name.split('.')[2];
            pref_func.pref_overwrite(pref.style[tgt], pref_def.style[tgt]);
            pref_func.settings.apply_pn13_1();
            pref_func.settings.onchange_funcs['style.sel']();
          },
          'style.userCSS.*': styleSheet.userCSS_changed,
////////          'catalog.click_area': function(){ // working code.
////////            if (pref_func.style_sheet) {
////////              if (pref_func.style_sheet.cssRules[2]) pref_func.style_sheet.deleteRule(2);
////////              pref_func.settings.onchange_funcs['catalog.click_area_add_rule']();
////////            }
////////          },
////////          'catalog.click_area_add_rule': function(){
////////////            var tgt  = site2[site.nickname].parse_funcs[site.whereami+'_html']['class_'+((pref.catalog.click_area==='entire')? 'thread' : 'thumbnail')]; // working code.
////////////            if (!tgt) tgt = 'dummy';
////////////            pref_func.style_sheet.insertRule('.'+tgt+' {cursor: pointer}',2);
////////            pref_func.style_sheet.insertRule('.'+pref.script_prefix+((pref.catalog.click_area==='entire')? '_thread' : '_thumbnail')+' {cursor: pointer}',2);
////////          },
//          'sound.beep_length_f' : notifier.sound.make_beep,
//          'sound.beep_volume_f' : notifier.sound.make_beep,
//          'sound.beep_freq'     : notifier.sound.make_beep,
//          'sound.src'           : notifier.sound.src,
//          'catalog.order.reply_to_me' : catalog_func.onchange_funcs['catalog.indexing'](),
//          'catalog.order.reply'  : catalog_func.onchange_funcs['catalog.indexing'](),
//          'catalog.order.watch'  : catalog_func.onchange_funcs['catalog.indexing'](),
//          'catalog.order.sticky' : catalog_func.onchange_funcs['catalog.indexing'](),
          'virtualBoard.p_board' : function(){liveTag.update_boardlist(true);},
          'virtualBoard.p_remove' : 'virtualBoard.p_board',
          'virtualBoard.max' : 'virtualBoard.p_board',
          'virtualBoard.show' : 'virtualBoard.p_board',
          'easy.virtualBoard_10_passive' : 'easy.virtualBoard_10',
          'easy.virtualBoard_10' : function(){pref_func.settings.onchange_funcs['pn13_1_warning_reload'](); pref_func.pref_samples.onclick_event.call(this);},
          'easy.virtualBoard_1' : 'easy.virtualBoard_10',
          'easy.virtualBoard_8_50' : 'easy.virtualBoard_10',
          'easy.virtualBoard_8_100' : 'easy.virtualBoard_10',
          'easy.virtualBoard_8_500' : 'easy.virtualBoard_10',
          'easy.virtualBoard_8_all' : 'easy.virtualBoard_10',
          'easy.virtualBoard_interSite' : 'easy.virtualBoard_10',
          'easy.posts_0h' : 'easy.virtualBoard_10',
          'easy.posts_24h' : 'easy.virtualBoard_10',
          'easy.threads_24h' : 'easy.virtualBoard_10',
          'easy.embed_index' : 'easy.virtualBoard_10',
          'easy.embed_index_lazy' : 'easy.virtualBoard_10',
          'easy.embed_index_infinite' : 'easy.virtualBoard_10',
          'easy.embed_index_backwash' : 'easy.virtualBoard_10',
          'easy.light' : 'easy.virtualBoard_10',
          'easy.stat_activate' : 'easy.virtualBoard_10',
          'easy2.beginner' : function(e){
            pref.easy2.presets = 1;
            pref_func.settings.onchange_funcs['easy2.presets'](e,pref.easy2.presets);
            pref_func.settings.onchange_funcs['easy2.apply'](e, true);
            pref_func.settings.onchange_funcs['reload'](e);
          },
          'easy2.presets' : function(e,idx){
            pref_func.pref_samples['easy2.presets']((idx!==undefined)? idx : pref.easy2.presets);
            pref_func.settings.apply_pn13_1();
          },
          'easy2.limits' : function(e,idx){
            pref_func.pref_samples['easy2.limits']();
            pref_func.settings.apply_pn13_1();
          },
          'easy2.apply' : function(e, force_reset){
            if (pref.easy2.reset || force_reset) pref_func.settings.onchange_funcs['load_default'](e);
            pref_func.pref_samples['easy2.presets']();
            pref_func.settings.onchange_funcs['pn13_1_warning_reload']();
            pref_func.pref_samples.onclick_event(null,pref.easy2);
          },
          'reload' : function(){location.reload();},
          'triage_simple_kill' : 'triage_simple',
          'triage_simple' : function(){pref_func.pref_samples.onclick_event.call(this);},
          'triage_basic' : 'triage_simple',
          'triage_basic_color' : 'triage_simple',
          'triage_colorful' : 'triage_simple',
          'triage_borders' : 'triage_simple',
          'triage_samples' : 'triage_simple',
          'triage_test' : 'triage_simple',
          'virtualBoard.scanStart' : function(){if (catalog_obj && catalog_obj.catalog_func()!==null) catalog_obj.catalog_func().catalog_liveTag_scan_site();},
          'virtualBoard.scanStop' : function(){scan.abort();},
          'virtualBoard.scan_domains.*': function(){
            if (pref.virtualBoard.instant_scan) {
              var domain = this.name.replace('virtualBoard.scan_domains.','');
              scan.keyword_load_1(domain);
            }},
          'virtualBoard.search.show': function(e, init){
            if (!site.components.boardlist) return;
            var tgt_name = 'virtualBoard.search';
            var bar = site.components.boardlist.getElementsByTagName('input')[tgt_name+'.str'];
            if (bar) bar = bar.parentNode;
            if (pref.virtualBoard.search.show) {
              if (!bar) {
                bar = document.createElement('span');
                bar.innerHTML = pref_func.format_html_str('<ITBL10"'+tgt_name+'.str"><span style="display:none"><ICBX"'+tgt_name+'.re">RE, &lt;<ITB2"virtualBoard.max"><span>\u25c0</span></span><span>\u25b6</span>');
                bar.style= 'float:right';
                pref_func.apply_prep(bar,false);
                pref_func.add_onchange(bar, pref_func.settings.onchange_funcs_formatted, pref_func.settings.oninput_funcs);
//                bar.oninput = function(e){pref.virtualBoard.search.str = e.target.value;liveTag.filter_onchange(pref.virtualBoard.search);}; // not storing to sessionStorage
                var pn_settings = bar.childNodes[1];
                var pn_open = bar.childNodes[2];
                var pn_close = bar.childNodes[1].childNodes[2];
                pn_open.onclick = function(){pn_open.style.display='none';pn_settings.style.display=null;};
                pn_close.onclick = function(){pn_open.style.display=null;pn_settings.style.display='none'};
                site.settings.parentNode.insertBefore(bar, site.settings);
                pref_func.mirror_targets.boardlist = bar;
                if (!init) liveTag.update_pn(); // activate filter
              }
            } else if (bar) {
              site.settings.parentNode.removeChild(bar); // 'if' for initialj
              pref_func.mirror_targets.boardlist = null;
              liveTag.update_pn(); // disable filter
            }
          },
          'virtualBoard.search.*': 'virtualBoard.search.str', // for 'search.re'. checkboxes don't fire oninput, though MDN says they fire. https://developer.mozilla.org/ja/docs/Web/HTML/Element/Input/checkbox
          'debug_site2': function(){if (pref.debug_mode.site2func) common_func.debug_site2func(pref.debug_mode.site2func);},
          'debug_pfunc': function(){if (pref.debug_mode.pfunc) common_func.debug_parse_funcs_entry(pref.debug_mode.pfunc);},
          'debug_pfunc_comp': function(){if (pref.debug_mode.pfunc_comp) common_func.debug_parse_funcs_entry(pref.debug_mode.pfunc, pref.debug_mode.pfunc_comp);},
          'debug_pfunc_all': function(){if (pref.debug_mode.pfunc_all) common_func.debug_parse_funcs_all(pref.debug_mode.pfunc_all);},
          'liveTag.ex_list_str' : function(){liveTag.ex_list_changed();},
          'liveTag.inherit_board_name' : function(){liveTag.inherit_board_name_changed();},
          'liveTag.inherit_board_tags' : function(){liveTag.inherit_board_tags_changed();},
          'page.mark_new_posts' : function(){if (cataLog.format_html) cataLog.format_html.time_filter_changed();},
          'recovery.comment' : function(){recovery.setup();},
          '*.open_spoiler_text': styleSheet.open_spoiler_text,
          '*.scroll_lock': function(){cataLog.general_event_handler.setup();},
          'button_test': function(){
//            site2['meguca'].catalog_native_prep(Date.now(), cataLog.components.pn12_0_4, cataLog.components.pn12_0, cataLog.embed_mode==='catalog');
            function callback(domain, board, no, result){
              console.log(result);
            }
            IDB.req_raw('meguca', 'meguca', 'mine', null, callback, 'get_all', true);
          },
          '*.posts_search_op': function(e,embed_mode){
            if (!embed_mode) embed_mode = cataLog.embed_mode;
            styleSheet.register('.CatChan_search_miss', (pref[embed_mode].posts_search_op==='opaque')? 'opacity:'+pref[embed_mode].posts_search_op_opacity/100+' !important' :
                                (pref[embed_mode].posts_search_op==='hide')? 'display:none !important' : null);},
          '*.posts_search_op_opacity': '*.posts_search_op',
          'style.post_editing': function(){styleSheet.register('.'+pref.script_prefix+'_post_editing', pref.style.post_editing);},
          'archive': {
            'restore2': function(e, files, posts){
              if (!cataLog.threads) return;
              if (e && !pref.archive.restore_auto && e.target.name!=='archive.restore_button') return;
              if (!posts) {
                files = Array.prototype.slice.call(pref3.archive.dir.files);
                posts = files.filter(function(v,i,a){return v.name.search(/\.(json|html*)$/)!=-1;});
                posts = posts.filter(function(v,i,a){return v.name.indexOf('_deleted.json')==-1;}); // PATCH
              }
              var imgs = files.filter(function(v,i,a){return v.name.search(/\.(json|html*)$/)==-1;});
              if (posts.length===0) return;
              archiver.restore_entry(posts,imgs, this['clear_files_button'], files.filter(function(v,i,a){return v.name.indexOf('_deleted.json')!=-1;}));
            },
            'dir': 'restore2',
            'files_sel': function(e){
              e.target.parentNode.querySelectorAll('span[name="FILES_ARCHIVE0"]')[0].style.display = (pref.archive.files_sel===0)? '' : 'none';
              e.target.parentNode.querySelectorAll('span[name="FILES_ARCHIVE1"]')[0].style.display = (pref.archive.files_sel===1)? '' : 'none';
              e.target.parentNode.querySelectorAll('span[name="FILES_ARCHIVE2"]')[0].style.display = (pref.archive.files_sel===2)? '' : 'none';
              if (pref.archive.files_sel===2) this['queryList']();
            },
            'restore_button': function(e){
              if (pref.archive.files_sel===0) this['restore2'](e);
              if (pref.archive.files_sel===2) this['IDB_thread_sel'](e);
              else this['restore'](e);
            },
            'restore': function(e){
//            if (!cataLog.threads) return;
//            if (!pref.archive.restore_auto && e.target.name!=='archive.restore') return;
              var posts= pref3.archive.jsons.files;
              var imgs = pref3.archive.imgs.files;
//            if (pref.archive.force_json) files = Array.prototype.filter.call(files,function(v){return v.name.substr(-5,5)==='.json';});
              if (posts.length===0 || (pref.archive.load_img && imgs.length===0)) return;
//            archiver.restore_entry(files,imgs, this['clear_files_button']);
              this['restore2'](null, Array.prototype.slice.call(imgs), posts);
            },
            'jsons': 'restore',
            'imgs': 'restore',
            'clear_files_button': function(){
              var doms = [pref3.archive.jsons, pref3.archive.imgs];
              for (var i=0;i<doms.length;i++) if (doms[i] && doms[i].parentNode) {
                var dom_new = doms[i].parentNode.insertBefore(doms[i].cloneNode(doms[i]),doms[i]);
                dom_new.onchange = doms[i].onchange;
                doms[i].parentNode.removeChild(doms[i]);
                dom_new.onchange({target:doms[i], currentTarget:doms[i]});
              }
            },
            get pn_IDB_board_sel(){return pref_func.settings.pn13 && pref_func.settings.pn13.querySelector('select[name="archive.IDB_board_sel"]');},
            get pn_IDB_thread_sel(){return pref_func.settings.pn13 && pref_func.settings.pn13.querySelector('select[name="archive.IDB_thread_sel"]');},
            'IDB_select_multiple': function(){
              this.pn_IDB_board_sel.multiple = pref.archive.IDB_select_multiple;
              this.pn_IDB_thread_sel.multiple = pref.archive.IDB_select_multiple;
            },
            'queryQuota': function(){
              if (navigator.webkitTemporaryStorage) navigator.webkitTemporaryStorage.queryUsageAndQuota(this['showQuota'].bind(this));
            },
            'showQuota': function(usage, limit){
              var tgt = pref_func.settings.pn13.querySelector('span[name="SHOW_QUOTA"]');
              if (tgt) tgt.textContent = usage.toLocaleString() + ' / ' + limit.toLocaleString() + ' (' + (usage*100/limit).toString().slice(0,5) + '%)';
            },
            'queryList': function(){
              if (!pref.test_mode['65']) if (!pref4.archive.IDB_board_sel_options)
              if (!brwsr.ff) window.indexedDB.webkitGetDatabaseNames().onsuccess = this['showList'].bind(this);
                else setTimeout(function(){this.showList({target:{result:Object.keys(liveTag.mems[site.nickname])}})}.bind(this),0);
            },
            'showList': function(e){
              if (e) {
                var results = e.target.result;
                var options = ['Select board'];
                for (var i=0;i<results.length;i++) options[options.length] = results[i].replace(/^[^\/]*/,'');
                options[options.length] = 'ALL (' + results.length + ')';
              } else options = null;
              pref4.archive.IDB_board_sel_options = options;
              pref_func.apply_prep(this.pn_IDB_board_sel, false);
            },
            'IDB_board_sel': function(){
              pref4.archive.IDB_thread_sel_options = null;
              var pn = this.pn_IDB_thread_sel;
              pref_func.apply_prep(pn, false);
              pn.style.display = '';
              var boards = this['IDB_selected_boards']();
              for (var i=0;i<boards.length;i++) IDB.req(site.nickname, boards[i], null, null, this['showThreadList_fromIDB'].bind(this), 'list_os');
            },
            'IDB_selected_boards': function(){
              if (pref.archive.IDB_board_sel===0) return [];
//            var board = pref4.archive.IDB_board_sel_options[pref.archive.IDB_board_sel];
//            return (board[0]==='A')? pref4.archive.IDB_board_sel_options.slice(1,-1) : [board]; // ALL
              return (pref4.archive.IDB_board_sel_options && pref.archive.IDB_board_sel===pref4.archive.IDB_board_sel_options.length-1)? pref4.archive.IDB_board_sel_options.slice(1,-1) :
                Array.prototype.slice.call(this.pn_IDB_board_sel.options).filter(function(v){return v.selected;}).map(function(v){return v.textContent;});
            },
            'showThreadList_fromIDB': function(domain, board, nos){
              var boards = this['IDB_selected_boards']();
              if (boards.length==1) board = '';
              var options = pref4.archive.IDB_thread_sel_options || ['ALL'];
              for (var i=0;i<nos.length;i++) options[options.length] = board + nos[i];
              options[0] = ' '; // assure the top before sort.
              options.sort();
              options[0] = 'ALL (' + (options.length-1) +')';
              pref4.archive.IDB_thread_sel_options = options;
              pref_func.apply_prep(this.pn_IDB_thread_sel, false);
            },
            'IDB_thread_sel': function(e){
              if (!cataLog.threads) return;
              if (!pref.archive.restore_auto && e.target.name!=='archive.restore_button') return;
              if (pref.archive.clear_threads && cataLog.threads) cataLog.catalog_clear_threads(0);
              this['IDB.selected_threads'](IDB.req, null, this['restore3'].bind(this), 'get_all');
            },
            'IDB.selected_threads': function(func, arg3, arg4, arg5){
              var ths = (pref.archive.IDB_thread_sel===0)? pref4.archive.IDB_thread_sel_options.slice(1) : // ALL
                Array.prototype.slice.call(this.pn_IDB_thread_sel.options).filter(function(v){return v.selected;}).map(function(v){return v.textContent;});
//                                                      [pref4.archive.IDB_thread_sel_options[pref.archive.IDB_thread_sel]];
              var boards = this['IDB_selected_boards']();
              var board = (boards.length===1)? boards[0] : '';
              if (func) for (var i=0;i<ths.length;i++) func(site.nickname, board || ths[i].replace(/[^\/]*$/,''), ths[i].replace(/\/[^\/]*\//,''), arg3, arg4, arg5);
              else {
                var proto = {domain:site.nickname, boards:boards};
                for (var i=0;i<ths.length;i++) ths[i] = {board:board || ths[i].replace(/[^\/]*$/,''), no:ths[i].replace(/\/[^\/]*\//,''), __proto__:proto};
                return ths;
              }
            },
            'restore3': function(domain, board, no, result){
              var obj = this['consolidate_IDB_result'](result, domain);
              if (obj.posts.length>0) {
                var th = archiver.restore({name:(site.nickname+board+no).replace(/\//,'-')}, site2[domain].parse_funcs.thread_json.prep_to_archive(obj.posts), obj.tn, true);
                if (obj.posts_deleted.length>0) {
                  if (pref.test_mode['80']) board = board.slice(0,-1)+'_IDB/';
                  var lth = liveTag.mems.init({domain:domain, board:board, no:no});
                  archiver.prep_deleted_posts(th, lth, true, obj.posts_deleted);
                }
              }
            },
            'consolidate_IDB_result': function(result, domain){
              var posts = [];
              var posts_deleted = [];
              var images = {};
              var thumbs = Object.create(images);
              var keys = Object.keys(result);
              for (var i=0;i<keys.length;i++) {
                if (keys[i].indexOf('posts_deleted')===0) posts_deleted = posts_deleted.concat(result[keys[i]]);
                else if (keys[i].indexOf('posts')===0) posts = posts.concat(result[keys[i]]);
                else if (keys[i]==='pruned_time') continue; // patch for old files.
                else {
                  var ext = keys[i].replace(/[^\.]*./,'');
                  var type = (ext==='webm')? 'video/webm' : 'image';
                  var file_obj = {type:type, file:result[keys[i]]};
                  if (keys[i].indexOf('tn_')===0) thumbs[keys[i].substr(3)] = file_obj;
                  else images[keys[i].substr(4)] = file_obj;
                }
              }
              var i = 0;
              while (i<posts.length-1 && posts[i].no<posts[i+1].no) i++;
              if (i!==posts.length-1) { // out of order or duplication may due to queueing system of IDB, retry or reload.
                posts.sort(this['consolidate_IDB_sort_func']);
                i = 0;
                while (i<posts.length-1) {
                  if (posts[i].no===posts[i+1].no) {
                    var j=i+2;
                    while (j<posts.length && posts[i].no===posts[j].no) j++;
                    if (domain==='meguca') {
                      var editing = posts[i].editing;
                      var k=i+1;
                      while (k<j && posts[k].editing==editing) k++;
                      if (k<j) {
                        k=j;
                        while (--k>i) if (posts[k].editing) {posts.splice(k,1);j--;}
                      }
                    }
                    while (--j>i) posts.splice(j,1); // 4chan has different coms when anchor refers deleted posts.
//                    while (--j>i) if (posts[j-1].com===posts[j].com) posts.splice(j,1); // BUG. posts[x].no must be unique and simple increase at 'check_deleted_posts'.
                  }
                  i++;
                }
              }
              j=0;
              for (var i=0;i<posts_deleted.length;i++) {
                while (j<posts.length && posts[j].no<posts_deleted[i].no) j++;
                if (j<posts.length && posts[j].no===posts_deleted[i].no) posts.splice(j,1);
              }
              var func_init = domain && site2[domain].parse_funcs.thread_json.consolidate_IDB_result_sub;
              if (func_init && posts.length!==0) func_init(posts);
              return {posts:posts, posts_deleted:posts_deleted, img:images, tn:thumbs};
            },
            'consolidate_IDB_sort_func': function(a,b){return (a.no!==b.no)? a.no - b.no : (a.com<b.com)? -1:1},
            'IDB.delete_board': function(){
              var boards = this['IDB_selected_boards']();
              for (var i=0;i<boards.length;i++) window.indexedDB.deleteDatabase(pref.script_prefix+'.'+boards[i]);
//              this['IDB.delete_board_pn']();
//            },
//            'IDB.delete_board_pn': function(){
              var pn = this.pn_IDB_thread_sel;
              if (pn) pn.style.display = 'none';
              this['showList'](null);
              this['queryList']();
            },
            'IDB.delete_thread': function(){
              this['IDB.selected_threads'](IDB.req, null, null, 'delete_th');
              this['IDB_board_sel'](null);
            },
            'IDB.delete_imgs': function(){
              this['IDB.selected_threads'](IDB.req, IDBKeyRange.bound('img_', 'img`', false, true), null, 'delete');
            },
            'IDB.export_thread': function(){
              var ths = this['IDB.selected_threads']();
              var filename = 'CatChan_IDB_'+ths[0].domain+'-'+((ths[0].boards.length==1)? ths[0].board.slice(1,-1) : ths[0].boards.length)+'-'+
                                                              ((ths.length===1)? ths[0].no : ths.length) +'.tar';
              var file_id = 'IDB_extract_'+Date.now();
              var callback = (function(this_obj){
                var count = ths.length;
                return function(domain, board, no, result){
                  this_obj['export_thread'](domain, board, no, result, file_id);
                  if (--count===0) archiver.tar.flush(file_id, filename);
                }
              })(this);
              for (var i=0;i<ths.length;i++) IDB.req(ths[i].domain, ths[i].board, ths[i].no, null, callback, 'get_all');
            },
            'export_thread': function(domain, board, no, result, file_id, filename){
              var obj = this['consolidate_IDB_result'](result, domain);
//            var file_id = 'CatChan_IDB_'+domain+'-'+board.slice(1,-1)+'-'+no+'.tar';
              var props = Object.keys(obj);
              for (var i=0;i<props.length;i++) {
                var props2 = (Array.isArray(obj[props[i]]))? ['dummy'] : Object.keys(obj[props[i]]);
                for (var j=0;j<props2.length;j++) {
                  var isPosts = props[i].indexOf('posts')===0;
                  if (isPosts && obj[props[i]].length===0) continue;
                  var data = (isPosts)? new Blob([JSON.stringify(site2[domain].parse_funcs.thread_json.prep_to_archive(obj[props[i]]))], {type:'text/plain'}) : obj[props[i]][props2[j]].file;
                  var suffix = (isPosts)? domain+'-'+board.slice(1,-1)+'-'+no+ props[i].substr(5)+'.json' : props[i] +'_'+ props2[j];
                  archiver.tar.add_blob(data, {domain:domain, board:board, no:no}, suffix, file_id, true);
                }
              }
              if (filename) archiver.tar.flush(file_id, filename);
            },
            'IDB.reset_time': function(){
              this['IDB.selected_threads'](archiver.clean_list);
            },
            'start': function(e){archiver.store_entry((e.target.name==='archive.start')? 'ARC' : 'ARC1');},
            'oneshot': 'start',
            'kwd.*': function(){pref.archive.kwd.rexps = common_func.kwd_prep_regexp(pref.archive.kwd);},
          },
          'test_mode.js_load': function(){
            var file = pref_func.settings.pn13.getElementsByTagName('input')['test_mode.js_file'].files[0];
            var url = window.URL.createObjectURL(file);
            var scr = document.createElement('script');
            scr.src = url;
            site.script_body.appendChild(scr);
          },
          '*.merge': function(e){site2['DEFAULT'].update_posts_merge_bases.onchange_merge(e);},
          '*.merge_list': '*.merge',
          '*.merge_list_str': '*.merge',
          '*.merge_lv': function(e){site2['DEFAULT'].update_posts_merge_bases.onchange_lv(e);},
          '*.merge_lv_str': '*.merge_lv',
          'scanBoard': function(e){if (cataLog.event_func) cataLog.event_func(e);},
          'scanBoardIf': 'scanBoard',
          'scanSite': 'scanBoard',
          'scanSiteIf': 'scanBoard',
          'tighten_loosed_limits': function(e){pref4.search_posts_active_once = false;},
        }
      },
      bind_myself: function(obj, args){for (var i of args) obj[i] = obj[i].bind(obj);},
      format_html_str: function(html){
        html = html.replace(/<br>([1-9]),/g,function(match,p1){ // function myself(match,p1){return (!p1)? '<br>' : myself(null,p1-1)+'&emsp;';}
                                              var str = '<br>';
                                              for (var i=0;i<p1;i++) str += '&emsp;';
                                              return str;
                                            });
        html = html.replace(/<TA"([\w.]+),(\d+),(\d+)"([^>]*)>/g,'<textarea style="height:1em" rows="$3" cols="$2" name="$1"$4></textarea>');
        html = html.replace(/<IC"([\w.]+)"([^>]*)>(\w)?/g,function(m,p1,p2,p3){return '<input type="checkbox" name="'+p1+'"'+p2+'>'+(p3?' '+p3:'');}); // with single space
        html = html.replace(/<ITB(L)?(\d+)"([\w.]+)"([^>]*)>(\w)?/g,function(m,p1,p2,p3,p4,p5){return '<input type="text"'+(p1?'':' style="text-align: right;"')+' size="'+p2+'" name="'+p3+'"'+p4+'>'+(p5?' '+p5:'');}); // with single space
        html = html.replace(/<ICBX"/g,'<input type="checkbox" name="'); // used for catalog.filter.kwd
//        html = html.replace(/<ITBL(\d+)"/g,'<input type="text" size="$1" name="');
//        html = html.replace(/<ITB(\d+)"/g,'<input type="text" style="text-align: right;" size="$1" name="');
//        html = html.replace(/<IR("[\w\.]+):([^:]+):([^"]+)">/g,'<input type="radio" name=$1" value="$2">$3');
        html = html.replace(/<IR"([\w\.]+),([^"]+)">/g,'<input type="radio" name="$1" value="$2">');
        html = html.replace(/<SSV("[\w\.]+")>/g,'<span data-class="show_value" style="font-weight:bold" name=$1></span>');
        html = html.replace(/<BTN"([\w.]+),([^"]+)"([^>]*)>/g,'<button type="button" name="$1"$3>$2</button>');
        html = html.replace(/<IF"/g,'<input type="file" name="');
        return html.replace(/<input type="(checkbox|radio)[^>]+>[^<]+/g,'<label>$&</label>');
      },
    };
  })();
  pref_func.settings.oninput_funcs = pref_func.add_onchange_format(pref_func.settings.onchange_funcs.__proto__);
///  pref_func.settings.onchange_funcs.entry_func = (function(myself){ // working code.
///    return function(e){
///      pref_func.apply_prep(this,true);
///      var pn_name = this.getAttribute('name'); // for <span>
///      if (myself[pn_name]) myself[pn_name].call(this,e);
///      else if (pn_name.indexOf('.')!=-1) {
///        var name = '*'+pn_name.substr(pn_name.indexOf('.')); // *.XXX
///        if (myself[name]) myself[name].call(this,e);
///        else if (pn_name.lastIndexOf('.')!=-1) {
///          var name = pn_name.substr(0,pn_name.lastIndexOf('.')+1)+'*'; // XXX.YYY.*
///          if (myself[name]) myself[name].call(this,e);
///        }
///      }
///      var pn = e.target.parentNode;
///      while (pn && pn!==site.script_body) {
///        if (pn.getAttribute('name')==='SUB') myself['SUB'].call(pn,{currentTarget:pn});
///        pn = pn.parentNode;
///      }
///    }
///  })(pref_func.settings.onchange_funcs);

  pref_func.settings.onchange_funcs['catalog.tag.ignore'] = pref_func.settings.onchange_funcs['tag.re_generate'];
  pref_func.settings.onchange_funcs['catalog.tag.max']    = pref_func.settings.onchange_funcs['tag.re_generate'];
  pref_func.settings.onchange_funcs['tag.gen_str']        = pref_func.settings.onchange_funcs['tag.gen'];
  pref_func.bind_myself(pref_func.settings.oninput_funcs.__proto__, ['SHOW','HIDE','SHOW2','HIDE2','SHOW3','HIDE3','TOGGLE2','SHOWALL','HIDEALL']);

  var options = {
    func0_prep: function(){},
    func0_exe : function(){}
  };

  common_func = {
    __proto__:common_func,
    overwrite_prop: function(dst,src){
      for (var i in src) {
        if (src[i]===undefined && dst[i]) delete dst[i];
        else if (typeof(dst[i])==='object' && typeof(src[i])==='object') common_func.overwrite_prop(dst[i],src[i]);
        else dst[i] = src[i];
      }
    },
    name2domainboardthread: function(name,fill){
//      var thread = name.replace(/[^\/]*\//g,'');
//      var domain = name.replace(/\/.*/,'');
//      var board  = name.replace(new RegExp('^'+domain),'').replace(new RegExp(thread+'$'),'');

//      name = new String(name); // not tested.
      var thread = name.substr(name.lastIndexOf('/')+1);
      var domain = name.substr(0,name.indexOf('/'));
      var board  = name.substr(domain.length,name.length-thread.length-domain.length);
      if (name===thread && thread.search(/[^0-9]/)!=-1) {
        domain = thread;
        thread = '';
      }
//      if (thread===domain) // BUG PATCH, SHOULD BE REMOVED.
//        if (thread.search(/[^0-9]/)!=-1) thread ='';
//        else domain = '';
      if (fill) {
        if (domain==='') domain = site.nickname;
        if (board==='') board = site.board;
      }
      return [domain,board,thread];
    },
    name2dbt: (function(){
      var type = { c:'catalog_html',
                   j:'catalog_json',
                   p:'page_html',
                   q:'page_json',
                   t:'thread_json',
//                   0:'thread_html' // default
                 };
      return function(name){
        var dbt = this.name2domainboardthread(name,true);
        dbt[3] = type[dbt[2][0]];
        if (dbt[3]) dbt[2] = dbt[2].substr(1);
        else dbt[3] = 'thread_html';
//        if (dbt[2][0].search(/[A-z]/)!=-1) {
//          dbt[3] = type[dbt[2][0]];
//          dbt[2] = dbt[2].substr(1);
//        } else dbt[3] = 'thread_html';
        return dbt;
      }
    })(),
//    fullname2dbt: function(name){ // slow
//      var dbt = name.split('/');
//      dbt[1] = '/'+dbt[1]+'/';
//      return dbt;
//    },
    fullname2dbt: function(name){
      var thread = name.substr(name.lastIndexOf('/')+1);
      var domain = name.substr(0,name.indexOf('/'));
      var board  = name.substr(domain.length,name.length-thread.length-domain.length);
      return [domain,board,thread];
    },
    dom_addEventListener: function(ary, dom, kwd, func){
      dom.addEventListener(kwd, func, false);
      ary[ary.length] = [dom, kwd, func];
    },
    dom_removeEventListener: function(ary, dom, kwd, func){
      for (var i=ary.length-1;i>=0;i--) {
        if ((!dom || dom===ary[i][0]) && (!kwd || kwd===ary[i][1]) && (!func || func===ary[i][2])) {
          ary[i][0].removeEventListener(ary[i][1], ary[i][2], false);
          ary.splice(i,1);
        }
      }
    },
    dom_addAttribute: function(dom,attr,val){
      var val_old = dom.getAttribute(attr);
      if (val_old) val = val_old + ' ' + val;
      dom.setAttribute(attr,val);
    },
    Triage: function(str,args){
      var tooltips = {
        'NONE': ['Don\'t hide this thread and set its style.',true],
        'ATTR': ['Set style additionally.',true],
        'KILL': ['Hide this thread permanently.',true],
        'TIME': ['Hide this thread until it gets new replies.',true],
        'WATCH': ['Watch this thread and mark as I\'ve read all posts so far.', false],
        'UNWATCH': ['Unwatch this thread.', false],
        'SHOW': ['Show this thread always without regard to filter setting.', false],
        'UNSHOW': ['Remove \'show\' marks.', false],
        'STICKY': ['Sticky this thread.', false],
        'UNSTICKY': ['Unsticky this thread.', false],
        'UNDO': ['Undo last modification.', false],
        'GO': ['Open this thread.', false],
        'ARC': ['Start archiving this thread.', false],
        'ARC1': ['Archive this thread one time.', false],
        'UARC': ['Unarchive this thread.', false],
      };
      tooltips['KILL_N'] = [tooltips['KILL'][0],false];
      tooltips['TIME_N'] = [tooltips['TIME'][0],false];
        var format_tgt = [];
        var toggles = ['WATCH','UNWATCH','SHOW','UNSHOW','STICKY','UNSTICKY','ARC','ARC1','UARC'];
        var pn = document.createElement('div');
        pn.name = (args.name)? args.name : '';
//        pn_triage.style.position = 'absolute';
//        pn_triage.name = 'pn_catalog_triage';
        pn.className = 'catalog_triage_parent';
        var lines = str.replace(/\s*\/\/.*/mg,'').split('\n');
        str = [];
        for (var i=lines.length-1;i>=0;i--) if (lines[i]==='') lines.splice(i,1);
        var triage_style_replace_list = (!brwsr.ff)? ['background','background-color'] : [];
        for (var i=0;i<lines.length;i++) str[i] = lines[i].split(',');
        for (var i=0;i<str.length;i++) {
          for (var j=0;j<str[i].length;j+=3) {
            var triage_button = document.createElement('button');
            triage_button.innerHTML = str[i][j+1];
            triage_button.name = pn.name + '('+i+','+j+')';
            triage_button.className = 'catalog_triage_button';
            triage_button.type = 'button';
            var triage_styles = (str[i][j+2])? str[i][j+2].split(';') : [];
            for (var k=0;k<triage_styles.length;k++) {
              var style_str = triage_styles[k].replace(/:.*/,'');
              for (var m=0;m<triage_style_replace_list.length;m+=2) style_str = style_str.replace(triage_style_replace_list[m],triage_style_replace_list[m+1]);
              triage_button.style[style_str] = triage_styles[k].replace(/[^:]*:/,'');
            }
//            triage_button.onclick = triage_factory(i,j);
            triage_button.onclick = args.onclick;
            pn.appendChild(triage_button);
            if (args.wheelpatch) triage_button.onmousewheel = args.wheelpatch;
            if (pn.name) pref_func.tooltips.str[triage_button.name] = ((tooltips[str[i][j]])? tooltips[str[i][j]][0] +
                                                                       ((tooltips[str[i][j]][1])? '\nSet style ' + ((str[i][j+2])? str[i][j+2] : 'default') + '.' : '') : '');
            if (toggles.indexOf(str[i][j])!=-1) format_tgt[format_tgt.length] = [triage_button, str[i][j]];
          }
          pn.appendChild(document.createElement('br'));
        }
//        pn.onclick = function(e){  // also works, but CSS is the better.
//          e.preventDefault();
//          var evt = document.createEvent('MouseEvents');
//          evt.initUIEvent('click', false, true, window, 1);
//          threads[pn12_triage_thread][0].dispatchEvent(evt);
//        };
        this.str = str;
        this.pn  = pn;
        this.format_tgt = (format_tgt.length!==0)? format_tgt : null;    
      },
//    make_triage: function(args){
//        var triage_str = [];
//        var pn_triage = document.createElement('div');
////        pn_triage.style.position = 'absolute';
////        pn_triage.name = 'pn_catalog_triage';
//        pn_triage.className = 'catalog_triage_parent';
//        var triage_str_lines = pref.catalog_triage_str.replace(/\/\/.*/mg,'').split('\n');
//        for (var i=triage_str_lines.length-1;i>=0;i--) if (triage_str_lines[i]==='') triage_str_lines.splice(i,1);
//        var triage_style_replace_list = (!brwsr.ff)? ['background','background-color'] : [];
//        for (var i=0;i<triage_str_lines.length;i++)
//          triage_str[i] = triage_str_lines[i].split(',');
//        for (var i=0;i<triage_str.length;i++) {
//          for (var j=0;j<triage_str[i].length;j+=3) {
//            var triage_button = document.createElement('button');
//            triage_button.innerHTML = triage_str[i][j+1];
//            triage_button.name = i+','+j;
//            triage_button.className = 'catalog_triage_button';
//            var triage_styles = (triage_str[i][j+2])? triage_str[i][j+2].split(';') : [];
//            for (var k=0;k<triage_styles.length;k++) {
//              var style_str = triage_styles[k].replace(/:.*/,'');
//              for (var m=0;m<triage_style_replace_list.length;m+=2) style_str = style_str.replace(triage_style_replace_list[m],triage_style_replace_list[m+1]);
//              triage_button.style[style_str] = triage_styles[k].replace(/[^:]*:/,'');
//            }
////            triage_button.onclick = triage_factory(i,j);
//            triage_button.onclick = args.onclick;
//            pn_triage.appendChild(triage_button);
//            if (args.wheelpatch) triage_button.onmousewheel = args.wheelpatch;
//          }
//          pn_triage.appendChild(document.createElement('br'));
//        }
////        pn_triage.onclick = function(e){  // also works, but CSS is the better.
////          e.preventDefault();
////          var evt = document.createEvent('MouseEvents');
////          evt.initUIEvent('click', false, true, window, 1);
////          threads[pn12_triage_thread][0].dispatchEvent(evt);
//////console.log('aaa');
////        };
//        return {pn:pn_triage, str:triage_str};
//    },
    modify_bookmark: function(name,add){
      var key = new RegExp('(^|,)'+name.replace(/\+/,'\\+')+'([\^@*!][^,\n]*)*(,|\n|$)','mg');
      var str = pref.catalog.filter.bookmark_list_str;
      str = str.replace(key,',') + ((add)? ','+name+'\n' : '');
      pref.catalog.filter.bookmark_list_str = str.replace(/,,+/g,',').replace(/^,/g,'').replace(/\n,/g,'\n').replace(/\n\n+/g,'\n').replace(/^\n/,'')
      if (catalog_obj.catalog_func()) {
        var tgt = catalog_obj.catalog_func().pn12_0_4.getElementsByTagName('textarea')['catalog.filter.bookmark_list_str'];
        pref_func.apply_prep(tgt,false);
      } else if (pref.catalog.auto_save_filter) { // see 'save' in catalog.
        if (localStorage) {
          key = pref.script_prefix + '.catalog.filter.' + pref.catalog_board_list_obj[pref.catalog_board_list_sel][0].key;
          var obj = JSON.parse(localStorage.getItem(key));
          obj.bookmark_list_str = pref.catalog.filter.bookmark_list_str;
          localStorage.setItem(key,JSON.stringify(obj));
        }
      }
    },
    perf_out: function(obj){
      obj.push(performance.now());
      var str = '';
      var last_ts = null;
      for (var i=0;i<obj.length;i++) {
        if (typeof(obj[i])==='number') {
          if (last_ts) str += (obj[i]-last_ts) + ', ';
          last_ts = obj[i];
        } else str += obj[i] + ', ';
      }
      console.log(str);
    },
    debug_show_proto_func_pool: null,
    debug_show_proto: function(name,obj,ex_keys,search_key) {
      if (!search_key) search_key='proto';
      if (!ex_keys) ex_keys = ['proto'];
      var str = name + ':';
      var keys = Object.keys(obj);
      for (var i=0;i<keys.length;i++) if (ex_keys.indexOf(keys[i])==-1) {
        str += keys[i] + ',';
        ex_keys.push(keys[i]);
        if (this.debug_show_proto_func_pool) this.debug_show_proto_func_pool[keys[i]] = obj[keys[i]];
      }
//      if (obj.hasOwnProperty(search_key)) str += '/' + this.debug_show_proto(obj[search_key], obj.__proto__, ex_keys, search_key); // for 'proto'
      if (obj.hasOwnProperty(search_key)) str += '/' + this.debug_show_proto(obj.__proto__[search_key], obj.__proto__, ex_keys, search_key); // for 'debug____proto'
      return str;
    },
    debug_parse_funcs_entry: function(str, str2) {
      var expand = (!str2)? pref.debug_mode.pfunc_expand : pref.debug_mode.pfunc_comp_expand_same || pref.debug_mode.pfunc_comp_expand_diff;
      if (expand) this.debug_show_proto_func_pool = {};
      console.log(this.debug_parse_funcs(str));
      if (str2) {
        var pool_0 = this.debug_show_proto_func_pool;
        this.debug_show_proto_func_pool = {};
        if (pref.debug_mode.pfunc_comp_proto) {
          var dp = str2.split(':');
          var start_point = site2[dp[0]].parse_funcs[dp[1]];
          var proto_org = start_point.__proto__;
          dp = pref.debug_mode.pfunc_comp_proto.split(':');
          dp = site2[dp[0]].parse_funcs[dp[1]];
          if (dp) start_point.__proto__ = dp;
        }
        console.log(this.debug_parse_funcs(str2));
        var pool_1 = this.debug_show_proto_func_pool;
      }
      if (this.debug_show_proto_func_pool)
        if (!str2) for (var i in this.debug_show_proto_func_pool) console.log(i+': '+this.debug_show_proto_func_pool[i]);
      else {
        for (var i in pool_1) {
          var same = pool_0[i] === pool_1[i];
          if (pref.debug_mode.pfunc_comp_expand_same && same || pref.debug_mode.pfunc_comp_expand_diff && !same) {
            console.log(i+': '+ (same? 'same':'differ') + ': '+ pool_0[i]);
            if (!same) console.log(i+': '+ (same? 'same':'differ') + ': '+ pool_1[i]);
          }
          delete pool_0[i];
        }
        for (var i in pool_0) console.log(i+': only_in_original: '+ pool_0[i]);
      }
      this.debug_show_proto_func_pool = null;
      if (proto_org) start_point.__proto__ = proto_org;
    },
    debug_parse_funcs: function(str) {
      for (var i in site2) for (var j in site2[i].parse_funcs) if (site2[i].hasOwnProperty('parse_funcs') && site2[i].parse_funcs.hasOwnProperty(j)) site2[i].parse_funcs[j]['debug____proto'] = i+'.'+j;
      var str2 = str.split(':');
      var start_point = site2[str2[0]].parse_funcs[str2[1]];
      return str+'::'+ ((start_point)? this.debug_show_proto('/'+start_point['debug____proto'],start_point, ['debug____proto','proto'], 'debug____proto') :
                                      'NONE');
    },
    debug_parse_funcs_parse: function(domain, src_type, str, force) {
      var src_types = [src_type+'_template', src_type];
      for (var s=0;s<2;s++) {
        var strs = this.debug_parse_funcs(domain+':'+src_types[s]).split(',');
        for (var i=0;i<strs.length;i++) {
          var idx_s = strs[i].lastIndexOf(':');
          if (strs[i].substr(idx_s+1)===str) {
            strs.splice(i+1,strs.length-i-1);
            var hier_str = strs[(i>0)?i-1:i].replace(/[^\/]*\//g,'').replace(/:[^:]*$/,'').replace(/\./,':');
            var root_str = strs[0].replace(/::.*/,'');
            if (hier_str!==root_str) strs[strs.length] = ' (==='+hier_str+')';
            return [strs, hier_str, src_types[s]];
          }
          if (idx_s===-1) strs.splice(i--,1);
          else strs[i]=strs[i].substr(0,idx_s+1);
        }
      }
      return [strs, hier_str, src_types[s]];
    },
    debug_parse_funcs_all: function(str) {
      var domains = ['DEFAULT','4chan','vichan','lain','8chan','KC','meguca','meguca1','meguca2','dist'];
      var types = ['','_json','_html']; // ,'_json_template','_html_template']; // '' for common
      var srcs = ['common','post','thread','page','catalog'];
      var objs = {};
      for (var d=0;d<domains.length;d++)
        for (var t=0;t<types.length;t++) {
          if (domains[d]==='KC' && types[t]==='_json') continue;
          for (var s=0;s<srcs.length;s++) {
            if (domains[d]!=='DEFAULT' && srcs[s]==='common' || !site2[domains[d]]) continue; // !site2[domains[d]] is a patch for 'dist'
            var src_type = srcs[s]+types[t];
            if (site2[domains[d]].parse_funcs[src_type]) {
              var result = this.debug_parse_funcs_parse(domains[d], src_type, str);
              var strs = result[0];
              var hier_str = result[1];
              src_type = result[2];
//            try {
              var obj_root = site2[domains[d]].parse_funcs[src_type];
              if (obj_root) {
                var obj = obj_root[str];
                var flag = true;
                for (var i in objs) if (objs[i][0]===obj) {strs[strs.length] = ' (==='+i+')'; flag=false; objs[i][1]++; break;}
  //              if (flag) objs[domains[d]+':'+src_type] = obj;
                if (flag) objs[hier_str] = [obj,1];
                if ((typeof(obj)==='string' || typeof(obj)==='number')) strs[str.length] = ', '+obj;
              }
//            } catch(e){
//              if (src_type.indexOf('_template')==-1) throw e; // templates don't have parse_funcs and cause excaption.
//            }
              console.log(strs.join(''));
            }
          }
        }
      var num = 0;
      if (pref.debug_mode.pfunc_all_expand) for (var i in objs) console.log((num++)+'('+objs[i][1]+'): '+ i +': '+objs[i][0]);
    },
    debug_site2func: function(name) {
      for (var i in site2) if(site2[i].hasOwnProperty(name)) site2[i]['debug____'+name] = i;
      var str = '';
      var funcs = {};
      for (var i in site2) {
        str += i+': '+site2[i]['debug____'+name]+', ';
        funcs[site2[i]['debug____'+name]] = site2[i][name];
      }
      console.log(str);
      if (pref.debug_mode.site2func_expand) for (var i in funcs) console.log(i+': '+funcs[i]);
    },
//    obj_scopy_from_key: function(obj){
//      for (var i in obj)
//        if (typeof(i)==='string' && Object.prototype.hasOwnProperty.call(obj,obj[i])) obj[i] = obj[obj[i]];
//      return obj;
//    },
//    set_value_to_root: function(leaf,key,val){ // working code.
//      if (Object.prototype.hasOwnProperty.call(leaf,key)) leaf[key] = val;
//      else this.set_value_to_root(Object.getPrototypeOf(leaf),key,val);
//    },
//    init_set_style: function(dom,src){
//      dom.style = {};
//      if (src) for (var i in src) dom.style[i] = src[i];
//      if (src===null) {
//        src = dom.getAttribute('style');
//        if (src) {
//          src = pref_func.style2obj(src);
//          for (var i in src) dom.style[i] = null;
//        }
//      }
//    },
    shallow_copy_1: function(src){
      var dst = Object.create(null);  
      for (var i in src) if (src.hasOwnProperty(i)) dst[i] = src[i];
      return dst;
    },
    deep_copy: function(dst,src){
      for (var i in src)
        if (src.hasOwnProperty(i))
          if (Array.isArray(src[i])) dst[i] = src[i].slice();
          else if (typeof(src[i])==='object') dst[i] = this.deep_copy({},src[i]);
          else dst[i] = src[i];
      return dst
    },
    image_resize : function(pn,w,h) {
      var nw = pn.naturalWidth;
      var nh = pn.naturalHeight;
      var fw = (nw>w)? nw/w : 1;
      var fh = (nh>h)? nh/h : 1;
//      if (fh>1 || fw>1) {
        pn.setAttribute('width', (fw>=fh)? w : nw/fh);
        pn.setAttribute('height',(fh>=fw)? h : nh/fw);
//      }
////      var f  = (fw>fh)? fw : fh;
////      pn.setAttribute('width',  nw/f);
////      pn.setAttribute('height', nh/f);
    },
    kwd_prep_regexp: function(kwd) {
      if (!kwd.str) return null;
      var kwds = (kwd.sentence)? [kwd.str] : kwd.str.split(' ');
      for (var i=kwds.length-1;i>=0;i--) {
        if (kwds[i]==='') kwds.splice(i,1);
        else {
          if (!kwd.re) kwds[i] = kwds[i].replace(/[\.\(\)\[\]\+\^\$\{\}]/g,'\\$&').replace(/\*/g,'.*').replace(/\?/g,'.');
          try {
            kwds[i] = new RegExp(kwds[i],(kwd.ci)? 'i' : '');
          } catch(e) {
            kwds.splice(i,1); // user input causes errors usually, ex. trailing \ in incremental search.
          }
        }
      }
      return (kwds.length===0)? null : kwds;
    },
    escape:(function(){
      var entities = {
        '<': '&lt;',
        '>': '&gt;',
        '&': '&amp;',
        '"': '&quot;',
        '\'':'&#039;', // '&apos;'
      };
      function escape(str){
        return entities[str];
      }
      return function(txt){
        return txt.replace(/[<>"'&]/g,escape);
      }
    })(),
    escape_text: function(txt){ // http://d.hatena.ne.jp/ockeghem/20070510/1178813849
      return txt.replace(/&/g,'&amp;').replace(/</g,'&lt;');
    },
    arraybuffer2blob: (function(){
      var mime_types = {jpg:'image/jpeg', jpeg:'image/jpeg', gif:'image/gif', png:'image/png', pdf:'application/pdf',
                        svg:'image/svg+xml', svgz:'image/svg+xml', 
                        htm:'text/html', html:'text/html', txt:'text/plain',
                        webm:'video/webm', mpg:'video/mpeg', mpeg:'video/mpeg', mp4:'video/mp4', ogv:'video/ogg',
                        mp3:'audio/mp3', 
                        gz:'application/x-gzip', tar:'application/x-tar', tgz:'application/x-tar', zip:'application/x-compress',
                        '7z':'application/x-7z-compressed', xz:'application/x-xz',
                       };
      return function(filename, data){
        var ext = filename.substr(filename.lastIndexOf('.')+1);
        var type = mime_types[ext] || 'text/plain';
        return new Blob([data], {type:type});
      }
    })(),
  };

  var common_obj = {
    thread_reader: null,
    events_beforeunload: [],
  };
  common_func.dom_addEventListener(common_obj.events_beforeunload, window, 'beforeunload', function(){common_func.dom_removeEventListener(common_obj.events_beforeunload)});
  common_func.dom_addEventListener(common_obj.events_beforeunload, window, 'focus', function(){DelayBuffer.prototype.hasFocus = true;});
  common_func.dom_addEventListener(common_obj.events_beforeunload, window, 'blur', function(){DelayBuffer.prototype.hasFocus = false;});

  var site = { // krautchan/int/
    max_page   : 20,
    autosage   : 300,
    board_name : '/int/',
    url_prefix : 'https://krautchan.net/int/',
    url_prefix2 : {},
    nickname   : 'KC',
    nicknames  : ['CatChan_tgt'],
    thread_keyword: 'thread',
    postform: null,
    postform_rules: null,
    get_ops    : null,
    get_posts  : null,
////////    make_url   : null,
////////    make_url2  : function(bn,idx){
////////      var nickname  = (bn.indexOf('/')==0)? site.nickname : bn.substr(0,bn.indexOf('/'));
////////      var boardname = '/' + bn.replace(/[^\/]*\//,'').replace(/\/.*/,'/');
////////      return [nickname, boardname, idx, site2[nickname].make_url(boardname,idx)];
////////    },
    server_name : null, // optional for 2chan.
    protocol : (document.location.href.search(/https/)!=-1)? 'https:' : 'http:',
    catalog_threads_in_page : null,
//    catalog_posts_in_thread : null,
    remove_posts : function(src){return src;},
    remove_files_info : function(src){return src;},
    remove_checkboxes : function(src){return src;},
////////    get_thread_link : function(src){return '_blank';},
    get_time_of_last_post : function(doc){return null;},
    header_height : function(){return 0;},
    patch: null,
    components: {},
    get key(){return site.nickname + site.board + ((site.whereami==='thread')? site.no : '');}, // for dynamic change of site.whereami in meguca.
    query_set_component: function(name){
      var query_word = site2[site.nickname].components[name];
      var comp = (typeof(query_word)==='string')? document.querySelector(query_word) :
                                                  document.querySelectorAll(query_word[0])[query_word[1]];
      if (comp) site.components[name] = comp;
      else delete site.components[name];
    },
    config: function(keyword,nickname, reentry){ // url='*site/board/etc', keyword='site'
      var href = window.location.href;
      var url_site = href.substr(0,href.indexOf(keyword)+keyword.length);
      var url_board = decodeURI(href.substr(url_site.length+1)) + '/'; // add '/' to the last for case of ending without slash.
      site.board = '/' + url_board.substr(0,url_board.indexOf('/')+1);
      site.url_prefix = url_site + site.board;
      site.server_name  = href.substr(0,href.indexOf(keyword)-1).replace(/https*:\/\/*/,'');
      site.nickname = nickname;
      site.isthread = window.location.href.search(site2[nickname].thread_keyword)!=-1;
//      for (var i in site2[nickname]) site[i] = site2[nickname][i];
//      site.features = site2[site.nickname].features;
      if (site.no===undefined) site.no = (site.whereami==='thread')? site2[site.nickname].get_ops(document)[0] : '';
//      site.myself = site2[site.nickname].get_ops(document)[0];
//      site.no = (site.whereami==='thread')? site.myself : '';
      if (reentry) return;
      if (!site0.isStep && site2[nickname].features) pref_func.pref_overwrite(site.features,site2[nickname].features);
      for (var i in site2[site.nickname].components) site.query_set_component(i);
      if (!site.settings && site.components.boardlist) site.settings = site.components.boardlist.appendChild(document.createElement('span'));
//      if (site2[site.nickname].pref_default) pref_func.pref_overwrite(pref,site2[site.nickname].pref_default);
      site.patch = site2[site.nickname].patch;
    },
    features : {page: false, graph: true, setting: true, setting2: true, postform: true, catalog: true, listener : false, uip_tracker: false, thread_reader: true, debug: false},
    owners_recommendation: '',
    catalog : false,
    whereami: null,
    embed_to: {},
    root_body : document.getElementsByTagName('body')[0],
//    root_body : (document.getElementsByTagName('body')[0])? document.getElementsByTagName('body')[0] :
//                                                            document.getElementsByTagName('frame')[0].contentDocument.getElementsByTagName('body')[0] // KC root
    embed_frame:'CatChan_embed_frame',
    embed_frame_win: null,
    boardlist: null,
    settings: null,
  };
  site.protocol = (document.location.href.search(/https/)!=-1)? 'https:' : 'http:'; // patch for Tampermonkey.
  site.root_body2 = site.root_body;

  var site2 = {};
  site2['DEFAULT'] = { // skeleton for default
    nickname : 'DEFAULT',
    home : '', // home is used url for iframe, so it MUST BE THE SAME ORIGIN, OR LEAVE IT BLANK.
    check_func: function(){ // for background iframe
      if (window.location.href.indexOf(this.domain_url)!=-1) {
        site.whereami = 'other';
        site.config(this.domain_url,this.nickname);
        return true;
      } else return false;
    },
//    check_func: function(){return false;}, // return true if the script is running in this site.
    boards_sel_from_tags : function(){return '';}, // return boards selection strings.
    protocol: site.protocol,
    components: {},
    spoiler_text: {
      spoiler: /span.spoiler$/,
      open: /span.spoiler:hover/,
    },
    make_tack: function(){
      var tack = document.createElement('i');
      tack.setAttribute('class','fa fa-thumb-tack');
      return tack;
    },
    postform:(function(){
      function onoff(ref){
//        if (this.tack && ref) ref.parentNode.insertBefore(this.tack, ref);
        if (this.tack) this.tack.style.display = (this.tack.style.display==='none')? '' : 'none';
      }
      return {
        tack: null,
        init:function(){
          if (site.postform) {
            this.tack = site2[site.nickname].make_tack();
            this.tack.setAttribute('style','float:right;font-size:2em');
            site.postform.parentNode.insertBefore(this.tack,site.postform);
          }
          return this.tack;
        },
        on: onoff,
        off:onoff,
      };
    })(),
    postform_prep: function(){ // the same as vichan.
      site.components.postform_submit2 = null;
      site.components.postform_submit2_observer = new MutationObserver(this.postform_submit2_find);
      site.components.postform_submit2_observer.observe(document.getElementsByTagName('body')[0], {childList: true});
    },
    postform_submit2_find: function(){
      var state_old = site.components.postform_submit2;
      site.query_set_component('postform_submit2');
      site.query_set_component('postform_comment2');
      if (common_obj.thread_reader) common_obj.thread_reader.setup_submit2();
      if (pref.features.recovery) recovery.setup2();
    },
    general_event_handler:(function(){
//      function func_false(){return false;}
      var obj = {
        common: {
          subscribe: function(catalog_root){
            if (this.mouseover) catalog_root.addEventListener('mouseover',this.mouseover,false);
          },
          unsubscribe: function(catalog_root){
            if (this.mouseover) catalog_root.removeEventListener('mouseover',this.mouseover,false);
          },
          get_mark: function(pn, clientY){
            return this.get_mark_from_height(clientY, document.getElementByTagName('div'));
          },
          get_mark_from_height: function(now_height, pns){
            var len = pns.length;
            var step = len >> 1;
            var i = 0;
            while (step>0) {
              if (pns[i+step].offsetTop<now_height) i += step;
              step >>= 1;
            }
            while (i+1<len && pns[i+1].offsetTop<now_height) i++;
            return pns[i];
          },
          isThumbnail: function(e){
            var et = e.target;
            return et.tagName==='IMG' && et.parentNode && et.parentNode.tagName==='A'; // et.parentNode for shrink_thumbnails, expanded image was removed already.
          },
          recSearch_thread: function(tgt,ecT){
            while (tgt && tgt!=ecT) {
              if (tgt.classList && tgt.classList.contains('thread')) return tgt;
              else tgt = tgt.parentNode;
            }
            return null;
          },
        },
      };
      obj.thread = Object.create(obj.common);
      obj.page = Object.create(obj.common);
      obj.catalog = Object.create(obj.common);
      return obj;
    })(),
//    catalog_background : '#b5ccf9',
//    catalog_bordercolor : '#000000',
    horizontal_separator_in_index: function(){
//      var pn = document.createElement('div');
//      pn.innerHTML = '<br><br class="clear"><hr>';
      var pn = document.createElement('hr');
      pn.setAttribute('class', pref.script_prefix+'_hs');
      return pn;
    },
//    get_next_image: function(img,name){return null;}, // return next image for prefetch3
    get_next_image: function(img,top, imgs){
      if (!imgs) imgs = cataLog.parent.getElementsByTagName('img');
      var idx = Array.prototype.indexOf.call(imgs,img);
      if (top) while (imgs[idx+1] && imgs[idx+1].offsetTop<top) idx++;
      return (idx>=0)? imgs[idx+1] : null;
    },
//    get_time_of_posts : function(thread){return [0,0];}, // returns parsed UTC time of last and op posts from element of the thread.
//    get_time_of_post_in_utc : function(post){return 0;}, // returns parsed UTC time of posts.
////////    get_thread_link : function(thread){return null;}, // returns href from element of the thread. THIS SHOULD BE MERGED WITH modify_thread_link.
    catalog_threads_in_page : function(doc){return [];}, // returns array of thread elements in the page from the document.
    remove_posts : function(thread,end){}, // removes posts from the thread with a certain remains.
    remove_files_info : function(thread){return thread;}, // removes file information from the thread, and returns itself.
//    remove_checkboxes : function(thread){return thread;}, // removes checkboxes from the thread, and returns itself.
    postform_rules : null,
    thread_keyword : 'thread', // thread keyword in URL.
    max_page : function(board){return 10;}, // returns max_page
//    max_page : 10, // maximum page number.
//    make_url : function(board,no,key){return ['_blank','raw'];}, // returns URL and type from board name and page number.
//    make_url3: function(board,th){return '_blank';}, // returns URL from board name and thread number.
//    make_url4: function(dbt){return '_blank';}, // returns URL from dbt.
////////////    enumerate_boards_to_scan:function(){ // 4chan // working code.
////////////      var obj = [];
////////////      var end = (site3[site.nickname].boards.length > pref.scan.max)? pref.scan.max : site3[site.nickname].boards.length;
////////////      for (var i=0;i<end;i++) obj[obj.length] = '/'+site3[site.nickname].boards[i].board+'/';
////////////      return obj;
////////////    },
////////    enumerate_boards_to_scan:function(){ // working code.(2016.01.09)
////////      var obj = [];
////////      var end = (site3[site.nickname].boards.length > pref.scan.max)? pref.scan.max : site3[site.nickname].boards.length;
////////      for (var i=0;i<end;i++) obj[obj.length] = site3[site.nickname].boards[i];
////////      return obj;
////////    },
    generate_boards_json: function(src, page_def){
      var proto = {pages:page_def};
      var arr = [];
      for (var i=0;i<src.length;i++)
        arr[arr.length] = (Array.isArray(src[i]))? {board:src[i][0], pages:src[i][1], __proto__:proto}
                                                 : {board:src[i],                     __proto__:proto};
      return {boards:arr};
    },
    url_boards_json: function(){return '';}, // returns url of boards.json.
    get_boards_json: function(key,callback,callback_always,  dummy_indicator){
      var key = 'boards_json_'+this.nickname;
      if (this.boards_json) this.get_boards_json_callback(this.nickname,{status:200, response:this.boards_json},[callback,callback_always]);
      else httpd.req({initiator:key,
                      INDICATOR: dummy_indicator? {shift:function(){}, report:function(){}} : null, IDX:0, FINISHED:0, SUC:0, max:1, // patch for 8chan, see tag.generate_caller
                      tgts:[{domain:this.nickname, url:this.url_boards_json()[0], responseType:'json', data_type:'json'}],
                      callback_1:function(req,val){this.get_boards_json_callback(key,val,[callback,callback_always,true])}.bind(this)},6);
    },
    get_boards_json_callback: function(key,value,args){
      if (value.status==200) {
        this.postprocess_board(value.response);
        if (!site3[this.nickname].boards) {liveTag.update_pn_buf.cancel();liveTag.update_pn_buf.do_tgt();}
        site3[this.nickname].boards = true;
      }
      if (args[0] && (args[1] || value.status===200))
        if (args[2]) args[0]();
        else setTimeout(args[0],0);
    },
////    get_boards_json_indicator: null, // working code.
////    get_boards_json: function(key,callback,callback_always,health_indicator){
////      var key = 'boards_json_'+this.nickname;
////      if (this.get_boards_json_indicator) {
////        this.get_boards_json_indicator.report({end:Date.now(), prog_str:'Aborted.', err_str:'Aborted by next request.'});
////        this.get_boards_json_indicator = null;
////      }
////      if (this.boards_json) this.get_boards_json_callback(this.nickname,{status:200, response:this.boards_json},[callback,callback_always]);
////      else {
////        var indicator;
////        if (health_indicator) { // patch
////          indicator = health_indicator.shift('limegreen','b',key);
////          indicator.report({start:Date.now(), prog_str:'Loading boards\' information'});
////          this.get_boards_json_indicator = indicator;
////        }
////        http_req.get(key,this.nickname+',dummy,dummy',this.url_boards_json(),this.get_boards_json_callback.bind(this),0,true,[callback,callback_always,indicator,key]);
////      }
////    },
////    get_boards_json_callback: function(key,value,args){
////      if (value.status==200) {
////        this.postprocess_board(value.response);
////        if (!site3[this.nickname].boards) liveTag.update_pn_buf.do_tgt();
////        site3[this.nickname].boards = true;
////      }
////      if (args[2]) {
////        args[2].report({end:Date.now(), prog_str: (value.status==200)? 'boards.json is loaded.' : '',
////                        err_str:  (value.status==200)? '' : 'Error at loading board\'s infomation.'});
////        this.get_boards_json_indicator = null;
////      }
////      if (args[3]) http_req.close(args[3]);
////      if (args[0] && (args[1] || value.status===200))
////        if (args[2]) args[0]();
////        else setTimeout(args[0],0);
////    },
    postprocess_board: function(val){ // for 4chan and all 
      for (var i=0;i<val.boards.length;i++) {
        var bd = liveTag.mems.init({domain:this.nickname, board:'/'+val.boards[i].board+'/'});
        bd.o = i;
        if (val.boards[i].pages && !bd.pgs) bd.pgs = val.boards[i].pages;
        if (val.boards[i].tags && val.boards[i].tags.length!=0) liveTag.postprocess_board_add_btag(val.boards[i].tags,bd);
      }
    },
////////    postprocess_board: function(val){ // 4chan // working code.
////////      site3[this.nickname].boards = [];
////////      for (var i=0;i<val.boards.length;i++) {
////////        var bd = liveTag.mems.init({domain:this.nickname, board:'/'+val.boards[i].board+'/'});
////////        site3[this.nickname].boards.push(bd); // BUG. increase length forever.
//////////        Object.defineProperty(bd,'bump_limit',{value:val.boards.bump_limit});
////////      }
////////    },

////    show_boardlist_replaced: false, // working code.
////    show_boardlist_physical_board: function(tags,func_onclick){
////      var as = site.components.boardlist.getElementsByTagName('a');
////      if (pref.virtualBoard.p_board==='replace') {
////        for (var i=pn.childNodes.length-2;i>=0;i-=2) { // skip every delimiter // working code.
//////          var key = pn.childNodes[i].textContent.substr(1); // working code.
//////          for (var j=0;j<as.length;j++) {
//////            if (as[j].textContent===key) {
//////              if (!as[j].style) as[j].style = {};
//////              if (as[j].style.display!=='none') {
//////                as[j].style.display='none';
//////                pn.childNodes[i].tagName = 'a'; // can't change by specification.
//////                pn.childNodes[i].setAttribute('href',as[j].getAttribute('href'));
//////                as[j].parentNode.insertBefore(pn.childNodes[i],as[j]);
//////              } else pn.removeChild(pn.childNodes[i]); // remove '#XXX'(tag)
//////              pn.removeChild(pn.childNodes[i]); // remove '/'(delimiter)
//////            }
//////          }
////          var key = pn.childNodes[i].textContent;
////          for (var j=0;j<as.length;j++) {
////            if (as[j].textContent===key || as[j].textContent===key.substr(1)) {
////              if (!as[j].classList.contains(pref.script_prefix+'_tag')) {
////                var tmp_node = liveTag.update_tag_string([pn.childNodes[i].textContent], '', pn.childNodes[i].onclick, 'a').childNodes[0];
////                tmp_node.setAttribute('href',as[j].getAttribute('href'));
////                as[j].parentNode.insertBefore(tmp_node,as[j]);
////                as[j].parentNode.removeChild(tmp_node.nextSibling);
////              } else pn.removeChild(pn.childNodes[i]); // remove '#XXX'(tag)
////              pn.removeChild(pn.childNodes[i]); // remove '/'(delimiter)
////            }
////          }
////        }
////        this.boardlist_replaced = true;
////      } else if (this.boardlist_replaced) {
////        for (var i=0;i<as.length;i++) {
////          if (as[i].style && as[i].style.display==='none') {
////            as[i].style.display='';
////            as[i].parentNode.removeChild(as[i].previousSibling);
////          }
////        }
////        this.boardlist_replaced = false;
////      }
////    },
    show_boardlist_boards: Object.create(null,{sel:{value:null, writable:true}}),
    show_boardlist_physical_board: function(tags,func_onclick){ // tuned for 8chan
      var tgts = this.show_boardlist_boards;
      if ((tgts.sel===true  && pref.virtualBoard.p_board==='replace') ||
          (tgts.sel===false && pref.virtualBoard.p_board==='both')) {
        var src = (tgts.sel)? 'v' : 'p';
        var dst = (tgts.sel)? 'p' : 'v';
        for (var i in tgts) {
          var tgt = tgts[i];
          if (tgt[src] && tgt[dst]) {
            tgt[dst].parentNode.insertBefore(tgt[src],tgt[dst]);
            tgt[dst].parentNode.removeChild(tgt[dst]);
          }
        }
        tgts.sel = !tgts.sel;
      }
      if (this.show_boardlist_boards.sel===null && pref.virtualBoard.p_board==='replace') {
        var as = site.components.boardlist.getElementsByTagName('a');
        for (var i=0;i<as.length;i++) {
          var key = as[i].textContent;
          if (this.show_boardlist_physical_extract_func) key = this.show_boardlist_physical_extract_func(key);
          if (key[0]!=='#') this.show_boardlist_boards['#'+ ((pref.liveTag.ci)? key.toLowerCase() : key)] = {p:as[i]};
        }
        this.show_boardlist_boards.sel = false;
      }
      if (pref.virtualBoard.p_board==='replace') {
        var boardlist_hit = {};
        for (var i=tags.length-1;i>=0;i--) {
          var key = (pref.liveTag.ci)? tags[i].toLowerCase() : tags[i];
          var tgt = this.show_boardlist_boards[key];
          if (tgt) {
            if (!tgt.v) {
              var p = tgt.p;
              var v = liveTag.update_tag_string([key], '', func_onclick, 'a').childNodes[0];
              v.setAttribute('href',p.getAttribute('href'));
              p.parentNode.insertBefore(v,p);
              p.parentNode.removeChild(p);
              tgt.v = v;
            }
            tags.splice(i,1);
            boardlist_hit[key] = null;
          }
        }
        if (pref.virtualBoard.v_remove) {
          for (var i in this.show_boardlist_boards)
            if (this.show_boardlist_boards[i].v && boardlist_hit[i]===undefined) {
              var p = this.show_boardlist_boards[i].p;
              var v = this.show_boardlist_boards[i].v;
              v.parentNode.insertBefore(p,v);
              v.parentNode.removeChild(v);
              delete this.show_boardlist_boards[i].v;
            }
        }
      }
    },
    show_boardlist_tags_in_bl: null,
    show_boardlist: function(tags,func_onclick){
//      for (var i=0;i<site.boardlist.length;i++) {
//        if (site.boardlist[i].lastChild.className===pref.script_prefix+'_tag') site.boardlist[i].removeChild(site.boardlist[i].lastChild);
//        site.boardlist[i].appendChild(pn); // can't clone events.
//      }
      var sbl = site.components.boardlist;
      this.show_boardlist_physical_board(tags,func_onclick);

      if (this.show_boardlist_tags_in_bl) {
        sbl.removeChild(this.show_boardlist_tags_in_bl);
        this.show_boardlist_tags_in_bl = null;
      }
//      if (sbl.lastChild.getAttribute && sbl.lastChild.getAttribute('name')===pref.script_prefix+'_tag_parent') sbl.removeChild(sbl.lastChild);
      if (pref.virtualBoard.show && tags.length!==0) {
        var pn = liveTag.update_tag_string(tags, ' / ', func_onclick);
        pn.insertBefore(document.createTextNode('[ '),pn.firstChild);
        pn.appendChild(document.createTextNode(' ]'));
        this.show_boardlist_tags_in_bl = sbl.appendChild(pn);
      }
    },
    get_ops : function(doc){return [];}, // returns array of op numbers from the document.
    get_posts : function(doc) {return [];}, // returns array of posts numbers from the document.
//    absolute_link : function(doc){}, // change link from relative to absolute which includes site URL.
    absolute_link : function(pn){
      var prefix = this.protocol + '//' + this.domain_url;
      var tgts = ['src','href'];
      var all = pn.getElementsByTagName('*'); //'*[src],*[href]'
      for (var i=0;i<all.length;i++) {
        for (var j=0;j<tgts.length;j++) {
          var tgt = all[i].getAttribute(tgts[j]);
          if (tgt && tgt.indexOf('http')!=0 && tgt.indexOf('mailto:')!=0 && tgt.indexOf('blob')!=0 && tgt.substr(0,2)!='//')
            all[i].setAttribute(tgts[j], prefix + tgt);
//            all[i].setAttribute(tgts[j],site2[doc.domain].protocol + '//' + site2[doc.domain].domain_url + tgt); // working code.
        }
      }
    },
    absolute_link_1: function(href){return site2[this.nickname].protocol + '//' + site2[this.nickname].domain_url + href;},
    link_dbtp2href_abs: function(dbtp, quote){
      var d = dbtp[0];
      return (d!=site.nickname? site2[d].protocol + '//' + site2[d].domain_url : '') + site2[d].link_dbtp2href(dbtp, quote);
    },
////////    insert_footer : function(thread,page_no,boardname,insert,date,nof_posts,nof_files){return [nof_posts,nof_files];}, // insert information footer, and returns count of posts and images.

////////    insert_footer2: function(thread,type,nums,nums2){}, // insert num of new replies to me, num of new replies.
//    prep_footer3 : function(){return null;}, // prepare footer
//    insert_footer3: function(thread,nums,nums2){}, // insert footer.

//    prep_own_posts: function(){}, // prepare own_post object.
//    prep_own_posts_event: function(e){}, // event entry for preparing own_post object.
    ls_key_own_posts: pref.script_prefix + '.own_posts.',
    prep_own_posts_event : function(e){
      if (e) site2[site.nickname].prep_own_posts_1(e.key); // gives 'this' value to 'prep_own_posts_1'. MUST BE site2[site.nickname].
      if (window.name===site.nickname) send_message('parent',[['OWN_POSTS', window.name, site3[window.name].own_posts]]);
    },
    prep_own_posts : function(bt){
      site3[this.nickname].own_posts = {};
      if (localStorage) {
        var keys = (bt)? [this.ls_key_own_posts + bt] : Object.keys(localStorage);
        for (var i=0;i<keys.length;i++) this.prep_own_posts_1(keys[i]);
      }
//console.log(site3[this.nickname].own_posts);
    },
    prep_own_posts_1 : function(key){
      if (key.indexOf(this.ls_key_own_posts)==0) {
        var bt = key.substr(this.ls_key_own_posts.length);
        var board = bt.substr(0,bt.lastIndexOf('/')+1);
        if (!site3[this.nickname].own_posts[board]) site3[this.nickname].own_posts[board] = {};
        var nos = JSON.parse(localStorage[key] || '[]');
        for (var j=0;j<nos.length;j++) site3[this.nickname].own_posts[board][nos[j]] = null;
      }
    },
//    clean_up_own_posts : function(ths,board){ // working code.
////console.log('clean up');
//      if (localStorage) {
//        var nos = {};
//        for (var i=0;i<ths.length;i++) nos[ths[i].key.substr(ths[i].key.lastIndexOf('/')+1)] = null;
//        var own_key_bd = this.ls_key_own_posts + board;
//        var keys = Object.keys(localStorage);
//        for (var i=0;i<keys.length;i++)
//          if (keys[i].indexOf(own_key_bd)==0 && nos[keys[i].substr(own_key_bd.length)]!==null) delete localStorage[keys[i]]
//      }
////console.log(site3[this.nickname].own_posts);
//    },
    clean_up_LS: function(domain, board, nos){
      if (domain!==site.nickname) return; // PATCH.
      if (localStorage) {
        if (pref.thread_reader.own_posts_tracker && pref.thread_reader.clean_up_own_posts) this.clean_up_LS_th(this.ls_key_own_posts, board, nos);
        if (pref[cataLog.embed_mode].deleted_posts.auto_clean) this.clean_up_LS_th(this.ls_key_deletedPosts, board, nos);
        if (pref.recovery.auto_clean) {
          this.clean_up_LS_th(this.ls_key_comment, board, nos);
          this.clean_up_LS_th(pref.script_prefix+'.comment.'+site.nickname, board, nos); // patch for half year, from 2016.09
        }
      }
    },
    ls_key_deletedPosts: pref.script_prefix + '.deletedPosts.',
    clean_up_deleted_posts_1: function(bt){if (localStorage) delete localStorage[this.ls_key_deletedPosts + bt];},
//    ls_key_comment: pref.script_prefix + '.draft.',
    ls_key_comment: pref.script_prefix + '.draft.',
    clean_up_LS_th: function(ls_key, board, nos){
      var ls_key_bd = ls_key + board;
      var keys = Object.keys(localStorage);
      for (var i=0;i<keys.length;i++)
        if (keys[i].indexOf(ls_key_bd)==0 && nos[keys[i].substr(ls_key_bd.length)]===undefined) delete localStorage[keys[i]]; // console.log('delete_LS: '+keys[i]);
    },
    check_reply: (function(){
      var com_or_txt = false;
      var pn_tags = document.createElement('div');
      var regexp_anchor      = '';
      var regexp_anchor_len  = 0;
      var regexp_anchor_cb   = '';
      var regexp_anchor_txt_1  = /^>>[0-9]+/; // RegExp.test executes RegExp.exec once.
      var regexp_anchor_txt    = />>[0-9]+/g;
      var regexp_anchor_cb_txt_1 = /^>>>\/[0-9A-z_\+]+\/[0-9]+/;
      var regexp_anchor_cb_txt = />>>\/[0-9A-z_\+]+\/[0-9]+/g;
      var regexp_anchor_com    = /&gt;&gt;[0-9]+/g;
      var regexp_anchor_cb_com = /&gt;&gt;&gt;\/[0-9A-z_\+]+\/[0-9]+/g;
      var remake_own_posts = true;
      var own_posts;
      var own_posts_cb;
      var tag_ex_list;
      var str_rm_list;
//      var time_offset = Math.floor(Date.now()/1000)*1000; // BUG.
////////      var count_replies = 0; // for direct call to check_t1 from native catalog.
      function add_you(post, add_name){
        var as = post.pn.getElementsByTagName('a');
        for (var i=0;i<as.length;i++) {
          var to_me = false;
          var txt = as[i].textContent;
          if (own_posts && own_posts[txt.substr(2)]===null && regexp_anchor_txt_1.test(txt)) to_me = true; // SHOULD USE SEARCH INSTEAD OF TEST TO KEEP CONSISTENCY.
          if (!to_me && own_posts_cb && regexp_anchor_cb_txt_1.test(txt)) {
            var tgt = txt.split('/');
            var bd = '/'+tgt[1]+'/';
            if (own_posts_cb[bd] && own_posts_cb[bd][tgt[2]]===null) to_me = true;
          }
          if (to_me) {
            if (pref.thread_reader.show_reply_to_me_by==='plain') as[i].parentNode.insertBefore(document.createTextNode(' (You)'), as[i].nextSibling);
            else as[i].textContent = as[i].textContent + ' (You)'; // break dollchan.
          }
        }
        if (add_name && own_posts && own_posts[post.no]===null) {
          var pn_name = post.parse_funcs_html.pn_name(post);
          if (pref.thread_reader.show_own_post_by==='plain') pn_name.parentNode.insertBefore(document.createTextNode(' (You)'), pn_name.nextSibling);
          else pn_name.innerHTML = pn_name.innerHTML + ' (You)';
        }
      }
      function check_1(post, watch, extracted_tags, extracted_posts){
        var of_mine = own_posts && (post.no in own_posts);
        if (of_mine) post.reply_of_mine = true;
        if (!of_mine || !pref.catalog_footer_ignore_my_own_posts) {
          var com = (com_or_txt)? post.com : post.body;
          if (com) {
            var to_me  = false;
            if (own_posts) {
              var anchors = com.match(regexp_anchor);
              if (anchors!==null) {
                for (var j=0;j<anchors.length;j++) {
                  var tgt = anchors[j].substr(regexp_anchor_len);
                  if (own_posts[tgt]===null) {to_me = true; break;}
            }}}
            if (!to_me && own_posts_cb) {
              anchors = com.match(regexp_anchor_cb);
              if (anchors!==null) {
                for (var j=0;j<anchors.length;j++) {
                  var tgt = anchors[j].split('/');
                  var bd = '/'+tgt[1]+'/';
                  if (own_posts_cb[bd] && own_posts_cb[bd][tgt[2]]===null) {to_me = true; break;}
            }}}
            if (to_me) {
              post.reply_to_me = true;
              watch[1]+=0x10000;
            }
          }
          watch[1]++;
        }
        extracted_posts[extracted_posts.length] = post;
        if (extracted_tags) check_t1(post, extracted_tags);
      }
      function check_t1(post, extracted_tags){
        if (com_or_txt) {
          var mail = post.com; // 4chan doesn't have 'mail'.
          if (!mail) return;
          mail = mail.replace(/<[^>]*>|&[^;]*;/g,' ');
          if (pref.test_mode['47']) {
            pn_tags.innerHTML = mail;
            mail = pn_tags[brwsr.innerText];
          }
        } else {
          if (post.editing) {
            extracted_tags[extracted_tags.length] = post;// post.no;
            return;
          }
          mail = post.body || post.com;
          if (!mail) return;
        }
        if (mail.indexOf('#')===-1) return; // short cut.
        if (str_rm_list) for (var i=0;i<str_rm_list.length;i++) mail = mail.replace(str_rm_list[i],'\n');
        var tags = mail.match(liveTag.scan_regex);
//        if (tags!==null) extracted_tags = extracted_tags.concat(tags);
        if (tags!==null)
          for (var i=0;i<tags.length;i++)
            if (tags[i].length<=pref.liveTag.maxstr) {
              if (tag_ex_list) {
                for (var j=tag_ex_list.length-1;j>=0;j--) if (tag_ex_list[j].test(tags[i])) break;
                if (j>=0) continue;
              }
              extracted_tags[extracted_tags.length] = tags[i];
            }
      }
      function prep_check_1(th){
        if (th.parse_funcs.type_com==='txt') {
          regexp_anchor     = regexp_anchor_txt;
          regexp_anchor_len = 2;
          regexp_anchor_cb  = regexp_anchor_cb_txt;
          com_or_txt        = false;
        } else {
          regexp_anchor     = regexp_anchor_com;
          regexp_anchor_len = 8;
          regexp_anchor_cb  = regexp_anchor_cb_com;
          com_or_txt        = true;
        }
      }
      function prep_check_t1(th){
        if (pref.liveTag.ex_list) {
          tag_ex_list = pref_func.merge_obj5a(th.key,pref.liveTag.ex_list_obj5,null);
          str_rm_list = pref_func.merge_obj5a(th.key,pref.liveTag.rm_list_obj5,null);
        } else {
          tag_ex_list = null;
          str_rm_list = null;
        }
//        tag_ex_list = (pref.liveTag.ex_list)? pref_func.merge_obj5(th.key,pref.liveTag.ex_list_obj5,null) : null;
      }
      return {
        remake_own_posts : function(){remake_own_posts = true;}, // couldn't get an event from myself, so don't miss posts from my thread.
        make_own_posts : function(){  // called also from catalog initialializer, prevent from being called twice at initial.
          site2[site.nickname].prep_own_posts();
          remake_own_posts = false;
        },
        add_you: add_you,
        set_own_posts: function(th){
          own_posts_cb = site3[th.domain].own_posts;
          own_posts = own_posts_cb[th.board] || own_posts_cb['ALL']; // 'ALL' for meguca.
//          own_posts = own_posts_cb[th.board];
          if (Object.keys(own_posts_cb).length==0) own_posts_cb = undefined; // patch for faster execution.
        },
//        check_t1: check_t1,
        check_t1_op: function(th){
          prep_check_1(th);
          prep_check_t1(th);
          var extracted_tags = [];
          check_t1(th, extracted_tags);
////          watch[0] = (watch[0]&0xfffe0000) | 1; // BUG, WHY???
//          watch[0] = (watch[0]&0xfffe0000);
////          watch[2] = th.time; // requires many changes
////          watch[2] = th.time_created; // requires many changes // BUG, WHY???
          return extracted_tags;
        },
        get_checked_time: function(watch){
//          return watch[2] + time_offset; // BUG.
          return watch[2];
        },
        set_watch_time: function(watch, time, key){
          if (time>0) {
            watch[0] |= 0x00040000;
////          watch[2]  = time - time_offset; // to reduce memory usage, but doesn't effect. // BUG!!! watch[2] is initialized to 0, and not watched thread will enter with this. all threads must be initialized to '-time_offset'.
//            watch[2]  = time;
            if (watch[0]&0x00800000) watch[2] = time; // to reduce memory churn, this may require 'double' instead of Int32 for watch[2], CAUTION for compression.
            else {
              this.time_watch[key] = time;
              watch[0] &= 0xff7fffff;
            }
          }
        },
        set_watched_to_last: function(watch, time, key){
          this.set_watch_time(watch, time, key);
          watch[1] = 0;
        },
        set_unwatch: function(watch){
          watch[0] &= 0xff73ffff;
          watch[1] = 0;
        },
        time_watch:{},
//        check: function(th, watch, make_pn){
        check: function(th, watch, notify, ext_posts){ // watch[0]>0 && watch[3]>0 : usual check,
          // watch[0]>0 && watch[3]<0 : retag, initialize tag but doesn't show new replies. (watch[3] must retain its value), and entry
          // watch[0]<0 && watch[3]>0 : watchtime is updated. rescan new replies and show them. (watch[0] can be destroyed), BUG, can't entry.
          // watch[0]<0 && watch[3]<0 : not used.
          //
          // watch[0] [15:0]: num of posts so far,
          //          [16]: initial,
          //          [17]: initial tag, retag,
          //          [18]: watch_req, [19]:watching, [22:20]:archive,
          //          [23]: watch time not initialized. (23,18) -> 10: not initialized, 11: watch_req, use watch[2], 01: watch_req, use tiem_watch, 00: usual state.
          //          [24]: reentry of detection of deleted posts
          //          [25]: posts_saved.
          // watch[1] number of unread replies to me << 16 + number of unread replies
          // watch[2] checked time'
          var tag_init = watch[0]&0x00020000; // patch for retag.
//          var init = (watch[3]<0); // patch for retag.
//          if (watch[3]<0) watch[3] = -watch[3];
//          var time_check = watch[3];
//          var time_check = watch[2] + time_offset; // BUG.
          var time_check = watch[2];
          var watchtime_changed = false;
//          var time_lastsaw = (watch[3]>0)? watch[3] : watch[0];
//          var time_lastsaw = (watch[3]>watch[0])? watch[3] : watch[0]; // redundant anymore.
//          if (watch[0]<0) { // initial
//            watch[0] = -watch[0];
//            time_check = watch[0];
//            watch[1] = 0;
//            watch[2] = (watch[2]&0xfffe0000) + ((th.omitted_posts)? th.omitted_posts+1 : 0); // number of replies so far, patch for 4chan catalog_json.
//            init     = true;
//            watchtime_changed = true;
//          }
          var time_watch = watch[2];
          if (watch[0]&0x00040000) { // initial
//            time_watch = cataLog.get_watch_time_of_a_thread(th.key,th.time_created,null, true); // BUG, can't handle if time_watch===0(not watched).
            if (watch[0]&0x00800000) {
              time_check = 0;
              watch[2] = 0;
            } else {
              time_watch = this.time_watch[th.key];
              delete this.time_watch[th.key];
            }
//            watch[2] = 0;
            watch[1] = 0;
            watch[0] = ((watch[0]&0xff7b0000) | 0x00080000)+ ((th.omitted_posts)? th.omitted_posts+1 : 0); // number of replies so far, patch for 4chan catalog_json.
                      // &=0xff7fffff for entry by clicking WATCH triage.
//            init     = true;
            watchtime_changed = true;
          }
          var time_check_old = time_check;
//console.log('start: '+dbt[0]+dbt[1]+dbt[2],watch[5]);
          var i = th.posts.length-1;
//          if (remake_own_posts) { // working code.
//            site2[site.nickname].prep_own_posts(); // couldn't get an event from myself, so don't miss posts from my thread.
//            remake_own_posts = false;
//          }
          if (i>=0) {
//            watch[2] = (th.posts[i].time*th.parse_funcs.time_unit || watch[2]) - time_offset; // BUG.
            watch[2] = th.posts[i].time*th.parse_funcs.time_unit || watch[2];
            if (th.parse_funcs.time_unit!=1) {
              time_check = Math.floor(time_check/th.parse_funcs.time_unit);
              time_watch = (watchtime_changed)? Math.floor(time_watch/th.parse_funcs.time_unit) : time_check;
            }
            var extracted_tags = (pref.liveTag.from==='post')? [] : null;
            if (extracted_tags) prep_check_t1(th);
            var ur_old = liveTag.generate_ur(watch[1]);
            var watching = watch[0]&0x000c0000;
            if (watching || extracted_tags) prep_check_1(th);
            if (watching) {
              if (remake_own_posts) this.make_own_posts();
              liveTag.mems[th.domain][th.board].nr = -1; // mark as dirty.
              prep_check_1(th);
              this.set_own_posts(th);
              while (i>=0 && th.posts[i].time>time_watch) check_1(th.posts[i--], watch, extracted_tags, ext_posts); // extracting tags in op is redundant, because they are ALWAYS extracted.
            }
            if (extracted_tags) while (i>0 && (tag_init || th.posts[i].time>time_check)) check_t1(th.posts[i--], extracted_tags); // tuned for initial loop. don't extract tags in op.
            if (!common_obj.thread_reader) {
              if (extracted_tags && extracted_tags.length!=0) var tags = liveTag.extract_tags(th, extracted_tags, null, !tag_init); // 'check_update_tags_color' is called in this.
              else if (pref.liveTag.style && watching) {
                var ur = liveTag.generate_ur(watch[1]);
                if (ur_old!=ur) liveTag.update_ur(th.key,ur,ur_old!=0 && watchtime_changed); // can choose faster function if ur==0.
              }
            }
            if (pref3.stats.use && stats) stats.aggregate(th); // '&& stats' is a patch for embed_thread.
            if (time_watch!==time_check || !watching) {
              i = th.posts.length;
              while (i>0 && th.posts[i-1].time>time_check) i--;
              var new_posts = th.posts.slice(i);
            }
          }
          watch[0] = (watch[0]&0xfff90000) + th.nof_posts;
//console.log('end:   '+dbt[0]+dbt[1]+dbt[2]);
//if (pref.debug_mode['3'] && extracted_tags.length!=0) console.log(th.key+': '+extracted_tags);
////////          if (cataLog.threads && cataLog.threads[th.key]) { // working code.
//////////            if (!cataLog.threads[th.key][9][0]) cataLog.threads[th.key][9] = cataLog.catalog_filter_query(th.key); // doesn't work because threads[name][8] is NOT updated.
////////            cataLog.insert_footer3(th.key,null,th.page,tags);
////////          }
          if (notify && (watch[0]&0x000c0000)) {
//            if (ext_posts.length!=0 && pref.notify.desktop.notify && th.parse_funcs.add_op_img_url) th.parse_funcs.add_op_img_url(ext_posts,th.board,th.domain); // can't get 'com' if 'meguca'
            if (ext_posts.length!=0 && pref.notify.desktop.notify) site2[th.domain].wrap_to_parse.posts({posts:ext_posts, __proto__:th});
            notifier.changed(th, ext_posts);
          }
          return {tags:tags, posts:new_posts || ext_posts, time_check_old:time_check_old};
        },
      }
    })(),

////////    get_posts2 : function(doc,pool){return {}}, // subfunction of check_reply_to_me, parse html to json.
    get_post_offsetTop : function(doc,num) {}, // get offsetTop of Nth object.
    favicon: {
      get_favicon: function(){
        var links = document.getElementsByTagName('head')[0].getElementsByTagName('link');
        for (var i=0;i<links.length;i++) if (links[i].getAttribute('rel')=='shortcut icon') return links[i];
        var pn = document.createElement('link');
        pn.setAttribute('rel','shortcut icon');
        pn.setAttribute('href',this.none);
        pn.setAttribute('type','image/x-icon');
        return document.getElementsByTagName('head')[0].appendChild(pn);
      },
      get_title: function(){
        var title = document.getElementsByTagName('head')[0].getElementsByTagName('title')[0];
        if (!title){
          title = document.createElement('title');
          title = document.getElementsByTagName('head')[0].appendChild(title);
        }
        return title;
      },
    }, // object for favicon
//    get_op_image_url: function(th,type){}, // get op image's url.
    get_icon : function(){}, // get sticky icon.
    add_icon : function(){}, // add sticky icon.
    time_revised_check: function(nof_ths){return false;},

    format_thread_layout   : function(thread){}, // formats its layout   for catalog.
    format_thread_style    : function(thread){}, // formats its style    for catalog.
    format_thread_contents : function(thread){}, // formats its contents for catalog.
    format_thread_always   : function(thread){}, // formats its contents for catalog, always executed.
////////    format_time            : function(thread){}, // formats its timestamp to local time.
    format_remove_tn_area_size: function(thread){}, // remove thumbnail area size
//    mark_newer_posts       : function(thread,time){return null;},  // mark newer posts, and returns marked first post.
//    unmark_post_from_event : function(post){},  // unmark post.
    mark_newer_posts_posts: function(posts,date,unmark, short_cut) {
      date = date/this.parse_funcs.post_json.time_unit;
      var marked_first_post = null;
      for (var i=posts.length-1;i>=0;i--) {
        var pn = posts[i].pn
        if (date<posts[i].time) {
          pn.setAttribute('style', pref.style.post_new);
          if (unmark) pn.addEventListener('mouseover', this.unmark_post_from_event, false);
          marked_first_post = pn;
        } else {
          if (short_cut) break;
          if (pn.getAttribute('style')!=null) pn.removeAttribute('style');
        }
      }
      return marked_first_post;
    },
    mark_newer_posts : function(nickname,posts,date, func, unmark, short_cut){
//      var offset_top = 0;
      var marked_first_post = null;
      for (var i=posts.length-1;i>=0;i--) {
//        var reply = posts[i];
////        posts[i] = posts[i].parentNode;
////        if (class_or_tag=='class') while (posts[i].className.search(key)==-1) posts[i] = posts[i].parentNode;
////        if (class_or_tag=='tag') while (posts[i].tagName.search(key)==-1) posts[i] = posts[i].parentNode;
//        if (class_or_tag=='class') reply = posts[i].getElementsByClassName(key)[0];
//        if (class_or_tag=='tag')  reply = posts[i].getElementsByTagName(key)[0];
        var reply = (func)? func(posts[i]) : posts[i];
        if (reply)
          if (date<site2[nickname].parse_funcs.post_html.time_pn(posts[i])) {
            reply.setAttribute('style', pref.style.post_new);
//            if (!reply.style) reply.style = {};
//            reply.style.border = '2px solid red'; // ca'nt use !important
            if (unmark) reply.addEventListener('mouseover', site2[nickname].unmark_post_from_event, false);
//            offset_top = reply.offsetTop;
            marked_first_post = reply;
          } else {
            if (reply.getAttribute('style')!=null) reply.removeAttribute('style');
            if (short_cut) break;
//            if (reply.style) reply.style.border = 'none';
          }
      }
//      return offset_top;
      return marked_first_post;
    },
    format_pn: function(pn,thq_no, pref_env, post, th){
      if (!pref_env) pref_env = pref[cataLog.embed_mode];
      if (pref_env.colorID) this.colorID(pn);
      if (pref_env.backlink) this.backlink(pn,thq_no, th); // th for short href.
      if (pref_env.localtime) this.localtime(pn);
      if (post) { // BUG, CALLED TWISE TIMES for deleted posts in embed_mode==='thread'
//        if (cataLog.embed_mode==='page' || cataLog.embed_mode==='thread') site2['DEFAULT'].check_reply.add_you(post, true); // "cataLog.embed_mode==='page'" is a patch.
        site2['DEFAULT'].check_reply.add_you(post, true);
        if (post.deleted_after) pn.classList.add('CatChan_search_miss');
        if (post.search_result!==undefined) site2[post.domain_html].update_posts0_class(pn, post.search_result);
      }
    },
    colorID: function(){},
    localtime: function(){},
    unmark_post_from_event: function(e) {
      e.target.removeEventListener('mouseover', site2['common'].unmark_post_from_event, false);
      site2['DEFAULT'].unmark_post(e.target);
    },
    unmark_post: function(pn) {
      pn.removeAttribute('style');
//      pn.setAttribute('style','border: none');
    },
    modify_thread_link     : function(thread){return [];}, // modify thread link and returns information to add event listener.
    preprocess_html        : function(doc_txt){return doc_txt;},  // pre-process document from txt. // cause memory leak.
    preprocess_doc         : null, //function(doc){},  // pre-process document.
////////    thread2headline : function(doc){return [0,0];},  // make headline from entire thread, returns num of [posts, images].
//    add_thread_link : function(doc,url){}, // add link to this thread.
    check_thread_archived : function(thread){return false;}, // check the thread is archived.
    get_owners_recommendation: function(){return '';}, // return string of owner's recommendation.
    get_board_tags : function(){return {};}, // return object of board tags.
//    get_json_url_thread : function(board,thread){return '';}, // return url of JSON API.
    get_json_url_catalog : function(board){return '';}, // return url of JSON API.
//    parse_json_thread: function(txt,from_http){return JSON.parse(txt);}, // parser of JSON API.
    parse_json_thread: function(obj,from_http){}, // parser of JSON API.
    parse_json_catalog: function(txt){return JSON.parse(txt);},  // parser of JSON API.
    uip_tgt_post : function(no){return null;}, // returns uip target post.
    uip_post_num : function(post){return null;}, // returns num in posts.
    uip_check: function(callback){}, // hook for uip_tracker.
    catalog_native_prep: function(depend_on_site){return [];}, // prepare for native catalog.
    catalog_native_prep_swap_sortSel: function(sortSel){
      sortSel.parentNode.insertBefore(cataLog.components.catalog.indexing, sortSel.nextSibling);
      sortSel.setAttribute('style', 'display:none');
    },
    catalog_frame_prep: function(pn12){}, // prepare for frame mode.
    catalog_native_frame_prep: function(pn12,pn12_button){ // prepare for frame mode in native catalog.
      var mode = false;
      var ifrm;
      var pn_catalog;
      function insert_remove_frame(){
        if (!mode) {
          pn_catalog = site2['common'].absorb_children(site.root_body);
          pn_catalog.style.width = pref.catalog_size_frame0_width + '%';
          pn_catalog.style.float = 'left';
          pn_catalog.style.height = '' + window.innerHeight + 'px';
          pn_catalog.style.overflow = 'scroll';
          ifrm = site2[site.nickname].catalog_native_frame_prep_frame(site.root_body,null);
        } else {
          site.root_body.removeChild(ifrm);
          ifrm = null;
          site.embed_frame_win = null;
          site2['common'].disgorge_children(pn_catalog);
//          this.removeEventListener('click', insert_remove_frame, false);
        }
        mode = !mode;
      }
      pn12_button.addEventListener('click', insert_remove_frame, false);
    },
    catalog_native_frame_prep_frame: function(parent,ref_node){
      ifrm = document.createElement('iframe');
      ifrm.setAttribute('name',site.embed_frame);
      ifrm.style.height = '' + window.innerHeight + 'px';
      ifrm.style.margin = '0px';
      ifrm.style.width = pref.catalog_size_frame1_width + '%';
      parent.insertBefore(ifrm,ref_node);
      site.embed_frame_win = ifrm.contentWindow;
      return ifrm;
    },
    catalog_embed_prep: function(pn12){ // https://developer.mozilla.org/ja/docs/Web/API/HTMLElement/style, reset by null.
      pn12.style.position = null;
      pn12.childNodes[1].style.width = null;
      pn12.childNodes[1].style.height = window.innerHeight + 'px';
      pn12.childNodes[0].childNodes[0].style.display = 'none';
      pn12.childNodes[0].childNodes[1].style.display = 'none';
      pn12.style.border = null;
      pn12.style.left = null;
      pn12.style.resize = null;
      pn12.style.top = null;
    },
    thread2search_obj : function(thread){return [thread[brwsr.innerText],'','','','','','',''];}, // return search_obj from thread.
////    get_click_area: function(pn){
////      var img = pn.getElementsByTagName('img');
////      return (img.length!=0)? img : pn;
////    },
//    get_click_area: function(pn){
//      var img0 = pn.getElementsByTagName('img')[0];
//      return (img0)? img0 : pn;
//    }
    popups_posts: (function(){
      function up_timer_factory(){
        var up_timer = null;
        var up_e = null;
        var up_func = null;
        var up_pf = null;
        var up_src = null;
        function over_0(pf, e, func, src){
          if (pf.popdown==='imm') func(e);
          else {
            if (!src) src = e.target;
            if (pf.popup_mMove) src.addEventListener('mousemove', over_1, false);
            up_func = func;
            up_pf = pf;
            up_src = src;
            over_1(e);
          }
        }
        function over_1(e){
          if (up_timer) clearTimeout(up_timer);
          up_timer = setTimeout(timer_end, up_pf.popup_delay);
          up_e = e;
        }
        function timer_end(stop){ // this may be fired twice, because this has a racing condition between finish of up_timer and over_1 event.
          if (stop) clearTimeout(up_timer);
          up_timer = null;
          if (up_pf.popup_mMove) up_src.removeEventListener('mousemove', over_1, false);
          if (!stop) up_func(up_e);
        }
        return {
          over: over_0,
          stop: function(){
            if (up_timer) {timer_end(true);return true;}
            return false;
          },
          get up_timer(){return up_timer;},
          out: function(e){
            if (e.relatedTarget===erT_done) {erT_done = null; return e.relatedTarget;}
            else return this.stop();
          },
        };
      }
      var pns = new Map();
      var erT_done = null;
      function out_1_if_exists(src, pn_ex){
        var pn = pns.get(src);
        if (pn)
          if (!Array.isArray(pn)) {if (pn!==pn_ex) out_1(pn);}
          else for (var i=0;i<pn.length;i++) if (pn[i] && pn[i]!==pn_ex) out_1(pn[i]);
      }
      function out_1(pn){
        var info = pns.get(pn);
        var pf = info.pf && info.pf() || pref.proto;
        if (pf.popdown==='imm') pop_down(pn);
        else info.timer = setTimeout(pop_down.bind(null,pn), pf.popdown_delay);
      }
      function pop_setup(src, pn, obj, pna){
        pns.set(src, pna || pn);
        pns.set(pn, obj || {src:src}); // bi-directional
        pn.addEventListener('mouseenter',pop_over, false);
        pn.addEventListener('mousedown',cnst.div_mousedown,false);
      }
      function pop_down(pn, snatch){
        if (pn && pn.parentNode) {
          if (!snatch) pn.parentNode.removeChild(pn);
          var info = pns.get(pn);
          if (info.key) posts.pop_load_req_delete(info.key, pn);
          if (info.chart && !snatch) info.chart.destroy();
          if (info.scroll) pn.removeEventListener(brwsr.mousewheel, cnst.div_scroll, false);
          var src = info.src;
          var pna = pns.get(src);
          if (Array.isArray(pna)) {
            pna[pna.indexOf(pn)] = null; // keep position, not splice
            for (var i=0;i<pna.length;i++) if (pna[i]) break;
            if (i==pna.length) pns.delete(src);
          } else pns.delete(src);
          pns.delete(pn);
          pn.removeEventListener('mouseenter', pop_over, false);
          pn.removeEventListener('mousedown',cnst.div_mousedown,false);
          if (snatch) {
            pn.removeEventListener('mouseleave', pop_out, false);
            return info;
          }
        }
      }
      function pop_over(e){
        var ecT = e.currentTarget;
        var info = pns.get(ecT);
        var pf = info.pf && info.pf() || pref.proto;
        if (pf.popdown==='imm') pop_down(ecT);
        else {
          if (info.timer) clear_down_timer(info);
          erT_done = e.relatedTarget;
          ecT.addEventListener('mouseleave', pop_out, false);
        }
      }
      function pop_out(e){
        var ecT = e.currentTarget;
        ecT.removeEventListener('mouseleave', pop_out, false);
        out_1(ecT);
      }
      function clear_down_timer(info){clearTimeout(info.timer); info.timer=null;}

      var hist_x = 'left';
      var hist_y = 'top';
      var ddEcW = 0;
      var ddEcH = 0;
      function set_pos(pn, e, hist, narrow_x, narrow_y){
        var factor_x = (!hist)? 0.5 : (hist_x==='left')? 3/4 : 1/4;
        var factor_y = (!hist)? 0.5 : (hist_y==='top')?  4/5 : 1/5;
        ddEcW = document.documentElement.clientWidth;
        ddEcH = document.documentElement.clientHeight;
        if (ddEcW*factor_x-e.clientX>0 ^ narrow_x) {pn.style.left = e.clientX + 10 + 'px'; hist_x='left';}
        else {pn.style.right = ddEcW - e.clientX + 10 + 'px'; hist_x='right';}
        if (ddEcH*factor_y-e.clientY>0 ^ narrow_y) {pn.style.top = e.clientY + 10 + 'px'; hist_y='top';}
        else {pn.style.bottom = ddEcH - e.clientY + 10 + 'px'; hist_y='bottom';}
//        if (document.documentElement.clientWidth/2-e.clientX>0) pn.style.left = e.clientX + 10 + 'px';
//        else pn.style.right = document.documentElement.clientWidth - e.clientX + 10 + 'px';
//        if (document.documentElement.clientHeight/2-e.clientY>0) pn.style.top = e.clientY + 10 + 'px';
//        else  pn.style.bottom = document.documentElement.clientHeight - e.clientY + 10 + 'px';
      }
      function adjust_pos(pn, e){
        var s = pn.style;
        var tb = parseInt(s.top?s.top:s.bottom,10);
        var visible_v = pn.offsetHeight + tb < ddEcH;
        if (!visible_v && tb > ddEcH*0.5) {
          var h = ddEcH - pn.offsetHeight;
          var pos = (h<0? 0:h)+'px';
          if (s.top) {s.top = pos; hist_y = 'bottom';}
          else {s.bottom = pos; hist_y = 'top';}
        }
        var lr = parseInt(s.left?s.left:s.right,10);
        var visible_h = pn.offsetWidth + lr < ddEcW;
        if (!visible_h && lr > ddEcW*0.5) {
          var pos = ddEcW - parseInt(s.left?s.left:s.right,10)+20 + 'px';
          if (s.left) {s.right = pos; s.left = null;}
          else {s.left = pos; s.right = null;}
        }
      }

      var blacklist = new WeakSet();
      var geh;
      function href2domain(href){
        if (href[0]==='/' || href[0]==='#') return site.nickname;
        else for (var d in liveTag.mems) if (href.indexOf(site2[d].domain_url)!=-1) return site2[d].nickname;
        for (var d in site2) if (href.indexOf(site2[d].domain_url)!=-1) return site2[d].nickname_href2domain || site2[d].nickname;
      }
      var up0 = up_timer_factory(); // surface
      function over(e, force){ // image_hover can be merged to this, and popup2 also. e.path can be created easily, mouseenter can be replaced to mouseover.
        out(e);
        var et = e.target;
        var pf_mode = pref[cataLog.embed_mode];
        if (pf_mode.popup && et.tagName==='A' && site2['DEFAULT'].popups_link_regex.test(et.textContent)) {
          posts.over(e, force);
        } else if (pf_mode.image_hover) {
          if (geh.isThumbnail(e)) up0.over(pf_mode.thumbnail.hover, e, cataLog.DIH.image_hover_add);
        }
      }
      function out(e){
        cataLog.DIH.image_hover_remove();
        if (up0.out(e)) return;
        var erT = e.relatedTarget;
        if (erT && erT.tagName==='A') out_1_if_exists(erT);
//        if (erT===erT_done) erT_done = null;
//        else if (up0.stop()) return;
//        else if (erT && erT.tagName==='A') {
//          var info = pns.get(erT);
//          if (info) out_1(info);
//        }
      }
      var posts = (function(){
        function over(e, force){
          if (pref.proto.popup_hlt && post_highlight_if_visible(e)) return;
          up0.force = force
          up0.over(pref.proto, e, pop_up);
          var domain = href2domain(e.target.getAttribute('href'));
          if (domain!==site.nickname) e.stopPropagation(); // prevent striking(----) because of being taken as a deleted post in 4chan.
        }
        function pop_up(e){
          var force = up0.force;
          var et = e.target;
          if (pns.has(et)) {clear_down_timer(pns.get(pns.get(et))); return;}
          var domain = href2domain(et.getAttribute('href'));
          if (!force && pref[cataLog.embed_mode].env.popup_native) {
            if (pref[cataLog.embed_mode].env.event_dynamic && !pref.test_mode['100']) {
              if (site.nickname===domain) return; // 4chan
            } else if (blacklist.has(et)) return // { // working code, but can't surpress dual popup.
  //            if (pref[cataLog.embed_mode].env.popup_native_kill) {
  //              var pn = blacklist.get(et);
  //              if (pn===null) {
  //                pn = et.cloneNode(true);
  //                pn.setAttribute('style','position:relative;left:-'+et.offsetWidth+'px;'); // to cause mouseout to popdown native popup.
  //                et.parentNode.insertBefore(pn,et.nextSibling);
  //                blacklist.set(pn,et);
  //              } else {
  //                et.parentNode.removeChild(et.previousSibling);
  //                et.removeAttribute('style');
  //                blacklist.delete(et);
  //              }
  //            } else return;
  //          }
          }
          pop_make(e, domain);
        }
        function pop_make(e, domain){
          var obj = popups_post_entry(e, domain);
          if (obj) pop_setup(e.target, obj.pn, obj.key? {src:e.target, key:obj.key} : null);
          return obj.pn;
        }
  
        var keys_loading = new Map();
        function pop_load(key, domain){
          var tgts = keys_loading.get(key);
          if (tgts) {
            for (var i=tgts.length-1;i>=0;i--) { // must be backward, tgts[i] will be removed in pop_down
              var tgt = tgts[i]; // backup is needed, pop_down removes tgts[i] itself.
              var pn = pns.get(tgt.target);
              if (pn) {
                pop_down(pn); // removes tgts[i]
                var pn2 = pop_make(tgt,domain);
                if (pn.style.left) pn2.style.left = pn.style.left; else pn2.style.right = pn.style.right;
                if (pn.style.top) pn2.style.top = pn.style.top; else pn2.style.bottom = pn.style.bottom;
              }
            }
            keys_loading.delete(key);
          }
        }
        function pop_load_req(e, key, pn){
          var val = {target:e.target, clientX:e.clientX, clientY:e.clientY, pn:pn};
          var tgts = keys_loading.get(key);
          if (tgts) tgts.unshift(val); // reverse ordering.
          else keys_loading.set(key,[val]);
        }
        function pop_load_req_delete(key, pn){
          var tgts = keys_loading.get(key);
          if (tgts) {
            for (var i=tgts.length-1;i>=0;i--) if (tgts[i].pn===pn) tgts.splice(i,1);
            if (tgts.length===0) keys_loading.delete(key);
          }
        }
  
        function post_highlight_if_visible(e){
          var href = e.target.getAttribute('href'); // keep as it is, et.href may be %xx%yy.
          var domain = href2domain(href);
          var th_q = site2[domain].popups_href2th_q(href);
          var no = th_q[1];
          var tgt_th = cataLog.threads[th_q[0].key];
          var posts = tgt_th && tgt_th[16] && tgt_th[16].posts;
          if (posts) {
            for (var i=posts.length-1;i>=0;i--) if (posts[i].no===no) break;
            var pn = (i>=0)? posts[i].pn : undefined;
            if (pn && window.getComputedStyle(pn).display!=='none') {
              var oT = pn.offsetTop;
              var sT = brwsr.document_body.scrollTop;
              if (oT>sT && oT+pn.offsetHeight<sT+document.documentElement.clientHeight) { // temporal, embed only. see 'get_ref_height'.
                pn.classList.add(site2[site.nickname].popups_posts_class_hlt);
                e.target.addEventListener('mouseout',post_highlight_end, false);
                pns.set(e.target, pn);
                post_dotted_if_multi_anchors(pn, e, {domain_html:pref.catalog.mimic_base_site? site.nickname : domain});
                return true;
              }
            }
          }
          return false;
        }
        var an_dotted = null;
        function post_highlight_end(e){
          var et = e.target;
          et.removeEventListener('mouseout',post_highlight_end, false);
          pns.get(et).classList.remove(site2[site.nickname].popups_posts_class_hlt);
          pns.delete(et);
          if (an_dotted) {
            an_dotted.classList.remove('dotted');
            an_dotted = null;
          }
        }
        function post_dotted_if_multi_anchors(pn, e, th){
          if (!pref.test_mode['108']) {
            var as = site2[th.domain_html].post_pn2ce(pn).getElementsByTagName('a');
            if (as.length>1) {
              var pn_post = site2[th.domain_html].post_an2pn(e.target);
              if (pn_post) {
                var pn_no = site2[th.domain_html].parse_funcs['post_html'].no({pn:pn_post});
                for (var i=0;i<as.length;i++) if (site2[th.domain_html].popups_href2dbtp(as[i].getAttribute('href'))[3]==pn_no) break;
                if (i!=as.length) {
                  as[i].classList.add('dotted');
                  an_dotted = as[i];
                }}}}
        }
        function popups_post_entry(e, domain){
          var et = e.target;
          var th = {domain:domain, domain_html: pref.catalog.mimic_base_site? site.nickname : domain};
          var th_q = site2[th.domain].popups_href2th_q(et.getAttribute('href'));
          if (!th_q) return;
          var dbt = th_q[2];
  //        if (pref[cataLog.embed_mode].env.event_dynamic && pref[cataLog.embed_mode].env.popup_native && site.nickname===th.domain && pref.test_mode['98']) return;
          var pn;
          var thqp = th_q[0][th_q[1]];
          var isOP = dbt[3] == dbt[2]; // thqp.no == dbt[2]; // == must be used, typeof(dbt[2]) is string.
          if (thqp===undefined && pref.test_mode['80']) { // patch
            th.no = th_q[2][2];
            var boards = ['_IDB/', '_File/'];
            for (var i=0;i<2;i++) {
              th.board = th_q[2][1].slice(0,-1)+boards[i];
              var th_q0 = liveTag.mems[th.domain][th.board] && liveTag.mems[th.domain][th.board][th.no] && liveTag.mems[th.domain][th.board][th.no].q;
              if (th_q0) {
                th_q[0] = th_q0;
                break;
              }
            }
          }
          if (thqp===undefined || Array.isArray(thqp)) {
            site2['DEFAULT'].popups_try_fetch_from_lth_ta(liveTag.mems[th.domain][dbt[1]][dbt[2]], parseInt(dbt[3],10), th); // may change thqp, th for domain_html(mimic)
            thqp = th_q[0][th_q[1]];
          }
          if (thqp===undefined || Array.isArray(thqp)) { // 'thqp===undefined' for multilevel popups.
            site2[th.domain].popups_post_fetch(th, dbt);
  //          cataLog.scan_init('popup',[th.domain+dbt[1]+((pref.catalog.catalog_json)? 't':'')+dbt[2]], {priority:8});
            pn = site2[th.domain_html].post_json2html({time: 0, com:'Loading...'}, dbt[1]);
            var key = dbt[0]+dbt[1]+dbt[2]+'#'+dbt[3];
            pop_load_req(e, key, pn);
  //          site2['DEFAULT'].popup_info = {node:et, clientX:e.clientX, clientY:e.clientY, key:dbt[0]+dbt[1]+dbt[2]+'#'+dbt[3], func_out:site2['DEFAULT'].popups_posts.pop_down.bind(null,pn)}; //out};
            site2['DEFAULT'].popups_set_waiting(th_q[0],th_q[1]);
          } else {
  //          if (site2['DEFAULT'].popup_info) site2['DEFAULT'].popup_info.func_out();
  //          if (site2['DEFAULT'].popup_info) et.onmouseout(); // BUG at editing, sometimes out is never issued because of being replaced.
  //          if (!thqp.pn || thqp.isOP || thqp.type_data==='html') {
  //          if (!thqp.pn || isOP && site.nickname!='4chan') {
            if (!thqp.pn || isOP || pref.test_mode['105']) { // test
  //          if (!thqp.pn || thqp.isOP || pref.proto.popdown!=='imm') { // BUG, this requires exact extraction of country, country_name or data for images even from html.
              if (!thqp.domain) { // PATCH, use prototype of liveTag.mems.
                var tgt = thqp;
                tgt.domain = th.domain;
                if (tgt.extra_files) for (var i=0;i<tgt.extra_files.length;i++) tgt.extra_files[i].domain = th.domain;
              }
              pn = site2[th.domain_html].post_json2html(thqp, dbt[1]);
            } else pn = thqp.pn.cloneNode(true);
            cataLog.format_html.prep_anchor_links(pn, th_q[0]);
            site2[th.domain_html].format_pn(pn, thqp, null, null, th_q[0]);
            post_dotted_if_multi_anchors(pn, e, th);
          }
          pn.style = {};
          pn.style.position = 'fixed';
          set_pos(pn,e, true);
  //        pn.style.left = e.clientX + 10 + 'px';
  //        if (!pref.test_mode['25']) pn.style.top  = e.clientY -15 + 'px';
  //        else pn.style.bottom  = window.innerHeight - e.clientY + 20 + 'px';
          pn.style.zIndex = pref[cataLog.embed_mode].popup_zIndex;
          if (site.nickname!=='KC') pn.style.borderStyle = 'solid';
          pn.style.boxShadow = 'rgb(153, 153, 153) 1px 1px 1px';
          if (site.nickname==='4chan') {
            pn.classList.add('preview');
            pn.style.display = 'block';
          }
  //        if (thqp.isOP) site2[th.domain_html].popups_op_func_use(pn,th_q[0], th_q[1]);
          site2[site.nickname].popups_post_pnode(et).appendChild(pn);
  //        site2['DEFAULT'].popups_posts.set(et,pn);
  //        site2['DEFAULT'].popup_info = null;
          if (pref.debug_mode['10']) console.log('popup: '+th_q[1]+': '+site2[th.domain].popups_debug(th_q[0]));
  //        }
          adjust_pos(pn,e);
          return key? {pn:pn, key:key} : {pn:pn};
        }
        return {
          over: over,
          pop_load: pop_load,
          pop_load_req_delete, pop_load_req_delete,
        };
      })();

      var preview = (function(){
        var up_th = up_timer_factory();
        var on_th = null;
        function th_over(e){
          var pf3 = pref[cataLog.embed_mode].popup3;
          if (pf3.ww==='no' && pf3.wn==='no' && pf3.nw==='no' && pf3.nn==='no') return;
          var tgt = geh.recSearch_thread(e.target, e.currentTarget);
          if (tgt) {
            if (up_th.up_timer && up_th.src===tgt) return;
            th_out(e);
            up_th.src = tgt;
            up_th.over(pf3, e, pop_up_th, tgt);
          } else th_out(e);
        }
        function th_out(e){
          var pn_ex = up_th.out(e);
          if (pn_ex===true) return;
          var tgt = geh.recSearch_thread(e.relatedTarget,e.currentTarget);
          if (tgt) out_1_if_exists(tgt,pn_ex);
          else if (on_th) out_1_if_exists(on_th,pn_ex);
          on_th = null;
        }
        function pop_up_th(e){
  //        if (pns.has(up_th.src)) {clear_down_timer(pns.get(up_th.src)); return;}
          var name = up_th.src.name;
          var pf = pref[cataLog.embed_mode].popup3;
          var pna = pns.get(up_th.src) || [];
          if (!pref.test_mode['110']) pop_up_th_1(pf.ww, e, name, pna, 0, false, false);
          pop_up_th_1(pf.wn, e, name, pna, 1, false, true);
          pop_up_th_1(pf.nw, e, name, pna, 2, true, false);
          pop_up_th_1(pf.nn, e, name, pna, 3, true, true);
          on_th = up_th.src
          up_th.src = null;
        }
        function pop_up_th_1(kind, e, name, pna, idx, narrow_x, narrow_y){
          if (kind==='no') return;
          if (pna[idx]) {clear_down_timer(pns.get(pna[idx])); return;}
          var pn = document.createElement('div');
          pn.setAttribute('class', pref.script_prefix+'_window');
  //        pn.style.width = '200px';
  //        pn.style.height = '200px';
          pn.style.position = 'fixed';
  //        pn.style.backgroundColor = 'red';
  //        pn.innerHTML = up_th.src.getAttribute('id');
          pn.style.border = '1px solid blue';
          if (kind!=='chart') cataLog.pop_up_set_contents(pn, kind, name);
          pn.addEventListener(brwsr.mousewheel, cnst.div_scroll, false);
          set_pos(pn, e, false, narrow_x, narrow_y);
          pna[idx] = site.popup_body.appendChild(pn);
          if (pref.catalog_popup_size_fix) {
            pn.style.width  = pn.offsetWidth + 'px';
            pn.style.height = pn.offsetHeight + 'px';
          }
          if (kind==='chart') {
            if (chart_obj && pref3.stats.use) {
              var chart = new chart_obj.PostChart(pn,[name]); // must be after appendChild to draw. (just to call destroy?)
            } else pn.innerHTML = 'Statistics needs to be activated.';
          }
          var btn = document.createElement('button');
          common_func.overwrite_prop(btn.style, {position:'absolute', top:'0px', left:'0px'});
          btn.classList.add(pref.script_prefix+'_autoTp');
          btn.appendChild(site2[site.nickname].make_tack());
          pn.appendChild(btn);
          btn.onclick = function(e){
            var btn = e.currentTarget;
            var pn = btn.parentNode;
            cnst.bottom_top(pn);
            var pn2;
            var chart = pop_down(pn,true).chart;
            if (chart) {
              var tn = document.createElement('div');
              var tn_imgs = site2[common_func.name2dbt(name)[0]].parse_funcs['catalog_html'].tn_imgs({pn:cataLog.threads[name][0]});
              if (tn_imgs[0]) tn.appendChild(tn_imgs[0].cloneNode());
//              if (site.nickname==='4chan') tn.appendChild(cataLog.threads[name][0].getElementsByTagName('img')[0].cloneNode());
              else tn.innerHTML = name;
              common_func.overwrite_prop(tn.style, {position:'absolute', bottom:'0px', left:'0px', opacity:0.4});
              pn.replaceChild(tn,btn);
              pn2 = chart_obj.PostChart.call(chart, null,null,chart);
              pn2.childNodes[1].replaceChild(pn, pn2.childNodes[1].childNodes[1]);
            } else {
              pn.removeChild(btn);
              pn2 = cnst.init3({func_str:'Show:tb'}).pn;
              pn2.appendChild(pn);
            }
            pn2.style.top = parseInt(pn.style.top,10) - pn2.offsetHeight + 'px';
            pn2.style.left = pn.style.left;
            common_func.overwrite_prop(pn.style, {position:'relative', border:null, top:null, left:null});
          };
          pop_setup(up_th.src, pn, chart? {src:up_th.src, chart:chart, scroll:true, pf:pf} : {src:up_th.src, scroll:true, pf:pf}, pna);
        }
        function pf(){return pref.proto.popup3;}
        return {
          init: function(pn){
            pn.addEventListener('mouseover',th_over,false);
            pn.addEventListener('mouseleave',th_out,false);
          },
          destroy: function(pn){
            pn.removeEventListener('mouseover',th_over,false);
            pn.removeEventListener('mouseleave',th_out,false);
          },
        }
      })();
      return {
        over: over,
        leave: up0.stop,
        pop_load: posts.pop_load,
        blacklist: blacklist,
        set_pos: set_pos, // to be removed.
        href2domain: href2domain,
        init: function(pn){
          geh = site2[site.nickname].general_event_handler[site.whereami];
          if (!pref.test_mode['110'] && cataLog.embed_mode==='catalog') preview.init(pn);
        },
      };
    })(),
    popups_posts_class_hlt: 'highlighted',
//    popups_op_func_set: function(){return 1;}, // vichan
//    popups_op_func_use: function(pn,thq,no){ // vichan
//      pn.setAttribute('class',pn.getAttribute('class')+' reply');
////      pn.insertBefore(thq[no].pn.parentNode.querySelector('.files').cloneNode(true),pn.firstChild);
//    },
    popups_post_fetch: function(th, dbt){
      cataLog.scan_init('popup',[th.domain+dbt[1]+((pref.catalog.catalog_json)? 't':'')+dbt[2]], {priority:8});
    },
//    popup_info:null,
//    popups_posts: new WeakMap(),
    popups_post_pnode: function(pnode){
      if (pref.test_mode['107']) return site.popup_body;
      if (!pref.test_mode['106']) {
        var p = pnode.parentNode;
        while (p) if (p===cataLog.parent) return site.popup_body; else p = p.parentNode;
      }
      var attr;
      while (attr = pnode.getAttribute('class'), (!attr || (attr.indexOf('post')==-1 && attr.indexOf('thread')==-1)) && pnode.parentNode) pnode = pnode.parentNode;
      return pnode;
    },
    
//    popups_href2dbtp: function(href, src, th){
//      if (href[0]==='#') {
//        href = th.board+'res/'+th.no+'.html'+href;
//        src.setAttribute('href',href);
//      }
//      var hrefs = href.split('/');
//      var p = hrefs[hrefs.length-1].substr(hrefs[hrefs.length-1].indexOf('#')+1);
//      var t = hrefs[hrefs.length-1].substr(0,hrefs[hrefs.length-1].indexOf('.'));
//      var b = (hrefs.length>=3)? '/'+hrefs[hrefs.length-3]+'/' : site.board;
//      var d = this.nickname;
//      return [d,b,t,p];
//    },
    popups_href2th_q: function(href){ //,src,th){
      var dbt = this.popups_href2dbtp(href); // ,src,th);
//      var th = liveTag.mems[d][b][t];
      if (!dbt[0] || !dbt[1] || !dbt[2]) return null; // hit this line when dbt[2]==='' caused by '>>>/a/'
      var lth = liveTag.mems.init({domain:dbt[0], board:dbt[1], no:parseInt(dbt[2],10)});
      if (lth.q===undefined) lth.q = (lth.no>1000000)? Object.create(lth) : Object.create({0:undefined, 1:undefined, 2:undefined, __proto__:lth}); // PATCH before removing [0:2] // crosslink, CYCLIC REFERENCE.
//      if (!liveTag.mems[dbt[0]][dbt[1]][dbt[2]] || !liveTag.mems[dbt[0]][dbt[1]][dbt[2]].q) return null; // patch for accessibility check. 'if (!th)' doesn't work. // WHY??? // HIT THIS LINE WHEN dbt[2]===''.
      return [liveTag.mems[dbt[0]][dbt[1]][dbt[2]].q, parseInt(dbt[3],10), dbt];
    },
////    popups_add: function(posts, posts_old, th){ // working code.
////      if (!posts_old) posts_old = [];
////      var th_q0 = liveTag.mems[th.domain][th.board][th.no];
////      if (th_q0.q===undefined) th_q0.q = {};
////      var thq = th_q0.q;
////      if (posts) for (var i=0;i<posts.length;i++) Object.defineProperty(posts[i],'no',{value:th.parse_funcs.no(posts[i])});
////      if (posts && posts.length!=0) {
//////        for (var i=0;i<posts.length;i++) Object.defineProperty(posts[i],'no',{value:parseInt(posts[i].pn.getElementsByClassName('post_no')[1].textContent,10)});
//////        if (posts_old.length!=0) while (posts_old[0].no<posts[0].no) this.popups_release(posts_old.shift()); // [0] is OP
////        if (posts.length>1) while (posts_old.length>1 && posts_old[1].no<posts[1].no) this.popups_release(posts_old.splice(1,1)[0]);
////      }
////      if (posts) {
////        for (var i=0;i<posts.length;i++) {
////          var flag_old = posts_old.length!=0 && posts_old[posts_old.length-1].no>posts[i].no;
////          var tgts = [];
////          var as = posts[i].pn.getElementsByTagName('a');
////          for (var j=0;j<as.length;j++)
////            if (as[j].textContent.search(/>>[0-9]+$/)!=-1) {
////              as[j].onmouseover = this.popups_post_entry;
////              if (!flag_old) {
////                var th_q = site2[th.domain].popups_href2th_q(as[j].getAttribute('href'),as[j],th);
////                if (th_q) {
////                  tgts[tgts.length] = as[j].getAttribute('href');
////                  this.popups_grep(th_q[0],th_q[1]);
////                }
////              }
////            }
////          if (!flag_old) {
////            posts_old[posts_old.length] = (tgts.length!==0)? {no:posts[i].no, tgts:tgts, thq:thq} : {no:posts[i].no, thq:thq};
////            this.popups_grep(thq,posts[i].no);
////            this.popups_set(thq,posts[i].no,posts[i]);
////            if (i===0) thq[posts[i].no].isOP = 1;
////          }
////        }
////      } else while (posts_old.length>1) this.popups_release(posts_old.shift());
////      if (pref.debug_mode['10']) {
////        var d_str = '';
////        for (var i in thq) d_str += i+':'+((thq[i].reffered)? thq[i].reffered : thq[i])+', ';
////        console.log('popups_add :'+th.key+': '+d_str);
////      }
////      return posts_old;
////    },
////    popups_grep: function(thq, no){
////      if (thq[no]===undefined) thq[no] = 1; // waiting to be filled, but not make requests.
////      else if (typeof(thq[no])==='number') thq[no] = thq[no] + ((thq[no]<0)? -1 : 1);
////      else ++thq[no].reffered;
////    },
////    popups_set: function(thq, no, val){
////      if (typeof(thq[no])==='number') {
////        thq[no] = val;
////        thq[no].reffered = (val_old>=0)? val_old : -val_old;
////      }
////    },
////    popups_release_1: function(th_q){
////      if (th_q) {
////        if (typeof(th_q[0][th_q[1]])==='number') {
////          th_q[0][th_q[1]] -= (th_q[0][th_q[1]]<0)? -1 : 1;
////          if (th_q[0][th_q[1]]===0) delete th_q[0][th_q[1]];
////        } else if (--th_q[0][th_q[1]].reffered===0) delete th_q[0][th_q[1]];
////      }
////    },
////    popups_release: function(post){
////      if (post.tgts)
////        for (var i=0;i<post.tgts.length;i++)
////          this.popups_release_1(site2[site.nickname].popups_href2th_q(post.tgts[i])); // TEMPORAL
////      this.popups_release_1([post.thq, post.no]);
////      if (pref.debug_mode['10']) {
////        var d_str = '';
////        for (var i in thq) d_str += i+':'+((thq[i].reffered)? thq[i].reffered : thq[i])+', ';
////        console.log('popups_release :'+post.no+': '+d_str);
////       }
////    },
    popups_add: function(tgt_th16, th, deactivate){
      var posts = tgt_th16.posts;
      if (!tgt_th16.popups) tgt_th16.popups = Object.create(null);
      var popups = tgt_th16.popups;
      var lth = liveTag.mems[th.domain][th.board][th.no];
      if (lth.q===undefined) lth.q = ( th.no>1000000)? Object.create(lth) : Object.create({0:undefined, 1:undefined, 2:undefined, __proto__:lth}); // PATCH before removing [0:2] // usual, lth.q is made in popups_href2th_q if crosslink. CYCLIC REFERENCE.
      if (posts) if (th.type_data==='html') {for (var i=0;i<posts.length;i++) if (!posts[i].no) Object.defineProperty(posts[i],'no',{value:th.parse_funcs.no(posts[i])});}
//                 else for (var i=0;i<posts.length;i++) if (!posts[i].pn) posts[i].pn = this.post_json2html(posts[i],th.board);
      var posts_exist = {};
      if (posts) {
        for (var i=0;i<posts.length;i++) {
          var post_no = posts[i].no;
          posts_exist[post_no] = null;
          if (popups[post_no]===undefined) {
            this.popups_add_1(th, posts[i], deactivate, lth.q, true);
//            var quotes = [];
//            var as = posts[i].pn.getElementsByTagName('a');
//            for (var j=0;j<as.length;j++)
////              if (as[j].textContent.search(/>>[0-9]+$/)!=-1) {
//              if (as[j].textContent.search(link_regex)!=-1) {
//                if (activate) as[j].onmouseover = this.popups_post_entry;
//                var th_q = site2[th.domain].popups_href2th_q(as[j].getAttribute('href'),as[j],th);
//                var a_class = as[j].parentNode.getAttribute('class');
//                if (!a_class || a_class.indexOf(site2[th.domain_html].backlink_class)==-1) { // skip backlinks
//                  if (th_q) {
//                    quotes[quotes.length] = [th_q[0], th_q[1]];
//                    site2[th.domain_html].popups_add_backlink(th_q[0],th_q[1],th.key+'#'+post_no, th);
//                  }
//                }
//              }
//            this.popups_set(thq,post_no,posts[i],quotes);
//            if (i===0) thq[post_no].isOP = site2[th.domain_html].popups_op_func_set(posts[i].pn);
            popups[post_no] = null;
          }
        }
      }
      if (!pref.catalog.filter.kwd.posts_active) for (var i in popups) {
        if (posts_exist[i]===undefined) {
//          this.popups_release(popups[i], i, th.key); // BUG???
          this.popups_release(lth, i);
          delete popups[i];
        }
      }
//      if (posts) site2[th.domain_html].format_pn(posts[0].pn, lth.q[th.no]); // PROBABLY THIS IS REDUNDANT, BUT NOT DEBUGGED.
//      if (pref.debug_mode['10']) this.popups_debug('popups_add: '+th.no+': ', lth.q);
    },
//        var link_regex = />>[0-9]+$|>>>\/[0-z_]+\/[0-9]+$/;
//        var link_regex = />>(>\/.+\/)*[0-9]+$/;
//    popups_link_regex: />>(>\/.+\/)*[0-9]+(\s\(You\))*$/, // patch for '(You)'
    popups_link_regex: /^>>(>\/[^/]+\/)*[0-9]+/, // patch for '(You)' and '(OP)'
    popups_add_1: function(th, post, deactivate, thq, dig){
      if (!post.pn) post.pn = site2[th.domain_html].post_json2html(post,th.board);
      var as = site2[th.domain_html].post_pn2ce(post.pn).getElementsByTagName('a');
      if (as.length>0) {
        var op_regexp = new RegExp('^>>'+th.no+'(\\s|\\(|$)');
        var quotes = [];
        for (var j=0;j<as.length;j++) {
  //        if (as[j].textContent.search(/>>[0-9]+$/)!=-1) {
          var as_txt = as[j].textContent;
          if (as_txt.search(this.popups_link_regex)!=-1) {
            if (deactivate) {
              if (pref[cataLog.embed_mode].env.popup_native_kill) as[j].parentNode.replaceChild(as[j].cloneNode(true),as[j]);
              else this.popups_posts.blacklist.add(as[j]);
            }
//            if (activate) as[j].onmouseover = this.popups_post_entry;
            var th_q = site2[th.domain].popups_href2th_q(as[j].getAttribute('href')); // ,as[j],th); // this may change href, so this must be here. <- FIXED.
            if (pref[cataLog.embed_mode].link_show_op && as_txt.search(op_regexp)===0 && as_txt.indexOf('(OP)')==-1) as[j].textContent += ' (OP)';
            if (pref[cataLog.embed_mode].link_show_cross && th_q && th_q[0]!=thq) as[j].textContent += ' \u2192';
  //          var a_class = as[j].parentNode.getAttribute('class');
  //          if (!a_class || a_class.indexOf(site2[th.domain_html].backlink_class)==-1) { // skip backlinks
              if (th_q) {
                quotes[quotes.length] = [th_q[0], th_q[1]]; // quotes may be multiple.
//                quotes[quotes.length] = [thq, th_q[1]]; // quotes may be multiple.  // use 'thq' instead of 'th_q[0]' for test_mode['80'] // BUG. MUST USE th_q[0]
                var skey = th_q[2][0]!==th.domain? th.key : th_q[2][1]!==th.board? th.board+th.no : th_q[2][2]!=th.no? th.no : null;
                site2[th.domain_html].popups_add_backlink(th_q[0],th_q[1], skey!==null? skey+'#'+post.no : post.no, th, dig);
//                site2[th.domain_html].popups_add_backlink(thq,th_q[1], skey!==null? skey+'#'+post.no : post.no, th, dig);
              }
  //          }
          }
        }
      }
      this.popups_set(thq,post.no,post, quotes && quotes.length!=0 && quotes);
//      if (op) thq[post.no].isOP = site2[th.domain_html].popups_op_func_set(post.pn);
    },
    popups_add_backlink: function(thq, no, key, th, dig){
      if (thq[no]===undefined) {
        thq[no] = [key];
        if (dig) this.popups_set_waiting(thq,no);
      } else if (Array.isArray(thq[no])) {
        if (thq[no].indexOf(key)==-1) {
          thq[no][thq[no].length] = key;
          if (dig) this.popups_set_waiting(thq,no); // may not waiting because of 'dig'.
        }
      } else {
        if (!thq[no].backlinks) thq[no].backlinks = [];
        var blks = thq[no].backlinks;
        if (blks.indexOf(key)==-1) {
          blks[blks.length] = key;
          if (thq[no].pn) if (pref[cataLog.embed_mode].backlink) site2[th.domain_html].add_backlinks(thq[no].pn, blks, blks.length-1, th);
        }
      }
    },
    add_backlinks: function(pn,backlinks,target, th){ // this refers site2[domain_html]
      var bks_pn = this.add_backlinks_bks_query(pn);
      var bks = bks_pn || this.add_backlinks_bks();
      if (!target) bks.innerHTML = ''; // this hits target===0 also and clean up.
      for (var i=(target || 0);i<backlinks.length;i++) {
        this.add_backlinks_add_1(bks, this.popups_backlink2dbtpth(backlinks[i], th));
        if (target) break;
      }
      if (!bks_pn) this.add_backlinks_bks_append(pn, bks);
    },
    popups_backlink2dbtpth: function(backlink, th){
      var dbtp;
      var dbtpth = (typeof(backlink)==='number')? [th.domain, th.board, th.no, backlink, '>>'+backlink]
          : (dbtp = backlink.split(/[\/#]/),
             dbtp.length==2? [th.domain, th.board, dbtp[0], dbtp[1], '>>'+(pref.proto.bl_ec? dbtp[0]+'#':'')+dbtp[1]]
                           : [dbtp[0] || th.domain, '/'+dbtp[1]+'/', dbtp[2], dbtp[3], (dbtp[0]? '>>>>'+dbtp[0]:'>>>')+'/'+dbtp[1]+'/'+(pref.proto.bl_ec? dbtp[2]+'#':'')+dbtp[3]]);
      dbtpth[5] = site2[dbtpth[0]].link_dbtp2href_abs(dbtpth); // don't use 'this', 'this' refers site2[domain_html], not site2[domain].
      return dbtpth;
    },
    remove_backlink: function(pn,idx){}, // dummy
    popups_remove_backlink: function(thq, no, key){
      if (!thq[no]) return; // 'quotes' may be multiple, then hit this line.
      var ary = (Array.isArray(thq[no]))? thq[no] : thq[no].backlinks;
      var idx = ary.indexOf(key);
      if (idx>=0) {
        ary.splice(idx,1);
        if (thq.no===no && pref.proto.bl_rm) if (thq[no]) this.remove_backlink(thq[no].pn, idx); // remove op only for faster execution. // includes cross link
        if (ary.length===0) return true; // prevent from infinite loop by reference loop of anchors.
      }
//      else console.log('ERROR in handling popups ' + no+', '+key+', '+thq[no].backlinks); // quotes allows multiple, but backlink doesn't, deletion of a post which has multiple links to a post hits this line.
//      if (ary.length===0 && thq[no].remove_if_no_backlinks) delete thq[no];
//      if (pref.debug_mode['10']) console.log('popups_remove_backlink: '+(idx>=0?'suc':'fail')+', '+no+'<-'+key+':    '+this.popups_debug(thq));
//      if (ary.length===0) return true;
    },
    popups_set: function(thq, no, val, quotes){
      if (no<=2) if (!Object.hasOwnProperty.call(thq,no)) thq[no] = undefined; // PATCH before renaming, now thq has prototype, [0][1] or [2] returns tags or watch.
      if (thq[no]===undefined) {
        thq[no] = val;
        if (thq[no].backlinks) thq[no].backlinks = undefined; // PATCH FOR MEGUCA, meguca has backlinks in native.
      } else if (Array.isArray(thq[no])) {
        val.backlinks = thq[no];
        thq[no] = val;
      } else { // for multiple entry at editing===true, update thq[no].
        if (thq[no].backlinks) val.backlinks = thq[no].backlinks;
        thq[no] = val;
      }
      if (quotes) thq[no].quotes = quotes;
      if (val.editing) this.popups_set_waiting(thq,no); // keep updating while editing by 'popups_fetched'
      this.popups_remove_waiting(thq,no);
    },
    popups_release: function(lth, no){ // in-place, on-demand ver.
      var quotes = [];
      var i=0;
      if (pref.debug_mode['12']) var initial_cond = {no:no, lth:lth, len:Object.keys(lth.q).length};
      prep_quotes(lth, no);
      while (--i>=0) {
        var tgt = quotes[i];
        lth = tgt[0];
        no  = tgt[1];
        if (tgt.length==4) {
          var q = tgt[2];
          var p = tgt[3];
          var skey = q.domain!==lth.domain? lth.key : q.board!==lth.board? lth.board+lth.no : q.no!=lth.no? lth.no : null;
          if (this.popups_remove_backlink(q, p, skey!==null? skey+'#'+no : parseInt(no,10))) { // only true if removed successfully, this prevents infinite loop by reference loop.
            this.popups_remove_waiting(q,p);
            prep_quotes(Object.getPrototypeOf(q), p);// emulates recursive call // overwrite for in-place
          }
        } else {
          if (lth.no!=no && lth.q && lth.q[no])
            if (!lth.q[no].backlinks || lth.q[no].backlinks.length===0) delete lth.q[no];
//            else if (lth.q[no].quote) lth.q[no].quote = null; // nullyf for strict accordance, but redundant.
//          if (pref.debug_mode['10']) console.log('popups_release: '+no+':    '+this.popups_debug(lth.q));
        }
      }
      if (pref.debug_mode['12']) console.log('popups_release: '+initial_cond.lth.key+': '+Object.keys(initial_cond.lth.q).length+' <- '+initial_cond.len+', '+initial_cond.no+
                                             ((pref.debug_mode['10'])? '    '+this.popups_debug(lth.q):''));
      function prep_quotes(lth, no){
        quotes[i++] = [lth, no];
        var qts = lth.q && lth.q[no] && lth.q[no].quotes; // lth may refer archived thread, which never have loaded.
        if (qts) for (var j=qts.length-1;j>=0;j--) quotes[i++] = [lth, no, qts[j][0], qts[j][1]];
      }
    },
//    popups_release: function(lth, no){ // working code. loop ver.
//      var quotes = format_quotes(lth, no, lth.q[no].quotes);
//      while (quotes.length>0) {
//        var tgt = quotes.shift();
//        lth = tgt[0];
//        no  = tgt[1];
//        if (tgt.length==4) {
//          var q = tgt[2];
//          var p = tgt[3];
//          var skey = q.domain!==lth.domain? lth.key : q.board!==lth.board? lth.board+lth.no : q.no!=lth.no? lth.no : null;
//          if (this.popups_remove_backlink(q, p, skey? skey+'#'+no : parseInt(no,10))) {
//            this.popups_remove_waiting(q,p);
//            var lth_next = Object.getPrototypeOf(q);
//            quotes = format_quotes(lth_next, p, lth_next.q[p].quotes).concat(quotes); // emulates recursive call
//            lth_next.q[p].quotes = null; // prevent from infinite loop by reference loop of anchors.
//          }
//        } else {
//          if (lth.no!=no && (!lth.q[no].backlinks || lth.q[no].backlinks.length===0)) delete lth.q[no];
//          if (pref.debug_mode['10']) console.log('popups_release: '+no+':    '+this.popups_debug(lth.q));
//        }
//      }
//      function format_quotes(lth,no, quotes){
//        return (quotes)? quotes.map(function(v){return [lth, no].concat(v);}).concat([[lth, no]]) : [[lth, no]];
//      }
//    },
////    popups_release_list: [], // DOESN'T WORK, leaves must be removed first, or lost reference and get too complicated procedures.
////    popups_release_recursive: function(){ // avoid recursive calls
////      while (this.popups_release_list.length>0) {
////        var tgt = this.popups_release_list.pop();
////        this.popups_release(tgt[0], tgt[1], tgt[2]);
////      }
////    },
//    popups_release: function(lth, no){ // working code // , thq_no_in){
//      var thq = lth.q;
//      var thq_no = thq[no]; //  || thq_no_in;
//      if (thq_no.quotes)
//        for (var i=0;i<thq_no.quotes.length;i++) {
//          var q = thq_no.quotes[i][0];
//          var p = thq_no.quotes[i][1];
//          var skey = q.domain!==lth.domain? lth.key : q.board!==lth.board? lth.board+lth.no : q.no!=lth.no? lth.no : null;
//          if (this.popups_remove_backlink(q, p, skey? skey+'#'+no : parseInt(no,10))) {
//            this.popups_remove_waiting(q,p);
////            this.popups_release_list.push([Object.getPrototypeOf(q), p, q[p]]); // DOESN'T WORK
//            try { 
//              this.popups_release(Object.getPrototypeOf(q), p); // RECURSIVE CALLS MAY CAUSE STACKOVERFLOW.
//            } catch(e){
//              setTimeout(this.popups_release.bind(this,Object.getPrototypeOf(q), p),0);
//            }
//          }
//        }
//      if (lth.no!=no && (!thq_no.backlinks || thq_no.backlinks.length===0)) delete thq[no];
////      else thq_no.remove_if_no_backlinks = 1;
//      if (pref.debug_mode['10']) console.log('popups_release: '+no+':    '+this.popups_debug(lth.q));
////      if (!thq_no_in && this.popups_release_list.length>0) this.popups_release_recursive();
//    },
    popups_set_waiting: function(thq,no){
      if (!thq.waiting) thq.waiting = [no];
      else {
        var i=0;
        while (i<thq.waiting.length && thq.waiting[i]<no) i++;
        if (thq.waiting[i]!=no) thq.waiting.splice(i,0,no);
      }
    },
    popups_remove_waiting: function(thq,no){
      if (!thq.waiting) return;
      var idx = thq.waiting.indexOf(no);
      if (idx!=-1) {
        thq.waiting.splice(idx,1);
        if (thq.waiting.length===0) delete thq.waiting;
      }
    },
    popups_fetched: function(th, lth, start){ // 'if (lth.q && lth.q.waiting)' is checked by caller.
      if (!start) start = 0;
      var j=th.posts.length-1;
      for (var i=lth.q.waiting.length-1;i>=0;i--) {
        var no = lth.q.waiting[i];
        while (j>start && no<th.posts[j].no) j--;
        if (no===th.posts[j].no) this.popups_fetched_1(th, lth, no, th.posts[j]);
        else if (th.type_source==='thread') {
          if (pref.test_mode['64']) this.popups_set(lth.q, no, {time: 0, com:'DELETED'});
          else this.popups_set(lth.q, no, {time: 0, com:'DELETED'}); // referring deleted posts should be here.
        } // else if (j===start) break;
        this.popups_posts.pop_load(th.key+'#'+th.posts[j].no, th.domain);
//        if (this.popup_info && this.popup_info.key===th.key+'#'+th.posts[j].no) this.popups_posts.pop_make({target:this.popup_info.node, __proto__:this.popup_info}, th.domain);
      }
    },
    popups_fetched_1: function(th, lth, no, post){
//      post.parse_funcs = th.parse_funcs; // redundant???  // CAUSED A BUG, parse_funcs are archived and stop its prototype chain.
      if (th.type_data==='html') this.popups_fetched_html(post, th); // wrap_to_parse.post and prepare_html_extract_params should be used, but not debugged, left this.
      site2[th.domain].wrap_to_parse.posts({posts:[post], __proto__:th});
      cataLog.format_html.prepare_html_post(th, post);
      this.popups_add_1(th, post, false, lth.q, false); // cut quote link.
//      this.popups_set(lth.q, no, post); // BUG, this doesn't update quotes, this will be appear in multiple popup mode, use popups_add_1.
//                                               // In single popup mode, this cut quote links and reduce memory consumption.
////      this.popups_set(lth.q, i, (th.type_data==='json')? post : this.popups_fetched_html(post, th)); // BUG, this deletes quote.
    },
    popups_try_fetch_from_lth_ta: function(lth, no, th){
      if (lth.ta) for (var i=lth.ta.posts.length-1;i>=0;i--) if (lth.ta.posts[i].no==no) {
        var post = lth.ta.posts[i];
        var th = {domain_html: th.domain_html, lth:lth, type_data:post.type_data || (post.pn? 'html':'json'), posts:[post], __proto__:lth};
        this.popups_fetched_1(th, lth, no, post);
        return;
      }
    },

    popups_fetched_html: function(post, th){ // PATCH, WILL BE REMOVED.
//      if (th.domain!==site.nickname && pref.catalog.mimic_base_site && th.domain_html!==site.nickname) {
//        var post_new = common_func.shallow_copy_1(post); // MAY COLLIDE???

//        site2[th.domain].wrap_to_parse_posts(th); // TEMPORAL
        var proto_obj = {domain:th.domain, board:th.board, domain_html:th.domain_html, parse_funcs:th.parse_funcs};
        if (post.extra_files) for (var j=0;j<post.extra_files.length;j++) for (var k in proto_obj) post.extra_files[j][k] = proto_obj[k];
        for (var k in proto_obj) post[k] = proto_obj[k];

//        if (th.parse_funcs.posts_full) th.parse_funcs.posts_full(th);
        if (post.parse_funcs.filename) post.filename = post.parse_funcs.filename(post);
//        if (th.parse_funcs.prep_mimic) th.parse_funcs.prep_mimic(th);

        var dummy = post.time; // invoke getter
        dummy = post.sub;
        dummy = post.com;
        dummy = post.name;
        dummy = post.no;
        dummy = post.op_img_url;
        post.type_data = th.type_data;
//      }
      return post;
    },
    backlink: function(pn,thq_no, th){
      var backlinks = (thq_no)? ((Array.isArray(thq_no))? thq_no : thq_no.backlinks) : null;
      if (backlinks) this.add_backlinks(pn,backlinks, undefined, th);
    },

    popups_debug: function(thq){
      if (!thq) return '';
      var keys = Object.keys(thq);
      var d_str = keys.length+', '+thq.key+': ';
      for (var j=0;j<keys.length;j++) {
        var i = keys[j];
        d_str += i+':'+((Array.isArray(thq[i]))? thq[i] : (thq[i].backlinks || thq[i].remove_if_no_backlinks || 'P'))+', ';
      }
      return d_str;
    },
    toplevel_anchor_pos:1,
    toplevel_anchor: function(pn, th){
      var as = pn.getElementsByTagName('a');
      var pos = this.toplevel_anchor_pos;
      var dbtp = [th.domain, th.board, th.no, null];
      for (var i=0;i<as.length;i++) {
        var href = as[i].getAttribute('href');
        if (href && href[0]==='#') {
          dbtp[3] = href.substr(pos);
          as[i].setAttribute('href',this.link_dbtp2href(dbtp));
        }
      }
    },

    wrap_to_parse: (function(){
      var th_regexp = /[A-z]/;
//      var parse_objs = {};
      var key_table = { // to reduce memory consumption.
        catalog: 'c',
        page:    'i',
        thread:  't',
        post:    'p',
        shortCatalog: 'b',
        shortThread:  's',
        html:    'h',
        json:    'j',
      };
      function get_getters(){
//        if (pref.test_mode['6']) return site4.parse_funcs_no_cache; // no cache parse to reduce memory consumption.
//        if (pref.test_mode['6']) return site4.parse_funcs_one_time; // one time parse for faster execution.
        return (pref.debug_mode.parse_error)? site4.parse_funcs_on_demand_debug : site4.parse_funcs_on_demand;
//        var obj = (pref.debug_mode.parse_error)? site4.parse_funcs_on_demand_debug : site4.parse_funcs_on_demand;
//        if (pref.test_mode['1'] && parse_funcs){ // test of static getters '&& parse_funcs' is a patch for test. // required to change 'get_getters(parse_funcs){'
//          var obj2 = {};
//          var props = ['no', 'key', 'time_bumped', 'nof_posts', 'nof_files', 'time_created', 'posts', 'sub', 'name', 'com', 'flag', 'flags', 'footer', 'sticky', 'pn', 'time', 'time_posted', 'txt']; // ['op_img_url'] // op_img_url is wrapped at localArhicve mode dynamically.
//          for (var i=0;i<props.length;i++)
//            Object.defineProperty(obj2,props[i],typeof(parse_funcs[props[i]]==='function')? {get:parse_funcs[props[i]], enumerable:true, configurable:true}
//                                                                                          : {value:parse_funcs[props[i]], enumerable:true, configurable:true}); // not writable
//          var time_tu_func = parse_funcs.time_unit===1?    function(){return this.time;}
//                           : parse_funcs.time_unit===1000? function(){return this.time * 1000;}
//                           :                               function(){return this.time * parse_funcs.time_unit;};
//          Object.defineProperty(obj2,'time_tu', {get:time_tu_func, enumerable:true, configurable:true});
//          obj2.__proto__ = obj;
//          return obj2;
//        }
//        return obj;
      }
      function prep_pfunc(domain, board, type){
//        var key = domain+board+type +'/'+pref.test_mode['6']+pref.debug_mode.parse_error;
//        var key = domain+board+type;
//        var parse_obj = parse_objs[key];
        var type_source = type.substr(0,type.indexOf('_'));
        var type_data   = type.substr(type.indexOf('_')+1);
        var key = key_table[type_source] + key_table[type_data] + ((pref.debug_mode.parse_error)? '_debug':'');
        var pfunc = liveTag.mems.init({domain:domain, board:board}).p[key];
        if (!pfunc) {
          var pfunc_root = liveTag.mems[domain].p;
          var pfunc = pfunc_root[key];
          if (!pfunc) {
            var proto = site2[domain].parse_funcs[type+'_template'] || get_getters();
            var domain_html = (pref.catalog.mimic_base_site || site2[domain].mimic_always)? site.nickname : domain;
            pfunc_root[key] = {domain: domain,
                       parse_funcs: site2[domain].parse_funcs[type],
                       parse_funcs_html: site2[domain_html].parse_funcs[type_source+'_html'],
                       type_parse: type,
                       type_source: type_source,
                       type_data: type_data,
                       type_html: type_source,
                       domain_html: domain_html,
//                       thread: null, // for faster execution.
//                       page_no: null,
//                       __proto__:site4.parse_funcs_on_demand
                       __proto__:proto
                              };
            pfunc = pfunc_root[key];
////            var template = site2[domain].parse_funcs[type+'_template'];
////            if (template) {
////////              var keys = Object.keys(template);
////////              for (var i=0;i<keys.length;i++) Object.defineProperty(pfunc, keys[i], {value:template[keys[i]], enumerable:true, configurable:true, writable:true});
//////              for (var i in template) Object.defineProperty(pfunc, i, {value:template[i], enumerable:true, configurable:true, writable:true}); // search in prototype, overwrite getters
////              for (var i in template) // search in prototype, overwrite getters
////                if (typeof(template[i])==='function') Object.defineProperty(pfunc, i, {get:template[i], enumerable:true, configurable:true});
////                else Object.defineProperty(pfunc, i, {value:template[i], enumerable:true, configurable:true, writable:true});
////            }
          }
          liveTag.mems[domain][board].p[key] = {
            board: board,
            __proto__: pfunc
          };
          pfunc = liveTag.mems[domain][board].p[key];
        }
        return pfunc;
      }
      return {
        get_getters: get_getters,
        get: function(doc_obj, domain, board, type, options){
          var parse_obj = prep_pfunc(domain, board, type);
          if (options) {
            if (options.thread!==undefined && th_regexp.test(options.thread)) options.thread = options.thread.substr(1);
            options.__proto__ = parse_obj;
            parse_obj = options;
          }
//          if (options) {  // working code.
//            if (options.thread) parse_obj.thread = (th_regexp.test(options.thread))? options.thread.substr(1): options.thread;
//            if (options.page) parse_obj.page = options.page;
//          }
          return (type.indexOf('_json')==-1)? site2[domain].parse_funcs[type].ths({pn:doc_obj, __proto__:parse_obj}) :
                                              site2[domain].parse_funcs[type].ths(doc_obj, parse_obj);
        },
////        clean: function(boards){
////          var keys = Object.keys(parse_objs);
////          for (var i=0;i<keys.length;i++) {
////            var key_split = keys[i].split('/');
////            if (boards[key_split[0]+key_split[1]]===undefined) parse_objs[keys[i]] = null;
////          }
////        }
        posts: function(th, start, proto_options){
          if (th.type_data===undefined) {
            var arr = [];
            if (th.posts) for (var i=0;i<th.posts.length;i++) if (!th.posts[i].domain && th.posts.pn) arr[arr.length] = th.posts[i];
            if (arr.length!=0) this.posts({type_data:'html', posts:arr, __proto__:th}, 0, common_func.shallow_copy_1(proto_options));
            th = {type_data:'json', __proto__:th};
          }
          var proto_obj = prep_pfunc(th.domain, th.board, 'post_'+th.type_data);
          if (proto_options) {
            proto_options.__proto__ = proto_obj;
            proto_obj = proto_options;
          }
          var localArchive = th.localArchive;
          if (localArchive) proto_obj = {localArchive:localArchive, __proto__:proto_obj};
//          var proto_obj = {domain:th.domain, board:th.board, domain_html:th.domain_html, parse_funcs:th.parse_funcs};
          if (th.posts) for (var i=start||0;i<th.posts.length;i++) {
            if (!th.posts[i].domain || localArchive) {
              if (th.posts[i].extra_files) for (var j=0;j<th.posts[i].extra_files.length;j++)
                if (!th.posts[i].extra_files.domain) th.posts[i].extra_files[j].__proto__ = proto_obj;
              th.posts[i].__proto__ = proto_obj;
            }
          }
          if (th.extra_files) if (!th.extra_files[0].domain || localArchive) for (var j=0;j<th.extra_files.length;j++) th.extra_files[j].__proto__ = proto_obj;
////      if (th.posts) for (var i=0;i<th.posts.length;i++) {
////        if (th.posts[i].extra_files) for (var j=0;j<th.posts[i].extra_files.length;j++) th.posts[i].extra_files[j].__proto__ = th.__proto__;
////        th.posts[i].__proto__ = th.__proto__;
////      }
////      if (th.extra_files) for (var j=0;j<th.extra_files.length;j++) th.extra_files[j].__proto__ = th.__proto__;
        },
      }
    })(),
    parse_pn_dummy: document.createElement('div'),
    parse_funcs: { // DEFAULT
      'common': {
////        entry : function(dtpo,req) { // doc, thread, post, object // working code.
////          for (var i=0;i<req.length;i++) {
////            if (req[i]===':ITER') {
////              if (req[i+1]===':ALL') for (var j=0;j<dtpo[req[i+2]].length;j++) this.exe_sub(dtpo,req,i,j);
////              else if (req[i+1]===':FL') {
////                this.exe_sub(dtpo,req,i,0);
////                this.exe_sub(dtpo,req,i,dtpo[req[i+2]].length-1);
////              } else if (req[i+1]===':FLx' || req[i+1]===':GFLx' || req[i+1]===':GALL') {
////                var j = dtpo[req[i+2]].length - pref[cataLog.embed_mode].t2h_num_of_posts;
////                if (j<1 || req[i+1]===':GALL') j=1;
////                if (req[i+1]===':FLx') {
////                  this.exe_sub(dtpo,req,i,0);
////                  while (j<dtpo[req[i+2]].length) this.exe_sub(dtpo,req,i,j++);
////                } else {
////  //                dtpo[req[i+3][0]] = [];
////                  Object.defineProperty(dtpo,req[i+3][0], {value:[], enumerable:true, configurable:true, writable:true});
////                  dtpo[req[i+3][0]].push(dtpo[req[i+2]][0][req[i+3][1]]);
////                  while (j<dtpo[req[i+2]].length) dtpo[req[i+3][0]].push(dtpo[req[i+2]][j++][req[i+3][1]]);
////                  for (var j=dtpo[req[i+3][0]].length-1;j>=0;j--) if (!dtpo[req[i+3][0]][j]) dtpo[req[i+3][0]].splice(j,1);
////                }
////              }
////              i += 3;
////  //          } else dtpo[req[i]] = this[req[i]](dtpo,req);
////            } else Object.defineProperty(dtpo,req[i], {value:this[req[i]](dtpo,req), enumerable:true, configurable:true, writable:true});
////          }
////        },
////        exe_sub : function(dtpo,req,i,j) {
////          dtpo[req[i+2]][j].domain = dtpo.domain;
////          dtpo[req[i+2]][j].board  = dtpo.board;
////          this.entry(dtpo[req[i+2]][j],req[i+3]);
////        },
        finisher : function(){return;},
        posts: function(){return undefined;},
        com: function(){return undefined;},
        flags: function(){return undefined;},
        flag: function(){return undefined;},
//        op_img_url: function() {return undefined;},
//        preventDefault:function(e){e.preventDefault();},
        th_init: null,
//        th_destroy: null,
        tn_as: function(th){return th.pn.getElementsByTagName('a');},
        tn_imgs: function(th){
          var imgs = [];
//          for (var i=0;i<as.length;i++) imgs[i] = as[i].getElementsByTagName('img')[0];
          var as = th.pn.getElementsByTagName('a');
          for (var i=0;i<as.length;i++) {
            var tmp = as[i].getElementsByTagName('img')[0];
            if (tmp) imgs[imgs.length] = tmp;
          }
          return imgs;
        },
        key: function(th){return th.domain + th.board + th.no;},
        pn: function(th){return site2[th.domain_html].catalog_json2html3(th,th.board, this.op_img_url(th));},
        op_img_url: function(th) {return site2[th.domain].catalog_json2html3_thumbnail(th, th.board);},
        get_op_src: function(th) {return th.op_img_url;},
        ths_array: function(doc,ths_col){
          var ths = [];
          if (ths_col)
            for (var i=ths_col.length-1;i>=0;i--) {
              var page = (doc.type_html==='catalog')? Math.floor(i/15)+'.'+i%15
                                                    : (doc.type_html==='page')? doc.page + '.' + i : undefined; // page_html
              ths[i] = {
                pn: ths_col[i],
                page: page,
                __proto__: doc.__proto__};
            }
          return ths;
        },
        time: function(th){return undefined;},
        time_posted : function(th){return undefined;},
        time_unit: 1,
        has_posts: true,
//        last_replies: function(th){return th.posts.slice(1);},
////        post_no: function(post){return post.no;},
        txt: function(th){
          site2['DEFAULT'].parse_pn_dummy.innerHTML = th.com;
          return site2['DEFAULT'].parse_pn_dummy[brwsr.innerText];
        },
        type_com: 'html',
        footer_clear: function(th){},
//        adopt_pn: function(th){
////          for (var i=0;i<th.posts.length;i++) Object.defineProperty(th.posts[i], 'pn', {value:document.adoptNode(th.posts[i].pn), enumerable:true, configurable:true, writable:true});
//          Object.defineProperty(th, 'pn', {value:document.adoptNode(th.pn), enumerable:true, configurable:true, writable:true});
//        },
        get_lth_from_node: function(pn){
          while (pn && !pn.name) pn = pn.parentNode;
          return pn && liveTag.mems.getFromName(pn.name) || null;
        },
//        txt2com: function(txt){return txt;},
      },    
      'catalog_html': {
        posts: function(th){return [{sub:th.sub, com:th.com, name:th.name, pn:th.pn}];},
        time: function(th){return th.time_created;},
        posts_full: (function(){
          var exlist = {posts:null, pn:null, flag:null, flags:null, footer:null, pn_name:null, ths:null, page:null,
                        tn_as:null, tn_imgs:null, txt:null,
                        parse_funcs:null, parse_funcs_html:null, type_parse:null, type_source:null, type_data:null, type_html:null,
                        domain:null, board:null, domain_html:null, exe_sub:null, exe_sub2:null};
          return function(th){
//            for (var prop in th) if (exlist[prop]===undefined) th.posts[0][prop] = th[prop]; // invoke getters.
            for (var prop in th) if (exlist[prop]===undefined)
              if (th.parse_funcs[prop]) Object.defineProperty(th.posts[0], prop, {value:th[prop], enumerable:true, configurable:true, writable:true}); // invoke getters to cut reference to pn(whole html), and also set th[prop].
          };
        })(),
        has_posts: false,
        type_com: 'txt',
        filename: function(th){
          var fname = th.op_img_url.replace(/.*\//,'');
          var idx = fname.indexOf('.');
          th.tim = fname.substr(0,idx);
//          th.ext = fname.substr(  idx);
          return th.tim;
        },
      },
      'catalog_json': {
        ths: function(obj, parse_obj) {
          var ths = [];
          for (var i=0;i<obj.length;i++)
            if (obj[i].threads) for (var j=0;j<obj[i].threads.length;j++) {
              obj[i].threads[j].page = i + '.' + j;
              obj[i].threads[j].sticky = obj[i].threads[j].sticky===1; // overwrite property of the same name before setting prototype to use polarity.
              obj[i].threads[j].type_html = 'catalog';
              obj[i].threads[j].__proto__ = parse_obj;
              ths[ths.length] = obj[i].threads[j];
            }
          return ths;
        },
//        posts: function(th){return [{sub:th.sub, com:th.com, name:th.name, trip:th.trip, pn:th.pn, time:th.time_created}];}, // time for post_json2html
//        posts: function(th){return [{sub:th.sub, com:th.com, name:th.name, time:th.time}];}, // this is used at scan, so the lighter is the best. 'time' is only for 'check_reply' and 'stats'. And this removes prototype chain to reduce memory consumption instead of using '[{__proto__:th}]'.
        posts: function(th){return [{time:th.time, DUMMY:true}];}, // 'time' is for 'check_reply' and 'stats'. And this removes prototype chain to reduce memory consumption instead of using '[{__proto__:th}]'.
        posts_full: function(th){
//          th.posts[0] = {}; // BUG NEVER DO THIS. posts_full is called AFTER SETTING PROTOTYPE in wrap_to_parse.posts in format_html.prepafe_html_prep_posts
            delete th.posts[0].DUMMY;
////          th.posts[0].no = th.no; // works
////          th.posts[0].time = th.time;
          var keys = Object.keys(th);
//          var exlist = ['obj','posts'];
//          for (var i=0;i<keys.length;i++) if (exlist.indexOf(prop)==-1) th.posts[0][keys[i]] = th[keys[i]]; // remove props in prototype chain. // will be this.
          for (var i=0;i<keys.length;i++) if (keys[i]!=='posts' && keys[i]!=='pn') th.posts[0][keys[i]] = th[keys[i]]; // remove props in prototype chain.
        },
        has_posts: false,
      },
//      'catalog_html': {
//        ths_array: function(doc,ths_col){ // working code.
//          var ths = [];
//          if (ths_col)
////            if (site.nickname!==doc.domain) site2[doc.domain].absolute_link(doc.pn, doc.board);
//            for (var i=ths_col.length-1;i>=0;i--) {
//              var page = Math.floor(i/15)+'.'+i%15;
//              ths[i] = {
//                pn: ths_col[i],
//                type_html: 'catalog_html',
////                page: Math.floor(i/15)+'.'+i%15, // cause warning of 'Object literal with complex property' in V8.
//                page: page,
//                __proto__: doc.__proto__};
//            }
//          return ths;
//        },
//      },
      'page_html': {
//        ths_array: function(doc,ths_col){ // working code.
//          var ths = [];
//          if (ths_col)
////            if (site.nickname!==doc.domain) site2[doc.domain].absolute_link(doc.pn, doc.board);
//            for (var i=ths_col.length-1;i>=0;i--) {
//              var page = (doc.page!=='?')? doc.page + '.' + i : doc.page;
//              ths[i] = {
//                pn: ths_col[i],
//                type_html: 'page_html',
////                page: (doc.page!=='?')? doc.page + '.' + i : doc.page, // cause warning of 'Object literal with complex property' in V8.
//                page: page,
//                __proto__: doc.__proto__};
//            }
//          return ths;
//        },
        posts_array: function(th,posts){ // working code.
          var pts = [];
//          var proto_kwd = 'post_' + th.type_data; // working code, WILL BE THIS.
//          var proto = (site2[th.domain].parse_funcs.hasOwnProperty(proto_kwd))? site2[th.domain].parse_funcs[proto_kwd] : th.__proto__; 
          var proto = th.__proto__; 
if (!pref.test_mode['5']) { // faster, because object creation is light,,,orz,,,
          for (var i=0;i<posts.length;i++) pts[pts.length] = {pn:posts[i], __proto__:proto};
} else {
          pts.pns = posts;
          pts.idx0 = 0;
          pts.idx1 = posts.length-1;
          pts.get0 = this.posts_get0;
          pts.get1 = this.posts_get1;
          pts.proto = proto;
//          var pts = {pn:posts, idx0:0, idx1:posts.length-1, length:posts.length, __proto__:proto};
          Object.defineProperty(pts, pts.idx0, {get: pts.get0, enumerable:true, configurable:true});
          Object.defineProperty(pts, pts.idx1, {get: pts.get1, enumerable:true, configurable:true});
}
          return pts;
        },
        posts_get0: function(){
//console.log('get0: '+this.idx0);
          var val = {pn:this.pns[this.idx0],  __proto__:this.proto}; // this.__proto__ reffers Array, doesn't work.
          Object.defineProperty(this, this.idx0, {value: val, enumerable:true, configurable:true, writable:true});
          if (++this.idx0<this.idx1) Object.defineProperty(this, this.idx0, {get: this.get0, enumerable:true, configurable:true});
          return val;
        },
        posts_get1: function(){
//console.log('get1: '+this.idx1);
//console.log('this.pns: ');
//console.log(this.pns);
          var val = {pn:this.pns[this.idx1],  __proto__:this.proto};
          Object.defineProperty(this, this.idx1, {value: val, enumerable:true, configurable:true, writable:true});
          if (--this.idx1>this.idx0) Object.defineProperty(this, this.idx1, {get: this.get1, enumerable:true, configurable:true});
          return val;
        },
//        posts_array: function(th,posts){ // working code.
//          var pts = [];
//          for (var i=0;i<posts.length;i++) pts[pts.length] = {pn:posts[i], __proto__:th.__proto__};
//          return pts;
//        },
        posts: function(th){return this.posts_array(th, th.pn.getElementsByClassName('post'));},
////////        posts_pn: function(th){return th.pn.getElementsByClassName('post');},
        time_posted: 'thread_html',
        time_bumped: function(th){ // TO BE FIXED.
          return th.posts[th.posts.length-1].time;
        },
        time_created: function(th){return th.posts[0].time;},
        key: function(th){return th.domain + th.board + th.no;},
        insert_footer4: function(ref){
          var footer = document.createElement('div');
          return ref.parentNode.insertBefore(footer,ref);
        },
        flags: function(th){ // for on demand access.
          var flags = [];
          var i = th.posts.length -1;
          var n = pref[cataLog.embed_mode].t2h_num_of_posts -1;
          if (i<n) { // POSTS MUST BE ACCESSED FROM HEAD OR TAIL.
            n=0;
            while (n<=i) {
//console.log('up: '+n+', '+i);
              if (th.posts[n]) flags[n] = th.posts[n].flag; // 8chan doesn't show 5 posts all the time.
              n++;
            }
          } else {
            while (n>=0) {
//console.log('down: '+n+', '+i);
//console.log(th.posts[i]);
              if (th.posts[i]) flags[n--] = th.posts[i--].flag;
              if (n==0) i=0;
            }
          }
          return flags;
        },
////        flags: function(th){ // for on demand access. // worked code, but post was changed to had to be accessed from top or end.
////          var flags = [];
////          var i = th.posts.length - pref.catalog_t2h_num_of_posts;
////          if (i<1) i=1;
////          if (th.posts.length!=0) flags[0] = th.posts[0].flag;
////          while (i<th.posts.length) {
////            if (th.posts[i]) flags[i] = th.posts[i].flag;
////            i++;
////          }
////          return flags;
////        },
        html_org: function(th){return th.pn.innerHTML;},
        sticky: function(){return false;},
////        pop_post_prep: function(th){ // working code.
////          th.children = th.pn.childNodes;
////          th.idx_pop = th.pn.childNodes.length-1;
////        },
        type_com: 'txt',
        replace_omitted_info : function(dst, src){dst.textContent = src.textContent;},
        replace_omitted_info2: 'replace_omitted_info',
        posts_full: 'catalog_html',
        get_max_page: function(doc){
          var pns = doc.getElementsByClassName('pages')[0];
          if (!pns) return;
          pns = pns.childNodes;
          var max = 0;
          for (var i=0;i<pns.length;i++) if (max+1 == pns[i].textContent) max++; // == used intentionally.
          return max;
        },
      },
      'page_json': {
        ths: function(obj, parse_obj){
          var ths = [];
          if (obj && obj.threads) for (var i=0;i<obj.threads.length;i++) { // patch for 8chan
//          for (var i=0;i<obj.threads.length;i++) {
            var tgt = obj.threads[i];
            if (tgt) { // patch for 8chan
              tgt.page = (parse_obj.page)? parse_obj.page + '.' + i : undefined;
              tgt.key = parse_obj.domain + parse_obj.board + tgt.posts[0].no;
              tgt.posts[0].__proto__ = parse_obj;
              tgt.__proto__ = tgt.posts[0];
              ths[i] = tgt;
            }
////            if (tgt) { // patch for 8chan // working code.
////              ths[i] = {obj: tgt, // buffered, because if obj is used, change of obj's contents will affect to this program directly.
////                        posts: tgt.posts, ext: tgt.posts[0].ext, tim:tgt.posts[0].tim,
////                        time: tgt.posts[0].time, // for 'check_reply.check_t1_op'
////                        key: parse_obj.domain + parse_obj.board + tgt.posts[0].no, no: tgt.posts[0].no,
////                        page: (parse_obj.page)? parse_obj.page + '.' + i : undefined,
////                        __proto__:parse_obj};
////            }
////            tgt.posts = null; // cut the reference, if leave this, cutting th.posts.length in 'update_posts_replace_prep' doesn't affect to tgt.posts and tgt.posts keep containing all posts.
          }
          return ths;
        },
        flags: function(th){
          if (!th.country) return undefined;
          var n = th.posts.length - pref[cataLog.embed_mode].t2h_num_of_posts;
          return [th].concat(th.posts.slice((n<=1)? 1 : n)); // patch for 4chan:catalog_html, it isn't formed as catalog_json, posts[0] doesn't contain full information.
//          return (n<=1)? th.posts.slice() : [th.posts[0]].concat(th.posts.slice(n));
        },
      },
      'thread_html'  : {
        ths_array: function(doc, ths_col){
          return [{pn:ths_col,
//                   type_html: 'thread_html',
//                   page: '?',
                   __proto__: doc.__proto__}];
        },
        time_posted : function(th){return th.posts[th.posts.length-1].time;},
        posts_full: 'catalog_html',
        type_com: 'txt',
      },
      'thread_json'  : {
        ths: function(obj, parse_obj){
          obj.key = parse_obj.domain + parse_obj.board + obj.posts[0].no;
          obj.posts[0].__proto__ = parse_obj;
          obj.__proto__ = obj.posts[0];
          return [obj];
        },
//        ths: function(obj, parse_obj){return site2['DEFAULT'].parse_funcs.page_json.ths({threads:[obj]}, parse_obj);}, // working code.
////        ths: function(obj, parse_obj){
////          return [{obj:obj, posts: obj.posts, ext: obj.posts[0].ext, tim:obj.posts[0].tim,
////                   key: parse_obj.domain + parse_obj.board + parse_obj.thread, no: parse_obj.thread, __proto__:parse_obj}];
////        },

////        pop_post_prep: function(obj){ // working code.
////          obj.idx_pop = obj.posts.length-1;
////        },
////        pop_post: function(obj){
////          if (obj.idx_pop>=0) {
////            obj.post = obj.posts[obj.idx_pop--];
//////            obj.post.parse_funcs = this;
//////            obj.post.__proto__ = obj.__proto__;
////            obj.post.time *= 1000; // DESTRUCTIVE
////            return true;
////          } else return false;
////        },
////        preprocess: function(obj){ // working code, but deleted.
////          if (!obj.preprocessed) {
////            obj.preprocessed = true;
////            for (var i=obj.posts.length-1;i>=0;i--) obj.posts[i].time *= 1000;
////          }
////        },
////        time_created : function(obj){return obj.posts[0].time;}, // preprocessed
////        time_bumped : function(obj){return obj.posts[obj.posts.length-1].time;}, // preprocessed
        time_created : function(obj){return obj.posts[0].time*1000;},
        time_bumped : function(obj){
          var i = obj.posts.length-1;
          while (i>0 && obj.posts[i].email && obj.posts[i].email==='sage') i--;
          return obj.posts[i].time*1000;
        },
        time_posted : function(obj){return obj.posts[obj.posts.length-1].time*1000;},
        nof_posts: function(obj){return obj.posts[0].replies+1;},
        nof_files: function(obj){return obj.posts[0].images+1;},
        has_nof_files: true,
        sub: function(obj){return (obj.posts[0].sub || '');},
        name: function(obj){return (obj.posts[0].name || '');},
        com: function(obj){return (obj.posts[0].com || '');},
        sticky: function(obj){return obj.posts[0].sticky===1;},
        time_unit: 1000,
        prep_to_archive: function(obj){return {posts:obj};},
        rip_from_archive: function(obj){return obj.posts || obj;}, // patch for dual acceptance, internal and external format.
//        proto: 'page_json'
      },
      'post_html': {
        sub: function(post){
          var sub = post.pn.getElementsByClassName('subject')[0];
          return (sub)? sub.textContent : '';
        },
        img2src: function(img){return img.parentNode.href;},
        img2ext: function(img){return img.parentNode.getAttribute('data-ext');},
      },
      'post_json': {
        time_unit: 1000,
        pn: function(post){return site2[post.domain_html].post_json2html(post,post.board);}, // blocked by template
        anchor: function(){},
      },
      'catalog_json_template': 'post_json_template',
      'page_json_template': 'post_json_template',
      'thread_json_template': 'post_json_template',
      'post_json_template': {
        sub: '',
        name: 'Anonymous',
        com: '',
        sticky: undefined,
        pn: undefined, // block getter
        no: undefined, // patch
        time: undefined, // patch
      },
    },
//    parse_funcs : function(dtp,req) { // doc, thread, post, use .call() to call with 'this'.
//      for (var i=0;i<req.length;i++) {
//        if (this[req[i]]) dtp[req[i]] = this[req[i]](dtp,req);
//        if (req[i]==='ths') i++;
//      }
//    },
    parse_parts:{
      add_op_img_url: function(posts,board,domain){
         for (var i=0;i<posts.length;i++)
          posts[i].op_img_url = site2[domain].catalog_json2html3_thumbnail(posts[i], board);
      },
    },
////    update_posts_replace: function(th,th_old,pnode) { // working code.
////      if (th_old.posts) {
////        th_old.posts[0].pn.innerHTML = th.posts[0].pn.innerHTML;
////        for (var i=th_old.posts.length-1;i>=1;i--) this.update_posts_remove(th_old,i,pnode);
////      }
////      th_old.posts = [th_old.posts[0]];
////      this.update_posts_add(th,th_old,pnode);
////    },
    update_posts_merge_prep: function(posts, posts_m, num, by_no) { // merge posts by time
      if (posts) {
        num = (num>=0)? num+1 : ((posts_m && posts_m.length)? posts_m.length : 0) + posts.length;
        if (num<posts.length) posts = posts.slice(0,1).concat(posts.slice(posts.length - num + 1)); // cut
        var i=1;
        var j=0;
        var posts_ret = [posts[0]];
        if (by_no) // by no.
          while (i<posts.length && j<posts_m.length) {
            if (posts[i].no === posts_m[j].no) {posts_ret[posts_ret.length] = posts[i++]; j++; continue;}
            posts_ret[posts_ret.length] = (posts[i].no < posts_m[j].no)? posts[i++] : posts_m[j++];
          }
        else
          while (i<posts.length && j<posts_m.length)
            posts_ret[posts_ret.length] = (posts[i].time * posts[i].parse_funcs.time_unit < posts_m[j].time * posts_m[j].parse_funcs.time_unit)? posts[i++] : posts_m[j++];;
        posts_ret = posts_ret.concat((i<posts.length)? posts.slice(i) : posts_m.slice(j));
        return (posts_ret.length<=num)? posts_ret :
                                        posts_ret.slice(0,1).concat(posts_ret.slice(posts_ret.length-num+1,posts_ret.length));
      }
    },
    update_posts_merge_bases: {
      bases: {},
      initialized: false,
      query: function(th, tgt, isShown){
        var key = th.key;
        if (this.bases[key]) return this.bases[key];
        var base = (tgt)? this.bases[tgt] : null;
        if (base) {
//        for (var i=0;i<tgts.length;i++) if (this.bases[tgts[i]]) {
//          var base = this.bases[tgts[i]];
          this.bases[key] = base;
          this.merge_th(th, base);
          if (isShown) cataLog.catalog_obj2.func_hide_org(key);
//          th.pn.setAttribute('style','display:none'); // TEMPORAL PATCH.
          cataLog.threads[key][0] = base.pn;
          return base;
        }
        this.bases[key] = this.base_factory(th, isShown);
        if (!this.initialized) this.setup_hook();
        return this.bases[key];
      },
      base_factory: (function(){
        var base_proto = {
          lazy_draw: function(idx){
            if (idx>=this.lazy.length) this.lazy[idx] = true; // all are not initialized.
            else this.lazy.splice(idx,0,true);
            if (this.lazy_idx>idx) this.lazy_idx = idx;
//            cataLog.show_catalog_cont();
          },
          remove: function(idx){
            this.posts.splice(idx,1);
            if (idx<this.lazy_idx) this.lazy_idx--;
            return (this.lazy)? !this.lazy.splice(idx,1)[0] : true;
          },
          draw_1_pos: function(idx){ // this.lazy_idx may refer "true" node by this.
            var n=idx+1;
            while (n<this.lazy.length && this.lazy[n]) n++; // skip myself also
            this.lazy[idx] = false;
            return n;
          },
          get_class: function(key, force, old) {
            if (!force && !pref.proto.merge_lv) return null;
            var lv = pref_func.merge_obj5a_sc(key,old? pref3.proto.merge_lv_obj2_old : pref3.proto.merge_lv_obj2, null);
//            var lv = (key===site.nickname+site.board+site.no)? 0 : 1; // test
            return (lv===null)? null : pref.script_prefix+'_merge'+lv;
          },
        };
        return function(th, isShown){
          site2['DEFAULT'].update_posts_merge_bases.class_add_all(th.posts, base_proto.get_class(th.key));
          return {
            pn: th.pn, // site2[th.domain].page_json2html3({domain:th.domain, board:th.board, no:0}, '/ALL_MERGED/', null, true),
            posts: th.posts.slice(),
            isShown: 1, // (isShown)? 1 : 0, // num of participants
            lazy: (pref[cataLog.embed_mode].lazyDraw.merge)? th.posts.map(function(){return false;}) : null,
            lazy_idx: (pref[cataLog.embed_mode].lazyDraw.merge)? th.posts.length : null,
            __proto__:base_proto
          };
        }
      })(),
      class_add_all: function(posts, merge_class){
        if (!merge_class) return;
        for (var i=0;i<posts.length;i++) if (posts[i].pn && posts[i].pn.parentNode) posts[i].pn.parentNode.classList.add(merge_class);
      },
      class_remove_all: function(posts, merge_class){
        if (!merge_class) return;
        for (var i=0;i<posts.length;i++) if (posts[i].pn && posts[i].pn.parentNode) posts[i].pn.parentNode.classList.remove(merge_class);
      },
      lazy_draw: null,
      remove_th: function(th, remove){
        var merge = this.bases[th.key];
        if (merge) {
//          var dbt = common_func.name2dbt(th.key);
//          if (!cataLog.threads[th.key][16].th) cataLog.threads[th.key][16].th = {domain:dbt[0], board:dbt[1], no:dbt[2], posts:th.posts.slice(), __proto__:cataLog.threads[th.key][16]}; // test patch, but these funcs are NOT reentrant.
//          var posts = (!remove)? th.posts.slice() : null;
//          var k = 0;
//          for (var i=th.posts.length-1;i>=0;i--) k = site2[th.domain_html].update_posts_remove_1(th, i, merge.pn, merge.isShown, merge, k);
          var pnode = (!remove)? site2[th.domain_html].page_json2html3_skelton(th) : null;
          site2[th.domain_html].update_posts_separate(th, merge, pnode);
          if (--this.bases[th.key].isShown==0) {
            cataLog.catalog_obj2.func_hide_org(th.key);
            this.shown.delete(merge);
            cataLog.catalog_obj2.lazy_tgts.delete(merge);
          }
          delete this.bases[th.key];
          if (!remove) cataLog.threads[th.key][0] = pnode;
//          if (!remove) {
//            var dbt = common_func.name2dbt(th.key);
//            var pnode = site2[th.domain_html].page_json2html3_skelton({no:dbt[2]});
//            for (var i=0;i<posts.length;i++) site2[th.domain_html].update_posts_insert(posts,th.posts,i,i,pnode,false); // th.posts is NOT updated.
//            th.posts = posts;
//            site2[th.domain_html].page_json2html3_add_omitted_info({posts:th.posts, __proto__:liveTag.mems.getFromName(th.key)},th.posts,th.posts); // th.nof_xxx are required.
////            site2[th.domain_html].page_json2html3_add_omitted_info(th,th.posts,th.posts); // th.nof_xxx are required.
//            cataLog.threads[th.key][0] = pnode;
//          }
        }
      },
      merge_th: function(th, merge){
        var k=0;
        for (var i=0;i<th.posts.length;i++) {
//          cataLog.format_html.prepare_html_post(th, merge.posts[i]); // NEED TO CHECK CAPABILITY OF REENTRY.
          k = site2[th.domain_html].update_posts_merge_1(th, merge, i, k);
        }
        this.bases[th.key].isShown++;
        if (merge.lazy && merge.lazy_idx<merge.posts.length) this.lazy_tgts.set(merge,th.key); // patch for merge_first. slightly redundant.
      },
      base_arr: function(name, old){
        return pref_func.merge_obj5a_sc(name, old? pref3.proto.merge_list_obj2_old : pref3.proto.merge_list_obj2, null);
      },
      base_tgts: function(name){
        if (pref[cataLog.embed_mode].merge) return Object.keys(this.bases)[0] || name;
        else if (pref[cataLog.embed_mode].merge_list) {
          var ref = this.base_arr(name);
          if (!ref) return null;
          for (var key in this.bases) if (this.base_arr(key)===ref) return key;
          return name;
        } else return null;
      },
      func_show: function(name,ref, with_hr){ // this refers catalog_obj2
        var mb = site2['DEFAULT'].update_posts_merge_bases;
        var base = mb.bases[name];
        if (!base) {
          var tgts = mb.base_tgts(name);
          if (tgts) {
            var tgt_th = cataLog.threads[name];
            base = mb.query({pn:tgt_th[0], __proto__:tgt_th[16]}, tgts, false);
          }
        }
//        var base = (pref[cataLog.embed_mode].merge)? mb.query({pn:tgt_th[0], __proto__:tgt_th[16]}, 'ALL', false) : mb.bases[name];
        if (base) {
//          if (base.isShown!=0) cataLog.catalog_obj2.func_hide_org(name);
//          if (base.isShown==0) base.isShown++;
          if (!mb.shown.has(base)) cataLog.catalog_obj2.func_show_org(name,ref, with_hr);
          return true;
        } else return this.func_show_org(name,ref, with_hr);
      },
      func_hide: function(name){ // this refers catalog_obj2
        var mb = site2['DEFAULT'].update_posts_merge_bases;
        if (mb.bases[name]) {
          mb.remove_th(cataLog.threads[name][16]);
          return true;
        } else return this.func_hide_org(name);
      },
      func_search_ref: function(key){ // this refers catalog_obj2
        var mb = site2['DEFAULT'].update_posts_merge_bases;
        return mb.bases[key] && mb.shown.get(mb.bases[key])!==key;
      },
      func_track_shown: function(name, update_drawn_y){ // this refers catalog_obj2
        var mb = site2['DEFAULT'].update_posts_merge_bases;
        var base = mb.bases[name];
        if (base) {
          if (!mb.shown.has(base)) {
//          var pn = base.pn;
//          if (!mb.shown.has(pn) || mb.shown.get(pn)===name) { // ===name for reentry.
            this.func_track_shown_org(name, !pref[cataLog.embed_mode].merge && update_drawn_y);
            mb.shown.set(base, name);
          }
          if (base.lazy && base.lazy_idx<base.posts.length) this.lazy_tgts.set(base,name);
          if (pref[cataLog.embed_mode].merge && update_drawn_y) 
            var step = (pref.test_mode['88'])? 1 : pref[cataLog.embed_mode].lazyDraw.merge_step;
            if (++this.post_count%step==0) this.drawn_y = cataLog.threads[name][16].posts[0].pn.offsetTop;
        } else this.func_track_shown_org(name, update_drawn_y);
      },
      shown: new Map(), // base -> name of first shown pair for search_ref
      shownSet: null,
      isShownForTails: function(name){
        if (!this.shownSet) {
          this.shownSet = new Set();
          for (var name of this.shown.values()) this.shownSet.add(this.base_arr(name));
        }
        return this.shownSet.has(this.base_arr(name));
      },
      func_track_reset: function(){ // this refers catalog_obj2
        var mb = site2['DEFAULT'].update_posts_merge_bases;
        mb.shown.clear();
        mb.shownSet = null;
        this.post_count = 0;
        this.lazy_tgts.clear();
        this.func_track_reset_org();
      },
      setup_hook: function(){
        cataLog.catalog_obj2.func_show_org = cataLog.catalog_obj2.func_show;
        cataLog.catalog_obj2.func_show     = this.func_show;
        cataLog.catalog_obj2.func_hide_org = cataLog.catalog_obj2.func_hide;
        cataLog.catalog_obj2.func_hide     = this.func_hide;
        cataLog.catalog_obj2.func_track_shown_org = cataLog.catalog_obj2.func_track_shown;
        cataLog.catalog_obj2.func_track_shown     = this.func_track_shown;
        cataLog.catalog_obj2.func_track_reset_org = cataLog.catalog_obj2.func_track_reset;
        cataLog.catalog_obj2.func_track_reset     = this.func_track_reset;
        cataLog.catalog_obj2.func_search_ref = cataLog.catalog_obj2.func_search_ref;
        cataLog.catalog_obj2.post_count = 0;
        var lazy_tgts = new Map();
        cataLog.catalog_obj2.lazy_tgts = lazy_tgts;
        this.lazy_tgts = lazy_tgts;
//        cataLog.catalog_obj2.lazy_draw = function(name){ // this refers catalog_obj2
//          var mb = site2['DEFAULT'].update_posts_merge_bases;
//          var merge = mb.bases[name];
//          if (!merge || !merge.lazy || merge.lazy_idx>=merge.posts.length) lazy_tgts.set(merge,name);
//        };
        this.initialized = true;
        cataLog.catalog_obj2.lazy_draw = function(){
          var ref_height = cataLog.get_ref_height(4);
          for (var merge of lazy_tgts.keys()) {
            var i = merge.lazy_idx;
            if (i>=1 && merge.posts[i-1].pn.offsetTop>ref_height) break;
            var j = 0;
            var step = (pref.test_mode['88'])? 1 : pref[cataLog.embed_mode].lazyDraw.merge_step;
            var th_domain_html = (pref.catalog.mimic_base_site)? site.nickname : cataLog.threads[lazy_tgts.get(merge)][16].domain_html;
            while (i<merge.posts.length) {
              if (merge.lazy[i]) {
                if (j<i) j=i+1;
                while (j<merge.lazy.length && merge.lazy[j]) j++;
                site2[th_domain_html].update_posts_insert(merge.posts,merge.posts,i,j,merge.pn);
                merge.lazy[i] = false;
                var merge_class = merge.get_class(merge.posts[i].key_op);
                if (merge_class) merge.posts[i].pn.parentNode.classList.add(merge_class);
              }
              if (!pref.test_mode['111']) if (++cataLog.catalog_obj2.post_count%step==0 && merge.posts[i].pn.offsetTop>ref_height) break; // slow.
              i++;
            }
            merge.lazy_idx = i;
            if (i>=merge.posts.length) lazy_tgts.delete(merge);
          }
        };
      },
      release_hook: function(){},
      onchange_merge: function(e){
        var mb = site2['DEFAULT'].update_posts_merge_bases;
        var et_name1 = (e.target.name || e.target.getAttribute('name')).split('.')[1];
        if (et_name1==='merge_list_str' && !pref[cataLog.embed_mode].merge_list) return;
        var check_tgts = (et_name1==='merge')? function(){return true;}
        : (et_name1==='merge_list')? function(name){return mb.base_arr(name) || mb.base_arr(name,true);}
                       : function(name){
                           var now = mb.base_arr(name);
                           var old = mb.base_arr(name,true);
                           return (now)? (!old || now.join()!==old.join()) : old;};
        for (var name in cataLog.threads) {
          var tgt_th = cataLog.threads[name];
          if (tgt_th[1] && check_tgts(name))
            if (cataLog.catalog_obj2.func_hide(name)) tgt_th[1] = false;
        }
        pref3.proto.merge_list_obj2_old = null;
        cataLog.catalog_obj2.func_track_reset();
        if (!mb.initialized) mb.setup_hook();
        if (et_name1==='merge') {
          if (pref[cataLog.embed_mode].merge) pref3.catalog.indexing_old = pref.catalog.indexing;
          cataLog.components.catalog.indexing.onfocus();
          pref.catalog.indexing = (pref[cataLog.embed_mode].merge)? 7 : pref3.catalog.indexing_old; // 7:/creation
          pref_func.apply_prep(cataLog.components.catalog.indexing,false,true); // call show_catalog();
          cataLog.components.catalog.indexing.onblur();
          cataLog.components.catalog.indexing.disabled = pref[cataLog.embed_mode].merge;
        } else cataLog.show_catalog();
      },
      onchange_lv: function(e){
        if (!pref[cataLog.embed_mode].merge && !pref[cataLog.embed_mode].merge_list) return;
        var et_name = (e.target.name || e.target.getAttribute('name')).split('.')[1];
        if (et_name==='merge_lv_str' && !pref[cataLog.embed_mode].merge_lv) return;
        var mb = site2['DEFAULT'].update_posts_merge_bases;
        for (var name in cataLog.threads) {
          if (!cataLog.threads[name][1]) continue;
          var base = mb.bases[name];
          if (!base) continue;
          var now = base.get_class(name);
          var old = base.get_class(name,true,true);
          if (et_name==='merge_lv' || now!=old) {
            var posts = cataLog.threads[name][16].posts;
            if (et_name!=='merge_lv' || !pref[cataLog.embed_mode].merge_lv) mb.class_remove_all(posts,old);
            if (et_name!=='merge_lv' ||  pref[cataLog.embed_mode].merge_lv) mb.class_add_all(posts,now);
          }
        }
        pref3.proto.merge_lv_obj2_old = null;
      },
    },
////////    update_posts_merge_base: null,
    update_posts_replace_prep: function(posts,posts_old,num) { // concate posts by no. existence of posts_old was checked in caller.
      if (!posts || posts.length<=1) return (num<0 || posts_old.length<=num+1)? posts_old : posts_old.slice(0,1).concat(posts_old.slice(-num));
      num = (num>=0)? num+1 : posts_old.length + posts.length -1;
      if (num==posts.length) return posts;
      if (num< posts.length) return posts.slice(0,1).concat(posts.slice(posts.length - num + 1)); // cut
      var first_no = posts[1].no;
      var i=1;
      while (i<posts_old.length && posts_old[i].no<first_no) i++;
      if (i===1) return posts;
      var start = (i>num-posts.length)? i-(num-posts.length) : 1;
      return posts.slice(0,1).concat(posts_old.slice(start,i),posts.slice(1));
    },
    update_posts0_class: function(pn,search_result) {
      if (search_result) pn.classList.remove('CatChan_search_miss');
      else               pn.classList.add('CatChan_search_miss');
    },
    update_posts_replace: function(th,th_old,pnode,merge,show, posts_used) {
      if (merge) {
        pnode = merge.pn;
        show  = merge.isShown;
      }
      if (th_old.posts) {
        var info_old = th_old.parse_funcs_html.get_omitted_info(th_old.posts[0]); // (th_old.posts[0].pn)? : null; // for lazy_draw in merge, but this is patched in 'update_posts_merge_1'.
        var info_new = (th.posts[0].pn)? th.parse_funcs_html.get_omitted_info(th.posts[0]) : site2[th.domain_html].page_json2html3_add_omitted_info(th,null,th.posts);
        if (info_old) {
//          if (info_new) th_old.parse_funcs_html.replace_omitted_info(info_old, info_new);
//          else info_old.parentNode.removeChild(info_old);
          th_old.parse_funcs_html.replace_omitted_info2(info_old, info_new, th); // REDUNDANT when check new replies at initial in page view.
        } else if (info_new) th_old.parse_funcs_html.set_omitted_info(th_old.posts[0], info_new);
////        var nos = {}; // working code.
////        for (var i=1;i<th.posts.length;i++) nos[th.posts[i].no] = null;
////        for (var i=th_old.posts.length-1;i>=1;i--) 
////          if (nos[th_old.posts[i].no]===undefined) {
////            this.update_posts_remove(th_old,i,pnode);
////            th_old.posts.splice(i,1);
////          }
        var k = -1;
        var j = th.posts.length-1;
//        var scroll_back = 0;
//        var now_height = (scroll_lock)? brwsr.document_body.scrollTop : 0; // WILL BE CHANGED TO get_now_height for multi inscance
        var editings = null;
        for (var i=th_old.posts.length-1;i>=1;i--) {
          while (j>1 && th.posts[j].no>th_old.posts[i].no) j--;
          var editing = th_old.posts[i].editing && th_old.posts[i].pn && th_old.posts[i]!==th.posts[j]; // meguca returns old data sometime since they uses cache.
          // Meguca uses caches of 30 seconds, so it returns old data sometime, and last posts aren't contained in old data sometimes.
          // CatChan takes this as a situation of "the posts was removed", so deleted_posts are fluctuate,
          // and th.posts may contain shallow copies of th_old.posts because deleted_posts are merged with live posts.
          // So, "insert-remove" method causes an error when the post is a shallow copy of an old post beacuse th.posts[j].pn.parentNode will be null.
          if (th.posts[j].no!=th_old.posts[i].no || editing) k = this.update_posts_remove_1(th_old, i, pnode, show, merge, k);
          if (editing) if (editings) editings[editings.length] = th.posts[j]; else editings = [th.posts[j]];
//          else if (th_old.posts[i].editing && (th_old.posts[i].pn) && th_old.posts[i]!==th.posts[j]) { // meguca returns old data sometime since they uses cache.
////          } else if (th_old.posts[i].editing && (!merge || show) && (th_old.posts[i].pn)) {
//            var thq = liveTag.mems[th.domain][th.board][th.no].q;
//            cataLog.format_html.prepare_html_post(th, th.posts[j]);
//            this.popups_add_1(th, th.posts[j], false, thq, j===0, true);
//            if (pref[cataLog.embed_mode].backlink) if (thq[th.posts[j].no].backlinks) site2[th.domain_html].add_backlinks(th.posts[j].pn,thq[th.posts[j].no].backlinks, undefined, th);
//            th_old.posts[i].pn.parentNode.insertBefore(th.posts[j].pn,th_old.posts[i].pn);
//            th_old.posts[i].pn.parentNode.removeChild(th_old.posts[i].pn);
//            th_old.posts[i] = th.posts[j];
//            posts_used[posts_used.length] = th.posts[j];
//          }
        }
//        if (scroll_back) window.scrollTo(0,now_height + scroll_back);
      }
      this.update_posts_add(th,th_old,pnode,merge,show, posts_used, editings);
    },
    update_posts_add: function(th,th_old,pnode,merge,show, posts_used, editings) {
      if (th_old.posts && th.posts) {
        var thq = liveTag.mems[th.domain][th.board][th.no].q;
        var time_unit = (merge)? th.parse_funcs.time_unit : 1; // (merge)? for safety.
//        var first_no = th_old.posts[1].no; // working, but not verified enough.
//        if (th.posts[1].no<first_no) {
//          var end=1;
//          while (end+1<th.posts.length && th.posts[end+1].no<first_no) end++;
//          var i=end;
//          while (i>=1) {
//            this.update_posts_1(th,th_old,pnode,merge, i, 1, time_unit, thq); // inset before
//            th_old.posts.splice(1,0,th.posts[i--]);
//          }
//          if (merge && show) this.update_posts_insert_merge(th.posts.splice(0,end+1),1);
//        }
//        var th_old_posts_length = th_old.posts.length;
//        for (var i=th_old_posts_length;i<th.posts.length;i++) {
//          this.update_posts_1(th,th_old,pnode,merge, i, th_old.posts.length, time_unit, thq); // th_old.posts.length is live count, always add to end. // add after
//          th_old.posts[th_old.posts.length] = th.posts[i];
//        }
//        if (th.posts.length>1 && merge && show) this.update_posts_insert_merge(th.posts,th_old_posts_length);

        var k = -1;
        var j=(merge)? 0 : 1; // for filter output, random insert.
        for (var i=(merge)? 0 : 1;i<th.posts.length;i++) {
          while (j<th_old.posts.length && th.posts[i].no>th_old.posts[j].no) j++;
          if (j>=th_old.posts.length || th.posts[i].no!=th_old.posts[j].no) {
            var editing = editings && editings.indexOf(th.posts[i])!=-1;
            var thq = editing? liveTag.mems[th.domain][th.board][th.no].q : null; // must be here?
            cataLog.format_html.prepare_html_post(th, th.posts[i]);
            if (editing) {
              this.popups_add_1(th, th.posts[i], false, thq, true);
              if (pref[cataLog.embed_mode].backlink) if (thq[th.posts[i].no].backlinks) site2[th.domain_html].add_backlinks(th.posts[i].pn,thq[th.posts[i].no].backlinks, undefined, th);
            }
            if (!merge) this.update_posts_insert(th.posts,th_old.posts,i,j,pnode); // th_old.posts.length is live count, always add to end.
            else k = this.update_posts_merge_1(th, merge, i, k);
//            this.update_posts_1(th,th_old,pnode,merge, i, j, time_unit, thq); // th_old.posts.length is live count.
            if (j<th_old.posts.length) th_old.posts.splice(j,0,th.posts[i]); // live array
            else th_old.posts[th_old.posts.length] = th.posts[i];
            posts_used[posts_used.length] = th.posts[i];
          }
          if (j<th_old.posts.length) j++;
        }
//        if (th.posts.length>1 && merge && show) this.update_posts_insert_merge(th.posts,0, th_old.posts[0].pn);
      }
    },
    update_posts_remove_1: function(th_old, i, pnode, isShown, merge, k){
      var post = th_old.posts[i];
      if (isShown) if (pref[cataLog.embed_mode].scroll_lock) cataLog.show_catalog_scroll_lock.modified(post);
      if (!merge) {
        if (post.pn) this.update_posts_remove(th_old,i,pnode); // MAY CAUSE A BUG. post.pn may not have the same lifetime as th.pn
      } else {
        k = (k==-1)? merge.posts.indexOf(post) // for faster search
                   : merge.posts.lastIndexOf(post, k);
        if (k==-1) k = merge.posts.lastIndexOf(post); // 4chan sometimes returns out-of-order posts.
        if (k>=0) if (merge.remove(k)) this.update_posts_remove(th_old,i,pnode);
      }
//      scroll_back += this.update_posts_remove(th_old,i,pnode,now_height); // SLOW.
      th_old.posts.splice(i,1);
      return k;
    },
    update_posts_merge_1: function(th, merge, i, k){
      var ref_time = th.posts[i].time_tu;
      if (k==-1) k = merge.posts.length-1;
      while (k>0 && merge.posts[k].time_tu>=ref_time) k--; // for faster search // 4chan sometimes returns out-of-order posts.
      while (k<merge.posts.length && (merge.posts[k].time_tu <ref_time || 
                                      merge.posts[k].time_tu==ref_time && merge.posts[k].no<=th.posts[i].no)) k++;
      if (merge.lazy) merge.lazy_draw(k);
      if (!merge.lazy || (!pref.test_mode['89'] && i==0)) {
        this.update_posts_insert(th.posts,merge.posts,i,merge.lazy? merge.draw_1_pos(k)-1:k, merge.pn); // th_old.posts.length is live count, always add to end if !merge.lazy.
        var merge_class = merge.get_class(th.key);
        if (merge_class) th.posts[i].pn.parentNode.classList.add(merge_class);
      }
//      if (i==0) th.posts[0].isOP = true;
//      if (merge.lazy) merge.lazy_draw(k);
//      else this.update_posts_insert(th.posts,merge.posts,i,k,merge.pn); // th_old.posts.length is live count, always add to end.
//      if (!pref.test_mode['89'] && merge.lazy && i==0) // required, sometimes OP has omitted_info outside of the OP. 
//        if (pref[cataLog.embed_mode].merge) this.update_posts_insert(th.posts,merge.posts,i,merge.draw_1_pos(k)-1,merge.pn);
////        if (pref.test_mode['89']) this.update_posts_insert(th.posts,merge.posts,i,merge.draw_1_pos(k)-1,merge.pn,merge); // i!=0 for ommited info, which doesn't expect lazy drawing. -1 of dst[j] is because dst isn't updated yet.
//        else th.posts[0].isOP = true;
      if (k<merge.posts.length) merge.posts.splice(k,0,th.posts[i]); // live array
      else merge.posts[merge.posts.length] = th.posts[i];
      return k;
    },
    update_posts_separate: function(th, merge, pn_sep){
      var merge_class = merge.get_class(th.key, true);
      var k=0;
      for (var i=0;i<th.posts.length;i++) {
        var post = th.posts[i];
        k = merge.posts.indexOf(post, k);
        if (k==-1) k = merge.posts.indexOf(post); // 4chan sometimes returns out-of-order posts.
        var exist = (k!=-1)? merge.remove(k) : false;
        if (merge.isShown) if (pref[cataLog.embed_mode].scroll_lock) cataLog.show_catalog_scroll_lock.modified(post);
        if (merge_class && post.pn.parentNode) post.pn.parentNode.classList.remove(merge_class);
        if (pn_sep) this.update_posts_insert(th.posts,[],i,i,pn_sep);
        else if (exist) this.update_posts_remove(th,i,merge.pn);
      }
    },
//    update_posts_1: function(th,th_old,pnode,merge, tgt, pos, time_unit, thq) { // working code.
//      if (!merge) this.update_posts_insert(th.posts,th_old.posts,tgt,pos,pnode,merge); // th_old.posts.length is live count, always add to end.
////      this.format_pn(th.posts[tgt].pn, th_old.q[th.posts[tgt].no]); // WILL BE THIS.
////      if (time_unit!==1) th.posts[tgt].time *= time_unit; // BUG!!!, THIS DOESN'T ALLOW MULTIPLE ENTRY, CAN'T BE USED FOR POSTS SEARCH.
//    },
////    update_posts_add: function(th,th_old,pnode,merge,show) { // working code.
////      if (th_old.posts && th.posts) {
////        var thq = liveTag.mems[th.domain][th.board][th.no].q;
////        var last_no = th_old.posts[th_old.posts.length-1].no;
////        if (th.posts[th.posts.length-1].no==last_no || th.posts.length<=1) return;
////        //        var i=1;
////        //        while (i<th.posts.length && th.posts[i].no<=last_no) i++;
////        var i=th.posts.length;
////        while (i>1 && th.posts[i-1].no>last_no) i--;
////        if (i>1) th.posts.splice(1,i-1);
////        if (pref[cataLog.embed_mode].t2h_num_of_posts>=0 && th.posts.length > pref[cataLog.embed_mode].t2h_num_of_posts+1) {
////          th.posts.splice(1,th.posts.length - pref[cataLog.embed_mode].t2h_num_of_posts -1);
////          this.page_json2html3_add_omitted_info(th, th_old.posts, th.posts);
////        }
////        var time_unit = (merge)? th.parse_funcs.time_unit : 1; // (merge)? for safety.
////        for (var i=1;i<th.posts.length;i++) {
////          if (!merge) this.update_posts_insert(th.posts,th_old.posts,i,th_old.posts.length,pnode,merge); // th_old.posts.length is live count, always add to end.
////            this.format_pn(th.posts[i].pn, (thq)? thq[th.posts[i].no] : null);
////          //          this.format_pn(th.posts[i].pn, th_old.q[th.posts[i].no]); // WILL BE THIS.
////          if (time_unit!==1) th.posts[i].time *= time_unit;
////          th_old.posts[th_old.posts.length] = th.posts[i];
////        }
////        if (th.posts.length>1 && merge && show) this.update_posts_insert_merge(th.posts,1);
////      }
////    },
////////    update_posts_insert_merge: function(src,start, src0_pn) { // working code, but very slow because of based on HTML.
////////      if (pref[cataLog.embed_mode].scroll_lock) cataLog.show_catalog_scroll_lock.set();
////////      var i,j;
////////      var myself = this.update_posts_prep_merge();
////////      var dst = myself.posts;
////////      var pnode = myself.pn;
////////      src = src.slice();
////////      src[0].pn = src0_pn; // patch for posts search
////////      for (var i=src.length-1;i>=0;i--) // sort by timestamp only, so if there is, that is already sorted.
////////        if (src[i].pn) {
////////          var tgt = src[i].pn.parentNode;
////////          while (tgt) {
////////            if (tgt===pnode) {src.splice(i,1);break;} // if other sorting scheme is needed, change this to 'update_posts_remove'
////////            else tgt = tgt.parentNode;
////////          }
////////        }
////////      if (src.length===0) return;
////////      if (start===0) {
////////        i = start;
////////        j = 0;
////////        var step = dst.length & 0x7ffffff0;
////////        while (i<src.length) {
////////          if (step>1) while (j+step<dst.length && (dst[j+step].time_tu<src[i].time_tu || dst[j+step].time_tu==src[i].time_tu && dst[j+step].no<=src[i].no)) j += step+1;
////////          while (j<dst.length && (dst[j].time_tu<src[i].time_tu || dst[j].time_tu==src[i].time_tu && dst[j].no<=src[i].no)) j++;
////////          if (j<dst.length) site2[site.nickname].update_posts_insert(src, dst, i++, j, pnode);
////////          else { // can't refer nodes after inserted one.
////////            var k = src.length-1;
////////            site2[site.nickname].update_posts_insert(src, dst, k--, j, pnode);
////////            while (k>=i) {
////////              site2[site.nickname].update_posts_insert(src, src, k, k+1, pnode); // can't refer nodes after inserted one.
////////              k--;
////////            }
////////            break;
////////          }
////////        }
////////      } else {
////////        i = src.length-1;
////////        j = dst.length;
////////        while (i>=start) {
////////          while (j>0 && (dst[j-1].time_tu>src[i].time_tu || dst[j-1].time_tu==src[i].time_tu && dst[j-1].no>src[i].no)) j--;
////////          site2[site.nickname].update_posts_insert(src, dst, i--, j, pnode);
////////          while (i>=start && !(j>0 && (dst[j-1].time_tu>src[i].time_tu || dst[j-1].time_tu==src[i].time_tu && dst[j-1].no>src[i].no))) { // dst is NOT updated. It's an object, not a live list.
////////            site2[site.nickname].update_posts_insert(src, src, i, i+1, pnode);
////////            i--;
////////          }
////////        }
////////      }
////////    },
////////    update_posts_prep_merge: function() {
////////      return (cataLog.embed_mode==='thread')? this.wrap_to_parse.get(document, site.nickname, site.board, 'thread_html', {thread:site.no})[0] :
////////                                              this.wrap_to_parse.get(document, site.nickname, site.board, 'page_html', {page:0})[0];
////////    },
////    update_posts_add: function(th,th_old,pnode) { // working code.
////      if (th_old.posts && th.posts) {
////        var thq = liveTag.mems[th.domain][th.board][th.no].q;
////        for (var i=1;i<th.posts.length;i++) {
////          if (th.posts[i].no>th_old.posts[th_old.posts.length-1].no) {
////            this.update_posts_insert(th,th_old,i,pnode);
////            this.format_pn(th.posts[i].pn, (thq)? thq[th.posts[i].no] : null);
//////            this.format_pn(th.posts[i].pn, th_old.q[th.posts[i].no]); // WILL BE THIS.
////            th_old.posts[th_old.posts.length] = th.posts[i];
////          }
////        }
////      }
////    },
////////    update_posts_add: function(th,th_old,pnode) { // working code.
////////      var ref = th_old.posts[0].nextSibling || null;
////////      for (var i=0;i<th.posts.length;i++) {
////////        if (th.posts[i].no>th_old.posts[th_old.posts.length-1].no) {
////////          pnode.appendChild(document.createElement('br'));
////////          pnode.appendChild(this.post_container(th.posts[i].pn || this.post_json2html(th.posts[i],th.posts.board),th.posts[i].no));
////////          th_old.posts[th_old.posts.length] = th.posts[i];
////////        }
////////      }
////////    },
    short_link:function(){return '';},
    page_json2html3_replace_expander: function(){}, // temporal
    page_json2html3_add_omitted_info: function(){}, // temporal
    post_json2html_fname_server: function(post){return post.tim+post.ext;},
    post_json2html_fname: function(post){return post.filename+post.ext;},
    post_com2txt: function(post){
      return (post.com)? post.com.replace(/<[^>]*>/g,' ').replace(/&gt;/g,'>').replace(/&lt;/g,'<').replace(/&amp;/g,'&') : ''; // most of lainchan, speed: 9.4/1.99, misshit 4%
    },
    patch:{},
    post_pn2ce: function(pn){
      return (pn.lastChild.tagName==='BLOCKQUOTE')? pn.lastChild : pn.getElementsByTagName('blockquote')[0];
    },
    post_an2pn: function(pn){
      while (pn && !pn.classList.contains('post')) pn = pn.parentNode;
      return pn;
    },
//    post_pn2ce: function(pn){return pn;},
  };
  site2['common'] = { // common functions
    absorb_children: function(pn){
      var container = document.createElement('div');
      while (pn.childNodes.length!=0) container.appendChild(pn.childNodes[0]);
      pn.appendChild(container);
      return container;
    },
    disgorge_children: function(pn){
      while (pn.childNodes.length!=0) pn.parentNode.appendChild(pn.childNodes[0]);
      pn.parentNode.removeChild(pn);
    },
    remove_by_classname : function(pn,classname,end,remove_br){
      if (end===undefined) end = 0;
      var tgts = pn.getElementsByClassName(classname);
      for (var i=tgts.length-1-end;i>=0;i--) {
        if (remove_br && tgts[i].nextSibling && tgts[i].nextSibling.tagName==='BR') tgts[i].parentNode.removeChild(tgts[i].nextSibling);
//if (!pref.test_mode['14']) tgts[i].setAttribute('style','display:none;'+(tgts[i].getAttribute('style') || ''));
//else
        tgts[i].parentNode.removeChild(tgts[i]);
      }
    },
//    remove_by_classname : function(pn,classname,end,remove_br){ // cause document leak in Chrome at 4chan/a/.
//      if (end===undefined) end = 0;
//      var tgts = pn.getElementsByClassName(classname);
//      for (var i=tgts.length-1-end;i>=0;i--) {
//        if (remove_br && tgts[i].nextSibling && tgts[i].nextSibling.outerHTML==='<br>') tgts[i].parentNode.removeChild(tgts[i].nextSibling);
//        tgts[i].parentNode.removeChild(tgts[i]);
//      }
//    },
    remove_by_tagname : function(pn,tagname,end){
      if (end===undefined) end = 0;
      var tgts = pn.getElementsByTagName(tagname);
      for (var i=tgts.length-1-end;i>=0;i--) tgts[i].parentNode.removeChild(tgts[i]);
    },
    remove_by_attribute : function(pns,attr_name,attr_val){ // pns must be array.
      for (var i=pns.length-1;i>=0;i--)
        for (var j=pns[i].childNodes.length-1;j>=0;j--)
          if (pns[i].childNodes[j].getAttribute)
            if (pns[i].childNodes[j].getAttribute(attr_name))
              if (pns[i].childNodes[j].getAttribute(attr_name).search(attr_val)!=-1) pns[i].removeChild(pns[i].childNodes[j]);
    },
    remove_attribute : function(doc,attr_name){
      var pns = doc.getElementsByTagName('*');
      for (var i=pns.length-1;i>=0;i--)
        if (pns[i].getAttribute && pns[i].getAttribute(attr_name)) pns[i].removeAttribute(attr_name);
    },
    add_attribute_by_classname : function(pn,classname,attr_name,attr_val){
      var tgts = pn.getElementsByClassName(classname);
      for (var i=tgts.length-1;i>=0;i--) tgts[i].setAttribute(attr_name,attr_val);
    },
    add_attribute_by_tagname : function(pn,tagname,attr_name,attr_val){
      var tgts = pn.getElementsByTagName(tagname);
      for (var i=tgts.length-1;i>=0;i--) tgts[i].setAttribute(attr_name,attr_val);
    },
    add_attribute_by_attribute : function(pns,attr_name,attr_val,attr_name2,attr_val2){ // pns must be array.
      for (var i=pns.length-1;i>=0;i--)
        for (var j=pns[i].childNodes.length-1;j>=0;j--)
          if (pns[i].childNodes[j].getAttribute)
            if (pns[i].childNodes[j].getAttribute(attr_name))
              if (pns[i].childNodes[j].getAttribute(attr_name).search(attr_val)!=-1) pns[i].setAttribute(attr_name2,attr_val2);
    },
    move_up_and_delete_parent : function(pns){
      for (var i=0;i<pns.length;i++) {
        var parent = pns[i].parentNode;
        var g_parent = parent.parentNode;
        g_parent.insertBefore(pns[i],parent);
        g_parent.removeChild(parent);
      }
    },
    remove_last_hrs_and_brs : function(th){
      while (1) {
        var last_node = th.childNodes[th.childNodes.length-1];
        if (last_node.tagName !== 'HR' && last_node.tagName !== 'BR') break;
        else th.removeChild(last_node);
      }
    },
    remove_brs : function(elem){
      var tgts = elem.getElementsByTagName('br');
      for (var i=tgts.length-1;i>=0;i--) tgts[i].parentNode.removeChild(tgts[i]);
    },
    remove_double_br : function(elem){
      var elems = elem.getElementsByTagName('*');
      for (var i=elems.length-2;i>=0;i--)
//        if (elems[i].outerHTML=='<br>' && elems[i+1].outerHTML=='<br>') elems[i+1].parentNode.removeChild(elems[i+1]); // CAN'T FIND STRINGS WITHOUT TAGS.
        if (elems[i].outerHTML==='<br>' && elems[i].nextSibling && elems[i].nextSibling.tagName==='BR') elems[i].parentNode.removeChild(elems[i].nextSibling);
    },
    remove_double_tags : function(elem,tag){
      var elems = elem.getElementsByTagName('*');
      for (var i=elems.length-2;i>=0;i--) {
        if (elems[i].tagName===tag && elems[i+1].tagName===tag) elems[i+1].parentNode.removeChild(elems[i+1]);
      }
    },
    change_utc_to_local : function(utc_str){
      var date = new Date(utc_str);
//      return date.toString().replace(/\ GMT.*/,'');
      return date.toLocaleString().replace(/\ /,' ('+date.toString().replace(/\ .*/,'')+') ');
    },
////////    thread2headline : function(doc,nickname){
////////      var retval  = site2[nickname].insert_footer(doc,0,'t2h',false,0,0,0);
////////      site2[nickname].remove_posts(doc,pref.catalog_t2h_num_of_posts);
////////      site2.common.remove_double_br(doc);
////////      var retval2 = site2[nickname].insert_footer(doc,0,'t2h',false,0,0,0);
////////      return [retval[0]-retval2[0], retval[1]-retval2[1]];
////////    },
  };
  var site4 = {
////////
//////// TUNING RESULTS to parse entire 4chan by chrome, (avarage of 3 times), 2015/10/5 on XXX.
////////     TYPE1: written in flat with 'exe_sub'. (traditional)
////////     TYPE2: written in array with 'exe_sub'.
////////     TYPE3: written in array.
////////     TYPE4: written in array systematically.
////////     TYPE5: written in flat.
////////   results(ms): (idle), (program), (anonymous_function), usage. 
////////     TYPE1: 179164.7, 24936.9, 12598.6, 17.3%
////////     TYPE2: 165382.5, 35503.6, 14546.3, 23.2%
////////     TYPE3: 169261.9, 23509.1, 13727.0, 18.0%
////////     TYPE4: 159156.4, 37429.6, 14104.5, 24.5%
////////     TYPE5: 159990.8, 32805.5, 14998.7, 23.0%
////////
//////// TUNING RESULTS use TYPE1 to parse entire 4chan 2015/12/19 on chrome 47.0.2526.106m. Just one trial.
////////     rev_547: 12min05s
////////     rev_714: 11min30s, why does 4chan become so slow? lainchan is not so slow.
////
////    parse_funcs_getters: {}, // works.
////    parse_funcs_getters: Object.create(null), // THIS DOESN'T WORK.
////    parse_funcs_getters: (function(){ // works if '{}'
//////      var obj = Object.create(null); // DOESN'T WORK, probably introduce problem to make prototype chain using '__proto__'.
////      var obj = {}; // works.
////      var props=['no','ths','key','time_bumped','nof_posts','nof_files','time_created','posts','sub','name','com','flag','flags',
////                 'footer','sticky','format','pn','pn_name','time','time_posted','tn_as','tn_imgs','op_img_url','post_no'];
////      for (var i=0;i<props.length;i++) Object.defineProperty(obj,props[i],{get:(function(prop){return function(){return this.exe_sub(prop);}})(props[i]), enumerable:true});
////      return obj;
////    })(),
////
    parse_funcs_getters: { // working code. // TYPE1
      get no() {return this.exe_sub('no');},
//      get ths() {return this.exe_sub('ths');}, // removed to get faster.
      get key() {return this.exe_sub('key');},
      get time_bumped() {return this.exe_sub('time_bumped');},
      get nof_posts() {return this.exe_sub('nof_posts');},
      get nof_files() {return this.exe_sub('nof_files');},
      get time_created() {return this.exe_sub('time_created');},
      get posts() {return this.exe_sub('posts');},
      get sub() {return this.exe_sub('sub');},
      get name() {return this.exe_sub('name');},
      get com() {return this.exe_sub('com');},
      get flag() {return this.exe_sub('flag');},
      get flags() {return this.exe_sub('flags');},
      get footer() {return this.exe_sub('footer');},
      get sticky() {return this.exe_sub('sticky');},
//      get format() {return this.exe_sub('format');},
      get pn() {return this.exe_sub('pn');},
//      get pn_name() {return this.exe_sub2('pn_name');},
      get time() {return this.exe_sub('time');},
      get time_posted() {return this.exe_sub('time_posted');},
//      get html_org() {return this.exe_sub('html_org');},
      get tn_as() {return this.exe_sub2('tn_as');},  // CAUTION. ADDED AFTER TUNING.
      get tn_imgs() {return this.exe_sub2('tn_imgs');},  // CAUTION. ADDED AFTER TUNING.
      get op_img_url() {return this.exe_sub('op_img_url');},
////      get post_no() {return this.exe_sub('post_no');},
//      get last_replies() {return this.exe_sub('last_replies');},   // CAUTION. ADDED AFTER TUNING.
      get txt() {return this.exe_sub('txt');},   // CAUTION. ADDED AFTER TUNING.

      get time_tu() {return this.time * this.parse_funcs.time_unit;},   // CAUTION. ADDED AFTER TUNING. THIS IS NOT A CALLER.
      get lth() {return liveTag.mems[this.domain][this.board][this.no];},   // CAUTION. ADDED AFTER TUNING. THIS IS NOT A CALLER.
      get type_mimic(){return this.type_parse;},
      get key_op() {return this.domain + this.board + (this.resto || this.op || this.no);}, // this.op for meguca, it always refer to op, while resto===0 if it is op itself.
    },
////    parse_funcs_on_demand : { // TYPE5
////      get no() {return Object.defineProperty(this,'no',{value:this.parse_funcs['no'](this), enumerable:true, configurable:true, writable:true})['no'];},
////      get ths() {return Object.defineProperty(this,'ths',{value:this.parse_funcs['ths'](this), enumerable:true, configurable:true, writable:true})['ths'];},
////      get key() {return Object.defineProperty(this,'key',{value:this.parse_funcs['key'](this), enumerable:true, configurable:true, writable:true})['key'];},
////      get time_bumped() {return Object.defineProperty(this,'time_bumped',{value:this.parse_funcs['time_bumped'](this), enumerable:true, configurable:true, writable:true})['time_bumped'];},
////      get nof_posts() {return Object.defineProperty(this,'nof_posts',{value:this.parse_funcs['nof_posts'](this), enumerable:true, configurable:true, writable:true})['nof_posts'];},
////      get nof_files() {return Object.defineProperty(this,'nof_files',{value:this.parse_funcs['nof_files'](this), enumerable:true, configurable:true, writable:true})['nof_files'];},
////      get time_created() {return Object.defineProperty(this,'time_created',{value:this.parse_funcs['time_created'](this), enumerable:true, configurable:true, writable:true})['time_created'];},
////      get posts() {return Object.defineProperty(this,'posts',{value:this.parse_funcs['posts'](this), enumerable:true, configurable:true, writable:true})['posts'];},
////      get sub() {return Object.defineProperty(this,'sub',{value:this.parse_funcs['sub'](this), enumerable:true, configurable:true, writable:true})['sub'];},
////      get name() {return Object.defineProperty(this,'name',{value:this.parse_funcs['name'](this), enumerable:true, configurable:true, writable:true})['name'];},
////      get com() {return Object.defineProperty(this,'com',{value:this.parse_funcs['com'](this), enumerable:true, configurable:true, writable:true})['com'];},
////      get flag() {return Object.defineProperty(this,'flag',{value:this.parse_funcs['flag'](this), enumerable:true, configurable:true, writable:true})['flag'];},
////      get flags() {return Object.defineProperty(this,'flags',{value:this.parse_funcs['flags'](this), enumerable:true, configurable:true, writable:true})['flags'];},
////      get footer() {return Object.defineProperty(this,'footer',{value:this.parse_funcs['footer'](this), enumerable:true, configurable:true, writable:true})['footer'];},
////      get sticky() {return Object.defineProperty(this,'sticky',{value:this.parse_funcs['sticky'](this), enumerable:true, configurable:true, writable:true})['sticky'];},
////      get format() {return Object.defineProperty(this,'format',{value:this.parse_funcs['format'](this), enumerable:true, configurable:true, writable:true})['format'];},
////      get pn() {return Object.defineProperty(this,'pn',{value:this.parse_funcs['pn'](this), enumerable:true, configurable:true, writable:true})['pn'];},
////      get pn_name() {return Object.defineProperty(this,'pn_name',{value:this.parse_funcs['pn_name'](this), enumerable:true, configurable:true, writable:true})['pn_name'];},
////      get time() {return Object.defineProperty(this,'time',{value:this.parse_funcs['time'](this), enumerable:true, configurable:true, writable:true})['time'];},
////      get time_posted() {return Object.defineProperty(this,'time_posted',{value:this.parse_funcs['time_posted'](this), enumerable:true, configurable:true, writable:true})['time_posted'];},
//////      get html_org() {return Object.defineProperty(this,'html_org',{value:this.parse_funcs['html_org'](this), enumerable:true, configurable:true, writable:true})['html_org'];},
////      get tn_as() {return Object.defineProperty(this,'tn_as',{value:this.parse_funcs['tn_as'](this), enumerable:true, configurable:true, writable:true})['tn_as'];},
////      get tn_imgs() {return Object.defineProperty(this,'tn_imgs',{value:this.parse_funcs['tn_imgs'](this), enumerable:true, configurable:true, writable:true})['tn_imgs'];},
////      get op_img_url() {return Object.defineProperty(this,'op_img_url',{value:this.parse_funcs['op_img_url'](this), enumerable:true, configurable:true, writable:true})['op_img_url'];},
////      get post_no() {return Object.defineProperty(this,'post_no',{value:this.parse_funcs['post_no'](this), enumerable:true, configurable:true, writable:true})['post_no'];},
////    },
    parse_funcs_on_demand : {},
    parse_funcs_on_demand_debug : {},
    parse_funcs_no_cache: {},
    parse_funcs_one_time: {}
  };
////  var props=['no','ths','key','time_bumped','nof_posts','nof_files','time_created','posts','sub','name','com','flag','flags', // works.
////             'footer','sticky','format','pn','pn_name','time','time_posted','tn_as','tn_imgs','op_img_url','post_no'];
////  for (var i=0;i<props.length;i++)
//////    Object.defineProperty(site4.parse_funcs_getters,props[i],{get:(function(prop){return function(){return this.exe_sub(prop);}})(props[i]), enumerable:true}); // TYPE2
////    Object.defineProperty(site4.parse_funcs_on_demand,props[i],{get:(function(prop){ // WORKS // TYPE3
////      return function(){
////        return Object.defineProperty(this,prop,{value:this.parse_funcs[prop](this), enumerable:true, configurable:true, writable:true})[prop];
////      }})(props[i]), enumerable:true});
  site4.parse_funcs_on_demand = { // working code. // TYPE1,2
    exe_sub : function(prop){return Object.defineProperty(this,prop,{value:this.parse_funcs[prop](this), enumerable:true, configurable:true, writable:true})[prop];},
    exe_sub2 : function(prop){return this.parse_funcs_html[prop](this);}, // no cache
    __proto__: site4.parse_funcs_getters
  }
  site4.parse_funcs_on_demand_debug = {
    exe_sub : function(prop){
      try {
        return Object.defineProperty(this,prop,{value:this.parse_funcs[prop](this), enumerable:true, configurable:true, writable:true})[prop];
      } catch(e) {
        console.log('parse_error: '+this.key+', '+this.type_parse+', '+prop);
        console.trace();
        console.log(this);
      }
    },
    exe_sub2 : function(prop){
      try {
        return this.parse_funcs_html[prop](this); // no cache
      } catch(e) {
        console.log('parse_error: '+this.key+', '+this.type_parse+', '+prop);
        console.trace();
        console.log(this);
      }
    },
    __proto__: site4.parse_funcs_getters
  }
  site4.parse_funcs_no_cache = {
    exe_sub : function(prop){return this.parse_funcs[prop](this);},
    exe_sub2 : function(prop){return this.parse_funcs_html[prop](this);},
    __proto__: site4.parse_funcs_getters
  }
  site4.parse_funcs_one_time = {
    get posts() {return Object.defineProperty(this,'posts',{value:this.parse_funcs['posts'](this), enumerable:true, configurable:true, writable:true})['posts'];},
    exe_sub : function(prop){return this.parse_funcs[prop](this);},
    exe_sub2 : function(prop){return this.parse_funcs_html[prop](this);},
    __proto__: site4.parse_funcs_getters
  }

////  (function (){ // WORKS, BUT TOO SLOW // TYPE4
////    var props=['no','ths','key','time_bumped','nof_posts','nof_files','time_created','posts','sub','name','com','flag','flags', // works.
////               'footer','sticky','format','pn','pn_name','time','time_posted','tn_as','tn_imgs','op_img_url','post_no'];
////    for (var i=0;i<props.length;i++) {
////      var func = (function(prop){return function(){
////                   return Object.defineProperty(this,prop,{value:this.parse_funcs[prop](this), enumerable:true, configurable:true, writable:true})[prop];
////                 }})(props[i]);
////      var func_no_cache = (function(prop){return function(){
////                   return this.parse_funcs[prop](this);
////                 }})(props[i]);
////      var func_debug = (function(func,prop){return function(){
////                         try {
//////                           return func();  // THIS DOESN'T WORK, WHY???
////                           return Object.defineProperty(this,prop,{value:this.parse_funcs[prop](this), enumerable:true, configurable:true, writable:true})[prop]; // works.
////                         } catch(e) {
////                           console.log('parse_error: '+this.key+', '+this.type_parse);
////                         }
////                       }})(func,props[i]);
////      Object.defineProperty(site4.parse_funcs_on_demand,props[i],{get:func, enumerable:true});
////      Object.defineProperty(site4.parse_funcs_on_demand_debug,props[i],{get:func_debug, enumerable:true});  // NOT DEBUGGED YET
////      Object.defineProperty(site4.parse_funcs_no_cache,props[i],{get:func_no_cache, enumerable:true});  // NOT DEBUGGED YET
////      if (props[i]!=='posts') Object.defineProperty(site4.parse_funcs_one_time,props[i],{get:func, enumerable:true});  // NOT DEBUGGED YET
////      else Object.defineProperty(site4.parse_funcs_one_time,props[i],{get:func_no_cache, enumerable:true});
////    }
////  })();

if (pref.features.domains['8chan']) {
  site2['8chan'] = {
    nickname : '8chan',
    domain_url: '8ch.net',
    domain_url_image: 'media.8ch.net',
//    home : site.protocol + '//8chan.co/faq.html', // stop twitter and IRC access.
//    home : site.protocol + '//8ch.net/faq.html', // stop twitter and IRC access.
//    home : site.protocol + '//8ch.net/favicon.ico', // can't work in FF.
    home: site.protocol + '//8ch.net' + ((brwsr.ff)? '/faq.html' : '/favicon.ico'),
//    protocol : 'https:',
    protocol : site.protocol,
    features : {uip_tracker: true},
    utilize_boards_json: true,
    check_func : function(){
      var href = window.location.href;
      if (href.search(/8chan.co|8ch.net/)!=-1) { // 8chan
        site2['8chan'].domain_url = (href.search(/8ch.net/)!=-1)? '8ch.net' : '8chan.co';
        this.home = site.protocol + '//' + this.domain_url + this.home.substr(this.home.lastIndexOf('/')); // FF doesn't work on favicon.
        site.whereami = (document.title.indexOf('404 - Page Not Found')!=-1)? '404'
                      : (href.search(/8ch\.net\/?$/)!=-1)? 'frame'
                      : (href.search(/catalog\.html/)!=-1)? 'catalog'
                      : (href.search(/res\/[0-9\+]*\.html/)!=-1)? 'thread'
                      : (href.search(/8ch\.net\/index/)!=-1)? 'boards'
                      : (href.search(/\/$|(index|[0-9]+)\.html|\/#all$/)!=-1)? 'page'
                      : (href.search(/boards.html/)!=-1)? 'boards'
                      : 'other';
        site.config(site2['8chan'].domain_url,'8chan');
        site.header_height = function(){
          var header = document.getElementsByClassName('boardlist')[0];
          return (header)? header.offsetHeight : 0;
        }
        site.postform = document.getElementsByTagName('form')[0];
//        site.postform_comment = document.getElementById('body');
        if (site.postform) this.postform_prep();
        site.max_page = site2['8chan'].max_page(site.board);
        site.catalog = href.search(/catalog\.html/)!=-1;
        site.embed_to = (site.whereami==='thread' || site.whereami==='page')? {
          top: function(){return document.getElementsByName('postcontrols')[0];},
          bottom: function(){return document.getElementsByClassName('boardlist bottom')[0];}
        } : (site.whereami==='catalog')? {
          top: function(){return document.getElementsByClassName('thumbnail')[0].nextSibling;},
          bottom: function(){return document.getElementsByTagName('footer')[0];}
        } : {};
        if (site.components.boardlist) site.components.boardlist.style.zIndex = 0;
        return true;
      } else {
        if (!brwsr.ff) {
          this.protocol = 'https:';
          this.home = this.protocol + '//' + this.domain_url + this.home.substr(this.home.lastIndexOf('/'));
        }
        return false;
      }
    },
    postprocess_board: function(val){
      for (var i=0;i<val.length;i++) {
        if (val[i].max>0) { // val[i].max is string, but this is ok.
          var bd = liveTag.mems.init({domain:this.nickname, board:'/'+val[i].uri+'/'});
          bd.o = i;
          if (val[i].pages && !bd.pgs) bd.pgs = val[i].pages;
////          site3[this.nickname].boards.push(bd); // BUG. increase length forever.
          Object.defineProperty(bd,'max',{value:parseInt(val[i].max,10), writable:true});
          if (bd.read_max===undefined) Object.defineProperty(bd,'read_max',{value:0, writable:true});
          if (val[i].tags && val[i].tags.length!=0) liveTag.postprocess_board_add_btag(val[i].tags,bd);
        }
      }
    },
////    enumerate_boards_to_scan:function(){
////      var obj = [];
////      var end = (site3[site.nickname].boards.length > pref.scan.max)? pref.scan.max : site3[site.nickname].boards.length;
////      for (var i=0;i<end;i++) 
////        if (site3[site.nickname].boards[i].max) obj[obj.length] = '/'+site3[site.nickname].boards[i].uri+'/';
////      return obj;
////    },
////    make_site3_bds:function(){ // working code.
////      var tgts = site3[site.nickname].boards;
////      for (var i=0;i<tgts.length;i++) site3[this.nickname].bds['/'+tgts[i].uri+'/'] = tgts[i].max;
////    },
    catalog_frame_prep: function(pn12){
      document.getElementsByTagName('header')[0].style.display='none';
      document.getElementsByClassName('footer')[0].style.display = 'none';
      var frame_menu = document.getElementsByClassName('menuCol')[0];
      frame_menu.firstChild.style.display='none';
      var frame_main = document.getElementsByClassName('bodyCol')[0];
      frame_main.firstChild.style.display = 'none';
      frame_menu.insertBefore(pn12,frame_menu.firstChild);
      var ifrm = this.catalog_native_frame_prep_frame(frame_main,frame_main.firstChild);
      this.catalog_embed_prep(pn12);
    },
    prep_own_posts_event : function(e){
      if (e && e.key==='own_posts') site2['8chan'].prep_own_posts();
      if (window.name==='8chan') send_message('parent',[['OWN_POSTS', window.name, site3[window.name].own_posts]]);
    },
    prep_own_posts : function(){
      var own_posts = {};
      var obj = JSON.parse(localStorage.getItem('own_posts'));
      for (var i in obj) {
        var board = '/'+i+'/';
        own_posts[board] = {};
        for (var j=0;j<obj[i].length;j++) own_posts[board][obj[i][j]] = null;
      }
//      for (var i in obj)
//        for (var j=0;j<obj[i].length;j++)
//          own_posts['/'+i+'/'+obj[i][j]] = null;
//console.log(own_posts);
      site3['8chan'].own_posts = own_posts;
    },
////    format_thread_always : function(th){
////////      site2.common.remove_last_hrs_and_brs(th); // working code.
////      if (th.nextSibling && th.nextSibling.tagName==='HR') th.appendChild(th.nextSibling);
////      else th.appendChild(document.createElement('hr'));
////    },
    preprocess_doc2: {
      thread_html: function(doc){
        var head = doc.getElementsByTagName('head')[0];
        while (head.firstChild) head.removeChild(head.firstChild);
        var body = doc.getElementsByTagName('body')[0];
        for (var i=body.childNodes.length-1;i>=0;i--) if (body.childNodes[i].name!=='postcontrols') body.removeChild(body.childNodes[i]);
      }
    },

    parse_funcs : { // 8chan
      'catalog_html' : {
//        ths: function(doc,req){
//          var req2 = req[req.indexOf('ths')+1];
//          var mixs = doc.pn.getElementsByClassName('mix');
//          var ths = [];
//          for (var i=0;i<mixs.length;i++) if (mixs[i].tagName==='DIV') {
//            ths.push({pn:mixs[i], board:doc.board, domain:doc.domain});
//            site2['DEFAULT'].parse_funcs.call(this,ths[ths.length-1],req2);
//          }
//          return ths;
//        },
        before_test : ['ths',':ITER',':ALL','ths',['key','time_bumped','nof_posts','nof_files']],
        after_test  : ['time_created','sub','name','com','footer','sticky','format'],
        full_hier   : ['ths',':ITER',':ALL','ths',['key','time_bumped','nof_posts','nof_files','time_created','sub','name','com','footer','sticky','format']],
//        full_th     : ['key','time_bumped','nof_posts','nof_files','sub','name','com','footer','sticky'],
        ths: function(doc) {
          var mixs = doc.pn.getElementsByClassName('mix');
          var ths = [];
if (pref.test_mode['0']) {
          for (var i=0;i<mixs.length;i++) if (mixs[i].tagName==='DIV') ths[ths.length] = {pn:mixs[i], page:Math.floor(i/15)+'.'+i%15};
} else { 
          for (var i=0;i<mixs.length;i++) if (mixs[i].tagName==='DIV') ths[ths.length] = mixs[i];
          ths = this.ths_array(doc,ths);
}
//          for (var i=0;i<ths.length;i++) ths[i].pn.getElementsByTagName('a')[0].addEventListener('click',this.preventDefault,false); // TEST, works.
          return ths;
        },
        th_init: function(th){
          var pn_child = th.pn.getElementsByTagName('div')[0];
//          pn_child.className = pn_child.className.replace(/grid\-size\-[a-z]*/,'grid-size-'+site2[th.domain].catalog_native_size); // BUG WHEN MIMICED.
          pn_child.className = pn_child.className.replace(/grid\-size\-[a-z]*/,'grid-size-'+site2['8chan'].catalog_native_size);
//          th.pn.getElementsByTagName('a')[0].removeAttribute('href');
//          th.pn.getElementsByTagName('a')[0].addEventListener('click',th.parse_funcs.preventDefault,false); // TEST
        },
//        th_destroy: function(pn, parse_funcs){
////          pn.getElementsByTagName('a')[0].removeEventListener('click',parse_funcs.preventDefault,false); // TEST
//        },
////        ths: function(doc) {
////          var mixs = doc.pn.getElementsByClassName('mix');
////          var ths = [];
////if (pref.test_mode['0']) {
////          for (var i=0;i<mixs.length;i++) if (mixs[i].tagName==='DIV') ths[ths.length] = {pn:mixs[i], page:Math.floor(i/15)+'.'+i%15};
////} else { 
//////          for (var i=0;i<mixs.length;i++) if (mixs[i].tagName==='DIV')
//////            ths[ths.length] = {pn:mixs[i], page:Math.floor(i/15)+'.'+i%15, type_html: 'catalog_html', __proto__:doc.__proto__};
////          for (var i=0;i<mixs.length;i++) if (mixs[i].tagName==='DIV') ths[ths.length] = mixs[i];
////          ths = this.ths_array(doc,ths);
////}
////          for (var i=0;i<ths.length;i++) {
////            var pn_child = ths[i].pn.getElementsByTagName('div')[0];
////            pn_child.className = pn_child.className.replace(/grid\-size\-[a-z]*/,'grid-size-'+site2['8chan'].catalog_native_size);
////          }
////          for (var i=0;i<ths.length;i++) ths[i].pn.getElementsByTagName('a')[0].removeAttribute('href');
//////          for (var i=0;i<ths.length;i++) ths[i].pn.getElementsByTagName('a')[0].addEventListener('click',this.preventDefault,false); // TEST
////          return ths;
//////          for (var i=mixs.length-1;i>=0;i--) if (mixs[i].tagName==='DIV') mixs[i]={pn:mixs[i]}; // CAN'T WRITE TO COLLECTION.
//////                                             else Array.prototype.splice.call(mixs,i,1);
//////          return mixs; // return collection
////        },
//        no : function(th){return th.pn.getElementsByTagName('img')[0].id.replace(/img\-/,'');},
        no : function(th){return parseInt(th.pn.getAttribute('data-id'),10);},
        sticky: function(th){return th.pn.getAttribute('data-sticky')==='true';},
        posts: 'DEFAULT.catalog_html',
        proto: 'vichan.catalog_html'
      },
      'catalog_json' : {
////        op_img_url: function(obj) { // working code.
////          return (obj.ext==='.jpg' || obj.ext==='.png' || obj.ext==='.jpeg' || obj.ext==='.gif' || obj.ext==='.webm' || obj.ext==='.mp4')?
////                   'https://' + site2['8chan'].domain_url + obj.board + 'thumb/' + obj.tim + '.jpg' :
////                 (obj.embed)? 'https:' + obj.embed.replace(/.*src="/,'').replace(/".*/,'') :
////                 (obj.ext==undefined)? 'https://' + site2['8chan'].domain_url + '/static/no-file.png' :
//////                 (obj.ext==undefined)? 'https://' + site2['8chan'].domain_url + '/static/assets' + obj.board + 'no-file.png' :
////                 '';
//////          return ((obj.ext==='.jpg' || obj.ext==='.jpeg' || obj.ext==='.gif' || obj.ext==='.png')? 'https://' + site2['8chan'].domain_url + obj.board + 'thumb/' + obj.tim + obj.ext : '');
////        },
        get_op_src: 'thread_json',
        proto: 'vichan.catalog_json'
      },
      'page_html'    : {
        ths: function(doc) {
//          var pc = doc.pn.getElementsByName('postcontrols')[0].childNodes;
//          var ths = [];
//          if (pc) for (var i=0;i<pc.length;i++) if (pc[i].id && pc[i].id.substr(0,6)=='thread') ths[ths.length] = pc[i];
//          ths = this.ths_array(doc,ths);
          var ths = this.ths_array(doc,doc.pn.getElementsByClassName('thread')); // 2015.04.26 changed to the same as 4chan.
          if (site.whereami!=='page' || !pref.catalog.embed_page) for (var i=0;i<ths.length;i++) ths[i].pn.removeAttribute('class');
//          for (var i=0;i<ths.length;i++) if (ths[i].pn.nextSibling && ths[i].pn.nextSibling.tagName==='HR') ths[i].pn.appendChild(ths[i].pn.nextSibling);
////          for (var i=0;i<ths.length;i++) {
////            var as = ths[i].pn.getElementsByTagName('a');
////            as[0].removeAttribute('href'); // changed 2015.04.26
////            as[1].removeAttribute('href'); // changed 2015.04.26
////          }
          return ths;
        },
//        no : function(th){return parseInt(th.pn.getElementsByClassName('post op')[0].id.substring(3),10);},
          pn: 'page_json', // for mimic
        filename: 'thread_html',
        proto: 'vichan.page_html'
      },
      'page_json'  : {
        has_posts: true,
//pn: function(th){return site2[th.domain_html].catalog_json2html3(th,th.board, this.op_img_url(th));}, // TEMPORAL PATCH
        proto: 'vichan.page_json'
      },
      'thread_html'  : {
////        qsel_th2posts: ':scope>.post.reply', // working code.
////        pop_post_prep: function(th){
////          th.posts_col = th.pn.querySelectorAll(this.qsel_th2posts);
////          th.idx_pop = th.posts_col.length-1;
////        },
////        pop_post: function(th){
////          while (th.idx_pop>=0) {
////            var pn = th.posts_col[th.idx_pop--];
////            if (pn.className && pn.className.indexOf('post')!=-1 && pn.className.indexOf('reply')!=-1) {
////              th.post = {pn:pn, parse_funcs:this, __proto__:th.__proto__};
////              return true;
////            }
////          }
////          return false;
////        },
        filename: function (th){ // post can be accepted.
          var filenames = [];
          var files = ((th.pn.classList.contains('op'))? th.pn.parentNode : th.pn).getElementsByClassName('files')[0];
          if (files) {
            var spans = files.getElementsByClassName('postfilename');
            for (var i=0;i<spans.length;i++) filenames[i] = spans[i].textContent;
//            files = files.getElementsByClassName('file');
//            for (var i=0;i<files.length;i++) {
//              var as = files[i].getElementsByTagName('a');
//              for (var j=0;j<as.length;j++) if (as[j].getAttribute('title')==='Save as original filename') filenames[filenames.length] = as[j].textContent;
//            }
          }
          if (filenames.length>1) {
            th.extra_files = [];
            for (var i=1;i<filenames.length;i++) th.extra_files[i-1] = {filename:filenames[i], __proto__:th.__proto__};
          }
          return filenames[0];
        },
        get_op_src: 'thread_json',
        proto: 'vichan.thread_html'
      },
      'thread_json'  : {
        get_op_src: function(th){return th.op_img_url.replace('thumb','src').replace('.jpg',th.ext);},
        proto: 'vichan.thread_json'
      },
    },

////    popups_op_func_set: function(pn){return pn.parentNode.querySelector('.files');},
//    popups_op_func_set: function(pn){return pn.querySelector('.files');}, // MUST BE CONSISTENT OF page_json2html
//    popups_op_func_use: function(pn,thq,no){
//      pn.setAttribute('class',pn.getAttribute('class')+' reply');
//      pn.insertBefore(thq[no].isOP.cloneNode(true),pn.firstChild);
//    },
    update_posts_remove: function(th_old,i,pnode){
      pnode.removeChild(th_old.posts[i].pn.nextSibling);
      pnode.removeChild(th_old.posts[i].pn);
    },
    update_posts_insert: function(src,dst,i,j,pnode){
      var ref = (j==1)? (dst[0].pn.nextSibling || null) :
                (j<dst.length)? (dst[j].pn.nextSibling && dst[j].pn.nextSibling.nextSibling || null) : null;
      if (!src[i].pn) src[i].pn = this.post_json2html(src[i],src[i].board);
      pnode.insertBefore(src[i].pn, ref);
      pnode.insertBefore(document.createElement('br'),ref);
    },

    catalog_json2html3_thumbnail: function(obj, board) {
      return (obj.ext==='.jpg' || obj.ext==='.png' || obj.ext==='.jpeg' || obj.ext==='.gif' || obj.ext==='.webm' || obj.ext==='.mp4')?
        this.protocol + '//' + ((obj.tim.length!=64)? this.domain_url + board + 'thumb/' + obj.tim + (obj.ext==='.gif'? '.gif' : '.jpg')
                                                    : this.domain_url_image + '/file_store/thumb/' + obj.tim + (obj.ext==='.gif'? '.gif' : obj.ext==='.png'? '.png' : obj.ext==='.jpeg'? '.jpeg' : '.jpg'))
      : (obj.embed)? (obj.embed.slice(0,2)=='//'?'https:':'') + obj.embed.replace(/.*src="/,'').replace(/".*/,'')
      : (obj.ext==='.swf')? '/static/file.png' :
//             (obj.ext===undefined)? site2['8chan'].protocol + site2['8chan'].domain_url + '/static/no-file.png' :
////             (obj.ext===undefined)? 'https://' + site2['8chan'].domain_url + '/static/assets' + board + 'no-file.png' :
             '';
//      return ((obj.ext==='.jpg' || obj.ext==='.jpeg' || obj.ext==='.gif' || obj.ext==='.png')? 'https://' + site2['8chan'].domain_url + board + 'thumb/' + obj.tim + obj.ext : '');
    },
    short_link:function(){return '';},
    favicon: {
      __proto__: site2['DEFAULT'].favicon,
      none: '/favicon.ico',
      reply: 'png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQElEQVR42mNgGEbg/5n/GJgYORQFDQ0IjK4BmxxWzehsQnJYBdFtxCWH1QBcrkKWw2sAWS6gKAwojgWqpIORDQBVkjfW5KYpFQAAAABJRU5ErkJggg==',
      reply_to_me: 'png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWUlEQVR42mNgAIH/Z/4zNDRgYpA4UQBqADIYZAaAaHRMtAEwjB42cEPQFaCzCclhFcQWK9jk0A1A8QJW2xgYiDeAJBdQFAbYAhLdRryxgByVuOKaYDoY2QAAcHCIXLRHYMUAAAAASUVORK5CYII='
    },
    proto : 'vichan'
  };
  site2['8chan_live'] = {
    parse_funcs : {
      'thread_html'  : {
        posts: function(th){return this.posts_array(th, th.pn.querySelectorAll(':scope>.post.reply'));},
        proto: '8chan.thread_html'
      }
    },
    proto : '8chan'
  };
}
if (pref.features.domains['8chan'] || pref.features.domains['lain'] || pref.features.domains['lainjp']) {
  site2['vichan'] = {
    components: {
      boardlist: '.boardlist',
      postform_comment: ['textarea[name="body"]',0],
      postform_comment2: ['textarea[name="body"]',1],
      postform_submit: ['input[name="post"]',0],
      postform_submit2: ['input[name="post"]',1],
    },
////    postform_prep: function(){
////      site.components.postform_submit2 = null;
////      site.components.postform_submit2_observer = new MutationObserver(this.postform_submit2_find);
////      site.components.postform_submit2_observer.observe(document.getElementsByTagName('body')[0], {childList: true});
////    },
////    postform_submit2_find: function(){
////      var postform_qr = document.querySelectorAll('input[name=post]')[1]; // quick reply
////      if (!site.components.postform_submit2 && postform_qr) {
////        site.components.postform_submit2 = postform_qr;
//////        site.components.postform_submit2_observer.disconnect();
//////        delete site.components.postform_submit2_observer;
////        if (common_obj.thread_reader) common_obj.thread_reader.add_event_to_submit(site.components.postform_submit2);
////      } else if (site.components.postform_submit2 && !postform_qr) {
////        if (common_obj.thread_reader) common_obj.thread_reader.remove_event_from_submit(site.components.postform_submit2);
////        site.components.postform_submit2 = null;
////      }
////      site.query_set_component('postform_comment2');
////      recovery.setup2();
////    },
    general_event_handler:(function(){
      var obj = {
        thread: {
          get_mark: function(pn, clientY){
            while (pn && pn!== cataLog.parent) {
              if (pn.tagName==='BR' || !pn.classList) {pn = pn.previousSibling || pn.parentNode; continue;}
              if (pn.classList.contains('post')) return pn;
              if (pn.classList.contains('postcontainer')) return pn.getElementsByClassName('post')[0];
              if (pn.parentNode && pn.parentNode.id && pn.parentNode.id.search(/^thread/)!=-1) {
                pn = pn.previousSibling;
                if (pn) continue;
                else break;
              }
              if (pn.id && pn.id.search(/^thread/)!=-1) break;
              pn = pn.parentNode;
            }
            return this.get_mark_from_height(clientY);
          },
          get_mark_from_height: function(now_height){
            return this.__proto__.get_mark_from_height(now_height, document.getElementsByClassName('post'));
          },
          image_hover_check_mode: function(img){
            return img.parentNode.parentNode.classList.contains('file')? 'page' : 'catalog';
          },
          __proto__: site2['DEFAULT'].general_event_handler.common,
        },
      };
      obj.page = {
        add_mouseover: pref.test_mode['68'], // true,
        mouseover: function(e){
          var et = e.target;
          var et_tagName = et.tagName;
          if (et_tagName==='A')
            if (pref[cataLog.embed_mode].popup_truncated && et.parentNode.className==='toolong') site2['DEFAULT'].popups_posts.over(e);
        },
        __proto__:obj.thread
      },
      obj.catalog = Object.create(obj.thread);
//      obj.catalog = { // working code
//        mouseover: function(e){
//          var et = e.target;
//          var et_tagName = et.tagName;
//          if (et_tagName==='IMG')
//            if (pref[cataLog.embed_mode].image_hover && et.parentNode.tagName==='A') cataLog.image_hover_add.call(et, e);
//        },
//        __proto__:obj.thread
//      };
      return obj;
    })(),
    boards_sel_from_tags : function(){
      var boards = document.getElementsByClassName('board-list-tbody')[0];
      var str = 'SELECTED_BOARDS,';
      for (var i=0;i<boards.childNodes.length;i++)
        if (boards.childNodes[i].style.display!=='none') str = str + '8chan' + boards.childNodes[i].getElementsByClassName('board-uri')[0].getElementsByTagName('a')[0].getAttribute('href') + ',';
      return str+'\n';
    },
//    catalog_background : '#eef2ff',
//    catalog_bordercolor : '#d6daf0',
    get_next_image: function(img,top){
      var imgs = Array.prototype.slice.call(cataLog.parent.getElementsByClassName('post-image')).filter(function(v){return v.src.substr(-5,5)!=='.webm';});
//      var imgs = cataLog.parent.getElementsByClassName('post-image');
//      var imgs = cataLog.parent.querySelectorAll('img[id^="thumbnail"]');
      return site2['DEFAULT'].get_next_image(img,top,imgs);
    },
//    get_time_of_posts : function(doc){ // working code.
//      var posts = doc.getElementsByClassName('post');
//      return [Date.parse(posts[posts.length-1].getElementsByTagName('time')[0].getAttribute('datetime')),
//              Date.parse(posts[0             ].getElementsByTagName('time')[0].getAttribute('datetime'))];
//    },
////////    get_thread_link : function(pn,bn,del,name){
////////      var as = pn.getElementsByClassName('post op')[0].getElementsByTagName('a');
////////      var hrefs = [];
////////      var href;
////////      for (var i=as.length-1;i>=0;i--) if (as[i].innerHTML==='[Reply]' || as[i].innerHTML==='[Last 50 Posts]') {
////////        var href = as[i].getAttribute('href');
////////        if (hrefs.length==0 || as[i].innerHTML==='[Reply]') hrefs.unshift(href);
////////        else hrefs.push(href);
////////        if (del) as[i].parentNode.removeChild(as[i]);
////////        else {
//////////          as[i].setAttribute('target',(pref.catalog_open_in_new_tab)? '_blank' : '_self');
//////////          as[i].setAttribute('onclick','open_new_thread('+as[i].getAttribute('href')+','+name+')');
////////          as[i].addEventListener('click', function(){open_new_thread(as[i].getAttribute('href'),name);}, false);
//////////          as[i].removeAttribute('href');
////////        }
////////      }
////////      return (hrefs.length!=0)? hrefs : null;
////////    },
    modify_thread_link : function(pn){
      var as = pn.getElementsByClassName('post op');
      if (as.length==0) return [];
      var retval = [];
      as = as[0].getElementsByTagName('a');
      for (var i=as.length-1;i>=0;i--) 
        if (as[i].innerHTML=='[Reply]' || as[i].innerHTML=='[Last 50 Posts]') {
          var href = as[i].getAttribute('href');
          if (href) {
            retval.push([as[i],href]);
//            as[i].addEventListener('click', make_open_new_thread_callback(href,name), false);
//            as[i].addEventListener('click', function(){open_new_thread(href,name);}, false);
            as[i].removeAttribute('href');
          }
        }
      return retval;
    },
//    add_thread_link : function(doc,url){
//      var pn = document.createElement('a');
//      pn.href = url.replace(new RegExp('/https*:\/\/'+site2['8chan'].domain_url+'/'),'');
//      pn.innerHTML = '[Reply]';
//      var th = doc.getElementsByClassName('post op')[0];
//      if (th) th.insertBefore(pn,th.firstChild);
//    },
    catalog_threads_in_page : function(doc){ // patch
      var doc_obj = {domain:site.nickname, pn:doc};
      var ths = this.parse_funcs['page_html'].ths(doc_obj);
      for (var i=0;i<ths.length;i++) ths[i] = ths[i].pn;
      return ths;
    },
//    catalog_threads_in_page : function(doc){return this.parse_funcs['page_html'].ths(doc);},
//    catalog_threads_in_page : function(doc){
//      var pc = doc.getElementsByName('postcontrols');
//      th = [];
//      if (pc.length!=0)
//        for (var i=0;i<pc[0].childNodes.length;i++)
//          if (pc[0].childNodes[i].id && pc[0].childNodes[i].id.substr(0,6)=='thread') th.push(pc[0].childNodes[i]);
//      return th;
//    },
    remove_posts : function(th,end){
      site2.common.remove_by_classname(th,'post reply',end,true);
//      site2.common.remove_double_br(th);
    },
    remove_files_info : function(th){
      site2.common.remove_by_classname(th,'fileinfo');
      site2.common.move_up_and_delete_parent(th.getElementsByClassName('post-image'));
    },
//    site.catalog_files_info = function(doc){return doc.getElementsByClassName('fileinfo');};
//    site.catalog_delete_checkboxs = function(doc){return doc.getElementsByClassName('delete');};
//    remove_checkboxes : function(doc){
//      var cbxs = doc.getElementsByClassName('delete');
//      for (var i=cbxs.length-1;i>=0;i--) cbxs[i].outerHTML = '';
//      return doc;
//    },
    postform_rules : null,
    thread_keyword : 'res',
    max_page : function(){return 15;},
    make_url4 : function(dbt){
      var url_prefix = this.protocol + '//' + this.domain_url + dbt[1];
//      if (dbt[3]==='page_json') dbt[3] = 'page_html'; // TEMPORAL PATCH
      if      (dbt[3]==='page_html')    return [url_prefix + ((dbt[2]!=0)? (parseInt(dbt[2],10)+1) :'index')+'.html', 'html'];
      else if (dbt[3]==='page_json')    return [url_prefix +                parseInt(dbt[2],10)             +'.json', 'json'];
      else if (dbt[3]==='catalog_json') return [url_prefix + 'catalog.json', 'json'];  // Doesn't contain information about webm thumbnail.
      else if (dbt[3]==='catalog_html') return [url_prefix + 'catalog.html', 'html'];
      else if (dbt[3]==='thread_html')  return [url_prefix + 'res/' + dbt[2] + '.html', 'html'];
      else if (dbt[3]==='thread_json')  return [url_prefix + 'res/' + dbt[2] + '.json', 'json'];
    },
////////    make_url : function(board,no,key){ // working code.
////////      var url_prefix = site2['8chan'].protocol + '//' + site2['8chan'].domain_url + board;
////////      if (key==='p') return [url_prefix + ((no!=0)? (no+1) :'index')+'.html', 'html'];
////////      else if (key==='j') return [url_prefix + 'catalog.json', 'json'];  // Doesn't contain information about webm thumbnail.
////////      else return [url_prefix + 'catalog.html', 'html'];
////////    },
//////////    make_url3: function(board,th){return site2['8chan'].protocol + '//' + site2['8chan'].domain_url + board + 'res/' + th + '.html';},
////////    make_url3: function(board,th){return site2['8chan'].protocol + '//' + site2['8chan'].domain_url + board + 'res/' + ((th[0]!=='t')? (th + '.html') : (th.substr(1) + '.json'));},
//////////    make_url3: function(board,th){
//////////      return [site2['8chan'].protocol + '//' + site2['8chan'].domain_url + board + 'res/' + ((th[0]!=='t')? (th + '.html') : (th.substr(1) + '.json')), (th[0]!=='t')? 'html' : 'json'];
//////////    },
    url_boards_json : function(){return [site2['8chan'].protocol + '//' + site2['8chan'].domain_url + '/boards.json','json'];},
//    enumerate_boards_to_scan:function(){
//      var obj = [];
//      var end = (site3[site.nickname].boards.length > pref.scan.max)? pref.scan.max : site3[site.nickname].boards.length;
//      for (var i=0;i<end;i++) 
//        if (site3[site.nickname].boards[i].max) obj[obj.length] = '/'+site3[site.nickname].boards[i].uri+'/';
//      return obj;
//    },
    get_ops : function(doc){
      var op_containers = doc.getElementsByClassName('post op');
      var ops = [];
//      for (var i=0;i<op_containers.length;i++) ops.push(op_containers[i].getElementsByTagName('input')[0].id.substring(7));
      for (var i=0;i<op_containers.length;i++) ops.push(parseInt(op_containers[i].id.substring(3),10));
      return ops;
    },
    get_posts : function(doc) {
      var posts = [];
//      var deletes = doc.getElementsByClassName('delete');
//      for (var i=0;i<deletes.length;i++) posts.push(deletes[i].id.substr(7));
      var nos = doc.getElementsByClassName('post_no');
      for (var i=0;i<nos.length;i++) if (nos[i].id) posts.push(parseInt(nos[i].id.substr(8),10));
      return posts;
    },
//    absolute_link : function(doc){
//      var all = doc.getElementsByTagName('*');
//      var tgts = ['src','href'];
//      for (var i=0;i<all.length;i++) {
//        for (var j=0;j<tgts.length;j++) {
//          var tgt = all[i].getAttribute(tgts[j]);
//          if (tgt && tgt.indexOf('http')!=0  && tgt.substr(0,2)!='//')  all[i].setAttribute(tgts[j],site2['8chan'].protocol + '//' + site2['8chan'].domain_url + tgt);
//        }
//      }
//    },
//    absolute_link : function(doc){
//      var all = doc.getElementsByTagName('*');
//      for (var i=0;i<all.length;i++) {
//        if (all[i].getAttribute('src')  && all[i].getAttribute('src').indexOf('http')!=0  && all[i].getAttribute('src').substr(0,2)!='//')  all[i].setAttribute('src',site2['8chan'].protocol + '//' + site2['8chan'].domain_url + all[i].getAttribute('src'));
//        if (all[i].getAttribute('href') && all[i].getAttribute('href').indexOf('http')!=0 && all[i].getAttribute('href').substr(0,2)!='//') all[i].setAttribute('href',site2['8chan'].protocol + '//' + site2['8chan'].domain_url + all[i].getAttribute('href'));
//      }
//    },
////////    insert_footer : function(th,page_no,bn,exe,date,nof_posts,nof_files){
////////      var key = (!brwsr.ff)? 'innerText' : 'innerHTML';
////////      nof_posts += th.getElementsByClassName('post').length;
////////      nof_files += th.getElementsByClassName('fileinfo').length;
////////      var om_info = th.getElementsByClassName('omitted');
////////      if (om_info[0]) {
////////        var str = om_info[0][key].replace(/\n/g,'');
////////        nof_posts += parseInt(str.replace(/\ post.*/,''),10);
////////        nof_files += parseInt('0'+str.replace(/\ image.*/,'').replace(/[^\ ]*\ /g,''),10);
////////      }
////////      if (exe) {
////////        var pn = document.createElement('div');
////////        pn.setAttribute('name','catalog_footer');
////////        if (pref.catalog_footer_br) pn.setAttribute('style','clear:both');
////////        pn.innerHTML = '<span>' + bn + '  ' + nof_posts + '/' + nof_files + '/' + page_no + '  </span>';
//////////        pn.innerHTML = '<span><span>' + bn + '  </span><span></span><span>' + nof_posts + '/' + nof_files + '/' + page_no + '  </span></span>';
////////        var flags = th.getElementsByClassName('flag');
////////        for (var i=0;i<flags.length;i++) {
////////          pn.appendChild(flags[i].cloneNode(false));
//////////          pn.appendChild(document.createTextNode(' '));
////////        }
////////        th.insertBefore(pn,th.getElementsByClassName('post op')[0]);
////////      }
////////      return [nof_posts,nof_files];
////////    },
////////    insert_footer2 : function(th,type,nums,nums2){
////////      var str_add = ((pref.catalog_footer_show_nof_rep_to_me)? nums[1]+'/' : '' ) +(nums2[2]-nums[2]);
////////      if (type==='page') {
////////        var footer = th.getElementsByTagName('div')['catalog_footer'];
//////////        footer.childNodes[0].childNodes[1].innerHTML = nums[1] + '/' + (nums2[2]-nums[2]) + '/';
//////////        footer.childNodes[0].innerHTML = footer.childNodes[0].innerHTML.replace(/  /,'  '+ nums[1] + '/' + (nums2[2]-nums[2]) + '/');
////////        var str = footer.childNodes[0].innerHTML;
////////        var fields = str.replace(/[^ ]*  /,'').split('/');
////////        if (fields.length>3) fields.splice(0,fields.length-3);
////////        footer.childNodes[0].innerHTML = str.replace(/  .*/,'  ') + ((nums[0]>=0)? str_add + '/' :'') + fields.join('/');
////////      } else {
////////        var footer = th.getElementsByTagName('strong')[0];
////////        footer.childNodes[0].innerHTML = (nums[0]>=0)? 'U: '+ str_add + ' / ' : '';
////////      } 
////////    },
//    prep_footer3 : function(footer,board){
////      th.footer.setAttribute('name',pref.script_prefix+'_footer');
//      if (pref.catalog_footer_show_board_name) {
////        footer.innerHTML = '<span name="'+pref.script_prefix+'_footer">' + footer.innerHTML +'</span>' + '&emsp;' + board;
//        footer.innerHTML = '<span>' + footer.innerHTML + '</span>' + '&emsp;' + board;
//        footer = footer.childNodes[0];
//      }
//      return footer;
//    },
//    insert_footer3 : function(footer,nums,nums2){
//      var str_add = ((pref.catalog_footer_show_nof_rep_to_me)? nums[1]+'/' : '' ) +(nums2[2]-nums[2]);
//      var str = (pref.catalog_footer_design==='native')? ((nums[0]>=0)? 'U: '+ str_add + ' / ' : '') + 'R: '+(nums2[2]-1) + ' / I: '+nums2[3]
//                                                       : ((nums[0]>=0)? str_add + '/' : '') + nums2[2] + '/'+nums2[3]; // trial.
//      footer.innerHTML = str;
//    },
////////    check_reply_to_me : function(name,dbt,nums,value,date,pool){
////////      var obj ;
////////      var time_check = (nums[6]==nums[0])? nums[3] : nums[0];
////////      if (dbt[2][0]==='t') {
////////        obj = ('response' in value)? value.response.posts : JSON.parse(value.responseText).posts;
////////        var images = 0;
////////        for (var i=0;i<obj.length;i++) {
////////          if ('filename' in obj[i]) images++;
////////          if (obj[i].extra_files) for (var j=0;j<obj[i].extra_files.length;j++) if ('filename' in obj[i].extra_files[j]) images++;
////////          obj[i].time *= 1000;
//////////obj[i].time += - pref.localtime_offset*3600000; // BUG PATCH.
////////          if (obj[i].ext==='.jpeg' || obj[i].ext==='.gif') obj[i].ext = '.jpg';
////////          if (obj[i].filename) obj[i].icon =  'https://' + site2['8chan'].domain_url + dbt[1] + 'thumb/' + obj[i].tim + obj[i].ext;
////////        }
////////        obj[0].images = images;
//////////        if (obj[obj.length-1].ext==='.jpeg' || obj[obj.length-1].ext==='.gif') obj[obj.length-1].ext = '.jpg';
//////////        if (obj[obj.length-1].filename) obj[obj.length-1].icon =  'https://' + site2['8chan'].domain_url + dbt[1] + 'thumb/' + obj[obj.length-1].tim + obj[obj.length-1].ext;
////////        pool.sticky = obj[0].sticky;
////////      } else obj = site2['8chan'].get_posts2(value,pool,time_check);
//////////      date = [obj[obj.length-1].time, date[1], obj.length, obj[0].images];
//////////      date[0] = obj[obj.length-1].time; // CAUSE BUG IN PAGE, THIS PREVENT REVISING POST'S INFO FOR POPUPS. AND MUST BE FIXED TIMEZONE MISUNDERSTOOD.
//////////if (date[4] != obj[obj.length-1].time) console.log('find: '+name+', '+date[4]+' -> '+obj[obj.length-1].time+', '+(obj[obj.length-1].time-date[4]));
////////      date[4] = obj[obj.length-1].time;
//////////                            IF UNCOMMENT, CAUSE BLINKS BECAUSE USING DIFFERENT METHOD TO EVALUATE,
//////////                            IF COMMENT, DELAYS UPDATE AND CAUSE BUG IN PAGE MODE.
//////////      date[2] = obj.length; // CAUSE BUG IN PAGE, THIS CAUSE INCONSISTENCY BETWEEN FOOTER AND POPUP COMMENTS.
//////////      date[3] = obj[0].images; // CAUSE BUG IN PAGE, THIS CAUSE INCONSISTENCY BETWEEN FOOTER AND POPUP COMMENTS.
////////
//////////      var i = 0;
//////////      while (i<obj.length && (!obj[i] || obj[i].time<=time_check)) i++;
////////      var i = obj.length;
////////      while (i-1>=0 && obj[i-1] && obj[i-1].time>time_check) i--;
//////////console.log(name+', '+obj.length+', '+(obj.length-i));
//////////      nums[2] = i;
////////      var rep_to_me = (nums[6]==nums[0])? nums[1] : 0;
////////      var rep       = (nums[6]==nums[0])? nums[7] : 0;
////////      nums[4] = [];
////////      if (nums[3]<nums[0]) nums[3]=nums[0];
////////      if (i<obj.length ) {
////////        while (i<obj.length) {
////////          if (pref.catalog_footer_ignore_my_own_posts && (dbt[1]+obj[i].no in site3['8chan'].own_posts)) {i++;continue;}
////////          rep++;
//////////          if (obj[i].time>nums[3]) nums[4].push({icon:obj[obj.length-1].icon, body:obj[obj.length-1].com, time:obj[obj.length-1].time, to_me:false});
////////          if (obj[i].time>nums[3]) nums[4].push({icon:obj[i].icon, body:obj[i].com, time:obj[i].time, to_me:false});
////////          var tgts = [];
////////          if (obj[i].com) {
////////            var anchors = obj[i].com.match(/&gt;&gt;[0-9]+/g);
////////            if (anchors) for (var j=0;j<anchors.length;j++) tgts.push(dbt[1]+anchors[j].substr(8));
////////            anchors = obj[i].com.match(/&gt;&gt;&gt;\/[0-9A-z_\+]+\/[0-9]+/g);
////////            if (anchors) for (var j=0;j<anchors.length;j++) tgts.push(anchors[j].substr(12));
//////////console.log(tgts);
////////            for (var j=0;j<tgts.length;j++) {
////////              if (site3['8chan'].own_posts[tgts[j]]===null) {
////////                rep_to_me++;
////////                if (obj[i].time>nums[3]) nums[4][nums[4].length-1].to_me = true;
//////////console.log(dbt[2]+', >>'+tgts[j]);
////////                break;
////////          }}}
//////////          var anchors = (obj[i].com)? obj[i].com.match(/&gt;&gt;[0-9]+/g) : null; // working code.
//////////          if (anchors) {
//////////            for (var j=0;j<anchors.length;j++) {
//////////              var tgt = anchors[j].substr(8);
//////////              if (site3['8chan'].own_posts[dbt[1]+tgt]===null) {
//////////                rep_to_me++;
//////////                if (obj[i].time>nums[3]) nums[4][nums[4].length-1].to_me = true;
////////////console.log(dbt[2]+', >>'+tgt);
//////////                break;
//////////          }}}
//////////          anchors = (obj[i].com)? obj[i].com.match(/&gt;&gt;&gt;\/[0-9A-z_\+]+\/[0-9]+/g) : null;
//////////          if (anchors) {
//////////            for (var j=0;j<anchors.length;j++) {
//////////              var tgt = anchors[j].substr(12);
//////////              if (site3['8chan'].own_posts[tgt]===null) {
//////////                rep_to_me++;
//////////                if (obj[i].time>nums[3]) nums[4][nums[4].length-1].to_me = true;
//////////                break;
//////////          }}} 
////////          i++;
////////        }
////////      }
////////      nums[2] = obj.length - rep;
////////      nums[1] = rep_to_me;
////////      nums[3] = obj[obj.length-1].time;
////////      nums[6] = nums[0];
////////      nums[7] = rep;
////////    },
////////    get_posts2 : function(doc,pool,time_check) {
////////      var obj = [];
////////      var posts = doc.getElementsByClassName('post');
//////////      for (var i=0;i<posts.length;i++) {
////////      var i=posts.length-1;
////////      while (i>=0) {
////////        var image = posts[i].getElementsByClassName('post-image');
////////        image = (image[0])? image[0].getAttribute('src') : undefined;
////////        var time = Date.parse(posts[i].getElementsByTagName('time')[0].getAttribute('datetime'));
////////        obj[i] = {
////////          time: time,
////////          com:  posts[i].getElementsByClassName('body')[0].innerHTML,
////////          no:   parseInt(posts[i].getElementsByClassName('post_no')[0].id.substr(8),10),
////////          icon: image
////////        }
////////        if (time<=time_check && i!=0) i=0;
////////        else i--;
////////      }
//////////      var image = posts[posts.length-1].getElementsByClassName('post-image');
//////////      obj[obj.length-1].icon = (image[0])? image[0].src : undefined;
////////      var files = doc.getElementsByClassName('thread')[0].getElementsByClassName('file');
//////////      for (var i=files.length-1;i>=0;i--) if (files[i].tagName!=='DIV') files[i].remove(); // slow?
////////      var nof_files = 0;
////////      for (var i=files.length-1;i>=0;i--) if (files[i].tagName==='DIV') nof_files++;
////////      var op_images = doc.getElementsByClassName('thread')[0].getElementsByClassName('files');
////////      op_images = (!op_images[0])? 0 : op_images[0].getElementsByClassName('file').length;
//////////      obj[0].images = files.length - op_images;
////////      obj[0].images = nof_files - op_images;
////////      pool.sticky = doc.getElementsByClassName('fa-thumb-tack').length!=0
////////      return obj;
////////    },
    get_post_offsetTop : function(doc,num) {
      return doc.getElementsByClassName('post')[num].offsetTop;
    },
    get_icon : function(pn,type,kind,tgt_th16){
      return (type==='catalog')? this.add_icon(pn,type,kind,tgt_th16) :
             (kind==='sticky')? pn.getElementsByClassName('fa-thumb-tack')[0] :
             null;
    },
    add_icon : function(pn,type,kind,tgt_th16){
      if (pn) {
        var del_tgt = tgt_th16['icon_'+kind];
        if (!del_tgt) {
          var count = 0;
          if (tgt_th16['icon_sticky']) count++;
          if (tgt_th16['icon_show_always']) count++;
          var icon = document.createElement('i');
          icon.setAttribute('class',(kind==='sticky')? 'fa fa-thumb-tack' : 'fa');
          if (kind==='show_always') icon.textContent = '\u2605';
          var ref;
          if (type==='catalog') {
            icon.setAttribute('style','position:absolute;left:' + (16*count) + 'px');
            ref = pn.getElementsByClassName('thread')[0];
            ref.insertBefore(icon,ref.firstChild);
          } else {
            var op = pn.getElementsByClassName('op')[0];
            ref = op.getElementsByClassName('mentioned')[0] || op.getElementsByClassName('post_no')[1].nextSibling;
//            ref = pn.getElementsByClassName('mentioned')[0] || Array.prototype.filter.call(pn.getElementsByTagName('a'),function(dom){return dom.textContent==='[Reply]';})[0];
            ref.parentNode.insertBefore(icon,ref);
          }
          return icon;
        } else del_tgt.parentNode.removeChild(del_tgt);
      }
      return null;
    },
//    add_icon : function(th,type,kind,tgt_th16){
//      if (type==='catalog') {
//        var parent = th.getElementsByClassName('thread')[0];
//        if (parent) {
//          var del_tgt = tgt_th16['icon_'+kind];
//          if (!del_tgt) {
//            var count = 0;
//            if (tgt_th16['icon_sticky']) count++;
//            if (tgt_th16['icon_show_always']) count++;
//            var icon = document.createElement('i');
//            icon.setAttribute('class',(kind==='sticky')? 'fa fa-thumb-tack' : 'fa');
//            icon.setAttribute('style','position:absolute;left:' + (16*count) + 'px');
//            if (kind==='show_always') icon.textContent = '\u2605';
//            parent.insertBefore(icon,parent.firstChild);
//            return icon;
//          } else del_tgt.parentNode.removeChild(del_tgt);
//        }
//      }
//      return null;
//    },
    favicon: {
      __proto__: site2['DEFAULT'].favicon,
      none: '/favicon.ico',
      reply: 'png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQElEQVR42mNgGEbg/5n/GJgYORQFDQ0IjK4BmxxWzehsQnJYBdFtxCWH1QBcrkKWw2sAWS6gKAwojgWqpIORDQBVkjfW5KYpFQAAAABJRU5ErkJggg==',
      reply_to_me: 'png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWUlEQVR42mNgAIH/Z/4zNDRgYpA4UQBqADIYZAaAaHRMtAEwjB42cEPQFaCzCclhFcQWK9jk0A1A8QJW2xgYiDeAJBdQFAbYAhLdRryxgByVuOKaYDoY2QAAcHCIXLRHYMUAAAAASUVORK5CYII='
    },
//    get_op_image_url: function(th,type){
//      var img = th.getElementsByTagName('img')[0];
//      return (img)? img.src : undefined; // patch.
//    },
    time_revised_check: function(nof_ths){return nof_ths>300;},
    format_thread_layout : function(th){
      site2.common.add_attribute_by_tagname(th,'img','style','margin:0px');
      site2.common.add_attribute_by_tagname(th,'iframe','style','margin:0px');
      site2.common.add_attribute_by_classname(th,'post','style','padding:0px');
      site2.common.add_attribute_by_classname(th,'intro','style','margin:0px');
      site2.common.add_attribute_by_classname(th,'body','style','margin:12px 5px');
    },
    format_thread_contents : function(th){
      site2.common.remove_by_classname(th,'delete');
//      site2.common.remove_by_tagname(th,'hr');
//      site2.common.remove_by_tagname(th,'br');
      site2.common.remove_by_classname(th,'omitted');
    },
    localtime: function(pn){
      var times = pn.getElementsByTagName('time');
      for (var i=0;i<times.length;i++) times[i].textContent = site2.common.change_utc_to_local(times[i].getAttribute('datetime'));
    },
    format_remove_tn_area_size: function(th){
      var files = th.getElementsByClassName('file');
      for (var i=0;i<files.length;i++){
        var file_style = files[i].getAttribute('style');
        if (file_style) {
          file_style = ((file_style)? file_style + ';' : '') + 'float:left;';
          if (file_style.indexOf('width')!=-1) file_style = file_style.replace(/width:[^;]*(;|$)/,'');
          if (file_style.indexOf('height')!=-1) file_style = file_style.replace(/height:[^;]*(;|$)/,'');
          files[i].setAttribute('style',file_style);
        }
      }
    },
//    get_time_of_post_in_utc : function(post){ // working code
//      return Date.parse(post.getElementsByTagName('time')[0].getAttribute('datetime'));
//    },
    mark_newer_posts: function(th,date,unmark, short_cut) {
//      return site2.common.mark_newer_posts('8chan',th.getElementsByClassName('post'),date,'border:2px solid red','border: none','class','post');
      return site2['DEFAULT'].mark_newer_posts('8chan',th.getElementsByClassName('post'),date,null,unmark, short_cut);
    },
//    unmark_post_from_event: function() {
//      this.setAttribute('style','border: none');
//      this.removeEventListener('mouseover', site2['8chan'].unmark_post_from_event, false);
//    },
//    mark_newer_posts : function(th,date){
//      var marked_first_post = null;
////      var offset_top = 0;
//      var times = th.getElementsByTagName('time');
//      for (var i=times.length-1;i>=0;i--) {
//        var mark = date<Date.parse(times[i].getAttribute('datetime'))-pref.localtime_offset*3600000;
//        var reply = times[i].parentNode;
//        while (reply.className.search(/post/)==-1) reply = reply.parentNode;
//        if (mark) {
//          reply.setAttribute('style','border: 2px solid red');
//          marked_first_post = reply;
////          offset_top = reply.offsetTop;
//        } else reply.setAttribute('style','border: none');
//      }
////      return offset_top;
//      return marked_first_post;
//    },
    get_owners_recommendation: function(){
      var blotter = document.getElementsByClassName('blotter')[0];
      if (blotter) {
        or_str = document.getElementsByClassName('blotter')[0][brwsr.innerText];
        var kwd = 'Recommendation: ';
        var idx = or_str.indexOf(kwd);
        if (idx!=-1) return or_str.substr(idx+kwd.length);
      }
      return '';
    },
////////    thread2headline : function(doc){
////////      return site2.common.thread2headline(doc,'8chan');
////////    },
//    get_json_url_thread: function(board,thread){
//      return site2['8chan'].protocol + '//8chan.co' + board +'res/' + thread + '.json';
//    },
    get_json_url_catalog: function(board){
      return site2['8chan'].protocol + '//' + site2['8chan'].domain_url + board +'catalog.json';
    },
    thread2search_obj: function(th){
      var coms  = aggregate_info(th.getElementsByClassName('body'));
      var subs  = aggregate_info(th.getElementsByClassName('subject'));
      var names = aggregate_info(th.getElementsByClassName('name'));

      var files = th.getElementsByClassName('files');
      var filenames = ['',''];
      if (files.length!=0) {
        for (var i=0;i<files.length;i++) {
          var files_in_post = files[i].getElementsByClassName('unimportant');
          filenames[i] = '';
          for (var j=0;j<files_in_post.length;j++) {
            if (files_in_post[j].getElementsByTagName('a').length!=0) filenames[i] = filenames[i] + files_in_post[j].getElementsByTagName('a')[0][brwsr.innerText] + '\n';
            if (files_in_post[j].getElementsByTagName('span').length!=0) filenames[i] = filenames[i] + files_in_post[j].getElementsByTagName('span')[0][brwsr.innerText] + '\n';
          }
        }
        for (var i=2;i<filenames.length;i++) filenames[1] = filenames[1] + filenames[i] + '\n';
        if (files[0].parentNode!=th) {
          filenames[1] = filenames[0] + '\n' + filenames[1];
          filenames[0] = '';
        }
      }
      return [coms[0], subs[0], names[0], filenames[0], coms[1], subs[1], names[1], filenames[1]];

      function aggregate_info(pns){
        if (pns.length!=0) {
          var parent = pns[0].parentNode;
          while (parent.classList.contains('post')) parent = parent.parentNode;
          var op_idx = (!parent.classList.contains('op'))? 0 : -1;
          var op = (op_idx>=0)? pns[0][brwsr.innerText] : '';
          var posts = '';
          for (var i=op_idx+1;i<pns.length;i++) posts = posts + pns[i][brwsr.innerText] + '\n';
          return [op, posts];
        } return ['',''];
      }
    },
    parse_json_thread: function(txt,from_http){
      var obj = {posts: []};
      var uids = {};
      var nof_uids = 0;
      var posts = document.getElementsByClassName('post');
      for (var i=0;i<posts.length;i++) {
        obj.posts[i] = {};
        obj.posts[i].no = posts[i].id.replace(/op_/,'').replace(/reply_/,'');
        var id = posts[i].getElementsByClassName('poster_id')[0].textContent;
        obj.posts[i].id = id;
        if (uids[id]===undefined) {
          nof_uids++;
          uids[id] = 1;
        }
        obj.posts[i].unique_ips = nof_uids;
      }
      return obj;
    },
    uip_check: function(callback){
      callback(0,200,'');
    },
    uip_tgt_post : function(no){
      var pn = document.getElementById('reply_'+no);
      if (pn) return pn;
      else return document.getElementById('op_'+no);
    },
    uip_post_num : function(tgt_post){
      return tgt_post.getElementsByClassName('intro');
    },
//    catalog_native_prep0: function(threads,callback,pn_filter,pn_tb,func_sel){
////      var node_ref = document.getElementsByClassName('catalog_search')[0].nextSibling;  // FF doesn't work.
//      var node_ref = document.getElementsByClassName('threads')[0];
//      node_ref.parentNode.insertBefore(pn_tb,node_ref);
//      node_ref.parentNode.insertBefore(pn_filter,node_ref);
//
//      site2['8chan'].catalog_from_native(Date.now(),document,threads,null);
//
//      document.getElementById('sort_by').addEventListener('change',func_event,false);
//      return function(){document.getElementById('sort_by').removeEventListener('change',func_event,false);};
//      function func_event(){
//        pref.catalog.indexing = document.getElementById('sort_by').selectedIndex;
//        func_sel();
//      }
//
////      var mixs = document.getElementsByClassName('mix');
////      var date_load = Date.now();
////      for (var i=0;i<mixs.length;i++) site2['8chan'].catalog_from_native_1(threads,mixs[i],date_load);
////      for (var i=0;i<mixs.length;i++) {
////        var url  = mixs[i].getElementsByTagName('a')[0].href;
////        mixs[i].getElementsByTagName('a')[0].removeAttribute('href');
////        var name = url.replace(/.*8chan\.co/,'8chan').replace(/res\//,'').replace(/\.html/,'');
////        var date = [0,0,0,0];
////        var date_load = 0;
////        var page_no = 0;
////        threads[name] = [mixs[i], false, null,
////                         [mixs[i].innerHTML, '8chan'],
////                         mixs[i][brwsr.innerText], null, null, url, date, true,
////                         null,
////                         null, null, date_load, page_no, 0];
////      }
////      http_req.get('catalog',site.nickname+site.board,site.protocol+'//8chan.co'+site.board+'catalog.json',site2['8chan'].catalog_from_json,false,false,[threads,callback,null,site.board]);
//    },
    catalog_native_prep: function(date,pn_filter,pn_tb,pn_hi, embed_catalog){
//      var node_ref = document.getElementsByClassName('catalog_search')[0].nextSibling;  // FF doesn't work.
      var node_ref = (site.whereami==='catalog')? document.getElementsByClassName('threads')[0]
                                                : document.getElementsByName('postcontrols')[0];
      cnst.tb_prep_for_embed(pn_tb);
      if (site.whereami==='catalog') {
        var selector_native = document.getElementById('sort_by');
        if (selector_native.selectedIndex!=0) {
          selector_native.selectedIndex = 0;
          var evt = document.createEvent('UIEvents');
          evt.initUIEvent('change', false, true, window, 1);
          selector_native.dispatchEvent(evt);
        }
        selector_native.style.display = 'none';
        document.getElementById('image_size').addEventListener('change', site2['8chan'].catalog_native_size_changed, false);
        var pn_tb_new = document.createElement('span');
        while (pn_tb.firstChild) pn_tb_new.appendChild(pn_tb.firstChild);
        pn_tb = pn_tb_new;
        pn_tb.appendChild(pn_tb.removeChild(pn_tb.childNodes[3]).firstChild);
      } else if (site.whereami==='page') {
        var pctrls = document.getElementsByName('postcontrols')[0];
        if (!pref.catalog_expand_with_hr || embed_catalog) {for (var i=pctrls.childNodes.length-1;i>=0;i--) if (pctrls.childNodes[i].tagName==='HR') pctrls.removeChild(pctrls.childNodes[i]);}
        else for (var i=pctrls.childNodes.length-1;i>=0;i--) if (pctrls.childNodes[i].tagName==='HR') pctrls.childNodes[i].setAttribute('class',pref.script_prefix+'_hs');
        pctrls.parentNode.insertBefore(document.createElement('hr'),pctrls.nextSibling);
      }
//      node_ref.parentNode.insertBefore(pn_hi,node_ref);
      node_ref.parentNode.insertBefore(pn_tb,node_ref);
      node_ref.parentNode.insertBefore(pn_filter,node_ref);
      var selector_catchan = pn_filter.getElementsByTagName('select')['catalog.indexing'];
      if (site.whereami==='catalog') selector_native.parentNode.insertBefore(selector_catchan,selector_native);
      else pn_tb.childNodes[3].insertBefore(selector_catchan,pn_tb.childNodes[3].firstChild);
//      pn_tb.childNodes[0].setAttribute('style',pn_tb.childNodes[0].getAttribute('style')+';display:none');
//      pn_tb.childNodes[1].setAttribute('style',pn_tb.childNodes[1].getAttribute('style')+';display:none');
////////      return site2['8chan'].catalog_from_native(date,document,site.board,site.whereami+'_html');
    },
    catalog_native_size: (document.getElementById('image_size'))? document.getElementById('image_size').value : 'small',
    catalog_native_size_changed: function(){site2['8chan'].catalog_native_size = this.value;},
    catalog_get_native_area: function(){
      if (site.whereami==='catalog') return document.getElementById('Grid');
      return document.getElementsByName('postcontrols')[0];
////      else { // working code.
////        var pc = document.getElementsByName('postcontrols')[0];
////        return pc.insertBefore(document.createElement('div'),pc.firstChild);
////      }
    },
////////    catalog_from_native : function(date,doc,board,type) { // working code.
////////      var ths;
////////if (pref.test_mode['0']) {
////////      ths = {domain:'8chan', board:board, pn:doc};
////////      this.parse_funcs['catalog_html'].entry(ths,this.parse_funcs['catalog_html']['full_hier']);
////////      return ths.ths;
////////} else {
////////////      var parse_obj = {domain:'8chan', board:board, parse_funcs:site2['8chan'].parse_funcs[type], __proto__:site4.parse_funcs_on_demand};
////////////      ths = {pn:doc, __proto__:parse_obj};
////////////      return ths.ths;
////////      return site2[this.nickname].wrap_to_parse.get(doc, this.nickname, board, type);
////////}
////////    },
//    catalog_from_native : function(date,doc,board) {
//      var ths;
//if (pref.test_mode['0']) {
//      ths = {domain:'8chan', board:board, pn:doc};
//      this.parse_funcs['catalog_html'].entry(ths,this.parse_funcs['catalog_html']['full_hier']);
//} else {
////      ths = {domain:'8chan', board:board, pn:doc, parse_funcs:this.parse_funcs['catalog_html'], __proto__:site4.parse_funcs_on_demand};
//      var parse_obj = {domain:'8chan', board:board, parse_funcs:site2['8chan'].parse_funcs['catalog_html'], __proto__:site4.parse_funcs_on_demand};
//      ths = {pn:doc, __proto__:parse_obj};
//}
//      return ths.ths;
//    },
//    catalog_from_native : function(date,doc,board) {
//      var mixs = doc.getElementsByClassName('mix');
//      var ths = [];
////      for (var i=0;i<mixs.length;i++) {
////        ths.push(site2['8chan'].catalog_from_native_1(mixs[i]));
////        if (mixs[i].parentNode) mixs[i].parentNode.removeChild(mixs[i]);
////      }
////var time_in = Date.now();
//      for (var i=0;i<mixs.length;i++) if (mixs[i].tagName==='DIV') ths.push(site2['8chan'].catalog_from_native_1(mixs[i],board));
////console.log('aaa: '+(Date.now()-time_in));
////      for (var i=0;i<ths.length;i++) if (ths[i].pn.parentNode) ths[i].pn.parentNode.removeChild(ths[i].pn);
//      return ths;
//    },
//    catalog_from_native_1 : function(th,board) {
//      th.getElementsByTagName('a')[0].removeAttribute('href');
//      var sub = th.getElementsByClassName('subject');
//      sub = (sub[0])? sub[0].textContent : '';
//      var opn = th.getElementsByTagName('img')[0].getAttribute('data-name');
//      var op = th[brwsr['innerText']].replace(th.getElementsByTagName('strong')[0][brwsr['innerText']],'');
//      if (sub!=='') op = op.replace(sub,'');
////      if (pref.catalog_footer_show_board_name) th.getElementsByTagName('strong')[0].innerHTML = '<span></span>' + th.getElementsByTagName('strong')[0].innerHTML + '&emsp;' + board;
//      return {
//        pn: th,
//        exist: false,
//        no: th.getElementsByTagName('img')[0].id.replace(/img\-/,''),
//        search_obj: [ op, sub, opn, '', '', '', '', ''],
//        page_no: '?',
//        time_bumped: (parseInt(th.getAttribute('data-bump'),10)-pref.localtime_offset*3600)*1000,
//        time_created : (parseInt(th.getAttribute('data-time'),10)-pref.localtime_offset*3600)*1000,
//        nof_posts: parseInt(th.getAttribute('data-reply'),10) +1,
//        nof_files: parseInt(th.getElementsByClassName('replies')[0].getElementsByTagName('strong')[0].textContent.replace(/.*I: */,''),10),
////        init_func: site2['8chan'].catalog_from_native_init_elem_func,
//        update_func: site2['8chan'].catalog_from_native_update_elem_func,
//        board: board,
//        footer: th.getElementsByTagName('strong')[0], // temporal
//        domain: '8chan', // temporal
//        sticky: th.getAttribute('data-sticky')==='true', // temporal
//      }
//    },
//    catalog_from_native_init_elem_func : function(th) {
//      th.setAttribute('class','mix');
//      th.setAttribute('style','display: inline-block;');
//    },
//    catalog_from_native_update_elem_func : function(th,src) {
//      th.setAttribute('data-reply',src.nof_posts);
//      th.setAttribute('data-bump',src.time_bumped);
//      th.setAttribute('data-time',src.time_created);
//    },
//    catalog_from_native_1 : function(th,board) { // working code
//      var th2 = {domain:'8chan', board:board, pn:th};
//      this.parse_funcs['catalog_html'].entry(th2,this.parse_funcs['catalog_html']['full_th']);
//      return th2;
//    },
    parse_funcs : { // vichan
      'catalog_html' : {
//        ths: function(doc) {
//          var ths = this.ths_array(doc,doc.pn.getElementsByClassName('mix'));
//          for (var i=0;i<ths.length;i++) ths[i].pn.getElementsByTagName('a')[0].removeAttribute('href');
//          return ths;
//        },
        ths: function(doc) {return this.ths_array(doc,doc.pn.getElementsByClassName('mix'));},
        no : function(th){return parseInt(th.pn.getElementsByTagName('img')[0].id.substr(4),10);},
        time_bumped: function(th){return parseInt(th.pn.getAttribute('data-bump'),10)*1000;},
        time_created : function(th){return parseInt(th.pn.getAttribute('data-time'),10)*1000;},
        nof_posts: function(th){return parseInt(th.pn.getAttribute('data-reply'),10) +1;},
//        nof_files: function(th){return parseInt(th.pn.getElementsByClassName('replies')[0].getElementsByTagName('strong')[0].textContent.replace(/.*I: */,''),10);},
        nof_files: function(th){return parseInt(th.pn.getElementsByTagName('strong')[0].textContent.replace(/.*I: */,''),10) +1;}, // assumes OP has 1 pic.
        key: function(th){
//          if (!th.hasOwnProperty('no')) th['no'] = this['no'](th);
if (pref.test_mode['0']) {
          if (!th.hasOwnProperty('no')) Object.defineProperty(th,'no',{value:this['no'](th), enumerable:true, configurable:true, writable:true});
}
          return th.domain + th.board + th.no;
        },
        sub: 'DEFAULT.post_html',
        name: function(th){return th.pn.getElementsByTagName('img')[0].getAttribute('data-name');},
        com: function(th){
          return th.pn.getElementsByClassName('replies')[0].innerHTML.replace(/\s*<strong>[^<]*<\/strong>\s*(<br>)*/,'').replace(/\s*$/,'');
        },
        type_com:'html',
//        com: function(th){ // working code.
//if (pref.test_mode['0']) {
//          if (!th.hasOwnProperty('sub')) th.sub = this.sub(th);
//}
//          return th.pn[brwsr.innerText].replace(th.pn.getElementsByTagName('strong')[0][brwsr.innerText],'').replace(th.sub,'');
//        },
        footer: function(th){return th.pn.getElementsByTagName('strong')[0];},
        sticky: function(th){return null;}, // patch
//        format: function(th){th.pn.getElementsByTagName('a')[0].removeAttribute('href');return null;},
        op_img_url: function(th){
          var img = th.pn.getElementsByTagName('img')[0];
          return (img)? img.getAttribute('src') : undefined; // patch.
        },
//        filename: function(th){return th.op_img_url;},
//        missing_info: {time_posted: null, op_img_src_url: null},
////        missing_info_fetch: function(th){scan.list_nup.add_board(th.domain+th.board,0,null,null,true);scan.scan('b',this.nickname)}, // BUG. catalog doesn't contain time_posted.
//        missing_info_fetch: function(th){scan.list_nup.add(th.key,0);scan.scan('t',this.nickname)}, // BUG. catalog doesn't contain time_posted.
        dynamic_image_hover: true,
        missing_info: 2,
        img2src: function(img){
          var lth = this.get_lth_from_node(img);
          if (!lth) return null;
          var src = img.src;
          if (lth.th && lth.th.ext) src = src.replace(/thumb/,'src').replace(/.[^\.]*$/,lth.th.ext);
          else if (lth.th.parse_funcs.missing_info) scan.scan_ui('image_hover', {tgts: [lth.domain+lth.board+'j0'], options:{callback:function(){cataLog.image_hover_reentry(img);}, priority:6}});
          return src;
        },
        get_op_src: 'thread_json',
      },
      'catalog_json' : {
        before_test : ['ths',':ITER',':ALL','ths',['key','time_bumped','nof_posts','nof_files']],
        after_test  : ['time_created','pn','footer'],
        full_hier   : ['ths',':ITER',':ALL','ths',['key','time_bumped','nof_posts','nof_files','pn','footer']],
        ths: 'DEFAULT.catalog_json',
        time_bumped: function(th){return th.last_modified*1000;},
        time_created : function(th){return th.time*1000;},
        nof_posts: function(th){return th.replies+1;},
        nof_files: function(th){return th.images+th.omitted_images;},
        key: function(th){return th.domain + th.board + th.no;},
//        sub: function(th){return ('sub' in th)? th.sub : '';},
//        name: function(th){return ('name' in th)? th.name : '';},
//        com: function(th){return ('com' in th)? th.com : '';},
//        sticky: function(th){return (th.sticky===1);}, // prevent memory leak.
        sub: function(th){return (th.hasOwnProperty('sub'))? th.sub : '';},
        name: function(th){return (th.hasOwnProperty('name'))? th.name : '';},
        com: function(th){return (th.hasOwnProperty('com'))? th.com : '';},
//        sticky: function(th){return (th.hasOwnProperty('sticky'))? th.sticky==='1' : false;},
        op_img_url: 'DEFAULT.common',
////        op_img_url: function(obj) { // working code.
////          return site2[obj.domain].protocol + '//' + site2[obj.domain].domain_url + obj.board + 'thumb/' + obj.tim + ((obj.ext==='.jpg')? '.png' : obj.ext);
//////          return this.protocol+ '//' + site2[obj.domain].domain_url + obj.board + 'thumb/' + obj.tim + ((obj.ext==='.jpg')? '.png' : obj.ext);
////        },
        missing_info: 1,
//        missing_info: null,
//        posts: 'DEFAULT.catalog_json', // DOESN'T WORK
        get_op_src: 'thread_json',
        time_unit: 1000,
        type_com: 'html',
        posts: 'DEFAULT.catalog_json',
        posts_full: 'DEFAULT.catalog_json',
        get_max_page: function(doc){return doc.length;},
        proto: 'catalog_html',
      },
      'page_json' : {
        has_posts: true,
        nof_posts: 'DEFAULT.thread_json', // VICHAN HAS A INCONSISTENCY, thread_json doesn't provide 'replies'.
        nof_files: function(th){return th.posts[0].images+th.posts[0].omitted_images;},
        ths: 'DEFAULT.page_json',
        proto:'thread_json'
      },
      'page_html' : {
        before_test : ['ths',':ITER',':ALL','ths',['key','time_bumped','nof_posts','nof_files']],
//        after_test  : [':ITER',':ALL','posts',['sub','name','com'],'flags'],
        after_test  : ['time_created',':ITER',':ALL','posts',['sub','name','com','flag'],':ITER',':GALL','posts',['flags','flag']],
        before_test_post : ['posts',':ITER',':FL','posts',['time'],'html_org','footer'],
//        ths: function(doc) {
//          var ths = doc.pn.querySelectorAll('div[id^=thread_]');
//          if (ths.length===0) ths = doc.pn.querySelectorAll('div[de-thread]'); // for dollchan archive // doesn't work because of other modification.
//          return this.ths_array(doc,ths);
//        },
        ths: function(doc) {return this.ths_array(doc,doc.pn.querySelectorAll('div[id^=thread_]'));},
        th_init: function(th){
          if (site.whereami!=='page' || !pref.catalog.embed_page) th.pn.removeAttribute('class');
//          var as = th.pn.querySelectot_inheritrAll('.files a');
//          for (var j=0;j<as.length;j++) as[j].removeAttribute('href');
////          for (var j=0;j<as.length;j++) as[j].addEventListener('click',th.parse_funcs.preventDefault,false); // not debugged.
        },
//        th_destroy: function(pn, parse_funcs){
////          var as = pn.querySelectorAll('.files a');
////          for (var j=0;j<as.length;j++) as[j].removeEventListener('click',parse_funcs.preventDefault,false); // not debugged.
//        },
//        ths: function(doc) {
//          var ths = this.ths_array(doc,doc.pn.querySelectorAll('div[id^=thread_]'));
//          if (site.whereami!=='page' || !pref.catalog.embed_page) for (var i=0;i<ths.length;i++) ths[i].pn.removeAttribute('class');
//          for (var i=0;i<ths.length;i++) {
//            var as = ths[i].pn.querySelectorAll('.files a');
//            for (var j=0;j<as.length;j++) as[j].removeAttribute('href');
//          }
//          return ths;
//        },
        no: 'post_html',
//        no : function(th){return parseInt(th.pn.id.substring(th.pn.id.indexOf('_')+1),10);},
////        post_no: 'page_html.no',
        time: function(post){
          var pn_time = post.pn.getElementsByTagName('time')[0]; // old threads doesn't have this.
          return (pn_time)? Date.parse(pn_time.getAttribute('datetime'))/1000 : undefined;
        },
        time_unit:1000, // must be the same as json
////////        time_posted: function(th){
////////if (pref.test_mode['0']) {
////////          if (!th.hasOwnProperty('posts')) this.entry(th,this.before_test_post);
////////}
////////          return th.posts[th.posts.length-1].time;
////////        },
        time_bumped: function(th){ // TO BE FIXED.
////if (pref.test_mode['0']) {
////          if (!th.hasOwnProperty('posts')) this.entry(th,this.before_test_post);
////}
////          return th.posts[th.posts.length-1].time;
          var i=th.posts.length;
          while (--i>=0) {
            var mail = th.posts[i].pn.getElementsByClassName('email')[0];
            if (!mail || mail.href!=='mailto:sage') return th.posts[i].time;
          }
          return undefined;
        },
        time_created : function(th){
if (pref.test_mode['0']) {
          if (!th.hasOwnProperty('posts')) this.entry(th,this.before_test_post);
}
          return th.posts[0].time;
        },
        nof_posts: function(th){
          var nof_posts = th.pn.getElementsByClassName('post').length;
          var nof_files = th.pn.getElementsByClassName('fileinfo').length;
          var om_info   = th.pn.getElementsByClassName('omitted')[0];
          if (om_info) {
            var str = om_info.childNodes[0].textContent.replace(/\n/g,'');
            nof_posts += parseInt(str.replace(/\ post.*/,''),10) || 0;
            nof_files += parseInt('0'+str.replace(/\ image.*/,'').replace(/[^\ ]*\ /g,''),10) || 0;
          }
//          th.nof_files = nof_files;
          Object.defineProperty(th,'nof_files',{value:nof_files, enumerable:true, configurable:true, writable:true});
          return nof_posts;
        },
        nof_files: function(th){
          if (!th.hasOwnProperty('nof_posts')) this['nof_posts'](th);
          return th.nof_files;
        },
        key: function(th){
//          if (!th.hasOwnProperty(('no')) th.no = this.no(th);
if (pref.test_mode['0']) {
          if (!th.hasOwnProperty('no')) Object.defineProperty(th,'no',{value:this['no'](th), enumerable:true, configurable:true, writable:true});
}
          return th.domain + th.board + th.no;
        },
        sub: 'DEFAULT.post_html',
        name: function(post){
          var name = post.pn.getElementsByClassName('name')[0];
          return (name)? name[brwsr.innerText] : '';
        },
        pn_name: 'post_html',
        com:  function(post){
          var com = post.pn.getElementsByClassName('body')[0];
//          return (com)? com[brwsr.innerText] : '';
          return (com)? com.innerHTML : '';
        },
        type_com:'html',
        footer: function(th){return this.insert_footer4(th.pn.getElementsByClassName('post op')[0]);},
//        footer: function(th){
//          var footer = document.createElement('div');
//          footer = th.pn.insertBefore(footer,th.pn.getElementsByClassName('post op')[0]);
//          return footer;
//        },
        sticky: function(th){return (th.pn.getElementsByClassName('fa-thumb-tack').length!=0);},
//        flag: function(post){return post.pn.getElementsByClassName('flag')[0];},
        flag: function(post){
          var flags = post.pn.getElementsByClassName('flag');
          return (flags.length!=0)? document.importNode(flags[0],false) : null;
        },
//        flags: function(th){
//          var flags = th.pn.getElementsByClassName('flag');
//          var pn_flags = [];
//          for (var i=0;i<flags.length;i++) pn_flags.push(flags[i].cloneNode(false));
//          return pn_flags;
//        },
//        flags: function(th){ // for on demand access.
//          var flags = [];
//          var i = th.posts.length - pref.catalog_t2h_num_of_posts;
//          if (i<1) i=1;
//          if (th.posts.length!=0) flags[0] = th.posts[0].flag;
//          while (i<th.posts.length) {
//            if (th.posts[i]) flags[i] = th.posts[i].flag;
//            i++;
//          }
//          return flags;
//        },
        op_img_url: function(th){
          var img = th.pn.getElementsByTagName('img');
          if (img.length>=2) {
            th.op_img_url2 = [];
            for (var i=1;i<img.length;i++) {
              var url2 = img[i].getAttribute('src');
              if (url2) th.op_img_url2[th.op_img_url2.length] = url2;
            }
          }
          return (img && img[0])? img[0].getAttribute('src') : undefined; // patch.
        },
        tn_as: function(th){return th.tn_imgs;},
//        tn_imgs: function(th){
//          var imgs = [];
//          var files = th.pn.getElementsByClassName('file');
//          for (var i=0;i<files.length;i++) imgs[i] = files[i].getElementsByTagName('img')[0];
//          return imgs;
//        },
        tn_imgs: function (th){ // post can be accepted.
          var imgs = [];
          var files = ((th.pn.classList.contains('op'))? th.pn.parentNode : th.pn).getElementsByClassName('files')[0];
          if (files) {
            files = files.getElementsByClassName('file');
            for (var i=0;i<files.length;i++) {
              var tmp = files[i].getElementsByTagName('img')[0] || files[i].getElementsByTagName('video')[0];
//              var tmp = files[i].getElementsByTagName('img')[0];
              if (tmp) imgs[imgs.length] = tmp;
            }
          }
          return imgs;
        },
        get_thread_links : function(th){
          var links = [];
          var as = th.pn.getElementsByClassName('post op')[0].getElementsByTagName('a');
          for (var i=0;i<as.length;i++) {
            if (as[i].textContent==='[Reply]') links.unshift(as[i]);
            if (as[i].textContent==='[Last 50 Posts]') links.push(as[i]);
            if (as[i].classList.contains(pref.script_prefix+'_link')) links.push(as[i]);
          }
          return links;
        },
        get_omitted_info : function(post){return post.pn.getElementsByClassName('omitted')[0];},
        set_omitted_info : function(post, info){post.pn.lastChild.appendChild(info);},
//        replace_omitted_info : function(dst, src){dst.childNodes[0].textContent = src.childNodes[0].textContent;},
        replace_omitted_info2 : function(dst, src){dst.childNodes[0].textContent = (src)? src.childNodes[0].textContent : '';},
        filename: 'thread_html',
        get_op_src: 'thread_json',
      },
      'thread_html' : {
        after_test  : ['time_created',':ITER',':FLx','posts',['sub','name','com','flag'],':ITER',':GFLx','posts',['flags','flag']],
//        'finisher' : function(th){site2['8chan'].remove_posts(th.pn,pref.catalog_t2h_num_of_posts);},
////        pop_post: function(th){ // working code.
////          while (th.idx_pop>=0) {
////            var pn = th.children[th.idx_pop--];
////            if (pn.className && pn.className.indexOf('post')!=-1 && pn.className.indexOf('reply')!=-1) {
////              th.post = {pn:pn, parse_funcs:this, __proto__:th.__proto__};
////              return true;
////            }
////          }
////          return false;
////        },
        get_op_src: 'thread_json',
        filename: function(th){
          var files = ((th.pn.classList.contains('op'))? th.pn.parentNode : th.pn).getElementsByClassName('files')[0];
          if (files) {
            files = files.querySelectorAll(':scope>.file');
            for (var i=0;i<files.length;i++) {
              var fname = files[i].getElementsByTagName('a')[0];
              if (!fname) continue; // file may be deleted.
              fname = fname.textContent;
              if (i===1) th.extra_files = [];
              if (i>=1) th.extra_files[i-1] = {domain:th.domain, board:th.board};
              var tgt = (i===0)? th : th.extra_files[i-1];
              tgt.filename = (th.domain==='lain')? files[i].getElementsByTagName('a')[1].getAttribute('download') // lainchan 2017.04.25- 
                                                 : files[i].getElementsByClassName('postfilename')[0].textContent.replace(/\..*/,'');
              tgt.ext = fname.substr(  fname.indexOf('.'));
              tgt.tim = fname.substr(0,fname.indexOf('.'));
              var info = (th.domain!=='lainjp')? files[i].getElementsByClassName('details')[0].textContent.split(',')
                                               : files[i].getElementsByClassName('unimportant')[0].textContent.split(',');
              tgt.w = parseInt(info[1].substr(0,info[1].indexOf('x')  ),10);
              tgt.h = parseInt(info[1].substr(  info[1].indexOf('x')+1),10);
              var fsize = info[0].split(/\s/);
              fsize[1] = (fsize[1]==='KB')? 1024 : (fsize[1]==='MB')? 1024*1024 : 1;
              tgt.fsize = parseFloat(fsize[0].replace(/\(/,'')) * fsize[1];
              var tn = files[i].querySelector('img.post-image');
              if (tn) {
                tgt.tn_w = parseInt(tn.style.width,10);
                tgt.tn_h = parseInt(tn.style.height,10);
              }
            }
          }
          return (files)? th.filename : undefined;
        },
        proto: 'page_html',
      },
      'thread_json' : {
        nof_posts: function(obj){return obj.posts.length;},
        nof_files: function(obj){
          var count=0;
          for (var i=1;i<obj.posts.length;i++) {
            if (obj.posts[i].filename) count++;
            if (obj.posts[i].extra_files) count += obj.posts[i].extra_files.length;
          }
          return count;
        },
        add_op_img_url: site2['DEFAULT'].parse_parts.add_op_img_url,
//        get_op_src: function(th){return th.op_img_url.replace('thumb','src').replace('.png',th.ext);},
        get_op_src: function(th, img){
          if (!th.ext && th.parse_funcs.missing_info) scan.scan_ui('image_hover', {tgts: [th.domain+th.board+'j0'], options:{callback:function(){cataLog.image_hover_reentry(img);}, priority:6}});
          return (th.ext)? th.op_img_url.replace('thumb','src').replace('.png',th.ext) : img.src;
        },
        pn_name: 'post_html',
        proto: 'DEFAULT.thread_json',
      },
      'post_html': {
        no: function(th){
          var id = th.pn.getAttribute('id');
          return parseInt(id.substring(id.indexOf('_')+1),10);},
        pn_name: function(post){return post.pn.getElementsByClassName('name')[0];},
        time_pn: function(post_pn){return Date.parse(post_pn.getElementsByTagName('time')[0].getAttribute('datetime'));},
//        txt2com: function(txt){
//          txt = txt.replace(/(^>[^>].*$)/mg,'<span class="quote">$1</span>');
//          txt = txt.replace(/\*\*([^(\*\*)]*)((\*\*)|$)/g,'<span class="spoiler">$1</span>');
//          return txt.replace(/\n/g,'<br>');},
        txt2com_spoiler_replace_txt: '<span class="spoiler">$1</span>',
        proto: 'DEFAULT.post_html',
      },
      'post_json': {
        proto: 'DEFAULT.post_json'
      },
    },
    update_posts_remove: function(th_old,i,pnode,merge){
      var tgt = th_old.posts[i].pn;
      if (!merge || tgt.parentNode!==pnode) tgt = tgt.parentNode;
      else this.update_posts_insert_pack(tgt);
      pnode.removeChild(tgt.nextSibling);
      pnode.removeChild(tgt);
    },
    update_posts_insert: function(src,dst,i,j,pnode){
////      var ref = (j==1)? (dst[0].pn.getElementsByClassName('op')[0].nextSibling || null) :
//      var ref = (i==1)? (dst[0].pn.nextSibling || null) :
//                        (dst[dst.length-1].pn.parentNode.nextSibling || null);
//      var ref = (j==0)? (dst[0].pn || null) :
//                (j==1)? (dst[0].pn.nextSibling || null) :
//                (j<dst.length)? (dst[j].pn.parentNode.nextSibling || null) :
//                (dst[dst.length-1].pn.parentNode.nextSibling &&
//                 dst[dst.length-1].pn.parentNode.nextSibling.nextSibling || null);
      var ref = (j<dst.length)? dst[j].pn : null;
//      var ref = dst[(j<dst.length)? j : dst.length-1];
//      ref = (ref)? ref.pn : null;
      var ref_pnode = ref && ref.parentNode;
      if (ref_pnode && ref_pnode!==pnode) ref = ref_pnode; // remove container
//      if (j>=1 && (!merge || ref.parentNode!==pnode)) ref = ref.parentNode; // remove container
      if (j>=dst.length) ref = pnode.getElementsByClassName('clear')[0]; // for universal merge with lazy draw, dst[dst.length-1].pn may remain in old pnode.
//      if (j>=dst.length) ref = ref && ref.nextSibling && ref.nextSibling.nextSibling || null;
      if (!src[i].pn) src[i].pn = this.post_json2html(src[i],src[i].board);
//      pnode.insertBefore(this.post_container(src[i].pn,src[i].no), ref); // working code.
//      pnode.insertBefore(document.createElement('br'),ref);
//      if (ref && ref.parentNode!==pnode) ref = ref.parentNode; // patch for thread merging.
      if (i===0) this.update_posts_insert_pack(src[i].pn);
      if (j===0 && dst[0]) this.update_posts_insert_pack(dst[0].pn);
//      if (j===0 && ref) this.update_posts_insert_pack(dst[0].pn); // BUG???
      var tgt = (j===0 && i===0)? src[i].pn : this.post_container(src[i].pn,src[i].no); // patch for thread merging.
      pnode.insertBefore(tgt, ref);
      pnode.insertBefore(document.createElement('br'),ref);
      if (i===0 && j===0) this.update_posts_insert_unpack(src[i].pn);
//      if (j===0) {
//        ref = dst[0].pn.nextSibling;
//        pnode.insertBefore(this.post_container(dst[0].pn,dst[0].no), ref);
//      }
    },
    update_posts0_class: function(pn,search_result) {
      site2['DEFAULT'].update_posts0_class(pn,search_result);
      this.update_posts_insert_pack_iter(pn, (search_result)? function(prev){prev.classList.remove('CatChan_search_miss');} : 
                                                              function(prev){prev.classList.add('CatChan_search_miss');});
    },
    update_posts_insert_pack: function(pn){
      this.update_posts_insert_pack_iter(pn, function(prev){pn.insertBefore(prev, pn.firstChild);});
    },
    update_posts_insert_pack_iter: function(pn, func){
      var prev = pn.previousSibling;
      while (prev) {
        var prev_prev = prev.previousSibling; // prev is livelist.
        if (prev.classList && (prev.classList.contains(pref.script_prefix+'_footer') || prev.classList.contains('files'))) func(prev);
        if (prev.classList &&  prev.classList.contains('op')) break;
        prev = prev_prev;
      }
    },
    update_posts_insert_unpack: function(pn){
      while (1) {
        var fchild = pn.firstChild;
        if (fchild && fchild.classList && (fchild.classList.contains(pref.script_prefix+'_footer') || fchild.classList.contains('files'))) pn.parentNode.insertBefore(fchild, pn);
        else break;
      }
    },
    add_backlinks_bks: (function(){
      var bks = document.createElement('span');
      bks.setAttribute('class','mentioned unimportant');
      return function(){
        return bks.cloneNode(false);
      };
    })(),
    add_backlinks_add_1: (function(){
      var blk = document.createElement('a');
      blk.setAttribute('class','mentioned'); // mentioned-XXXX in lainchan.
      return function(bks, dbtpth){
        var pn = blk.cloneNode(true);
        pn.setAttribute('href',dbtpth[5]);
        pn.textContent = dbtpth[4];
        pn.onclick = this.backlink_onclick;
//        pn.onmouseover = this.popups_post_entry;
        bks.appendChild(pn);
      };
    })(),
    add_backlinks_bks_query: function(pn){
      return pn.getElementsByClassName('mentioned')[0];
    },
////    add_backlinks: function(pn,backlinks,target,th){
////      var bks_pn = pn.getElementsByClassName('mentioned')[0];
////      var bks = bks_pn || this.add_backlinks_bks();
////      if (!target) bks.innerHTML = '';
////      for (var i=(target || 0);i<backlinks.length;i++) {
////        var dbtp = this.popups_backlink2dbtpth(backlinks[i], th);
////        var domain = dbtp[0];
//////        var board = dbtp[1];
//////        var post_no = dbtp[3];
////        var href = site2[domain].link_dbtp2href(dbtp);
////        if (domain!==site.nickname) href = site2[domain].absolute_link_1(href);
//////        var blk = null; // IS THIS REQUITED???
//////        if (target!==undefined)
//////          for (var j=0;j<bks.childNodes.length;j++)
//////            if (bks.childNodes[j].textContent==='>>'+post_no) {
//////              blk = bks.childNodes[j];
//////              break;
//////            }
//////        if (!blk)
////        this.add_backlinks_add_1(bks, dbtp, href);
////        if (target) break;
////      }
////      if (!bks_pn) {
////        var ref = pn.getElementsByClassName('post_no')[1];
////        var pnode = ref.parentNode;
////        do {ref = ref.nextSibling;} while (ref && ref.tagName==='I');
////        pnode.insertBefore(bks,ref);
////      }
////    },
    add_backlinks_bks_append: function(pn, bks){
      var ref = pn.getElementsByClassName('post_no')[1];
      var pnode = ref.parentNode;
      do {ref = ref.nextSibling;} while (ref && ref.tagName==='I');
      pnode.insertBefore(bks,ref);
    },
    popups_href2dbtp: function(href){ //, src, th){
//      if (href[0]==='#') {
//        href = th.board+'res/'+th.no+'.html'+href;
//        src.setAttribute('href',href);
//      }
      var hrefs = href.split('/');
      var p = hrefs[hrefs.length-1].substr(hrefs[hrefs.length-1].indexOf('#')+1);
      var t = hrefs[hrefs.length-1].substr(0,hrefs[hrefs.length-1].indexOf('.'));
      var b = (hrefs.length>=3)? '/'+hrefs[hrefs.length-3]+'/' : site.board;
      var d = this.nickname;
      return [d,b,t,p];
    },
    link_dbtp2href: function(dbtp){
      return dbtp[1] + 'res/' + dbtp[2] + '.html#' + dbtp[3];
    },
    backlink_onclick: function(){
      highlightReply.call(this,parseInt(this.textContent.substr(2),10));
    },
//    backlink_class: 'mentioned',
    colorID: function(pn) {
      var id = pn.getElementsByClassName('poster_id')[0];
      if (id) {
        var bg = id.textContent;
        var bg_r = parseInt(bg.substr(0,2),16);
        var bg_g = parseInt(bg.substr(2,2),16);
        var bg_b = parseInt(bg.substr(4,2),16);
        var fg = (bg_r + bg_g + bg_b>384)? 0 : 255;
        id.setAttribute('style','padding: 0px 5px; border-radius: 8px; color: rgb('+fg+','+fg+','+fg+'); background-color: rgb('+bg_r+','+bg_g+','+bg_b+');');
      }
    },
//    localtime: function(pn) {
//      var pn_time = pn.getElementsByTagName('time');
//      for (var i=0;i<pn_time.length;i++)
//        pn_time[i].textContent = site2.common.change_utc_to_local(pn_time[i].getAttribute('datetime'));
//    },
//    post_com2txt: function(com){
//      return com.replace(/<[^>]*>/g,' ').replace(/&gt;/g,'>').replace(/&lt;/g,'<').replace(/&amp;/g,'&').replace(/&hellip;/g,'\u2026'); // most of lainchan, speed: 10.62/2.02
//    },
    post_container : function(post_pn,no) {
      var pn = document.createElement('div');
      pn.setAttribute('id','pc'+no);
      pn.setAttribute('class','postcontainer');
      pn.innerHTML = '<div class="sidearrows">&gt;&gt;</div>';
      pn.appendChild(post_pn);
      return pn;
    },
    short_link: function(name, nof_posts, num, kwd_head, kwd_tail){
      var dbt = common_func.fullname2dbt(name);
      return (nof_posts>100)? '<a href="' +dbt[1]+ 'res/' +dbt[2]+ '+50.html" class="' + pref.script_prefix + '_link' + '">'+kwd_head+'50'+kwd_tail+'</a>' : '';
    },
    post_json2html : function(post, board, op, short_link) {
      var pn = document.createElement('div');
      var time_unit = (post.parse_funcs && post.parse_funcs.time_unit) || 1;
      var date = new Date((post.time || 0) * time_unit);
      var html_str =
        '<div class="post ' +((op)? 'op':'reply')+ '" id="reply_'+post.no+'" style="border: none">'+
//        '<div class="post reply" id="reply_'+post.no+'" style="border: none">'+
          '<p class="intro">'+
            '<input type="checkbox" class="delete" name="delete_'+post.no+'" id="delete_'+post.no+'">'+
            '<label for="delete_'+post.no+'">'+
              ((post.sub)? '<span class="subject">'+post.sub+ ' </span>' : '')+
              ((post.email)? '<a class="email" href="mailto:' + post.email + '">' : '') +
                '<span class="name">'+(post.name || '')+'</span>'+
                ((post.trip)? '<span class="trip">' + post.trip + '</span>' : '') +
              ((post.capcode)? '<span class="capcode" style="color:orange;font-weight:bold">## ' + post.capcode + '</span>' : '') +
              ((post.email)? '</a> ' : ' ') +
              ((post.country)? '<img class="flag flag-' + post.country.toLowerCase() + '" src="/static/blank.gif" style="width:16px;height:11px;" alt="' + post.country_name + '" title="' + post.country_name +'"> ' : ' ')+
              '<time datetime="'+ date.toISOString() + '">' + date.toLocaleString()+'</time>'+
            '</label>'+
            ((post.id)? '<span class="poster_id">'+post.id+'</span>' : '')+
            '&nbsp;'+
            '<a class="post_no" id="post_no_'+post.no+'">No.</a>'+
//            '<a class="post_no" onclick="citeReply(12486)" href="/tech/res/12393.html#q12486">12486</a>'+
            '<a class="post_no">'+post.no+'</a>'+
            ((op)? ('<a href="' + site2[post.domain].make_url4([post.domain, board, post.no, 'thread_html'])[0] +'">[Reply]</a>'+
//            ((op)? ('<a href="' +board+ 'res/' +post.no+ '.html">[Reply]</a>'+
                   ((short_link)? short_link : '')) : '') +
//////////            '<span class="mentioned unimportant"><a class="mentioned-12497" onclick="highlightReply('12497');" href="#12497">&gt;&gt;12497</a></span>'+
          '</p>';
      if (post.filename) {
        html_str += '<div class="files">' +
                    this.post_json2html_file(post,board, post.extra_files);
        if (post.extra_files) for (var i=0;i<post.extra_files.length;i++) html_str += this.post_json2html_file(post.extra_files[i],board, true);
        html_str += '</div>';
      }
      html_str +=
          '<div class="body">'+ ((post.com)? post.com : '') +
//////////            '<a onclick="highlightReply('12446');" href="/tech/res/12393.html#12446">&gt;&gt;12446</a><br>'+
//////////            '<a onclick="highlightReply('12403');" href="/tech/res/12393.html#12403">&gt;&gt;12403</a><br>'+
//////////            '<span class="quote"><br>&gt;people saying nice things about openstack</span><br><br>Thanks, lainons. I work on developing openstack and people seem to love complaining about it, so it's heartening to hear somewhat happy people.'+
          '</div>'+
        '</div>';
      pn.innerHTML = html_str;
      return pn.childNodes[0];
    },
    post_pn2ce: function(pn){
      return (pn.lastChild.className==='body')? pn.lastChild : pn.getElementsByClassName('body')[0];
    },
    post_json2html_file : function(post, board, multifile) {
      var fsize_str = (((post.fsize>1048576)? post.fsize/1048576 : post.fsize/1024)+0.005).toString();
      fsize_str = fsize_str.substr(0,fsize_str.indexOf('.')+3) + ((post.fsize>1048576)? ' MB' : ' KB');
      var fname_server = site2[post.domain].post_json2html_fname_server(post);
      var fname = site2[post.domain].post_json2html_fname(post);
      var furl = site2[post.domain].catalog_json2html3_src(post,board);
      var turl = site2[post.domain].catalog_json2html3_thumbnail(post,board);
      var html_str = 
              '<div class="file' + ((multifile)?' multifile':'')+'"' +((multifile)?' style="width:'+(post.tn_w+40)+'px"':'') +'>'+
                '<p class="fileinfo">File: '+
                  '<a href="'+furl+'">'+fname_server+'</a> '+
                  '<span class="details">('+fsize_str+', '+post.w+'x'+post.h+', '+
                    '<span class="postfilename">'+fname+'</span>) '+
////////                  '<span class="unimportant image_id">'+
//////////                    '<a href="http://imgops.com/https://lainchan.org/tech/src/1445201930315.jpg" target="_blank">ImgOps</a>'+
//////////                    '<a href="http://regex.info/exif.cgi?url=https://lainchan.org/tech/src/1445201930315.jpg" target="_blank">Exif</a>'+
//////////                    '<a href="http://iqdb.org/?url=https://lainchan.org/tech/src/1445201930315.jpg" target="_blank">iqdb</a>'+
////////                  '</span>'+
                  '</span>'+
                '</p>'+
                '<a href="'+furl+'" target="_blank">'+
                  ((post.ext!=='.webm')? '<img class="post-image" src="'+turl+'" style="width: '+post.tn_w+'px; height: '+post.tn_h+'px; max-width: 98%;" alt=""'+
                                         ((post.tn_w===128 && post.tn_h===128)? 'onerror="this.onerror=null;this.src=\'/static/spoiler.png\';"' : '')+ '>' : // vichan doesn't have any information about spoilered.
                                         '<video class="post-image" src="'+furl+'" style="width: '+post.tn_w+'px; height: '+post.tn_h+'px; max-width: 98%;">')+
                '</a>'+
              '</div>';
      return html_str;
    },
    page_json2html3_skelton: function(obj, both){
      var th = document.createElement('div');
      th.setAttribute('class','thread');
      th.setAttribute('id','thread_'+obj.no);
      th.setAttribute('data-board',obj.board.slice(1,-1));
//      th.setAttribute('style','float: left; overflow: hidden;');
      var br = document.createElement('br');
      br.setAttribute('class','clear');
      th.appendChild(br);
      th.appendChild(document.createElement('hr'));
      return (both)? [th,br] : th;
    },
    page_json2html3 : function(obj,board,thumb_url, assign_pn) { // TEMPORAL, USE thumb_url TO MIMIC.
      var doms = this.page_json2html3_skelton(obj,true);
      var th = doms[0];
      var ref = doms[1];
      var op = this.post_json2html((obj.posts && obj.posts[0])? obj.posts[0] : obj, board, true, site2[obj.domain].short_link(obj.key, obj.nof_posts, 2, '[Last ',' Posts]'));
      var files = op.getElementsByClassName('files')[0];
      if (files) th.insertBefore(files, ref);
      op.setAttribute('class','post op');
      if (obj.posts && obj.posts[0] && obj.posts[0].extra_files) op.setAttribute('style','clear:both;');
      th.insertBefore(op, ref);
//      if (assign_pn) obj.posts[0].pn = th;
      if (assign_pn || !obj.posts[0].pn) obj.posts[0].pn = op;
      if (obj.posts) {
        for (var i=1;i<obj.posts.length;i++) {
//          th.appendChild(this.post_json2html(obj.posts[i], board));
          var pn = this.post_json2html(obj.posts[i], board);
          th.insertBefore(this.post_container(pn,obj.posts[i].no), ref);
          th.insertBefore(document.createElement('br'), ref);
          if (assign_pn || !obj.posts[i].pn) obj.posts[i].pn = pn;
        }
        this.page_json2html3_add_omitted_info(obj,obj.posts,obj.posts);
////////      } else { // WILL BE REDUNDANT
////////        var keys = Object.keys(obj); // obj.posts===undefined, but it is defined as undefined, so key contains 'posts'. 
////////        obj.posts = [];
////////        obj.posts[0] = {};
////////        for (var i=0;i<keys.length;i++) if (keys[i]!=='posts') obj.posts[0][keys[i]] = obj[keys[i]]; // remove props in prototype chain.
////////        obj.posts[0].pn = op;
      }
      return th;
    },
    page_json2html3_replace_expander : function(posts_old, idx, key) {
      var omit_info = posts_old[0].pn.getElementsByClassName('omitted')[0];
      if (omit_info) {
        if (omit_info.childNodes.length>=3) omit_info.removeChild(omit_info.childNodes[2]);
        if (omit_info.childNodes.length>=2) omit_info.removeChild(omit_info.childNodes[1]); // 'if ()' is a parch for a bug in lainchan, inconsistency between usual boards and /mega/
//        omit_info.removeChild(omit_info.childNodes[1]);
        omit_info.appendChild(cnst.config_expander(key, idx));
      }
    },
    page_json2html3_add_omitted_info : function(th,posts_old,posts) {
      var nof_files = 0;
      for (var i=1;i<posts.length;i++) nof_files += (posts[i].type_data==='html')? posts[i].pn.getElementsByClassName('file').length :
                                                    (!posts[i].filename)? 0 :
                                                    (posts[i].extra_files)? posts[i].extra_files.length+1 : 1;
      var nof_files_omitted = th.nof_files - nof_files;
      var nof_posts_omitted = th.nof_posts - posts.length;

      var omit_info = (posts_old)? posts_old[0].pn.getElementsByClassName('omitted')[0] : null;
      if (nof_posts_omitted!=0) {
//      if (th.nof_posts>1) {
        if (!omit_info) {
          omit_info = document.createElement('span');
          omit_info.setAttribute('class','omitted');
//          omit_info.innerHTML = 'dummy<a href="javascript:void(0)">Click to expand</a>.';
          omit_info.innerHTML = 'dummy';
          omit_info.appendChild(cnst.config_expander(th.key));
          if (posts_old) posts_old[0].pn.appendChild(omit_info);
        }
//        omit_info.childNodes[0].textContent = (nof_posts_omitted!==0)? (nof_posts_omitted +' post' + ((nof_posts_omitted!==1)? 's':'') +
//          ((nof_files_omitted)? ' and ' + nof_files_omitted + ' image repl'+ ((nof_files_omitted===1)? 'y' : 'ies') : '') + ' omitted. ') : '';
        omit_info.childNodes[0].textContent = nof_posts_omitted +' post' + ((nof_posts_omitted!==1)? 's':'') +
          ((nof_files_omitted)? ' and ' + nof_files_omitted + ' image repl'+ ((nof_files_omitted===1)? 'y' : 'ies') : '') + ' omitted. ';
      } else if (omit_info) omit_info.childNodes[0].textContent = 'Showing all posts.'; //if (omit_info && posts_old) posts_old[0].pn.removeChild(omit_info);
      return omit_info;
    },
    catalog_json2html3_thumbnail: function(obj, board) {
      return ((obj.ext==='.jpg' || obj.ext==='.jpeg' || obj.ext==='.gif' || obj.ext==='.png')? 'https://' + this.domain_url + board + 'thumb/' + obj.tim + obj.ext : '');
    },
    catalog_json2html3_src: function(obj, board) {
      return ((obj.ext==='.jpg' || obj.ext==='.jpeg' || obj.ext==='.gif' || obj.ext==='.png' || obj.ext==='.webm')? 'https://' + this.domain_url + board + 'src/' + obj.tim + obj.ext : '');
    },
    catalog_json2html3 : function(obj,board,thumb_url) {
      var th = document.createElement('div');
      th.setAttribute('class','mix');
      th.setAttribute('style','display: inline-block;');
//      if (obj.ext==='.gif' || obj.ext==='.png') obj.ext='.jpg';
//      if (obj.ext==='.gif' || obj.ext==='.jpeg') obj.ext='.jpg';
      th.innerHTML = '<div class="thread grid-li grid-size-' + site2[site.nickname].catalog_native_size + '">' +
                     '<a href="' + site2[obj.domain].make_url4([obj.domain,obj.board,obj.no,'thread_html'])[0] + '">' +
//                     '<a href="' + thumb_url + '">' +
//                     '<a>' +
                       '<img src="' + thumb_url +
                       '" id="img-' + obj.no +
                       '" data-subject="' + obj.sub +
                       '" data-name="' + obj.name +
                       '" data-muhdifference="" data-last-reply="" data-last-subject="" data-last-name="" data-last-difference=""' +
                       'class="' + board + ' thread-image" title="' + new Date(obj.last_modified*1000).toLocaleString() + ' '+obj.ext + '"></a>' +
                     '<div class="replies"><strong>R: ' + (obj.nof_posts-1) +' / I: ' + obj.nof_files +
//                     ((pref.catalog_footer_show_board_name)? ' '+board : '')
                     '</strong>' + 
                     ((obj.sub)? '<p class="intro"><span class="subject">' + obj.sub + '</span></p>' : '<br>') +
                     obj.com + '</div></div>';
      return th;
    },
//    catalog_json2html3 : function(obj,board) {
//      th = document.createElement('div');
////      if (obj.ext==='.gif' || obj.ext==='.png') obj.ext='.jpg';
//      if (obj.ext==='.gif' || obj.ext==='.jpeg') obj.ext='.jpg';
//      th.innerHTML = '<div class="thread grid-li grid-size-small"><a href="'
//                   + site2['8chan'].make_url3(board,obj.no) + '"><img src="'
//                   + ((obj.ext==='.jpg' || obj.ext==='.jpeg' || obj.ext==='.gif' || obj.ext==='.png')? 'https://' + site2['8chan'].domain_url + board + 'thumb/' + obj.tim + obj.ext : '')
//                   + '" id="img-'
//                   + obj.no  + '" data-subject="'
//                   + obj.sub + '" data-name="'
//                   + obj.name+ '" data-muhdifference="" data-last-reply="" data-last-subject="" data-last-name="" data-last-difference=""'
////                   + 'class="scriptcdc thread-image" title="' + new Date(obj.last_modified*1000).toLocaleString() +'"></a>'
//                   + 'class="'+board+' thread-image" title="' + new Date(obj.last_modified*1000).toLocaleString() + ' '+obj.ext + '"></a>'
//                   + '<div class="replies"><strong>R: '
//                   + obj.replies +' / I: '
//                   + (obj.images+obj.omitted_images)
////                   + ((pref.catalog_footer_show_board_name)? ' '+board : '')
//                   + '</strong>'
//                   + ((obj.sub)? '<p class="intro"><span class="subject">' + obj.sub + '</span></p>' : '')
//                   + obj.com + '</div></div>';
//      return th;
//    },
    catalog_from_json3 : function(obj,board) {
      var ths;
if (pref.test_mode['0']) {
      ths = {domain:'8chan', board:site.board, obj:obj};
      this.parse_funcs['catalog_json'].entry(ths,this.parse_funcs['catalog_json']['full_hier']);
} else {
//      ths = {domain:'8chan', board:board, obj:obj, parse_funcs:this.parse_funcs['catalog_json'], __proto__:site4.parse_funcs_on_demand};
////      var parse_obj = {domain:'8chan', board:board, parse_funcs:this.parse_funcs['catalog_json'], __proto__:site4.parse_funcs_on_demand};
////      ths = {obj:obj, __proto__:parse_obj};
      return site2[this.nickname].wrap_to_parse.get(obj, this.nickname, board, 'catalog_json');
}
      return ths.ths;
    },
//    catalog_json2html2 : function(obj,board) {
//      th = document.createElement('div');
//      th.setAttribute('data-reply',obj.replies);
//      th.setAttribute('data-bump',obj.last_modified);
//      th.setAttribute('data-time',obj.time);
////      if (obj.ext==='.gif' || obj.ext==='.png') obj.ext='.jpg';
//      if (obj.ext==='.gif' || obj.ext==='.jpeg') obj.ext='.jpg';
//      th.innerHTML = '<div class="thread grid-li grid-size-small"><a href="'
//                   + site2['8chan'].make_url3(board,obj.no) + '"><img src="'
////                   + ((obj.ext==='.jpg' || obj.ext==='.jpeg' || obj.ext==='.gif' || obj.ext==='.png')? 'https://media.' + site2['8chan'].domain_url + board + 'thumb/' + obj.tim + obj.ext : '')
//                   + ((obj.ext==='.jpg' || obj.ext==='.jpeg' || obj.ext==='.gif' || obj.ext==='.png')? 'https://' + site2['8chan'].domain_url + board + 'thumb/' + obj.tim + obj.ext : '')
//                   + '" id="img-'
//                   + obj.no  + '" data-subject="'
//                   + obj.sub + '" data-name="'
//                   + obj.name+ '" data-muhdifference="" data-last-reply="" data-last-subject="" data-last-name="" data-last-difference=""'
////                   + 'class="scriptcdc thread-image" title="' + new Date(obj.last_modified*1000).toLocaleString() +'"></a>'
//                   + 'class="scriptcdc thread-image" title="' + new Date(obj.last_modified*1000).toLocaleString() + ' '+obj.ext + '"></a>'
//                   + '<div class="replies"><strong>R: '
//                   + obj.replies +' / I: '
//                   + (obj.images+obj.omitted_images)
////                   + ((pref.catalog_footer_show_board_name)? ' '+board : '')
//                   + '</strong>'
//                   + ((obj.sub)? '<p class="intro"><span class="subject">' + obj.sub + '</span></p>' : '')
//                   + obj.com + '</div></div>';
//      return th;
//    },
//    catalog_from_json2 : function(doc_json,board) {
//    catalog_from_json2 : function(obj,board) {
////      var obj = JSON.parse(doc_json);
//      var ths = [];
//      for (var i=0;i<obj.length;i++)
//        for (var j=0;j<obj[i].threads.length;j++) {
//          var name = '8chan' + board + obj[i].threads[j].no;
//          var pn = site2['8chan'].catalog_json2html2(obj[i].threads[j],board);
//          ths.push(site2['8chan'].catalog_from_native_1(pn,board));
//          ths[ths.length-1][14] = i + '.' +j;
//        }
//      return ths;
//    },
    patch:{
      expand_thumbnail_inline_load: function(){
        var pnode = this.parentNode && this.parentNode.parentNode;
        if (pnode && pnode.classList && pnode.classList.contains('multifile') && pnode.style.width) { // patch for multifile in vichan
          this.setAttribute('data-originalWidth',pnode.style.width);
          pnode.style = '';
        }
      },
    },
    proto : 'DEFAULT'
  };
}
if (pref.features.domains['KC']) { 
  site2['KC'] = {
    nickname : 'KC',
    domain_url: 'krautchan.net',
//    features : {thread_reader: true},
    components: {
      boardlist: '.menu',
      postform_comment: '#postform_comment',
      postform_submit: '#postform_submit',
    },
    make_tack: function(){
      var tack = document.createElement('img');
      tack.setAttribute('src','/images/sticky.gif');
      return tack;
    },
//    postform: {
//      init:function(){
//        this.tack = site2[site.nickname].make_tack();
//        this.tack.setAttribute('style','float:right;font-size:2em;');
//        site.postform.parentNode.insertBefore(this.tack,site.postform);
//        return this.tack;
//      },
//      __proto__:site2['DEFAULT'].postform
//    },
    boards_json: site2['DEFAULT'].generate_boards_json(
      [['b',15],['int',20],'vip',
       'a','c','co','d','e','f','fb','fe','fit','jp','k','l','li',['m',5],'n','ng','p','ph','prog','sp',
       't',['trv',18],'tu','tv','v','w','we','wk','wp','z','zp','ft','r',['h',8],'s','bans','kc','rfk',['rvss',15]], 10),
    check_func : function(){
      if (!site2['KC'].force_https) site2['KC'].protocol = site.protocol;
      var href = window.location.href;
      if (href.search(/krautchan.net/)!=-1) { // Krautchan
        site.whereami = (document.head.innerHTML.indexOf('404 Not Found')!=-1)? '404'
                      : (href.search(/krautchan\.net\/?$/)!=-1)? 'frame'
                      : (href.search(/catalog/)!=-1)? 'catalog'
                      : (href.search(/thread/)!=-1)? 'thread'
                      : (href.search(/\/$|(index|[0-9]+)\.html|\/#all$/)!=-1)? 'page'
                      : 'other';
        if (site.whereami==='page' || site.whereami==='thread') {
          this.components.boardlist = 'body > div:nth-child(3)';
          delete this.show_boardlist_physical_extract_func;
        }
        site.config('krautchan.net','KC');
        site.max_page  = (site2['KC'].max_page_kc[site.board]==undefined)? 10 : site2['KC'].max_page_kc[site.board];
        if (site.whereami==='catalog') {
          if (href[href.length-1]==='/') href = href.substr(0,href.length-1);
          site.board = href.substr(href.lastIndexOf('/'))+'/';
        }
        if (site.whereami==='frame') {
          site.root_body2 = document.createElement('div');
          site.embed_frame = 'main';
          site.embed_frame_win = main;
          navigation.onload = function(){
            site.root_body = navigation.document.body;
            site.root_body.appendChild(site.root_body2);
          };
        }
        site.embed_to = (site.whereami==='thread' || site.whereami==='page')? {
          top: function(){return document.querySelector('form[action="/delete"]');},
          bottom: function(){return document.querySelector('form[action="/delete"]').nextSibling;}} : {};
//        if (site.whereami==='thread' || site.whereami==='page') {
//          site.embed_to['top']    = document.querySelector('form[action="/delete"]');
//          site.embed_to['bottom'] = document.querySelector('form[action="/delete"]').nextSibling;
////        } else if (site.whereami==='catalog') {
////          site.embed_to['top']    = document.getElementsByTagName('header')[0].nextSibling;
////          site.embed_to['bottom'] = document.getElementsByTagName('footer')[0];
//        }
        site.postform = document.getElementById('postform');
        site.postform_rules = document.getElementById('rules_row');
////        this.pref_default(pref); // working code.
        return true;
      } else return false;
    },
////    pref_default: function(pref){ // working code.
////      pref.thread_reader.own_posts_tracker = true;
////      pref.thread_reader.check_num_of_children = false;
////    },
    force_https : false,
    protocol : 'https:',
//    home : site.protocol + '//krautchan.net', // cause memory leak
    home : site.protocol + '//krautchan.net/regeln.html',
//    home : site.protocol + '//krautchan.net/favicon.ico',
    show_boardlist_physical_extract_func: function(key){return key.substr(1,key.length-2);},
    catalog_frame_prep: function(pn12){
      var source = [navigation.document.body, main.document.body];
//      for (var i=0;i<2;i++) {
//        var container = document.createElement('div');
//        container.style.display = 'none';
//        while (source[i].childNodes.length!=0) container.appendChild(source[i].childNodes[0]);
//        source[i].appendChild(container);
//      }
      site2['common'].absorb_children(source[0]).style.display = 'none';
      site2['common'].absorb_children(source[1]).style.display = 'none';
      source[0].insertBefore(pn12,source[0].firstChild);
      source[0].insertBefore(pn12,source[0].firstChild);
      site.root_body.appendChild(site.root_body2);
      this.catalog_embed_prep(pn12);
    },
////    catalog_background : '#cfcede',
////    catalog_background : '#dadafc',
//    catalog_background : '#e0e0fc',
//    catalog_bordercolor : '#aaaacc',
//    catalog_threads_in_page : function(doc){return doc.getElementsByClassName('thread');},
    catalog_threads_in_page : function(doc){return doc.getElementsByClassName('thread_body');},
//    remove_posts : function(doc){
//      var threads_body = doc.getElementsByClassName('thread_body');
//      var posts = [];
//      for (var i=0;i<threads_body.length;i++) {
//        posts_in_thread = threads_body[i].getElementsByTagName('table');
//        for (var j=0;j<posts_in_thread.length;j++) posts.push(posts_in_thread[j]);
//      }
//      for (var i=posts.length-1;i>=0;i--) posts[i].innerHTML = '';
//      return doc;
//    },
    max_page_kc : {
      '/int/' : 20,
      '/b/'   : 15,
      '/trv/' : 13,
      '/m/'   : 5
    },
    max_page: function(bn){return site2['KC'].max_page_kc[bn];},
    make_url4 : function(dbt){
      var url_prefix = this.protocol + '//' + this.domain_url;
      dbt[3] = dbt[3].replace(/_json/,'_html');
      if      (dbt[3]==='page_html')    return [url_prefix + dbt[1] + ((dbt[2]==0)? '' : dbt[2] + '.html'), 'html'];
      else if (dbt[3]==='catalog_html') return [url_prefix + '/catalog' + dbt[1].substr(0,dbt[1].length-1), 'html'];
      else if (dbt[3]==='thread_html')  return [url_prefix + dbt[1] + 'thread-' + dbt[2] + '.html', 'html'];
    },
    trim_list: 'no',
//////////    make_url : function(board,no){return [site2['KC'].protocol + '//krautchan.net' + board + ((no==0)? '' : no + '.html'), 'html'];}, // working code.
////////    make_url : function(board,no,key){
////////      var url_prefix = site2['KC'].protocol + '//krautchan.net';
////////      return (key==='p')? [url_prefix + board + ((no==0)? '' : no + '.html'), 'html'] : 
////////                          [url_prefix + '/catalog' + board.substr(0,board.length-1),'html'];
////////    },
////////    make_url3: function(board,th){return  site2['KC'].protocol + '//krautchan.net' + board + 'thread-' + th + '.html';},
    get_next_image: function(img,top){
      var imgs = Array.prototype.slice.call(document.querySelectorAll('img[id^=thumbnail]')).filter(function(v){return v.src.substr(-5,5)!=='.webm';});
//      var imgs = cataLog.parent.querySelectorAll('img[id^="thumbnail"]');
      return site2['DEFAULT'].get_next_image(img,top,imgs);
    },
    get_ops : function(doc){
      var ops = [];
      var divs = doc.getElementsByTagName('div');
      for (var i=0;i<divs.length;i++)
        if (divs[i].className == 'thread' || divs[i].className == 'thread kc_showReplies')
          ops.push(divs[i].id.substring(7)); // substring(7) for removing 'thread_'
      return ops;
    },
    get_posts : function(doc) {
      var posts = [];
      var anchors = doc.getElementsByTagName('a');
      for (var i=0;i<anchors.length;i++) if (anchors[i].name != '') posts.push(anchors[i].name);
      return posts;
    },
////////    get_thread_link : function(pn,boardname,del){
//////////      var keyword = (boardname=='/int/')? 'Reply' : 'Antworten';
////////      var as = pn.getElementsByClassName('postheader')[0].getElementsByTagName('a');
//////////      for (var i=0;i<as.length;i++) if (as[i][brwsr.innerText]==keyword) return as[i].getAttribute('href');
//////////      for (var i=0;i<as.length;i++) if (as[i].innerHTML==keyword) {
////////      for (var i=0;i<as.length;i++) if (as[i][brwsr.innerText]=='Reply' || as[i][brwsr.innerText]=='Antworten') {
////////        var href = as[i].getAttribute('href');
////////        if (del) {
////////          var j=0;
////////          var parent = as[i].parentNode;
////////          while (parent.childNodes[j]!=as[i]) j++;
////////          parent.removeChild(parent.childNodes[j+1]);
////////          parent.removeChild(as[i]);
////////          parent.removeChild(parent.childNodes[j-1]);
////////        } else as[i].setAttribute('target',(pref.catalog_open_in_new_tab)? '_blank' : '_self');
////////        return href;
////////      }
////////      return null;
////////    },
    modify_thread_link : function(pn){
      var retval = [];
      var as = pn.getElementsByClassName('postheader')[0].getElementsByTagName('a');
      for (var i=0;i<as.length;i++) if (as[i][brwsr.innerText]=='Reply' || as[i][brwsr.innerText]=='Antworten') {
        var href = as[i].getAttribute('href');
        retval.push([as[i],href]);
        as[i].removeAttribute('href');
      }
      return retval;
    },
//    add_thread_link : function(doc,url){
//      var pn = document.createElement('a');
//      pn.href = url.replace(/https*:\/\/krautchan\.net/,'');
//      pn.innerHTML = 'Reply';
//      var th = doc.getElementsByClassName('postheader')[0];
//      if (th) {
//        th.insertBefore(pn,th.firstChild);
//        th.insertBefore(document.createTextNode('['),pn);
//        th.insertBefore(document.createTextNode(']'),pn.nextSibling);
//      }
//    },
    time_offset : 1, // 1 for usual, 2 for summer time.
//    get_time_of_posts : function(doc){ // working code.
//      var postdates = doc.getElementsByClassName('postdate');
//      return [parseInt(brwsr.Date_parse(postdates[postdates.length-1][brwsr.innerText]),10) - site2['KC'].time_offset*3600000,
//              parseInt(brwsr.Date_parse(postdates[0                 ][brwsr.innerText]),10) - site2['KC'].time_offset*3600000];
//    },
//    get_time_of_posts : function(th){ // cause error
//      var posts = th.getElementsByTagName('table');
//      return [site2['KC'].get_time_of_post_in_utc(posts[posts.length-1]),site2['KC'].get_time_of_post_in_utc(posts[0])];
//    },
//    get_time_of_post_in_utc : function(post){ // working code
//      var postdates = post.getElementsByClassName('postdate');
//      if (postdates[0]) return parseInt(brwsr.Date_parse(postdates[0][brwsr.innerText]),10) - site2['KC'].time_offset*3600000;
//    },
    mark_newer_posts: function(th,date,unmark, short_cut) {
      var pn = site2['DEFAULT'].mark_newer_posts('KC',th.getElementsByTagName('table'),date, function(post){return post.getElementsByClassName('postreply')[0];}, unmark, short_cut);
      return (pn!=null)? pn.offsetParent : null;
    },
    localtime: function(pn){
      var postdate = pn.getElementsByClassName('postdate')[0];
      if (postdate) {
        var lt = postdate.cloneNode(false);
        lt.setAttribute('class','CatChan_localtime');
        lt.textContent = site2.common.change_utc_to_local(site2['KC'].parse_funcs.post_html.time_pn_1(postdate)); // use direct path to hope to be inline optimized.
        postdate.parentNode.insertBefore(lt,postdate.nextSibling);
        postdate.setAttribute('style','display:none');
      }
//      var times = pn.getElementsByClassName('postdate');
//      for (var i=0;i<times.length;i++) times[i].textContent = site2.common.change_utc_to_local(Date.parse(times[i][brwsr.innerText])-site2['KC'].time_offset*3600000);
//      for (var i=0;i<times.length;i++) times[i].textContent = site2.common.change_utc_to_local(brwsr.Date_parse(times[i][brwsr.innerText])-site2['KC'].time_offset*3600000);
    },
    remove_files_info : function(th){
      site2.common.remove_by_classname(th,'filename');
      site2.common.remove_by_classname(th,'fileinfo');
      var imgs = th.getElementsByTagName('img');
      for (var i=0;i<imgs.length;i++) if (imgs[i].id && imgs[i].id.search('thumbnail')!=-1) {
        imgs[i].removeAttribute('onmouseover');
        imgs[i].removeAttribute('onmouseout');
        imgs[i].removeAttribute('onload');
        site2.common.move_up_and_delete_parent([imgs[i]]);
      }
      var files = th.getElementsByClassName('file_thread');
      for (var i=0;i<files.length;i++) site2.common.remove_brs(files[i]);
      for (var i=0;i<files.length;i++) site2.common.remove_by_attribute([files[i]],'id','filename');
//      site2.common.remove_by_classname(th,'file_thread');
//      site2.common.remove_by_classname(th,'postbody');
    },
////////    insert_footer : function(th,page_no,bn,exe,date,nof_posts,nof_files){
////////      var key = (!brwsr.ff)? 'innerText' : 'innerHTML';
////////      var posts = th.getElementsByTagName('table');
////////      nof_posts += posts.length +1; // +1 for OP.
////////      var files = th.getElementsByClassName('file_thread');
////////      nof_files += th.getElementsByClassName('filename').length;
////////      var om_info = th.getElementsByClassName('omittedinfo');
////////      if (om_info[0]) {
////////        var str = om_info[0][key].replace(/\n/g,'');
////////        nof_posts += parseInt(str.replace(/\ post.*/,''),10);
////////        nof_files += parseInt('0'+str.replace(/\ file.*/,'').replace(/[^\ ]*\ /g,''),10);
////////      }
////////      if (exe) {
////////        var pn = document.createElement('div');
//////////        pn.name = 'catalog_footer';
////////        pn.setAttribute('name','catalog_footer');
//////////        pn[key] = bn + '  ' + nof_posts + '/' + nof_files + '/' + page_no + '  ';
////////        pn.innerHTML = '<span>' + bn + '  ' + nof_posts + '/' + nof_files + '/' + page_no + '  </span>';
////////        var imgs = th.getElementsByTagName('img');
////////        for (var i=0;i<imgs.length;i++) {
//////////          if (imgs[i].src && imgs[i].getAttribute('src').search(/images\/balls/)!=-1) pn.appendChild(imgs[i].cloneNode(false)); // doesn't work in KC.
////////          if (imgs[i].getAttribute('src') && imgs[i].getAttribute('src').search(/images\/balls/)!=-1) pn.appendChild(imgs[i].cloneNode(false));
////////        }
////////        th.insertBefore(pn,files[0]);
////////      }
////////      return [nof_posts,nof_files];
////////    },
    remove_posts : function(th,end){
//      site2.common.remove_by_tagname(th,'table',end);
//      site2.common.remove_double_tags(th,'A');
      var tgts = th.getElementsByTagName('table');
      for (var i=tgts.length-1-end;i>=0;i--) {
        if (tgts[i].previousSibling.previousSibling) tgts[i].parentNode.removeChild(tgts[i].previousSibling.previousSibling); // a tags
        tgts[i].parentNode.removeChild(tgts[i].previousSibling); // text
//if (!pref.test_mode['14']) tgts[i].setAttribute('style','display:none;'+(tgts[i].getAttribute('style') || ''));
//else
        tgts[i].parentNode.removeChild(tgts[i]);
      }
    },
////////    absolute_link : function(doc){
////////      var all = doc.pn.getElementsByTagName('*');
////////      for (var i=0;i<all.length;i++) {
////////        if (all[i].getAttribute('src'))  all[i].setAttribute('src', site2['KC'].protocol + '//krautchan.net'+all[i].getAttribute('src'));
////////        if (all[i].getAttribute('href')) all[i].setAttribute('href',site2['KC'].protocol + '//krautchan.net'+all[i].getAttribute('href'));
////////      }
////////    },
    format_thread_layout : function(th){
      site2.common.add_attribute_by_classname(th,'file_thread','style','float:left;margin:5px');
      site2.common.add_attribute_by_classname(th,'file_reply','style','float:left;margin:5px');
      th.getElementsByTagName('blockquote')[0].setAttribute('style','margin:5px;clear:both');
//      var ph = th.getElementsByClassName('postheader');
//      th.insertBefore(ph,th.getElementsByClassName('postbody')[0]);
    },
    format_thread_style : function(th){
      site2.common.add_attribute_by_classname(th,'postreply','style','background:#cacaec');
    },
    format_thread_contents : function(th){
      site2.common.remove_by_tagname(th,'input');
      site2.common.remove_by_classname(th,'report_parent');
      site2.common.remove_by_attribute(th.getElementsByClassName('postheader'),'onclick','hideThread');
      site2.common.remove_by_attribute(th.getElementsByClassName('file_thread'),'onclick','toggleThumbnail');
//      site2.common.add_attribute_by_attribute(th.getElementsByClassName('file_thread'),'onclick','toggleThumbnail','style','display:none');
      site2.common.remove_by_attribute(th.getElementsByClassName('file_thread'),'href','shipainter');
//      site2.common.remove_by_classname(th,'thread_hidden');
      site2.common.remove_by_tagname(th,'hr');
//      site2.common.remove_by_tagname(th,'br');
      site2.common.remove_by_classname(th,'omittedinfo');
    },
    preprocess_html : function(doc_txt,page){ // cause memory leak in chrome, but fail without this in FF or GreaseMonkey.
      if (doc_txt) {
//        if (page) while (doc_txt.search(/<script[>\ ](.|\n)*<\/script>/)!=-1) doc_txt = doc_txt.replace(/<script[>\ ](.|\n)*<\/script>/,''); // slower execution.
//        while (doc_txt.search(/onload="imageFinishedLoading\([0-9]*\)"/)!=-1) doc_txt = doc_txt.replace(/onload="imageFinishedLoading\([0-9]*\)"/,''); // slower execution.
//        if (page) doc_txt = doc_txt.replace(/<script[>\ ](.|\n)*<\/script>/mg,''); // cause leak in Chrome, probably a bug.
        if (page) doc_txt = doc_txt.replace(/<script[> ].*<\/script>/mg,''); // cause leak in Chrome, probably a bug. (remove \n)
        doc_txt = doc_txt.replace(/onload="imageFinishedLoading\([0-9]*\)"/mg,''); // cause leak in Chrome, probably a bug.
// sanitize
        doc_txt = doc_txt.replace(/onmouseover="[^"]*"/mg,'');
        doc_txt = doc_txt.replace(/onmouseout="[^"]*"/mg,'');
        doc_txt = doc_txt.replace(/onclick="[^"]*"/mg,'');
      }
      return doc_txt;
    },
    preprocess_doc : function(doc){
//      site2.common.remove_by_tagname(doc,'script');
      site2.common.remove_attribute(doc,'onload');
      site2.common.remove_attribute(doc,'onmouseover');
      site2.common.remove_attribute(doc,'onmouseout');
      site2.common.remove_attribute(doc,'onclick');

      site2.common.remove_attribute(doc,'onchange');
      site2.common.remove_attribute(doc,'onfocus');
      site2.common.remove_attribute(doc,'onsubmit');
var pns = doc.getElementsByTagName('*');
for (var i=pns.length-1;i>=0;i--)
  if (pns[i].getAttribute && pns[i].getAttribute('href') && pns[i].getAttribute('href').indexOf('javascript:')==0) pns[i].removeAttribute('href');

if (pref.test_mode['28']) {
      doc.getElementsByTagName('html')[0].innerHTML = doc.getElementsByTagName('html')[0].innerHTML; // remake to sanitize.
}
    },
////////    thread2headline : function(doc){
////////      return site2.common.thread2headline(doc,'KC');
////////    },
    catalog_native_prep: function(date,pn_filter,pn_tb,pn_hi){
      var node_ref = (site.whereami==='catalog')? document.getElementsByClassName('catalog')[0]
                                                : document.querySelector('form[action="/delete"]');
//      var node_ref = (site.whereami==='catalog')? document.getElementById('settings')
//                                                : document.getElementsByName('postcontrols')[0];
//      pn_tb.setAttribute('style', 'float:right');
      cnst.tb_prep_for_embed(pn_tb);
//      if (site.whereami==='catalog') {
      var selector_catchan = pn_filter.getElementsByTagName('select')['catalog.indexing'];
      selector_catchan.setAttribute('style','float:left');
      node_ref.parentNode.insertBefore(selector_catchan,node_ref);
      pn_tb.childNodes[3].setAttribute('style','float:left');
      node_ref.parentNode.insertBefore(pn_tb,node_ref);
////////      return site2['KC'].catalog_from_native(date,document,site.board,site.whereami+'_html');
    },
////////    catalog_from_native : function(date,doc,board,type) { // working code.
////////      return site2[this.nickname].wrap_to_parse.get(doc, this.nickname, board, type);
////////////      var parse_obj = {domain:'KC', board:board, parse_funcs:site2['KC'].parse_funcs[type], __proto__:site4.parse_funcs_on_demand};
////////////      var ths = {pn:doc, __proto__:parse_obj};
////////////      return ths.ths;
////////    },
    catalog_get_native_area: function(){
      if (site.whereami==='page') return document.querySelector('form[action="/delete"]');
      else return document.getElementsByClassName('catalog')[0];
    },
////    get_click_area: function(pn, th){
////      var areas = [];
////      if (th.type_html==='catalog_html') {
////        var tn = pn.getElementsByClassName('thumbnail');
////        for (var i=0;i<tn.length;i++) areas.push(tn[i].getElementsByTagName('img')[0]);
////      } else if (th.type_html==='page_html') {
////        var fths = pn.getElementsByClassName('file_thread');
////        for (var i=0;i<fths.length;i++) {
////          var imgs = fths[i].getElementsByTagName('img');
////          areas.push(imgs[imgs.length-1]);
////        }
////      }
////      return (areas.length!=0)? areas : [pn]; 
////    },
//    get_click_area: function(pn, th){
//      if (th.type_html==='catalog_html') {
//        var tn = pn.getElementsByClassName('thumbnail');
//        return (tn[0])? tn[0].getElementsByTagName('img')[0] : pn;
//      } else if (th.type_html==='page_html') {
//        var imgs = pn.getElementsByClassName('file_thread')[0].getElementsByTagName('img');
//        return imgs[imgs.length-1];
//      }
//    },
    parse_funcs : { // KC
      'catalog_html' : {
        ths: function(doc) {
          var ths = this.ths_array(doc,doc.pn.getElementsByClassName('thread'));
          var t = Date.now() - pref.localtime_offset*3600000; // patch
          for (var i=0;i<ths.length;i++) {
            if (ths[i].time_bumped<0) ths[i].time_bumped += t;
//            var as = ths[i].pn.getElementsByTagName('a');
//            for (var j=0;j<as.length;j++) as[j].removeAttribute('href');
          }
          return ths;
        },
//        th_init: function(th) {
//          var as = th.pn.getElementsByTagName('a');
//          for (var j=0;j<as.length;j++) as[j].addEventListener('click',th.parse_funcs.preventDefault,false);
//        },
//        th_destroy: function(pn, parse_funcs){
//          var as = pn.getElementsByTagName('a');
//          for (var j=0;j<as.length;j++) as[j].removeEventListener('click',parse_funcs.preventDefault,false);
//        },

        no : function(th){return parseInt(th.pn.getAttribute('id').substr(7),10);}, // the same as 4chan.
//        time_bumped: function(th){return 0;},
        time_bumped: function(th){
          return -1 -parseInt(th.page.substr(0,th.page.indexOf('.')),10)*16 - parseInt(th.page.substr(th.page.indexOf('.')+1));},
        time_created : function(th){return 0;},
        nof_posts: function(th){
          var footer = th.pn.getElementsByClassName('omitted_text')[0];
//          Object.defineProperty(th, 'footer', {value:footer, enumerable:true, writable:true, configurable:true});
//          footer.innerHTML = '';
          var nof_posts = (footer)? parseInt(footer.textContent.match(/[0-9]+/),10) : 0;
          return (isNaN(nof_posts))? 1 : nof_posts + 1;
        },
        nof_files: function(th){return 0;},
        key: function(th){return th.domain + th.board + th.no;},
        sub: function(th){
          var sub = th.pn.getElementsByTagName('header')[0].textContent.trim();
          return (sub.search(/^#[0-9]+$/)==0)? '' : sub;
        },
        name: function(th){return '';},
//        com: function(th){return th.pn.getElementsByTagName('section')[0][brwsr.innerText];},
        com: function(th){return th.pn.getElementsByTagName('section')[0].innerHTML;},
        type_com: 'html',
        footer: function(th){
          var footer = th.pn.getElementsByClassName('omitted_text')[0]; // must parse pn because of mimic mode.
          footer.innerHTML = '';
          return footer;
        },
        sticky: function(th){return false;},
//        format: function(th){th.pn.getElementsByTagName('a')[0].removeAttribute('href');return null;},
        op_img_url:function(th){
//          var img = th.pn.getElementsByClassName('thumbnail')[0].getElementsByTagName('img');
          var tn  = th.pn.getElementsByClassName('thumbnail');
          var img = (tn[0])? tn[0].getElementsByTagName('img') : null; // parse other site's html
          var url = (img && img[img.length-1])? img[img.length-1].getAttribute('src') : undefined;
          return url;
        },
        get_op_src: 'thread_html',
        filename: function (th){ // post can be accepted.
          var op = th.pn.classList.contains('thread') || th.pn.classList.contains('thread_body');
          var files = th.pn.getElementsByClassName('post_files')[0].getElementsByTagName('figure');
          if (files) 
            for (var i=0;i<files.length;i++) {
              var href = files[i].getElementsByTagName('img')[0].getAttribute('src');
              if (i===1) th.extra_files = [];
              if (i>=1) th.extra_files[i-1] = {domain:th.domain, board:th.board};
              var idx = href.lastIndexOf('/');
              var tgt = (i===0)? th : th.extra_files[i-1];
//              tgt.filename = href.substr(idx+1);
              tgt.filename = files[i].getElementsByTagName('img')[0].getAttribute('alt');
//              tgt.filename_server = href.substr(0,idx).replace(/[^\/]*\//g,'');
              tgt.filename_server = href.substr(idx+1);
            }
          return th.filename;
        },
        prep_mimic: 'page_html',
        tn_imgs: function(){return [];}, // dynamic, or function(th){return th.pn.getElementsByClassName('thumbnail');},
        img2src: function(img){return th.op_img_url.replace('thumbnails','files');},
        dynamic_image_hover: true,
      },
      'catalog_json' : {
        proto: 'catalog_html',
      },
      'page_html' : {
        ths: function(doc) {return this.ths_array(doc, doc.pn.getElementsByClassName('thread'));},
        th_init: function(th) {
          th.pn.removeAttribute('class');
          th.pn.style.clear = 'none';
        },
//        th_destroy: function(pn, parse_funcs){},
//        no : function(th){return th.pn.id.substr(7);},
//        no : function(th){return parseInt(th.pn.id.substr((th.pn.classList.contains('thread'))? 7:5),10);}, // page and posts
        no : function(th){ // page and posts
          return parseInt((th.pn.id)? th.pn.id.replace(/[^_\-]*./,'') : // /int/
                                      th.pn.getElementsByClassName('postnumber')[0].getElementsByTagName('a')[1].textContent, 10);}, // other boards.
//        ths: function(doc) { // working code.
//          var ths = this.ths_array(doc, doc.pn.getElementsByClassName('thread'));
//          for (var i=0;i<ths.length;i++) {
//            Object.defineProperty(ths[i], 'no', {value:ths[i].pn.id.substr(7), enumerable:true, writable:true, configurable:true});
//            ths[i].pn.removeAttribute('class'); // collection ISN'T writable? and if wrote, its enumerator doesn't work.
//            ths[i].pn.style.clear = 'none';
//          }
//          return ths;
//        },
//        no : function(th){return parseInt(th.pn.getElementsByClassName('quotelink')[0][brwsr.innerText],10);},
        posts: function(th){return this.posts_array(th, th.pn.querySelectorAll('.thread_body, td.postreply'));},
//        posts: function(th){return this.posts_array(th, th.pn.querySelectorAll('.thread_body, .postreply'));}, // doesn't work for thread_reader.
//        posts: function(th){ // working code.
//          var posts = [];
//          posts[0] = {pn:th.pn.getElementsByClassName('thread_body')[0], __proto__:th.__proto__}; // OP
//          var replies = th.pn.getElementsByClassName('postreply');
//          for (var i=0;i<replies.length;i++) posts[posts.length] = {pn:replies[i], __proto__:th.__proto__};
//          return posts;
//        },
        time: 'post_html.time',
        nof_posts: function(th){
          var nof_posts = th.pn.getElementsByTagName('table').length +1; // +1 for OP.
          var nof_files = th.pn.getElementsByClassName('filename').length;
          var om_info = th.pn.getElementsByClassName('omittedinfo');
          if (om_info[0]) {
            var str = om_info[0][brwsr.innerText].replace(/\n/g,'');
            nof_posts += parseInt(str.replace(/\ post.*/,''),10);
            nof_files += parseInt('0'+str.replace(/\ file.*/,'').replace(/[^\ ]*\ /g,''),10);
          }
          Object.defineProperty(th,'nof_files',{value:nof_files, enumerable:true, configurable:true, writable:true});
          return nof_posts;
        },
        nof_files: function(th){
          if (!th.hasOwnProperty('nof_posts')) this['nof_posts'](th);
          return th.nof_files;
        },
        sub:  function(post){
          var sub = post.pn.getElementsByClassName('postsubject')[0];
          return (sub)? sub.textContent : '';},
        name: function(post){return post.pn.getElementsByClassName('postername')[0][brwsr.innerText];},
        pn_name: function(post){return post.pn.getElementsByClassName('postername')[0];},
//        com:  function(post){return (post.pn.getElementsByClassName('postbody')[0] || post.pn).getElementsByTagName('p')[0][brwsr.innerText];},
        com:  function(post){return (post.pn.getElementsByClassName('postbody')[0] || post.pn).getElementsByTagName('p')[0].innerHTML.replace(/^\s*/,'').replace(/\s*$/,'');},
        type_com: 'html',
        footer: function(th){return this.insert_footer4(th.pn.getElementsByClassName('file_thread')[0]);},
//        sticky: function(th){return (th.pn.getElementsByClassName('stickyIcon').length!=0);},
        flag: function(post){  // same as 8chan
          var balls = post.pn.getElementsByTagName('img');
          for (var i=0;i<balls.length;i++) if (balls[i].getAttribute('src').search(/images\/balls/)!=-1) break;
//          return (i<balls.length)? balls[i].cloneNode(false) : null; // may cause memory leak
//          return (i<balls.length)? document.importNode(balls[i],false) : null;
          if (i<balls.length) {
            var ball = document.importNode(balls[i],false);
            ball.setAttribute('src', site2['KC'].absolute_link_1(ball.getAttribute('src')));
            return ball;
          } else return null;
//          if (i<balls.length) { // didn't stop memory leak.
//            var ball = document.createElement('img');
//            ball.setAttribute('src',balls[i].getAttribute('src'));
//            return ball;
//          } else return null;
        },
        op_img_url:function(th){
//          var img = th.pn.getElementsByClassName('file_thread')[0].getElementsByTagName('img');
          var ft  = th.pn.getElementsByClassName('file_thread');
          var img = (ft[0])? ft[0].getElementsByTagName('img') : null; // parse other site's html
          var url = (img && img[img.length-1])? img[img.length-1].getAttribute('src') : undefined;
          if (ft.length>=2) {
            th.op_img_url2 = [];
            for (var i=1;i<ft.length;i++) {
              img = ft[i].getElementsByTagName('img');
              var url2 = (img && img[img.length-1])? img[img.length-1].getAttribute('src') : undefined;
              if (url2) th.op_img_url2[th.op_img_url2.length] = url2;
            }
          }
//          return url;
          return site2[th.domain].protocol + '//' + site2[th.domain].domain_url + url; // patch
        },
////        post_no: function(post){return parseInt(post.pn.getElementsByClassName('quotelink')[1][brwsr.innerText],10);},
        get_op_src: 'thread_html',
        get_thread_links : function(th){
          var as = th.pn.getElementsByClassName('postheader')[0].getElementsByTagName('a');
          for (var i=0;i<as.length;i++) 
            if (as[i].textContent==='Reply' || as[i].textContent==='Antworten') return [as[i]];
        },
        get_omitted_info : function(post){return post.pn.getElementsByClassName('omittedinfo')[0];},
        set_omitted_info : function(post, info){post.pn.insertBefore(info,post.pn.getElementsByClassName('postbody')[0].nextSibling);},
        replace_omitted_info2 : function(dst, src){dst.childNodes[0].textContent = (src)? src.childNodes[0].textContent : '';},
        filename: function (th){ // post can be accepted.
          var op = th.pn.classList.contains('thread') || th.pn.classList.contains('thread_body');
          var files = th.pn.getElementsByClassName((op)? 'file_thread' : 'file_reply');
          if (files) 
            for (var i=0;i<files.length;i++) {
              var href = files[i].getElementsByClassName('filename')[0].getElementsByTagName('a')[0].getAttribute('href');
              if (i===1) th.extra_files = [];
              if (i>=1) th.extra_files[i-1] = {domain:th.domain, board:th.board};
              var idx = href.lastIndexOf('/');
              var tgt = (i===0)? th : th.extra_files[i-1];
              tgt.filename = href.substr(idx+1);
//              tgt.filename_server = href.substr(0,idx).replace(/[^\/]*\//g,'');
              tgt.filename_server = href.substr(0,idx).replace(/[^\/]*\//g,'').replace(/jpeg$/,'jpg');
              var info = files[i].getElementsByClassName('fileinfo')[0].textContent.replace(/\s/g,'').split(',');
              tgt.w = parseInt(info[1].substr(0,info[1].indexOf('x')  ),10);
              tgt.h = parseInt(info[1].substr(  info[1].indexOf('x')+1),10);
              var fsize = info[1].split(/\s/);
              fsize[1] = (fsize[1]==='kB')? 1000 : (fsize[1]==='MB')? 1000000 : 1;
              tgt.fsize = parseInt(fsize[0],10) * fsize[1];
              var tn = files[i].querySelector('img[id^=thumbnail]');
              if (tn) {
                tgt.tn_w = parseInt(tn.getAttribute('width'),10);
                tgt.tn_h = parseInt(tn.getAttribute('height'),10);
              }
            }
          return th.filename;
        },
        tn_imgs: function(th){return th.pn.querySelectorAll('img[id^=thumbnail]');},
        prep_mimic: function (th){
//          th.posts[0].no = th.no; // doesn't work because posts[0].no has getter.
//          for (var i=0;i<th.posts.length;i++) Object.defineProperty(th.posts[i],'no',{value:th.no}); // test patch
          th.op_img_url = th.parse_funcs.op_img_url(th);
        },
        get_op_src: function(th){return site2['KC'].catalog_json2html3_src(th);},
        get_max_page: function(doc){
//          var pns = doc.querySelectorAll('form[action*=delete]')[0].lastChild.previousSibling.previousSibling.previousSibling.getElementsByTagName('*'); // CAN'T GET [1] because it's a text node.
          var pns = doc.querySelectorAll('form[action*=delete]')[0].lastChild.previousSibling.previousSibling.previousSibling.childNodes[1].childNodes[1].childNodes[0].childNodes[3].childNodes; // WORKS ONLY PAGE 0.
          var max = 0;
          for (var i=0;i<pns.length;i++) {
            var text = pns[i].textContent.replace(/\s+/g,'');
            if (max+1 == text || '['+(max+1)+']'===text) max++; // == used intentionally.
          }
          return max;
        },
      },
      'thread_html' : {
//        ths: function(doc) { // pn of thread isn't used.
//          var ths = site2['KC'].parse_funcs.page_html.ths(doc);
//          for (var i=0;i<ths.length;i++) {
//            var ph = ths[i].pn.getElementsByClassName('postheader')[0];
//            if (ph) {
//              ph.appendChild(document.createTextNode(' ['));
//              var link = document.createElement('a');
//              link.setAttribute('href',ths[i].board + 'thread-' + ths[i].no + '.html');
//              link.innerHTML = 'Reply';
//              ph.appendChild(link);
//              ph.appendChild(document.createTextNode('] '));
//            }
//          }
//          return ths;
//        },
//        ths: function(doc) {return this.ths_array(doc, doc.pn.getElementsByClassName('thread_body'));}, // patch, but for what???, de-patched for trial.
//        com:  function(post){return post.pn.getElementsByTagName('blockquote')[0][brwsr.innerText];},
        com:  function(post){return post.pn.getElementsByTagName('blockquote')[0].innerHTML.replace(/^\s*/,'').replace(/\s*$/,'');},
        type_com: 'html',
        time_created: function(th){
return th.parse_funcs.time(th.posts[0]);},
        time_bumped: function(th){
return th.parse_funcs.time(th.posts[th.posts.length-1]);},
////        pop_post_prep: function(th){ // working code.
////          th.children = th.pn.getElementsByClassName('postreply');
////          th.idx_pop = th.children.length-1;
////        },
////        pop_post: function(th){
////          if (th.idx_pop>=0) {
////            th.post = {pn:th.children[th.idx_pop--], parse_funcs:this, __proto__:th.__proto__};
////            return true;
////          }
////          return false;
////        },
        get_op_src: function(th){return th.op_img_url.replace('thumbnails','files');},
        proto: 'page_html',
      },
      'post_html' : {
        flag: 'page_html',
        time: function(post){
          return site2['KC'].parse_funcs.post_html.time_pn(post.pn); // use direct path to hope to be inline optimized.
        },
        time_pn: function(post_pn){
          var postdate = post_pn.getElementsByClassName('postdate')[0];
          return (postdate)? site2['KC'].parse_funcs.post_html.time_pn_1(postdate) : undefined; // use direct path to hope to be inline optimized.
        },
        time_pn_1: function(postdate){
          return Date.parse(postdate.textContent) + (pref.localtime_offset-site2['KC'].time_offset)*3600000; // FF accepts KC's format
        },
      },
      'post_json' : {
        time_unit: 1, // for archive.list_all
      }
    },

    general_event_handler:{
//      catalog:{ // working code
//        mouseover: function(e){
//          var et = e.target;
//          var et_tagName = et.tagName;
//          if (et_tagName==='IMG')
//            if (pref[cataLog.embed_mode].image_hover && et.parentNode.className==='thumbnail') cataLog.image_hover_add.call(e.target,e, e.target.src.replace(/thumbnail/,'file'));
//        },
//        __proto__: site2['DEFAULT'].general_event_handler.catalog
//      },
    },

    popups_href2dbtp: function(href){ //, src, th){
//      if (href[0]==='#' && th) {
//        href = this.link_dbtp2href([th.domain, th.board, th.no, href.substr(1)]);
//        src.setAttribute('href',href);
//      }
      var hrefs = href.split(/[\/#]/);
      var p = hrefs[hrefs.length-1];
      var t = hrefs[hrefs.length-2].replace('thread-','').replace('.html','');
      var b = (hrefs.length>=3)? '/'+hrefs[hrefs.length-3]+'/' : site.board;
      return ['KC',b,t,p]
    },
    link_dbtp2href: function(dbtp){
      return dbtp[1] + 'thread-' + dbtp[2] + '.html#' + dbtp[3];
    },

    post_json2html_fname_server: function(post){return post.filename_server;},
    post_json2html_fname: function(post){return post.filename;},
    catalog_json2html3_src: function(obj) {
      return site.protocol + '//' + site2[obj.domain].domain_url + '/files/' + obj.filename_server;
    },
    catalog_json2html3_thumbnail: function(obj) {
      return site.protocol + '//' + site2[obj.domain].domain_url + '/thumbnails/' + obj.filename_server;
    },
//    catalog_json2html3_thumbnail: function(obj, board) {
//      var ext = (obj.ext==='.jpg' || obj.ext==='.png' || obj.ext==='.gif' || obj.ext==='.webm')? '.jpg' : obj.ext;
//      return (obj.ext)? 'http://i.4cdn.org' + obj.board + obj.tim + 's' + ext : '';
//    },




    
    post_json2html : function(post, board, op, short_link, th_no) {
      var pn = document.createElement('div');
      var time_unit = (post.parse_funcs && post.parse_funcs.time_unit) || 1;
      var date = new Date((post.time || 0) * time_unit -(pref.localtime_offset-site2['KC'].time_offset)*3600000);
      var html_file = '';
      if (post.filename) {
        html_file += this.post_json2html_file(post,board, post.extra_files);
        if (post.extra_files) for (var i=0;i<post.extra_files.length;i++) html_file += this.post_json2html_file(post.extra_files[i],board, true);
      }
      pn.innerHTML =
        '<div class="' +((op)? 'thread_body' : 'postreply" id="post-' +post.no) + '">'+ // <td> can't be used alone.
          '<div class="postheader">'+
            '<input name="post_' + post.no+ '" value="delete" type="checkbox">'+
            ((post.flag)? post.flag.outerHTML : '')+ //  '<img src="/images/balls/ca.png">'+
            '<span class="postsubject">' +post.sub+ '</span> '+
            '<span class="postername">' +post.name+ '</span> '+
            '<span class="postdate">' + date.toLocaleString()+ '</span> '+
            '<span class="postnumber">'+
              '<a href="/int/thread-' +th_no+ '.html#' +post.no+ '" class="quotelink">No.</a>'+
              '<a href="/int/thread-' +th_no+ '.html#q'+post.no+ '" class="quotelink">' +post.no+ '</a>'+
            '</span> '+
            '<div class="report_parent"><a href="/report/int/' +th_no +'" class="report_link"><img src="/images/icon-report.png"></a></div>'+
            ((op)? ' [<a href="' + board + 'thread-' + post.no + '.html">Reply</a>] ' : '')+
          '</div>'+
          html_file+
          '<div' + ((op)? ' class="postbody"' : '') + '>'+
            '<blockquote>'+
              '<p id="post_text_' +post.no+ '">'+ post.com + '</p>'+
            '</blockquote>'+
          '</div>'+
        '</div>'; //'<td>';
      return pn.childNodes[0];
    },
    post_pn2ce: function(pn){ // NOT DEBUGGED BECAUSE KC WAS CLOSED.
      return (pn.lastChild.firstChild.tagName==='BLOCKQUOTE')? pn.lastChild.firstChild : pn.getElementsByTagName('blockquote')[0];
    },
    post_json2html_file : function(post, board, multifile) {
      var fsize_str = (((post.fsize>1048576)? post.fsize/1048576 : post.fsize/1024)+0.005).toString();
      fsize_str = fsize_str.substr(0,fsize_str.indexOf('.')+3) + ((post.fsize>1048576)? ' MB' : ' KB');
      var fname_server = site2[post.domain].post_json2html_fname_server(post);
      var fname = site2[post.domain].post_json2html_fname(post);
      var furl = site2[post.domain].catalog_json2html3_src(post,board);
      var turl = site2[post.domain].catalog_json2html3_thumbnail(post,board);
      var html_str =
        '<div class="file_thread">'+
          '<span class="filename">'+
            '<a href="/download/' +fname_server+ '/' +fname+ '">' +fname+ '</a>'+
          '</span>'+
//          '<img id="button_expand_image_185478186" src="/images/button-expand.gif" style="cursor: pointer">'+
//          '<a href="/paint?action=new&amp;board=int&amp;thread=35608887&amp;modify=185478186&amp;applet=shipainter" onmouseover="helpTip('Modify picture')" onmouseout="UnTip()">'+
//            '<img src="/images/button-paint.gif" border="0" width="15" height="15"></a>
          '<br>'+
          '<span class="fileinfo"> '+ fname.substr(fname.lastIndexOf('.')+1).toUpperCase()+ ', ' +post.w+ 'x' +post.h+ ', ' + fsize_str + '</span><br>'+
          '<a href="' +furl+ '" target="_blank">'+
           '<img style="display: block" id="thumbnail_' +fname_server+ '" src="' +turl+ '" width="' +post.tn_w+ '" height="' +post.tn_h+ '">'+
          '</a>'+
//          '<span id="filename_XXXXXXXXX" style="display: none; margin-top: 0px; margin-left: 0px;">iPhone-SE-vs-iPhone-6S.jpg</span>'+
        '</div>'
      return html_str;
    },
    page_json2html3 : function(obj,board,thumb_url, assign_pn) { // TEMPORAL, USE thumb_url TO MIMIC. // copied from vichan.
      assign_pn = true; // test patch
      var th = document.createElement('div');
      th.setAttribute('id','thread_'+obj.no);
      th.setAttribute('style','clear:both');
      th.innerHTML = '<hr><a name=' +obj.no+ '></a>';
//      th.setAttribute('style','float: left; overflow: hidden;');
      var op = this.post_json2html((obj.posts && obj.posts[0])? obj.posts[0] : obj, board, true, site2[obj.domain].short_link(obj.key, obj.nof_posts, 2, '[Last ',' Posts]'), obj.no);
//      var files = op.getElementsByClassName('file_thread');
//      if (files.length>0) for (i=0;i<files.length;i++) th.appendChild(files[i]);
//      if (obj.posts && obj.posts[0] && obj.posts[0].extra_files) op.setAttribute('style','clear:both;');
      th.appendChild(op);
//      if (assign_pn) obj.posts[0].pn = th;
      if (assign_pn || !obj.posts[0].pn) obj.posts[0].pn = op;
      if (obj.posts) {
        for (var i=1;i<obj.posts.length;i++) {
//          th.appendChild(this.post_json2html(obj.posts[i], board));
          var pn = this.post_json2html(obj.posts[i], board);
          this.update_posts_insert_1(this.post_container(pn,obj.posts[i].no), obj.posts[i].no, null, th);
//          var pn = this.post_container(this.post_json2html(obj.posts[i], board),obj.posts[i].no); // WHY DID I DO THIS? PROBABLY THERE IS A PROBLEM IN A SOLUTION ABOVE.
//          this.update_posts_insert_1(pn, obj.posts[i].no, null, th);
//          th.appendChild(document.createElement('br'));
          if (assign_pn || !obj.posts[i].pn) obj.posts[i].pn = pn;
        }
        this.page_json2html3_add_omitted_info(obj,obj.posts,obj.posts);
////////      } else { // WILL BE REDUNDANT
////////        var keys = Object.keys(obj); // obj.posts===undefined, but it is defined as undefined, so key contains 'posts'. 
////////        obj.posts = [];
////////        obj.posts[0] = {};
////////        for (var i=0;i<keys.length;i++) if (keys[i]!=='posts') obj.posts[0][keys[i]] = obj[keys[i]]; // remove props in prototype chain.
////////        obj.posts[0].pn = op;
      }
//      var br = document.createElement('br');
//      br.setAttribute('class','clear');
//      th.appendChild(br);
//      th.appendChild(document.createElement('hr'));
      return th;
    },
    page_json2html3_replace_expander : function(posts_old, idx, key) {
      var omit_info = posts_old[0].pn.getElementsByClassName('omittedinfo')[0];
      if (omit_info) {
//        omit_info.removeChild(omit_info.childNodes[1]);
        omit_info.appendChild(cnst.config_expander(key, idx));
      }
    },
    page_json2html3_add_omitted_info : function(th,posts_old,posts) {
      var nof_files = 0;
      for (var i=1;i<posts.length;i++) nof_files += (posts[i].type_data==='html')? posts[i].pn.getElementsByClassName('file_thread').length :
                                                    (!posts[i].filename)? 0 :
                                                    (posts[i].extra_files)? posts[i].extra_files.length+1 : 1;
      var nof_files_omitted = th.nof_files - nof_files;
      var nof_posts_omitted = th.nof_posts - posts.length;

      var omit_info = (posts_old)? posts_old[0].pn.getElementsByClassName('omittedinfo')[0] : null;
      if (th.nof_posts>1) { // for expand ALL
        if (!omit_info) {
          omit_info = document.createElement('span');
          omit_info.setAttribute('class','omittedinfo');
//          omit_info.innerHTML = 'dummy<a href="javascript:void(0)">Click to expand</a>.';
          omit_info.innerHTML = 'dummy';
          omit_info.appendChild(cnst.config_expander(th.key));
          if (posts_old) posts_old[0].pn.insertBefore(omit_info, posts_old[0].pn.getElementsByClassName('postbody')[0].nextSibling);
        }
        omit_info.childNodes[0].textContent = (nof_posts_omitted!==0)? (nof_posts_omitted +' post' + ((nof_posts_omitted!==1)? 's':'') +
          ((nof_files_omitted)? ' and ' + nof_files_omitted + ' file'+ ((nof_files_omitted===1)? '' : 's') : '') + ' are not shown. ') : '';
      } else if (omit_info) omit_info.childNodes[0].textContent = 'Showing all posts.'; //if (omit_info && posts_old) posts_old[0].pn.removeChild(omit_info);
      return omit_info;
    },
    update_posts_remove: function(th_old,i,pnode,merge){
      pnode = pnode.getElementsByClassName('thread_body')[0];
      var tgt = th_old.posts[i].pn;
      if (!merge || tgt.parentNode!==pnode) tgt = tgt.parentNode.parentNode.parentNode;
      else this.update_posts_insert_pack(tgt);
      if (tgt.previousSibling && tgt.previousSibling.tagName==='A') pnode.removeChild(tgt.previousSibling); // <a>
      pnode.removeChild(tgt);
    },
    update_posts_insert: function(src,dst,i,j,pnode){
      var ref = dst[j];
//      var ref = dst[(j<dst.length)? j : dst.length-1];
      ref = (ref)? ref.pn : null;
      var ref_pnode2 = ref && ref.parentNode && ref.parentNode.parentNode && ref.parentNode.parentNode.parentNode;
      if (ref_pnode2 && ref_pnode2.parentNode && ref_pnode2.parentNode.parentNode===pnode) ref = ref_pnode2; // remove container
//      if (j>=dst.length) ref = ref && ref.nextSibling && ref.nextSibling.nextSibling || null;
      if (!src[i].pn) src[i].pn = this.post_json2html(src[i],src[i].board);
      if (i===0) this.update_posts_insert_pack(src[0].pn);
      if (j===0 && ref) this.update_posts_insert_pack(dst[0].pn);
      var tgt = (j===0 && i===0)? src[i].pn : this.post_container(src[i].pn,src[i].no); // patch for thread merging.
      this.update_posts_insert_1(tgt,src[i].no,ref,pnode);
      if (i===0 && j===0) this.update_posts_insert_unpack(src[0].pn);
    },
    update_posts_insert_1: function(tgt,no,ref,pnode){
      pnode = pnode.getElementsByClassName('thread_body')[0];
      var pn_a = document.createElement('a');
      pn_a.setAttribute('name',no);
      pnode.insertBefore(pn_a,ref);
      pnode.insertBefore(tgt, ref);
    },
    update_posts0_class: site2['vichan'].update_posts0_class,
    update_posts_insert_pack: site2['vichan'].update_posts_insert_pack,
    update_posts_insert_pack_iter: function(pn, func){
      var prev = pn.previousSibling;
      while (prev) {
        var prev_prev = prev.previousSibling; // prev is livelist.
        if (prev.classList && (prev.classList.contains(pref.script_prefix+'_footer') || prev.classList.contains('file_thread') || prev.classList.contains('post_header'))) func(prev);
        if (prev.classList &&  prev.classList.contains('postbody')) break;
        prev = prev_prev;
      }
    },
    update_posts_insert_unpack: function(pn){
      while (1) {
        var fchild = pn.firstChild;
        if (fchild && fchild.classList && (fchild.classList.contains(pref.script_prefix+'_footer') || fchild.classList.contains('file_thread') || fchild.classList.contains('post_header'))) pn.parentNode.insertBefore(fchild, pn);
        else break;
      }
    },
    post_container : function(post_pn,no) {
      var pn = document.createElement('table');
      pn.innerHTML = '<tbody><tr><td valign="top">&gt;&gt;</td></tr></tbody>';
      pn.childNodes[0].childNodes[0].appendChild(post_pn);
      return pn;
    },




    catalog_json2html3 : function(obj,board,thumb_url) {
      var th = document.createElement('article');
      th.setAttribute('class','thread teaser');
      th.setAttribute('id','thread-'+obj.no);
      var post_flag = null;
      if (obj.flags && obj.flags[0]) {
//        post_flag = obj.flags[0].cloneNode(false);
        post_flag = document.importNode(obj.flags[0],false);
        post_flag.setAttribute('class','post_country');
      }
//      th.innerHTML = '<a href="http://boards.4chan.org' + obj.board + 'thread/' + obj.no + ((obj.sub)? '/'+obj.sub.replace(/ /,'-') : '') + '">' + // cause direct jump

        th.innerHTML =
//          '<article tabindex="0" id="thread_' + obj.no + '" class="thread teaser">'+
            '<article class="thread_OP" id="' + obj.no + '">'+
              '<div class="post">'+
                '<header>'+
                  '<a><h1>'+
                    ((post_flag)? post_flag.outerHTML : '') + 
//                    '<img class="post_country" src="http://krautchan.net/images/balls/kz.png" style="cursor:pointer" name="KC/catalog/01234567">/+
                        ((obj.sub)? obj.sub : '#'+obj.no )+ 
//                        obj.sub + 
                  '</h1></a>'+
                '</header>'+
                '<div class="post_body">'+
                  '<a>'+
                    '<div class="post_files multiple">'+
                      '<figure>'+
                        '<div class="thumbnail">'+
                          '<img src="' + obj.op_img_url + '">'+
                        '</div>'+
                      '</figure>'+
                      ((obj.op_img_url2 && obj.op_img_url2[0])? (
                        '<figure>'+
                          '<div class="thumbnail">'+
                            '<img src="' + obj.op_img_url2[0] + '">'+
                          '</div>'+
                        '</figure>'+
                        ((obj.op_img_url2 && obj.op_img_url2[1])? (
                          '<figure>'+
                            '<div class="thumbnail">'+
                              '<img src="' + obj.op_img_url2[1] +'">'+
                            '</div>'+
                          '</figure>'+
                          ((obj.op_img_url2 && obj.op_img_url2[2])? (
                            '<figure>'+
                              '<div class="thumbnail">'+
                                '<img src="' + obj.op_img_url2[2] + '">'+
                              '</div>'+
                            '</figure>') :
                          '')) :
                       '')) : '') +
                    '</div>'+
                  '</a>'+
                  '<div class="omittedposts">'+
                    '<span class="omitted_text">R: 0 / I: 0 / P: 0.0&emsp;/catalog/</span>'+
                  '</div>'+
                  '<div class="post_text"><section>'+
                    obj.com +
                  '</section></div>'+
                '</div>'+
              '</div>'+
            '</article>';
//          '</article>';
      var tns = th.getElementsByClassName('thumbnail');
      tns[0].childNodes[0].addEventListener('load',site2['KC'].catalog_json2html3_onload,false);
      return th;
    },
    catalog_json2html3_onload : function() {
      this.removeEventListener('load',site2['KC'].catalog_json2html3_onload,false);
      var w = this.naturalWidth;
      var h = this.naturalHeight;
      var f = ((w>h)? w : h) / 200;
      this.setAttribute('width', w/f);
      this.setAttribute('height', h/f);
    },
    favicon : {
      __proto__: site2['DEFAULT'].favicon,
      none: '/favicon.ico',
      reply: 'png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAKJJREFUOE9jZPh/hgECfv4yts59/PgxlAujZGVlzx6dzMDOBhMAaoCjtEA01SAuUBBZDQrnwEwsGoCCKBp+HEPwPx6QkZFB1gPifjyAUABUbGxsDLIUaAxEItQFxRIgFygIlAIqSAsEKYYDkGGhLpaWlsgaQNxQFxRrxcTEsLgbhxBI8SDUQLKnSQ9WUiOO9KRBfuL7cQzoH2C0oAGQJ5GcDQBwM6RhinByrgAAAABJRU5ErkJggg==',
      reply_to_me: 'png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAMxJREFUOE9jZPh/hgECfv4yts59/PgxlAujZGVlzx6dzMDOBhMAavh/5j8MoKkGcdMCQYbCEYSFT8OBmagafhxD1iAjI4NsCYj78QBCA1CxsbEx0FKEDaEuKK4CcoFOAOoB2pMWCFIMAXANlpaWyBpA3FAXFGvFxMSQNWDxNJIQSDFEA5EAoQFfKGG1gQQNcP0gn4W6EPY0JFhBoQYJb8LBCo44KPp4gHDEoUQ70B5MgJ40kBMW0G2YAGviA9nz4xjQP8CQRgMgTyI5GwD2xdfU779fsgAAAABJRU5ErkJggg=='
    },
    add_backlinks: function(pn,backlinks,target,th){}, // dummy
  };
}
if (pref.features.domains['4chan'] || pref.features.domains['meguca']) {
  site2['4chan_i'] = {
    home:undefined,
    nickname:'4chan_i',
    nickname_href2domain:'4chan',
    domain_url: 'i.4cdn.org',
    check_func: site2['DEFAULT'].check_func,
    proto:'4chan'
  };
  site2['4chan'] = {
    nickname : '4chan',
//    home : site.protocol + '//boards.4chan.org/int/',
    home : site.protocol + '//boards.4chan.org/favicon.ico',
    protocol: 'http:',
    make_tack: function(){
      var tack = document.createElement('img');
      tack.setAttribute('src','//s.4cdn.org/image/sticky.gif');
      tack.setAttribute('class','stickyIcon retina');
      return tack;
    },
    postform_rules: null,
    postform: {
//      init:function(){
//        this.tack = site2[site.nickname].make_tack();
//        this.tack.setAttribute('style','float:right;font-size:2em;');
//        site.postform.parentNode.insertBefore(this.tack,site.postform);
//        return this.tack;
//      },
      activation: function(){
        document.getElementById('togglePostFormLink').getElementsByTagName('a')[0].click();
        this.activation = null;
      },
      __proto__:site2['DEFAULT'].postform
    },
    features : {uip_tracker: true},
    components: {
      boardlist: '.boardList',
      postform_comment: 'textarea[name="com"]',
      postform_submit: 'input[type="submit"]',
      postform_comment2: ['textarea[name="com"]',1],
      postform_submit2: ['input[type="submit"]',2],
    },
    spoiler_text: {
      open_rule: 's,s a:not(:hover) {color: #fff!important;}',
    },
    general_event_handler:(function(){
      var obj = {
        thread: {
////          last_viewed: function(e){return e.target.classList && e.target.classList.contains('post');}, // working code, but not used.
////          get_next_mark: function(pn){
////            var parent_next = pn.parentNode && pn.parentNode.nextSibling;
////            if (parent_next.tagName==='SPAN') parent_next = parent_next.nextSibling;
////            var next_post = parent_next && parent_next.getElementsByClassName('post')[0];
////            if (!next_post) {
////              var parent_parent_next = pn.parentNode.parentNode.nextSibling;
////              next_post = parent_parent_next.getElementsByClassName('post')[0];
////            }
////            return next_post;
////          },
////          get_prev_mark: function(pn){
////            var parent_prev = pn.parentNode && pn.parentNode.previousSibling;
////            if (parent_prev.tagName==='SPAN') parent_prev = parent_prev.previousSibling;
////            var prev_post = parent_prev && parent_prev.getElementsByClassName('post')[0];
////            if (!prev_post) {
////              var parent_parent_prev = pn.parentNode.parentNode.previousSibling;
////              prev_post = parent_parent_prev.getElementsByClassName('post')[0];
////            }
////            return prev_post;
////          },
          get_mark: function(pn, clientY){
            while (pn && pn!== cataLog.parent) {
              if (pn.classList.contains('post')) return pn;
              if (pn.classList.contains('postContainer')) return pn.getElementsByClassName('post')[0];
              if (pn.parentNode && pn.parentNode.classList.contains('thread')) {
                pn = pn.previousSibling;
                if (pn) continue;
                else break;
              }
              if (pn.classList.contains('thread')) break;
              pn = pn.parentNode;
            }
            return this.get_mark_from_height(clientY);
          },
          get_mark_from_height: function(now_height){
            return this.__proto__.get_mark_from_height(now_height, document.getElementsByClassName('post'));
          },
          image_hover_check_mode: function(img){
            return img.parentNode.classList.contains('fileThumb')? 'page' : 'catalog';
          },
          __proto__: site2['DEFAULT'].general_event_handler.common,
        },
      };
//      obj.catalog = { // working code
//        mouseover: function(e){
//          var et = e.target;
//          var et_tagName = et.tagName;
//          if (et_tagName==='IMG')
//            if (pref[cataLog.embed_mode].image_hover && et.parentNode.tagName==='A') cataLog.image_hover_add.call(et, e);
//        },
//        __proto__:obj.thread
//      };
      obj.catalog = Object.create(obj.thread);
      obj.page = Object.create(obj.thread);
      return obj;
    })(),
    domain_url: 'boards.4chan.org',
    check_func : function(){
      var href = window.location.href;
      if (href.search(this.domain_url)===-1) return false;
      site.whereami = (document.title.indexOf('404 Not Found')!=-1)? '404'
                    : (href.search(/catalog/)!=-1)? 'catalog'
                    : (href.search(/thread\/[0-9]+/)!=-1)? 'thread'
                    : (href.search(/archive/)!=-1)? 'archive'
                    : (href.search(/\/$|(index|[0-9]+)(\.html)*|\/#all$/)!=-1)? 'page'
                    : 'other';
      if (site.whereami==='thread') site.no = parseInt(href.replace(/.*thread\/([0-9]+)/,'$1'),10);
      site.config(this.domain_url,'4chan');
      this.postform_prep();
      site.max_page = site2['4chan'].max_page(site.board);
      site.header_height = function(){
        var header = document.getElementById('header');
        return (header)? header.offsetHeight : 0;
      }
      site.embed_to = (site.whereami==='thread')? {
        top:function(){return document.getElementsByClassName('navLinks')[0];},
        bottom:function(){return document.getElementsByClassName('bottomad')[0] || document.getElementById('boardNavDesktopFoot');}
//          site.embed_to['bottom'] = document.getElementsByClassName('bottomad')[0];
      } : (site.whereami==='page')? {
        top:function(){return document.getElementById('ctrl-top');},
//          site.embed_to['bottom'] = document.getElementsByClassName('board')[0].nextSibling; // fail
        bottom:function(){return document.getElementsByClassName('pagelist')[0];}
      } : (site.whereami==='catalog')? {
        top:function(){return document.getElementById('content').previousSibling;},
        bottom:function(){return document.getElementsByClassName('navLinksBottom')[0].nextSibling;}
      } : {};
      site.postform = document.getElementsByClassName('postForm')[0];
      return true;
    },
//    catalog_background : '#ffffee',
    //    catalog_bordercolor : '#f0e0d6',
    get_next_image: function(img,top){
      var imgs = cataLog.parent.querySelectorAll('img[data-md5]');
      var idx = Array.prototype.indexOf.call(imgs,img);
      if (idx==-1) idx = Array.prototype.indexOf.call(imgs,img.previousSibling);
      if (top) while (imgs[idx+1] && imgs[idx+1].offsetTop<top) idx++;
      if (idx>=0) {
        while (imgs[idx+1] && imgs[idx+1].parentNode.getAttribute('href').search(/\.webm$/)!=-1) idx++;
        return imgs[idx+1];
      } else return null;
    },
    format_expanded_thumbnail: function(img){
      img.removeAttribute('data-md5');
      img.className = 'expanded-thumb';
    },
    catalog_threads_in_page : function(doc){return doc.getElementsByClassName('thread');},
    catalog_posts_in_thread : function(doc){return doc.getElementsByClassName('replyContainer');},
    max_page : function(){return 10;},
    make_url4 : function(dbt, trim_page){ // dbt[2] is string.
      var url_prefix  = site.protocol + '//' + this.domain_url  + dbt[1];
      var url_prefix2 = site.protocol + '//' + 'a.4cdn.org' + dbt[1];
      if (dbt[3]==='catalog_html' || (trim_page && dbt[2]==0 && dbt[3]==='page_json')) dbt[3] = 'catalog_json'; // catalog_html is a skelton.
      return (dbt[3]==='page_json')?       [url_prefix2 + (parseInt(dbt[2],10)+1) + '.json', 'json', (trim_page)? '4chan'+dbt[1]+'j0' : undefined] : // dbt[2] is string.
             (dbt[3]==='catalog_json')?    [url_prefix2 + 'catalog.json', 'json', '4chan'+dbt[1]+'j0'] :
             (dbt[3]==='thread_json')?     [url_prefix2 + 'thread/' + dbt[2] + '.json', 'json'] :
             (dbt[3]==='page_html')?       [url_prefix  + ((dbt[2]!=0)? (parseInt(dbt[2],10)+1) :''), 'html'] :
             (dbt[3]==='thread_html')?     [url_prefix  + 'thread/' + dbt[2], 'html'] : null;
    },
    trim_list: 'force_init',
//////////    make_url : function(board,no){return [site.protocol+'//boards.4chan.org' + board + ((no!=0)? (no+1) :''), 'html'];},  // worling code.
//////////    make_url3: function(board,th){return  site.protocol+'//boards.4chan.org' + board + 'thread/' + th;},
////////    make_url : function(board,no,key){
////////      var url_prefix = site.protocol+'//boards.4chan.org' + board;
////////      return (key==='p')? [url_prefix + ((no!=0)? (no+1) :''), 'html'] :
////////                          [url_prefix + 'catalog.json'       , 'json']; // 4chan's html is skelton.
//////////             (key==='j')? [url_prefix + 'catalog.json'       , 'json'] :
//////////                          [url_prefix + 'catalog'            , 'html'];
////////    },
////////    make_url3: function(board,th){return site.protocol+'//boards.4chan.org' + board + 'thread/' + ((th[0]!=='t')? th : th.substr(1)+'.json');},
    url_boards_json : function(){return [site.protocol+'//a.4cdn.org/boards.json', 'json'];},
    archive_patch_domain: function(proto){
      Object.defineProperty(proto,'domain_xhr',{get:function(){return (this.url.indexOf('i.4cdn.org/')===-1)? null : '4chan_i';}, configurable:true, enumerable:true});
    },
    get_ops : function(doc){
      var ops = [];
      var threads = doc.getElementsByClassName('thread');
      for (var i=0;i<threads.length;i++) ops.push(threads[i].id.substring(1));
      return ops;
    },
    get_posts : function(doc) {
      var posts = [];
      var post_containers = doc.getElementsByClassName('postContainer');
      for (var i=0;i<post_containers.length;i++) posts.push(parseInt(post_containers[i].id.substring(2),10));
      return posts;
    },
////////    get_thread_link : function(pn,bn,del){
////////      var link = pn.getElementsByClassName('replylink')[0];
////////      if (link) {
//////////        if (del) link.parentNode.parentNode.removeChild(link.parentNode);
////////        if (del) {
////////          link.parentNode.removeChild(link.nextSibling);
////////          link.parentNode.removeChild(link.previousSibling);
////////          link.parentNode.removeChild(link);
////////        } else if (pref.catalog_open_in_new_tab) link.setAttribute('target','_blank');
////////        return link.getAttribute('href');
////////      } else return null;
////////    },
    modify_thread_link : function(pn){
      var link = pn.getElementsByClassName('replylink')[0];
      if (link) {
        var href = link.getAttribute('href');
        link.removeAttribute('href');
        return [[link, href]];
      } else return [];
    },
//    add_thread_link : function(doc,url){
////      <a href="thread/32599218/finland-general" class="replylink" rel="canonical">Reply</a>
//      var pn = document.createElement('a');
//      var prefix = new RegExp('https*://boards\.4chan\.org/[^/]*/');
//      pn.href = url.replace(prefix,'');
//      pn.className = 'replylink';
//      pn.rel = 'canonical';
//      pn.innerHTML = 'Reply';
//      var th = doc.getElementsByClassName('thread')[0];
//      if (th) {
//        th.insertBefore(pn,th.firstChild);
//        th.insertBefore(document.createTextNode('['),pn);
//        th.insertBefore(document.createTextNode(']'),pn.nextSibling);
//      }
//    },
    check_thread_archived : function(th){
      return (th.getElementsByClassName('archivedIcon').length!=0);
    },
//    get_time_of_posts : function(doc){
//      var posts = doc.getElementsByClassName('postContainer');
//      var last_post = posts[posts.length-1];
//      return [(parseInt(posts[posts.length-1].getElementsByClassName('dateTime')[0].getAttribute('data-utc'),10)- pref.localtime_offset*3600)*1000,
//              (parseInt(posts[0             ].getElementsByClassName('dateTime')[0].getAttribute('data-utc'),10)- pref.localtime_offset*3600)*1000];
//    },
//    get_time_of_posts : function(th){ // working code.
//      var posts = th.getElementsByClassName('postContainer');
//      return [site2['4chan'].get_time_of_post_in_utc(posts[posts.length-1]),site2['4chan'].get_time_of_post_in_utc(posts[0])];
//    },
//    get_time_of_post_in_utc : function(post){ // working code
//      return parseInt(post.getElementsByClassName('dateTime')[0].getAttribute('data-utc'),10)*1000;
//    },
    mark_newer_posts: function(th,date,unmark, short_cut) {
      return site2['DEFAULT'].mark_newer_posts('4chan',th.getElementsByClassName('postContainer'),date,function(post){return post.getElementsByClassName('post')[0];}, unmark, short_cut);
//      return site2['DEFAULT'].mark_newer_posts('4chan',th.getElementsByClassName('postContainer'),date,function(post){return post.getElementsByClassName('post reply')[0];}, unmark, short_cut);
    },
    localtime: function(pn){
      var times = pn.getElementsByClassName('dateTime');
      for (var i=0;i<times.length;i++) times[i].textContent = site2.common.change_utc_to_local(parseInt(times[i].getAttribute('data-utc'),10)*1000);
    },
    remove_files_info : function(th){
      site2.common.remove_by_classname(th,'fileText');
      site2.common.remove_by_classname(th,'mFileInfo');
      var filethumbs = th.getElementsByClassName('fileThumb');
      for (var i=0;i<filethumbs.length;i++) site2.common.move_up_and_delete_parent([filethumbs[i].childNodes[0]]);
    },
//    remove_checkboxes : function(doc){
//      var cbxs = doc.getElementsByTagName('input');
//      for (var i=cbxs.length-1;i>=0;i--) cbxs[i].outerHTML = '';
//      return doc;
//    },
    remove_posts : function(th,end){
      site2.common.remove_by_classname(th,'postContainer replyContainer',end,true);
//      site2.common.remove_double_br(th);
    },
//    absolute_link : site2['DEFAULT'].absolute_link.bind({protocol:'http:',domain_url:'http://boards.4chan.org'}), // working code.
////    absolute_link : function(doc,board){
////      var url_prefix = 'http://boards.4chan.org';
////      var protocol   = 'http:';
////      var all = doc.getElementsByTagName('*');
////      for (var i=0;i<all.length;i++) {
////        if (all[i].getAttribute('src')) 
////          if (all[i].getAttribute('src').substr(0,2)!='//') all[i].setAttribute('src', url_prefix+board+all[i].getAttribute('src'));
////          else all[i].setAttribute('src', protocol+all[i].getAttribute('src'));
////        if (all[i].getAttribute('href'))
////          if (all[i].getAttribute('href').substr(0,2)!='//') all[i].setAttribute('href',url_prefix+board+all[i].getAttribute('href'));
////          else all[i].setAttribute('href',protocol+all[i].getAttribute('href'));
////      }
////    },
////////    insert_footer : function(th,page_no,bn,exe,date,nof_posts,nof_files){
////////      var key = (!brwsr.ff)? 'innerText' : 'innerHTML';
////////      nof_posts += th.getElementsByClassName('postContainer').length;
////////      nof_files += th.getElementsByClassName('fileText').length;
////////      var om_info = th.getElementsByClassName('summary desktop');
////////      if (om_info[0]) {
////////        var str = om_info[0][key].replace(/\n/g,'');
////////        nof_posts += parseInt(str.replace(/\ post.*/,''),10);
////////        nof_files += parseInt('0'+str.replace(/\ image.*/,'').replace(/[^\ ]*\ /g,''),10);
////////      }
////////      if (exe) {
////////        var pn = document.createElement('div');
////////        pn.setAttribute('name','catalog_footer');
////////        pn.innerHTML = '<span>' + bn + '  ' + nof_posts + '/' + nof_files + '/' + page_no + '  </span>';
////////        var flags = th.getElementsByClassName('flag');
////////        for (var i=0;i<flags.length;i+=2) { // contains both mobile and desktop.
////////          pn.appendChild(flags[i].cloneNode(false));
//////////          pn.appendChild(document.createTextNode(' '));
////////        }
////////        var op_info = th.getElementsByClassName('postInfo desktop')[0];
////////        op_info.parentNode.insertBefore(pn,op_info);
////////      }
////////      return [nof_posts,nof_files];
////////    },
    format_thread_layout : function(th){
      site2.common.add_attribute_by_classname(th,'post op','style','padding:0px');
//      site2.common.add_attribute_by_classname(th,'file','style','float:left');
      site2.common.add_attribute_by_tagname(th,'blockquote','style','margin:12px 5px');
    },
    format_thread_contents : function(th){
      site2.common.remove_by_tagname(th,'input');
      site2.common.remove_by_classname(th,'mobile');
//      site2.common.remove_by_classname(th,'postLink mobile');
//      site2.common.remove_by_classname(th,'postInfoM mobile');
      site2.common.remove_by_classname(th,'sideArrows');
      site2.common.remove_by_classname(th,'summary');
    },
////////    thread2headline : function(doc){
////////      return site2.common.thread2headline(doc,'4chan');
////////    },
//    get_json_url_thread: function(board,thread){
//      return site.protocol + '//a.4cdn.org' + board +'thread/' + thread + '.json';
//    },
    get_json_url_catalog: function(board){
      return site.protocol + '//a.4cdn.org' + board +'catalog.json';
    },
    uip_check: function(callback, callback_sage){
//      var dbt = [site.nickname,site.board,site.no,(pref.uip_tracker.sage.detect)? 'catalog_json' : 'thread_json']; // catalog doesn't contain 'unique_ips'
      var dbt = [site.nickname,site.board,site.no,'thread_json']; // [site.protocol + '//a.4cdn.org' + site.board +'thread/' + site.no + '.json', 'json'];
      http_req.get('uip',dbt.join(),'',callback,false,false);
      if (pref.uip_tracker.sage.detect) {
        dbt[3] = 'catalog_json';
        http_req.get('sage_detection',dbt.join(),'',this.sage_detect,false,false, callback_sage);
      }
    },
    sage_detect_last_bumps: {}, // TEMPORAL
    sage_detect: function(key,value, callback){
      var dbt = key.split(',');
      var ths = site2['4chan'].wrap_to_parse.get(value.response, dbt[0], dbt[1], dbt[3], {page:0});
      var obj = site2['4chan'].parse_funcs['catalog_json'].add_sage(ths, site2['4chan'].sage_detect_last_bumps, site.no);
      callback(obj);
    },
    parse_json_thread: function(obj,from_http){
      if (from_http) {
//        var obj = JSON.parse(txt);
        obj.posts[obj.posts.length-1]['unique_ips'] = obj.posts[0]['unique_ips'];
        return obj;
      } else {
        var obj = {posts: []};
        var uids = {};
        var nof_uids = 0;
        var posts = document.getElementsByClassName('postContainer');
        for (var i=0;i<posts.length;i++) {
          obj.posts[i] = {};
          obj.posts[i].no = posts[i].id.replace(/pc/,'');
          var id = posts[i].getElementsByClassName('posteruid')[0];
          if (id) {
            id = id.textContent;
            obj.posts[i].id = id;
            if (uids[id]===undefined) {
              nof_uids++;
              uids[id] = 1;
            }
          }
          obj.posts[i].unique_ips = nof_uids;
        }
//        obj.posts[posts.length-1].unique_ips = document.getElementById('unique-ips').textContent; // not refreshed.
        obj.posts[posts.length-1].unique_ips = 0;
        return obj;
      }
    },
    uip_tgt_post : function(no){
      return document.getElementById('p'+no);
//      return document.getElementById('pc'+no);
    },
    uip_post_num : function(tgt_post){
      return tgt_post.getElementsByClassName('postNum');
    },
    prep_own_posts_reg: /^4chan\-track\-[0-9A-z]+\-[0-9]+$/,
    prep_own_posts_event : function(e){
      if (e) if (site2['4chan'].prep_own_posts_1(e.key)) e = null;
      if (window.name==='4chan' && !e) send_message('parent',[['OWN_POSTS', window.name, site3[window.name].own_posts]]);
    },
    prep_own_posts : function(bt){
      site3[this.nickname].own_posts = {};
      if (localStorage) {
        var keys = (bt)? [('4chan-track'+bt).replace(/\//g,'-')] :
                         Object.keys(localStorage || '{}');
        for (var i=0;i<keys.length;i++) this.prep_own_posts_1(keys[i]);
      }
//console.log(site3[this.nickname].own_posts);
    },
    prep_own_posts_1 : function(key){
      if (this.prep_own_posts_reg.test(key)) {
        var board = '/' + key.replace(/^4chan\-track\-/,'').replace(/\-[0-9]+$/,'') + '/';
        if (!site3[this.nickname].own_posts[board]) site3[this.nickname].own_posts[board] = {};
        var nos = JSON.parse(localStorage[key] || '{}');
        for (var j in nos) site3[this.nickname].own_posts[board][j.substr(2)] = null;
        return true;
      }
      return false;
    },

    catalog_native_prep: function(date,pn_filter,pn_tb,pn_hi){
      var node_ref = (site.whereami==='catalog')? document.getElementById('ctrl') :
                                                  document.getElementById('ctrl-top');
      if (site.whereami==='thread' || !node_ref) { // !node_ref for 4chan-X v1.13.8.7
        var node_ref = document.getElementsByClassName('navLinks');
        for (var i=0;i<node_ref.length;i++)
          if (window.getComputedStyle(node_ref[i]).display!=='none') {node_ref = node_ref[i]; break;}
      }
//      pn_tb.setAttribute('style', 'float:right');
      cnst.tb_prep_for_embed(pn_tb);
      if (site.whereami==='catalog') {
        var selector_native = document.getElementById('order-ctrl');
        if (selector_native.selectedIndex!=0) {
          selector_native.selectedIndex = 0;
          var evt = document.createEvent('UIEvents');
          evt.initUIEvent('change', false, true, window, 1);
          selector_native.dispatchEvent(evt);
        }
        selector_native.style.display = 'none';
        document.getElementById('size-ctrl').addEventListener('change', site2['4chan'].catalog_native_size_changed, false);

////        var fl = document.getElementById('filters-ctrl'); // working code.
////        fl.parentNode.setAttribute('style','display:none');
////        var qf2 = this.catalog_native_prep_clonenode(document.getElementById('qf-box'));
//////        var qf = document.getElementById('qf-box');
//////        var qf2= qf.cloneNode();
//////        qf2.name = 'CatChan_qf2';
//////        qf.parentNode.insertBefore(qf2,qf.nextSibling);
//////        qf.setAttribute('style','display:none');
////        var kwd_str = document.getElementsByName('catalog.filter.kwd.str')[0];
////        if (kwd_str.value!=='') {
////          kwd_str.value = '';
////          pref_func.apply_prep(kwd_str,true,true);
////        }
////        qf2.onkeyup = function(){
////          pref.catalog.filter.kwd.str = this.value;
////          pref_func.apply_prep(kwd_str,false);
////          kwd_str.onkeyup();
////        }
////        var qfctrl = this.catalog_native_prep_clonenode(document.getElementById('qf-ctrl'),true);
////        qfctrl.onclick = function(){
////          var qf_cnt = document.getElementById('qf-cnt');
////          if (qf_cnt.style.display==='none') qf_cnt.style.display = 'inline';
////          else {
////            qf_cnt.style.display = 'none';
////            qf2.value = '';
////            qf2.onkeyup();
////          }
////        }
////        var qfc = this.catalog_native_prep_clonenode(document.getElementById('qf-clear'),true);
////        qfc.onclick = function(){
////          qfctrl.onclick();
////        }
        pref3.catalog.filter.kwd.init(document.getElementById('qf-box'), pn_filter).id = null;
//        var qf = document.getElementById('qf-box');
//        var qf2 = qf.cloneNode(false);
//        qf2.name = 'catalog.filter.kwd.str';
//        qf2.id = null;
//        qf2.oninput = cataLog.event_func;
//        qf.parentNode.insertBefore(qf2,qf);
//        qf.setAttribute('style','display:none');
//        pref3.catalog.filter.kwd.obj = [pn_filter.getElementsByTagName('input')['catalog.filter.kwd.str'], qf2];
        var clear_func = pref3.catalog.filter.kwd.clear.bind(pref3.catalog.filter.kwd);
        document.getElementById('qf-ctrl').addEventListener('click',clear_func,false);
        document.getElementById('qf-clear').addEventListener('click',clear_func,false);
//        clear_func();

//        var pn_tb_new = document.createElement('span');
//        while (pn_tb.firstChild) pn_tb_new.appendChild(pn_tb.firstChild);
//        pn_tb = pn_tb_new;
//        pn_tb.appendChild(pn_tb.removeChild(pn_tb.childNodes[3]).firstChild);
      } else if (site.whereami==='page') {
//        var pctrls = document.getElementsByClassName('board')[0]; // test patch
//        for (var i=pctrls.childNodes.length-1;i>=0;i--) if (pctrls.childNodes[i].tagName==='HR') pctrls.removeChild(pctrls.childNodes[i]);
//        pctrls.parentNode.insertBefore(document.createElement('hr'),pctrls.nextSibling);
      }
//      node_ref.parentNode.insertBefore(pn_tb,node_ref);
      node_ref.appendChild(pn_tb);
//      node_ref.parentNode.insertBefore(pn_filter,node_ref);
      var selector_catchan = pn_filter.getElementsByTagName('select')['catalog.indexing'];
      if (site.whereami==='catalog') selector_native.parentNode.insertBefore(selector_catchan,selector_native);
      else pn_tb.childNodes[3].insertBefore(selector_catchan,pn_tb.childNodes[3].firstChild);
////////      return site2['4chan'].catalog_from_native(date,document,site.board,site.whereami+'_html');
    },
    catalog_native_prep_clonenode : function(node,deep) {
      var cn = node.cloneNode(deep);
      cn.setAttribute('name',((cn.name)? cn.name : 'clone_node') + '_CatChan');
      node.parentNode.insertBefore(cn,node.nextSibling);
      node.setAttribute('style','display:none');
      return cn;
    },
////////    catalog_from_native : function(date,doc,board,type) { // working code.
////////      return this.wrap_to_parse.get(doc, this.nickname, board, type);
////////    },
//    catalog_from_native : function(date,doc,board,type) { // working code.
//      var parse_obj = {domain:'4chan', board:board, parse_funcs:site2['4chan'].parse_funcs[type], __proto__:site4.parse_funcs_on_demand};
//      var ths = {pn:doc, __proto__:parse_obj};
//      return ths.ths;
//    },
    catalog_get_native_area: function(){
      if (site.whereami==='catalog') return document.getElementById('threads');
      else return document.getElementsByClassName('board')[0];
    },
    catalog_native_size: (document.getElementById('size-ctrl'))? document.getElementById('size-ctrl').value : 'small',
    catalog_native_size_changed: function(){
      site2['4chan'].catalog_native_size = this.value;
      var threads = catalog_obj.catalog_func().get_threads();
      for (var name in threads) if (threads[name][0]) site2['4chan'].catalog_json2html3_size_changed(threads[name][0].getElementsByTagName('img')[0]);
      catalog_obj.catalog_func().show_catalog();
    },
    parse_funcs : { // 4chan
      'catalog_html' : {
        ths: 'thread_html',
//        th_init: function(th) {
//          th.pn.getElementsByTagName('a')[0].addEventListener('click',th.parse_funcs.preventDefault,false);
//        },
//        th_destroy: function(pn, parse_funcs){
//          pn.getElementsByTagName('a')[0].removeEventListener('click',parse_funcs.preventDefault,false);
//        },
//        ths: function(doc) {
//          var ths = this.ths_array(doc,doc.pn.getElementsByClassName('thread'));
//          for (var i=0;i<ths.length;i++)
//            ths[i].pn.getElementsByTagName('a')[0].removeAttribute('href');
//          return ths;
//        },
        no : function(th){return parseInt(th.pn.getAttribute('id').substr(7),10);},
        time_bumped: function(th){return -1;},
        time_created : function(th){return -1;},
        nof_posts: function(th){
          var footer = th.pn.getElementsByClassName('meta')[0];
          var tmp = footer.textContent.match(/[0-9]+/g);
          if (tmp===null) tmp = [0,0];
          else if (tmp.length==1) tmp[1]=0;
          Object.defineProperty(th, 'nof_files', {value:parseInt(tmp[1],10), enumerable:true, writable:true, configurable:true});
          Object.defineProperty(th, 'footer', {value:footer, enumerable:true, writable:true, configurable:true});
          footer.innerHTML = '';
          return parseInt(tmp[0],10);
        },
        nof_files: function(th){
          if (!th.hasOwnProperty('nof_posts')) th['nof_posts'] = this['nof_posts'](th);
          return th.nof_files;
        },
        key: function(th){return th.domain + th.board + th.no;},
        sub: function(th){
          var ts = th.pn.getElementsByClassName('teaser')[0];
          var sub = (ts)? ts.getElementsByTagName('b') : null;
          var com = (!ts)? '' : (sub && sub[0])? ((ts.childNodes[1])? ts.childNodes[1].textContent : '') : ts.childNodes[0].textContent;
          Object.defineProperty(th, 'com', {value:com, enumerable:true, writable:true, configurable:true});
          return (sub && sub[0])? sub[0].textContent : '';
        },
        name: function(th){return '';},
        com: function(th){
          if (!th.hasOwnProperty('sub')) Object.defineProperty(th, 'sub', {value:this['sub'](th), enumerable:true, writable:true, configurable:true});
          return th.com;
        },
        footer: function(th){
//          if (!th.hasOwnProperty('nof_posts')) Object.defineProperty(th, 'nof_posts', {value:this['nof_posts'](th), enumerable:true, writable:true, configurable:true});
//          return th.footer;
          var footer = th.pn.getElementsByClassName('meta')[0]; // must parse pn because of mimic mode.
          footer.innerHTML = '';
          return footer;
        },
        sticky: function(th){return th.pn.getElementsByClassName('stickyIcon')[0]!==undefined;},
//        format: function(th){th.pn.getElementsByTagName('a')[0].removeAttribute('href');return null;},
        tn_as: function(th){return th.pn.getElementsByTagName('a');},
        tn_imgs: function(th){
          var a0 = th.pn.getElementsByTagName('a')[0];
          return (a0)? [a0.getElementsByTagName('img')[0]] : [];}, // for chart popup, not using tn_as
//        tn_imgs: function(th){return (th.tn_as[0])? [th.tn_as[0].getElementsByTagName('img')[0]] : [];},
        class_thread: 'thread',
        class_thumbnail: 'thumb',
//        op_img_url: function(th){ // working code.
//          var img = th.pn.getElementsByTagName('img')[0];
//          return (img)? img.getAttribute('src') : undefined; // patch.
//        },
        op_img_url: function(th){return (th.tn_imgs[0])? th.tn_imgs[0].getAttribute('src') : undefined;}, // patch. // BUG IN MIMIC MODE, BECAUSE THIS REQURES TH.PN AND TH.PN WILL BE WRITTEN AFTERWARDS. // moved from DEFAULT.common
        get_op_src: 'thread_json',
//        get_op_src: function(th){ // working code.
//          return (th.op_img_url.indexOf('s.4cdn.org')!=-1)? th.op_img_url : th.op_img_url.replace(/s(\.\w+)$/,'$1');}, // TEMPORAL PATCH
        dynamic_image_hover: true,
        missing_info: 1,
        img2src: function(img){
          var lth = this.get_lth_from_node(img);
          if (!lth) return null;
          var src = img.src;
          if (lth.th && lth.th.ext) src = src.replace(/thumb/,'src').replace(/s\.[^\.]*$/,lth.th.ext);
          else if (lth.th.parse_funcs.missing_info) scan.scan_ui('image_hover', {tgts: [lth.domain+lth.board], options:{callback:function(){cataLog.image_hover_reentry(img);}, priority:6}}); // NEVER ACTIVATED because catalog.json is read always at initial
          return src;
        },
        time_unit: 1000,
      },
      'catalog_json' : {
        ths: function(obj, parse_obj) {
          var ths = [];
          for (var i=0;i<obj.length;i++)
            if (obj[i].threads) for (var j=0;j<obj[i].threads.length;j++) {
              var tgt = obj[i].threads[j];
              tgt.__proto__ = parse_obj;
              ths[ths.length] = {
                page: i + '.' + j,
                key: parse_obj.domain + parse_obj.board + tgt.no,
                __proto__: tgt,
              }
            }
          return ths;
        },
//        ths: 'DEFAULT.catalog_json',
        time_posted: function(th){return (th.last_replies)? th.last_replies[th.last_replies.length-1].time*1000 : th.time_created;},
        time_bumped: function(th){return (th.bumplimit)? undefined : th.time_posted;},
        time_created : function(th){return th.time*1000;},
        nof_posts: function(th){return th.replies+1;}, // same as 8chan
        nof_files: function(th){return th.images+1;},
////        key: function(th){return th.domain + th.board + th.no;}, // same as 8chan
////        sub: function(th){return (th.hasOwnProperty('sub'))? th.sub : '';},
////        name: function(th){return (th.hasOwnProperty('name'))? th.name : '';},
////        com: function(th){return (th.hasOwnProperty('com'))? th.com : '';},
        op_img_url: 'DEFAULT.common',
////        op_img_url: function(th) {
////          return site2['4chan'].catalog_json2html3_thumbnail(th, th.board);},
        //        footer: function(th){return th.pn.getElementsByClassName('meta')[0];},
        posts: function(th){
          return (th.last_replies)? [th.__proto__].concat(th.last_replies) : [th.__proto__];
        },
////        posts: function(th){
////          var posts = site2['DEFAULT'].parse_funcs.catalog_json.posts(th);
////          if (th.last_replies) posts = posts.concat(th.last_replies);
////          return posts;
////        },
//////        posts: function(th){return th.last_replies;}, // can't show icon in desktop notification. // BUG, don't hit at search.
//////        posts: function(th){ // work, but parse redundantly
//////          if (th.last_replies) for (var i=0;i<th.last_replies.length;i++)
//////            th.last_replies[i].op_img_url = site2['4chan'].catalog_json2html3_thumbnail(th.last_replies[i], th.board);
//////          return th.last_replies;
//////        },
        has_posts: true,
////        last_replies: function(th){return undefined;}, // stop parsing loop between 'posts' and 'last_replies'
//        add_op_img_url: function(th){  // slow in chrome because of making needless prefetch.
//          for (var i=0;i<th.posts.length;i++)
//            th.posts[i].op_img_url = site2['4chan'].catalog_json2html3_thumbnail(th.posts[i], th.board);
//        },
//        add_op_img_url: function(posts,board){
//          for (var i=0;i<posts.length;i++)
//            posts[i].op_img_url = site2['4chan'].catalog_json2html3_thumbnail(posts[i], board);
//        },
        add_op_img_url: site2['DEFAULT'].parse_parts.add_op_img_url,
        time_unit: 1000,
        get_op_src: 'thread_json',
        type_com: 'html',
        posts_full: null,
////        posts_full: 'DEFAULT.catalog_json',
        missing_info: undefined,
        tn_as: 'catalog_html',
        tn_imgs: 'catalog_html',
        footer: 'catalog_html',
        class_thread: 'catalog_html',
        class_thumbnail: 'catalog_html',
        add_sage: function(ths, bumps, end_no){
          var i=0;
          while (i<ths.length && ths[i].sticky) if (ths[i].no===end_no) return ths[i]; else i++;
          if (pref.uip_tracker.sage.patch_bug3) { // ignore not updated data
            var latest_bump = bumps['ALL'] || 0;
            while (i<ths.length && ths[i].last_modified<latest_bump) if (ths[i].no===end_no) return ths[i]; else i++;
            if (i<ths.length) bumps['ALL'] = ths[i].last_modified;
          }
          if (i==ths.length) return;
          if (ths[i].no==end_no) return ths[i];
          latest_bump = ths[i].last_modified; // for deletion of the last post, instead of ths[i].posts[ths[i].posts.length-1].time;
          var tolerance = pref.uip_tracker.sage.tolerance;
          while (++i<ths.length) { // can't use stateful fast approach because of 4chan's bug.
            var th = ths[i];
            if (!th.bumplimit) {
              for (var j=th.posts.length-1;j>=1;j--) { // annotate all
                var time = th.posts[j].time;
                if (bumps[th.no]>=time) break; // for deletion
                if (latest_bump+tolerance>=time) break; // bug of 4chan at roundup, 1 tolerance is required.
//                if (latest_bump>=time) break;
                th.posts[j].email = 'sage'; // vichan has 'email' field.
                if (pref.debug_mode['30']) console.log('detect: sage: p:'+Math.floor(i/15)+'.'+(i%15)+', '+th.key+'#'+th.posts[j].no+', '+time+', '+latest_bump);
              }
              if (j===0) time = th.posts[0].time; // j===0 when all posts are sage.
              if (th.posts.length===1 || th.posts[th.posts.length-1].time!=th.last_modified) time = th.last_modified; // for deletion of the last post, assumes last post was age. th.posts.length===1 for new threads which has no posts.
//              if (time<th.last_modified) time = th.last_modified; // for deletion of the last post.
              if (!bumps[th.no] || bumps[th.no]<time) bumps[th.no] = time;
              latest_bump = (pref.uip_tracker.sage.patch_bug2 && i<pref.uip_tracker.sage.patch_bug2nth)? th.last_modified : bumps[th.no]; // for fast board like /v/.
//              latest_bump = bumps[th.no];
            }
            if (th.no==end_no) return th;
          }
        },
        flags: 'DEFAULT.page_json',
        proto: 'DEFAULT.catalog_json',
      },
      'page_html' : {
        ths: 'thread_html',
        th_init: function(th) {th.pn.removeAttribute('class');},
//        th_destroy: function(pn, parse_funcs){},
        no: 'post_html',
//        ths: function(doc) { // working code.
//          var ths = this.ths_array(doc, doc.pn.getElementsByClassName('thread'));
//          for (var i=0;i<ths.length;i++) {
//            Object.defineProperty(ths[i], 'no', {value:ths[i].pn.id.substr(1), enumerable:true, writable:true, configurable:true});
//            ths[i].pn.removeAttribute('class'); // collection ISN'T writable? and if wrote, its enumerator doesn't work.
//          }
//          return ths;
//        },
//        no : function(th){return parseInt(th.pn.getElementsByClassName('postContainer')[0].id.substring(2),10);},
//        last_replies: 'catalog_json',
        time: 'post_html',
        nof_posts: function(th){
          var nof_posts = th.pn.getElementsByClassName('postContainer').length;
          var nof_files = th.pn.getElementsByClassName('fileText').length;
          var om_info   = th.pn.getElementsByClassName('summary desktop')[0];
          if (om_info) {
            var str = om_info[brwsr.innerText].replace(/\n/g,'');
            nof_posts += parseInt(str.replace(/\ post.*/,''),10);
            nof_files += parseInt('0'+str.replace(/\ image.*/,'').replace(/[^\ ]*\ /g,''),10);
          }
          Object.defineProperty(th,'nof_files',{value:nof_files, enumerable:true, configurable:true, writable:true});
          return nof_posts;
        },
        nof_files: function(th){
          if (!th.hasOwnProperty('nof_posts')) this['nof_posts'](th);
          return th.nof_files;
        },
        sub: 'DEFAULT.post_html',
        name: function(post){return post.pn.getElementsByClassName('name')[0][brwsr.innerText];}, // same as 8chan
        com:  function(post){return post.pn.getElementsByClassName('postMessage')[0].innerHTML;},
        footer: function(th){return this.insert_footer4(th.pn.getElementsByClassName('postInfo desktop')[0]);},
        sticky: function(th){return (th.pn.getElementsByClassName('stickyIcon').length!=0);},
        flag: 'post_html',
        op_img_url:function(th){
          var img = th.pn.getElementsByTagName('img')[0];
          var url = (img)? img.getAttribute('src') : undefined;
          return url;
        },
        get_thread_links : function(th){return th.pn.querySelectorAll('.replylink,.'+pref.script_prefix+'_link');}, // PATCH
//        get_thread_links : function(th){return th.pn.getElementsByClassName('replylink');}, 
//        get_omitted_info : function(post){return post.pn.getElementsByClassName('summary')[0];},
        get_omitted_info : function(post){
          var omit_info = post.pn.parentNode.nextSibling;
          return (omit_info && omit_info.classList.contains('summary'))? omit_info : undefined;
//          var omit_info = post.pn.parentNode.parentNode; // working, but slow.
//          if (omit_info) omit_info = omit_info.getElementsByClassName('summary')[0];
////          if (omit_info && omit_info.childNodes[1]) omit_info = omit_info.childNodes[1];
//          return omit_info;
        },
        set_omitted_info : function(post, info){post.pn.parentNode.parentNode.insertBefore(info, post.pn.parentNode.nextSibling);},
        replace_omitted_info : function(dst, src){dst.childNodes[1].textContent = src.childNodes[1].textContent;},
        replace_omitted_info2 : function(dst, src, th){
//          if (!dst.childNodes[1]) { // for 4chan-X v1.13.8.7 in therad, but this isn't required.
          if (dst.tagName==='A') { // for 4chan-X v1.13.8.7
            var span = document.createElement('span');
            span.setAttribute('class','summary');
            span.appendChild(document.createElement('span'));
            span.appendChild(dst);
            dst = span;
          }
//          if (!src) dst.parentNode.removeChild(dst); // BUG, when I choose ALL in expander, the expander will disappear.
          if (!src) {
            dst.childNodes[0].setAttribute('style','display:none');
            dst.childNodes[1].setAttribute('style','display:none');
          } else {
            if (dst.childNodes[1].style.display==='none') {
              if (th.domain===site.nickname) dst.childNodes[0].removeAttribute('style');
              dst.childNodes[1].removeAttribute('style');
            }
            this.replace_omitted_info(dst,src);
          }
        },
        get_op_src: 'thread_json',
        time_unit: 1000,
        pn_name: 'post_html', // temporal patch, this should be removed using inherit. Errors can be reproduced when there are mine posts in thread and add_you function is working.
      },
      'page_json'  : {
        ths: 'DEFAULT.page_json',
        get_op_src: 'thread_json',
        proto: 'thread_json'
      },
      'thread_html' : {
        ths: function(doc) {return this.ths_array(doc, doc.pn.getElementsByClassName('thread'));},
//        ths: function(doc) {return site2['DEFAULT'].parse_funcs['thread_html'].ths_array(doc, doc.pn.getElementById('t'+doc.thread));}, // working code.
//        ths: function(doc) { // working code.
//          return [{pn:doc.pn.getElementById('t'+doc.thread),
//                   type_html: 'thread_html',
//                   page: '?',
//                   __proto__: doc.__proto__}];
//        },

//        pop_post: function(th){ // debuging code.
//          th.post = th.posts[--th.idx_pop];
//          return th.post;
//        },
//        pop_post_prep: function(th){
//          delete th.posts;
//          th.idx_pop = th.posts.length;
//        },
////        pop_post: function(th){ // working code
////          while (th.idx_pop>=0) {
////            var pn = th.children[th.idx_pop--];
////            if (pn.className && pn.className.indexOf('postContainer')!=-1) {
////              th.post = {pn:pn, parse_funcs:this, __proto__:th.__proto__};
////              return true;
////            }
////          }
////          return false;
////        },
//////        post_no: function(post){return parseInt(post.pn.id.substr(3),10);},
////        post_no: function(post){return parseInt(post.pn.id.substr(2),10);}, // 2015.05.12, maybe depends on baord???
        get_op_src: 'thread_json',
        time_unit: 1000,
        pn_name: 'post_html', // temporal patch, this should be removed using inherit. Errors can be reproduced when there are mine posts in thread and add_you function is working.
        proto: 'page_html',
      },
      'thread_json'  : {
////        op_img_url: function(th){
////          return site2[th.domain].catalog_json2html3_thumbnail(th.posts[0],th.board);},
        tn_as: 'catalog_html.tn_as',
        sticky: function(th){return th.posts[0].sticky;},
        time_bumped : function(obj){return (obj.posts[0].bumplimit)? undefined : obj.posts[obj.posts.length-1].time*1000;}, // 4chan doesn't have email field.
//                   obj.posts[site3[this.domain].boards[this.board].bump_limit-2].time*1000 :   // for safety, 2.
//        get_op_src: function(th){return th.op_img_url.replace(/s\..*/,th.ext);},
        get_op_src: function(th, img){
          if (th.op_img_url.indexOf('s.4cdn.org')!=-1) return th.op_img_url;
          if (!th.ext && th.parse_funcs.missing_info) scan.scan_ui('image_hover', {tgts: [th.domain+th.board+'j0'], options:{callback:function(){cataLog.image_hover_reentry(img);}, priority:6}}); // NEVER ACTIVATED because catalog.json is read always at initial
          return (th.localArchive)? site2[th.domain].catalog_json2html3_src(th,th.board) :
                 (th.ext)? th.op_img_url.replace(/s(\.\w+)$/, th.ext) : img.src;
//          return (th.ext)? th.op_img_url.replace(/s(\.\w+)$/, th.ext) : img.src;
        },
        consolidate_IDB_result_sub: function(posts){
          posts[0].nof_posts = posts.length;
          var nof_files = 0;
          for (var i=0;i<posts.length;i++) if (posts[i].filename) nof_files++;
          posts[0].nof_files = nof_files;
        },
        flags: 'DEFAULT.page_json',
        proto: 'DEFAULT.thread_json'
      },
      'post_html': {
        no : function(th){
          var id = th.pn.getAttribute('id');
          return parseInt(id.substr(1),10) || parseInt(id.substr(2),10)},
        time: function(post){
          return parseInt(post.pn.getElementsByClassName('dateTime')[0].getAttribute('data-utc'),10);
        },
        time_pn: function(post_pn){return parseInt(post_pn.getElementsByClassName('dateTime')[0].getAttribute('data-utc'),10)*1000;}, // returns utc.
        flag: function(post){  // same as 8chan
          var flags = post.pn.getElementsByClassName('flag');
          return (flags.length!=0)? document.importNode(flags[0],false) : null;
        },
//        txt2com: function(txt){
//          txt = txt.replace(/(^>[^>].*$)/mg,'<span class="quote">$1</span>');
//          txt = txt.replace(/\*\*([^(\*\*)]*)((\*\*)|$)/g,'<s>$1</s>');
//          return txt.replace(/\n/g,'<br>');},
        txt2com_anchor_class: 'quotelink',
        txt2com_spoiler_replace_txt: '<s>$1</s>',
        time_unit: 1000,
        pn_name: function (post){return post.pn.getElementsByClassName('desktop')[0].getElementsByClassName('name')[0];},
        proto: 'DEFAULT.post_html',
      },
      'post_json': {
        proto: 'DEFAULT.post_json',
      },
    },
////    toplevel_anchor: function(th){
////      var as = th.pn.getElementsByTagName('a');
////      for (var i=0;i<as.length;i++) {
////        var href = as[i].getAttribute('href');
////        if (href && href[0]==='#') as[i].setAttribute('href',th.board + 'thread/' + th.no + href);
////      }
////    },
    popups_posts_class_hlt: 'highlight',
    popups_href2dbtp: function(href){ //, src, th){
//      if (href[0]==='#' && th) {
//        href = this.link_dbtp2href([th.domain, th.board, th.no, href.substr(2)]);
//        src.setAttribute('href',href);
//      }
      var hrefs = href.split(/[\/#]/); // hrefs will be [ '', '1234'] when href is #1234.
      var len = hrefs.length;
      var p = hrefs[len-1].substr(1);
      var t = len>=2 && hrefs[len-2] || site.no;
      var b = (len>=4 && hrefs[len-4])? '/'+hrefs[len-4]+'/' : site.board;
      if (hrefs[len-2]==='catalog') {
        p = hrefs[len-1].slice(2,-3);
        t = p;
        b = (len>=3 && hrefs[len-3])? '/'+hrefs[len-3]+'/' : site.board;
      }
      return ['4chan',b,t,p]
    },

    update_posts_remove: function(th_old,i,pnode){
if (pref.debug_mode['13'] && th_old.posts[i].pn.parentNode.parentNode!==pnode) console.log(th_old.posts[i].pn);
      var tgt = th_old.posts[i].pn.parentNode;
      var expander = (i==0)? tgt.nextSibling : null; // for merge
      pnode.removeChild(tgt);
      if (expander && expander.tagName==='SPAN') pnode.removeChild(expander);
    },
////    update_posts_remove_lock: function(th_old,i,pnode, now_height){ // TEST, slow implementation
////      var ref, ref_pos;
////      var tgt = th_old.posts[i].pn.parentNode;
////      if (now_height && tgt.offsetTop<now_height) ref = tgt.nextSibling || tgt.parentNode.nextSibling;
////      if (ref) ref_pos = ref.offsetTop;
////      pnode.removeChild(th_old.posts[i].pn.parentNode);
////      return (ref)? ref.offsetTop - ref_pos : 0;
////    },
    update_posts_insert: function(src,dst,i,j,pnode){
      var ref = (j<dst.length)? dst[j].pn.parentNode : null;
      if (!src[i].pn) src[i].pn = this.post_json2html(src[i], src[i].board);
      var tgt = src[i].pn.parentNode || this.post_container(src[i].pn,src[i].no);
      var expander = (i==0)? tgt.nextSibling : null; // for merge
      pnode.insertBefore(tgt, ref);
      if (expander && expander.tagName==='SPAN') pnode.insertBefore(expander, ref);
    },
//    update_posts_insert: function(src,dst,i,j,pnode){ // working code.
//      var ref;
//      if (j<dst.length) {
//        ref = dst[j].pn.parentNode;
//        if (ref.tagName==='SPAN') ref = ref.nextSibling; // skip summary, don't see j===1 for merge.
//      } else ref = null;
//      if (!src[i].pn) src[i].pn = this.post_json2html(src[i], src[i].board);
//      var tgt = src[i].pn.parentNode || this.post_container(src[i].pn,src[i].no);
//      pnode.insertBefore(tgt, ref);
//    },
////    update_posts_insert: function(th,th_old,i,j,pnode){ // working code.
//////      var ref = (j==1)? (th_old.posts[0].pn.parentNode.nextSibling || th_old.posts[0].pn.parentNode) : 
//////                         th_old.posts[th_old.posts.length-1].pn.parentNode;
////      var ref;
////      if (j<th_old.posts.length) {
////        ref = th_old.posts[j].pn.parentNode;
////        if (ref.tagName==='SPAN') ref = ref.nextSibling; // skip summary, don't see j===1 for merge.
////      } else ref = null;
////      if (!th.posts[i].pn) th.posts[i].pn = this.post_json2html(th.posts[i],th.board);
////      pnode.insertBefore(this.post_container(th.posts[i].pn,th.posts[i].no), ref);
////    },
////    update_posts_insert_lock: function(th,th_old,i,j,pnode, now_height){ // TOO SLOW
////      var ref, ref_pos;
////      if (j<th_old.posts.length) {
////        ref = th_old.posts[j].pn.parentNode;
////        if (ref.tagName==='SPAN') ref = ref.nextSibling; // skip summary, don't see j===1 for merge.
////      } else ref = null;
////      if (now_height && ref) ref_pos = ref.offsetTop;
////      if (!th.posts[i].pn) th.posts[i].pn = this.post_json2html(th.posts[i],th.board);
////      pnode.insertBefore(this.post_container(th.posts[i].pn,th.posts[i].no), ref);
////      return (ref_pos<now_height)? ref.offsetTop - ref_pos : null;
////    },
    post_container : function(post_pn,no, op) {
      var pn = document.createElement('div');
      pn.setAttribute('id','pc'+no);
      pn.setAttribute('class','postContainer ' + ((op)? 'op' : 'reply') + 'Container');
      if (op) {
//<div class="postLink mobile"><span class="info">97 Replies / 26 Images</span><a href="thread/138122016" class="button">View Thread</a></div>
      } else {
        pn.innerHTML = '<div class="sideArrows" id="sa'+no+'">&gt;&gt;</div>';
      }
      pn.appendChild(post_pn);
      return pn;
    },
    remove_backlink: function(pn,idx){
      var bks = pn && pn.getElementsByClassName('backlink')[0];
      var blk = bks && bks.childNodes[idx];
      if (blk) bks.removeChild(blk);
    },
    add_backlinks_bks: (function(){
      var bks = document.createElement('div'); // why div???
      bks.setAttribute('class','backlink');
      return function(){
        return bks.cloneNode(false);
      }
    })(),
    add_backlinks_add_1: (function(){
      var blk = document.createElement('a');
      blk.setAttribute('class','quotelink');
      var blk2 = document.createElement('span');
      blk2.appendChild(blk);
      blk2.appendChild(document.createTextNode(' '));
      return function(bks, dbtpth){
        blk.setAttribute('href',dbtpth[5]);
        blk.textContent = dbtpth[4];
        var pn = blk2.cloneNode(true);
        if (dbtpth[0]!=='4chan' || pref.test_mode['91']) { // TO BE REMOVED
          var pn1 = pn.firstChild;
          pn1.onclick = this.backlink_onclick;
//          pn1.onmouseover = this.popups_post_entry;
        }
        bks.appendChild(pn);
      };
    })(),
    add_backlinks_bks_query: function(pn){
      return pn.getElementsByClassName('backlink')[0];
    },
////    add_backlinks: function(pn,backlinks,target, th){
////if (pref.test_mode['35']) return;
////      var bks_pn = pn.getElementsByClassName('backlink')[0];
////      var bks = bks_pn || this.add_backlinks_bks();
////      if (!target) bks.innerHTML = ''; // this hits target===0 also and clean up.
////      for (var i=(target || 0);i<backlinks.length;i++) {
////        var dbtp = this.popups_backlink2dbtpth(backlinks[i], th);
//////        var domain = dbtp[0];
//////        var board = dbtp[1];
//////        var post_no = dbtp[3];
//////        var txt = dbtp[4];
//////        var href = site2[domain].link_dbtp2href(dbtp);
//////        if (domain!==site.nickname) href = site2[domain].absolute_link_1(href);
////
//////        var blk = null; // IS THIS REQUIRED???
//////        if (target!==undefined) {
//////          var as = bks.getElementsByTagName('a');
//////          for (var j=0;j<as.length;j++)
//////            if (as[j].textContent===txt) {
//////              blk = as[j];
//////              break;
//////            }
//////        }
//////        if (!blk)
////        this.add_backlinks_add_1(bks, dbtp);
////        if (target) break;
////      }
////      if (!bks_pn) pn.getElementsByClassName('desktop')[0].appendChild(bks); // for 4chan-X v1.13.8.7
//////        var ref = this.backlink_parent_prevSib(pn);
//////        ref.parentNode.insertBefore(bks,ref.nextSibling);
////    },
    add_backlinks_bks_append: function(pn, bks){
      pn.getElementsByClassName('desktop')[0].appendChild(bks); // for 4chan-X v1.13.8.7
    },
    toplevel_anchor_pos:2,
    link_dbtp2href: function(dbtp, quote){
      return (dbtp[1]!=site.board || dbtp[2]!=site.no? dbtp[1]+'thread/'+dbtp[2] : '') + '#'+(quote?'q':'p')+dbtp[3];
    },
    backlink_onclick: function(){
      highlightReply.call(this,parseInt(this.textContent.substr(2),10)); // call native function in 4chan.
    },
//    backlink_class: 'quotelink',
    backlink_parent_prevSib: function(pn){return pn.getElementsByClassName('postNum')[1];},

//    post_json2html : site2['vichan'].post_json2html,
    //    post_json2html_file : site2['vichan'].post_json2html_file,
    post_com2txt: function(post){
      return (post.com)? post.com.replace(/<[^>]*>/g,' ').replace(/&gt;/g,'>').replace(/&lt;/g,'<').replace(/&quot;/g,'"').replace(/&#039;/g,"'").replace(/&#0*44;/g,',').replace(/&amp;/g,'&') : ''; // most of 4chan. speed: 13.07/2.38 inlainchan.
    },
    post_json2html : function(post, board, op, short_link, op_no) {
      if (op_no===undefined) op_no = post.op || post.resto || post.no;
      if (op===undefined) op = post.resto===0 || post.no==post.op;
      var pn = document.createElement('div');
      var time_unit = (post.parse_funcs && post.parse_funcs.time_unit) || 1;
      var date = new Date((post.time || 0) * time_unit);
      var name = post.name || 'Anonymous';
      if (post.ext) {
        var fsize_str = (((post.fsize>1048576)? post.fsize/1048576 : post.fsize/1024)+0.005).toString();
        fsize_str = fsize_str.substr(0,fsize_str.indexOf('.')+3) + ((post.fsize>1048576)? ' MB' : ' KB');
//        var fname_server = site2[post.domain].post_json2html_fname_server(post);
//        var fname = site2[post.domain].post_json2html_fname(post);
        var furl = site2[post.domain].catalog_json2html3_src(post,board);
        var turl = site2[post.domain].catalog_json2html3_thumbnail(post,board);
        var tn_f = (op)? 1 : ((post.tn_w>post.tn_h)? post.tn_w : post.tn_h) / 125; // 150;
        var file_html = 
          '<div class="file" id="f' + post.no + '">'+
            '<div class="fileText" id="fT' + post.no + '">File: '+
              '<a '+(post.filename.length>30? 'title="'+post.filename+post.ext+'" ':'')+'href="' + furl + '" target="_blank">'+
                    (post.spoiler? 'Spoiler Image' : post.filename.length>30? post.filename.slice(0,25)+'(...)':post.filename) + post.ext + '</a>'+
              ' (' + fsize_str + ', ' + post.w + 'x' + post.h + ')</div>'+
            '<a class="fileThumb" href="' +furl + '" target="_blank">'+
              '<img src="' + turl + '" alt="' + fsize_str + '" data-md5="' + post.md5 + '" style="height: ' + ((post.spoiler)? 100 : (op)? post.tn_h : post.tn_h / tn_f) + 'px; width:' + ((post.spoiler)? 100 : (op)? post.th_w : post.tn_w/tn_f) +'px;">'+
              '<div data-tip="" data-tip-cb="mShowFull" class="mFileInfo mobile">' + fsize_str + ' ' + post.ext.substr(1).toUpperCase() + '</div>'+
            '</a>'+
          '</div>';
      }
      var dbtp = [post.domain, board, op_no, post.no];
//      var href_prefix = (post.domain!=='4chan' || site.board!==board || site.whereami==='catalog')? board+'thread/' : (site.whereami==='page')? 'thread/' : '';
      pn.innerHTML =
        '<div id="p' + post.no + '" class="post reply">'+
          '<div class="postInfoM mobile" id="pim' + post.no + '">'+
            this.post_json2html_nameblock(post, name, false)+
            '<span class="dateTime postNum" data-utc="' + post.time + '">' + site2['common'].change_utc_to_local(date) + '</span>'+
          '</div>'+
          ((post.ext && op)? file_html : '') +
          '<div class="postInfo desktop" id="pi' + post.no + '">'+
            '<input type="checkbox" name="' + post.no +'" value="delete"> '+ // a blank is here
            ((post.sub)? '<span class="subject">' + post.sub + '</span> ' : '')+
            this.post_json2html_nameblock(post, name, true)+
            '<span class="dateTime" data-utc="' + post.time + '">' + site2['common'].change_utc_to_local(date) + '</span> '+
            '<span class="postNum desktop">'+
              '<a href="'+ this.link_dbtp2href_abs(dbtp)      + '" title="Link to this post">No.</a>'+
              '<a href="'+ this.link_dbtp2href_abs(dbtp,true) + '" title="Reply to this post">' + post.no + '</a>'+
//              '<a href="'+ href_prefix + op_no + '#p' + post.no + '" title="Link to this post">No.</a>'+
//              '<a href="'+ href_prefix + op_no + '#q' + post.no + '" title="Reply to this post">' + post.no + '</a>'+
            '</span>'+
            ' &nbsp; '+
//            ((op)? '<span>[<a href="thread/' + op_no + ((post.sub)? '/' + post.sub.replace(/\s/g,'-').toLowerCase() +' ': '') + '" class="replylink">Reply</a>]</span>' : '') +
            ((op)? ('<span>[<a href="' + site2[post.domain].make_url4([post.domain, board, post.no, 'thread_html'])[0] +'" class="replylink">Reply</a>]</span>'+
                   ((short_link)? short_link.replace(/>\[/g,'>').replace(/<a/g,'<span>[<a').replace(/\]<\/a/g,'</a>]</span') : '')) : '') +
          '</div>' +
          ((post.ext && !op)? file_html : '') +
          '<blockquote class="postMessage" id="m' + post.no + '">'+ (post.com || '') + '</blockquote>'+ 
        '</div>';
      return pn.removeChild(pn.childNodes[0]);
    },
    post_json2html_nameblock: function(post, name, desktop) {
      var color;
      return '<span class="nameBlock">'+
        '<span class="name">' + name + '</span> '+
        ((post.trip)? '<span class="postertrip">' + post.trip + '</span> ' : '') +
        ((post.capcode)? '<strong class="capcode hand id_mod" title="Highlight posts by Moderators">##' + post.capcode + '</strong>' : '')+
//        '<img src="//s.4cdn.org/image/modicon.gif" alt="Mod Icon" title="This user is a 4chan Moderator." class="identityIcon retina"></span>
        ((post.id)? '<span class="posteruid id_'+post.id+'">(ID: '+
          '<span class="hand" title="Highlight posts by this ID"'+
          (desktop? (color = this.post_json2html_colorID(post), ' style="color: ' + color[1] + '; background-color: rgb(' + color[0] + ');"'):'') + '>'+post.id+'</span>'+
        ')</span> ' : '')+
        site2['4chan'].post_flag2html(post) +
      ((desktop)? '</span> ' : '<br></span>');
    },
    post_flag2html: function(post){
      return post.country? '<span '+(post.country_name? 'title="'+post.country_name+'" ':'')+'class="flag flag-'+post.country.toLowerCase()+'"></span>' : ''; // post.flag? post.flag.outerHTML : '';
    },
    post_json2html_colorID: function(post){
      var rgb = 0;
      for (var i=0;i<post.id.length;i++) rgb = (rgb << 5) - rgb + post.id.charCodeAt(i);
      var r = rgb >> 24 & 255;
      var g = rgb >> 16 & 255;
      var b = rgb >> 8  & 255;
      return [ r+','+g+','+b, (.299 * r + .587 * g + .114 * b > 125)? 'black' : 'white'];
    },
// codes from 4chan (extension.min.1076.js)
//    $.hash = function(e) {
//      var t, i, a = 0;
//      for (t = 0,
//           i = e.length; t < i; ++t)
//        a = (a << 5) - a + e.charCodeAt(t);
//      return a
//    }
//    IDColor.compute = function(e) {
//      var t, i;
//      return t = [],
//      i = $.hash(e),
//      t[0] = i >> 24 & 255,
//      t[1] = i >> 16 & 255,
//      t[2] = i >> 8 & 255,
//      t[3] = .299 * t[0] + .587 * t[1] + .114 * t[2] > 125,
//      this.ids[e] = t,
//      t
//    }
//    ,
//    IDColor.apply = function(e) {
//      var t;
//      t = IDColor.ids[e.textContent] || IDColor.compute(e.textContent),
//      e.style.cssText = "    background-color: rgb(" + t[0] + "," + t[1] + "," + t[2] + ");    color: " + (t[3] ? "black;" : "white;")
//    }
    page_json2html3_skelton: function(obj) {
      var th = document.createElement('div');
      th.setAttribute('class','thread');
      th.setAttribute('id','t'+obj.no);
      return th;
    },
    page_json2html3 : function(obj,board,thumb_url, assign_pn) { // TEMPORAL, USE thumb_url TO MIMIC.
      var th = this.page_json2html3_skelton(obj);
      var op = this.post_json2html((obj.posts && obj.posts[0])? obj.posts[0] : obj, board, true, site2[obj.domain].short_link(obj.key, obj.nof_posts, 2, '[Last ',' Posts]'), obj.posts[0].no);
//      var files = op.getElementsByClassName('file')[0];
//      if (file) th.insertBefore(file, op.getElementsByclassName('desktop')[0]);
      op.setAttribute('class','post op');
//      if (obj.posts && obj.posts[0] && obj.posts[0].extra_files) op.setAttribute('style','clear:both;');
      th.appendChild(this.post_container(op,obj.posts[0].no,true));
//      if (assign_pn) obj.posts[0].pn = th;
//      if (assign_pn || !obj.posts[0].pn) Object.defineProperty(obj.posts[0], 'pn', {value:op, enumerable:true, configurable:true, writable:true});
      if (assign_pn || !obj.posts[0].pn) obj.posts[0].pn = op;
      if (obj.posts) {
        for (var i=1;i<obj.posts.length;i++) {
//          th.appendChild(this.post_json2html(obj.posts[i], board));
          var pn = this.post_json2html(obj.posts[i], board);
          th.appendChild(this.post_container(pn,obj.posts[i].no));
//          th.appendChild(document.createElement('br'));
//          if (assign_pn || obj.posts[i].pn) Object.defineProperty(obj.posts[i], 'pn', {value:pn, enumerable:true, configurable:true, writable:true}); // temporal, overwrite getter.
          if (assign_pn || !obj.posts[i].pn) obj.posts[i].pn = pn;
        }
        this.page_json2html3_add_omitted_info(obj,obj.posts,obj.posts);
      }
//      var br = document.createElement('br');
//      br.setAttribute('class','clear');
//      th.appendChild(br);
//      th.appendChild(document.createElement('hr'));
      return th;
    },
    page_json2html3_replace_expander : function(posts_old, idx, key) {
      var omit_info = posts_old[0].pn.parentNode.parentNode.getElementsByClassName('summary')[0];
      if (omit_info) omit_info.appendChild(cnst.config_expander(key, idx));
    },
    page_json2html3_add_omitted_info : function(th,posts_old,posts) {
      var nof_files = 0;
      for (var i=1;i<posts.length;i++) nof_files += (posts[i].type_data==='html')? posts[i].pn.getElementsByClassName('file').length :
                                                    (posts[i].filename)? 1 : 0;
      var nof_files_omitted = th.nof_files - nof_files;
      var nof_posts_omitted = th.nof_posts - posts.length;

      var omit_info = (posts_old)? this.parse_funcs['page_html'].get_omitted_info(posts_old[0]) : null;
      if (nof_posts_omitted!=0) {
        if (!omit_info) {
          omit_info = document.createElement('span');
          omit_info.setAttribute('class','summary');
          omit_info.innerHTML = '<img class="extButton expbtn" title="Expand thread" alt="+" data-cmd="expand" data-id="' + posts[0].no + '" ' + 
            'src="//s.4cdn.org/image/buttons/burichan/post_expand_plus.png">' +
            '<span class="summary"></span><span style="display: none;">Showing all replies.</span>';
          if (th.domain!=='4chan' || pref[cataLog.embed_mode].use_expander_always) omit_info.appendChild(cnst.config_expander(th.key));
          if (posts_old) this.parse_funcs['page_html'].set_omitted_info(posts_old[0],omit_info);
        }
        omit_info.childNodes[1].textContent = nof_posts_omitted + ((nof_posts_omitted==1)? ' reply' : ' replies') +
                                ((nof_files_omitted)? ' and ' + nof_files_omitted + ' image' + ((nof_posts_omitted!==1)? 's' : '') : '') + ' omitted.';
        if (th.domain!==site.nickname) omit_info.childNodes[0].style.display = 'none';
      } else if (omit_info) omit_info.childNodes[1].textContent = 'Showing all replies.'; //if (omit_info && posts_old && posts_old[0].pn.nextSibling===omit_info) posts_old[0].pn.parentNode.removeChild(omit_info);
      return omit_info;
    },
    catalog_json2html3_thumbnail: function(obj, board) {
      return (!obj.ext)? ''
        : (obj.spoiler)? '//s.4cdn.org/image/spoiler-a1.png'
        : this.protocol+'//i.4cdn.org' + board + obj.tim + 's'  // not 'obj.board' but 'board' is for thread_json.
          + ((obj.ext==='.jpg' || obj.ext==='.png' || obj.ext==='.gif' || obj.ext==='.webm')? '.jpg' : obj.ext);
    },
    catalog_json2html3_src: function(obj, board) {
      return (obj.ext)? this.protocol+'//i.4cdn.org' + board + obj.tim + obj.ext : // not 'obj.board' but 'board' is for thread_json.
                        '';
    },
//    catalog_json2html3_src: function(obj, board) { // working code.
//      return (obj.ext)? this.protocol+'//i.4cdn.org' + board + obj.tim  // not 'obj.board' but 'board' is for thread_json.
//                          + ((obj.ext==='.jpg' || obj.ext==='.webm')? '.jpg' : obj.ext)
//                      : '';
//    },
    catalog_json2html3 : function(obj,board,thumb_url) {
      var th = document.createElement('div');
      th.setAttribute('class','thread');
      th.setAttribute('id','thread-'+obj.no);
      th.innerHTML = '<a href="' + this.protocol + '//boards.4chan.org' + obj.board + 'thread/' + obj.no + ((obj.sub)? '/'+obj.sub.replace(/ /,'-') : '') + '">' + // (cause direct jump) fixed.
//      th.innerHTML = '<a>' +
                       '<img alt="" id="thumb-' + obj.no + '" class="thumb"' + // cause popup error
//                       '<img alt="" id="thumb-' + obj.no + // don't load image.
                         ((obj.tn_w)? 'width="' + ((this.catalog_native_size==='small')? obj.tn_w*3/5 : obj.tn_w) + '"' : '' ) +
                         ((obj.tn_h)? 'height="' + ((this.catalog_native_size==='small')? obj.tn_h*3/5 : obj.tn_h) + '"' : '' ) +
                         'src=' + thumb_url + ' data-id="' + obj.no + '">' +
                     '</a>' +
                     '<div title="(R)eplies / (I)mages" id="meta-' + obj.no + '" class="meta">' +
                       'R: <b>' + obj.nof_posts + '</b> / I: <b>' + obj.nof_files + '</b></div>' +
                     '<div class="teaser">' + ((obj.sub)?'<b>'+obj.sub+'</b>':'') + ((obj.com)? ((obj.sub)? ': ' : '' ) + obj.com : '') + '</div>';
//      if (!obj.tn_w || !obj.tn_h) {
        th.childNodes[0].childNodes[0].addEventListener('load',site2['4chan'].catalog_json2html3_onload,false);
//      }
      return th;
    },
    catalog_json2html3_onload : function() {
      this.removeEventListener('load',site2['4chan'].catalog_json2html3_onload,false);
      if (!this.tn_w || !this.tn_h) site2['4chan'].catalog_json2html3_size_changed(this);
      this.removeAttribute('class'); // remove popup.
    },
    catalog_json2html3_size_changed : function(myself) {
      var w = myself.naturalWidth;
      var h = myself.naturalHeight;
      var f = ((w>h)? w : h) / ((site2['4chan'].catalog_native_size==='small')? 150 : 250);
      myself.setAttribute('width', w/f);
      myself.setAttribute('height', h/f);
    },
    favicon : {
      __proto__: site2['DEFAULT'].favicon,
      none: '/favicon.ico',
      reply: 'png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAoUlEQVQ4T61TwRGAMAiTmexMDuVMOlM1XOEoAj60L20gDUlLy8dF6Kd+dM/TqTEmK6shAe4GW8zfQlLVMAGat2NVgr2dUDWJymomBRlJdUCoAEdbFZ7A4qEHw9jHCM5U/k1TiEyMkiqj8ikIgY1YCXxUUQp2NCW3F8malZno9kk9qKLKMKj4nwAScaGiETw2KRix8RWG5MhEjynB24usXusFrlPCCCmAi/UAAAAASUVORK5CYII=',
      reply_to_me: 'png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAvUlEQVQ4T61TXRrDIAiDXWmeabvTzlSvVGb8hFIK3ct8aeUnJkSZxmLZBF+/hBvHWLafRQDY6Wn5B3WKANUhrIkIADQF0Zqxt0NGbP5PACREDhXMDFZREr22g+Wn9VmTMnj3RlqwmKTNJYNfAGi8MPD61mAvEnzAZlDZmA0xs7q08Q7AW5wCVC54aWaxl4A5qFWVCyE+DF830Tf7Kd/ZCBb/BwBFyMgkxNyJgVKFv5CTXeWYM4DqLsTHlD33Lx2GzAg15eTiAAAAAElFTkSuQmCC'
    },
    stats_ID: function(th, posts_new, lth){
      if (!lth.sID) lth.sID = {ids:{}, cs:{}, nid:0, nc:0, np:0, h:null};
      var sID = lth.sID;
      if (th.unique_ips) {
        sID.np = th.unique_ips;
        if (!th.id && th.posts) {
          if (!sID.h) sID.h = [];
          sID.h.push(th.posts[th.posts.length-1].no, th.nof_posts, th.unique_ips);
        }
      }
      if (posts_new && posts_new.length>0 && (th.id || th.country)) {
        for (var i=0;i<posts_new.length;i++) {
          var c = posts_new[i].country;
          if (c) if (sID.cs[c]) sID.cs[c]++; else {sID.cs[c]=1;sID.nc++;}
          if (posts_new[i].id) {
            var id = (c || '') + posts_new[i].id;
            if (sID.ids[id]) sID.ids[id]++; else {sID.ids[id]=1;sID.nid++;}
          }
        }
      }
      if (th.nof_posts==1) {sID.np=1; return false;}
//      return posts_new && posts_new.length>0 && pref.threadStats.full && (!th.id && !th.unique_ips || th.unique_ips>sID.nid); // for thread moving, but this can't make an initial kick.(BUG)
      return posts_new && posts_new.length>0 && pref.threadStats.full && !th.id && !th.unique_ips; // TEMPORAL PATCH, !th.id SHOULD BE REPLAED BY INFO IN boards.json
    },
  };
  site2['4channel'] = {
//    nickname:'4channel',
    domain_url: 'boards.4channel.org',
    check_func: site2['4chan'].check_func,
    proto:'4chan'
  };
}
if (pref.features.domains['meguca']) {
  site2['meguca1'] = { // meguca.org v1
    nickname : 'meguca',
    protocol: 'https:',
    home : 'https://meguca.org/favicon.ico',
    domain_url: 'meguca.org',
    domain_url_image: 'meguca.org',
    features : {page: false, graph: false, setting2: false, thread_reader:false},
//    features : {page: false, graph: false, setting2: false, thread_reader:false, catalog:false, setting: false}, // temporal
    components: {
      boardlist: '#navTop'
    },
    pref_default: {
//      patch: {delayed_invoke: {use: true, sec:10}},
      catalog:{image_hover:true},
    },
    boards_json:{boards:[{board:'a'}, {board:'an'}, {board:'cr'}, {board:'g'}, {board:'v'}]},
    check_func : function(){
      var href = window.location.href;
      if (href.indexOf('/meguca.org/')!=-1) {
        site.whereami = (href.indexOf('/catalog')!=-1)? 'catalog'
                      : (href.search(/page[0-9]/)!=-1)? 'page'
                      : (href.search(/[0-9]+$/)!=-1)? 'thread'
//                      : (document.getElementsByTagName('title')[0] && document.getElementsByTagName('title')[0].textContent==='404')? '404' 
                      : 'other';
        site.config('meguca.org',this.nickname);
        site.max_page = 3;
        site.header_height = function(){
          var header = document.getElementById('banner');
          if (header) return header.offsetHeight;
          else return 0;
        }
////        site.myself = (site.whereami==='thread')? parseInt(href.replace(/.*res\//,'').replace(/\.html/,''),10) : 0;
////        if (site.whereami==='thread' || site.whereami==='page') {
////          site.embed_to['top']    = document.getElementsByName('postcontrols')[0];
////          site.embed_to['bottom'] = document.getElementsByTagName('footer')[0];
////        } else if (site.whereami==='catalog') {
////          site.embed_to['top']    = document.getElementsByTagName('header')[0].nextSibling;
////          site.embed_to['bottom'] = document.getElementsByTagName('footer')[0];
////        }
////        if (site.whereami==='thread' || site.whereami==='page') {
//////          site.postform = document.getElementsByTagName('form')['post'].getElementsByTagName('tbody')[0];
////          site.postform = document.getElementsByTagName('form')['post'];
////          site.postform_comment = document.getElementById('body');
////          this.postform_prep();
////
//////          var bar_bottom = document.getElementsByClassName('bottom')[0];
//////////          site.root_body2 = bar_bottom.insertBefore(document.createElement('span'),bar_bottom.childNodes[1]); // working code.
////////          site.root_body2 = document.getElementsByClassName('pages')[0];
////////          site.root_body2.setAttribute('style','width:auto');
//////////          site.root_body2 = document.getElementById('style-select');
////        }
////        pref.thread_reader.own_posts_tracker = true;
////        setTimeout(function(){this.postprocess_board(this.boards_json)}.bind(this),0);
        return true;
      } else {
        this.prep_own_posts(); // make own_posts structure WITH PROTOTYPE.
        return false;
      }
    },
    make_url4 : function(dbt){
      var url_prefix  = this.protocol + '//' + this.domain_url; // force to use https:
      if (dbt[3]==='page_json' && dbt[2]==0) dbt[3] = 'catalog_json'; // dbt[2] is string, === can't be used.
      if      (dbt[3]==='page_html')    return [url_prefix + ((dbt[2]!=0)? (parseInt(dbt[2],10)+1) :''), 'html'];
      else if (dbt[3]==='catalog_json') return [url_prefix + '/api/board'+ dbt[1].substr(0,dbt[1].length-1), 'json'];
      else if (dbt[3]==='thread_html')  return [url_prefix + dbt[1] + dbt[2], 'html'];
      else if (dbt[3]==='thread_json')  return [url_prefix + '/api/thread/' + dbt[2], 'json'];
    },
////    prep_own_posts_reg: /^4chan\-track\-[0-9A-z]+\-[0-9]+$/,



    catalog_get_native_area: function(){
      return (site.whereami==='catalog')? document.getElementById('catalog') :
                                          document.getElementsByName('postcontrols')[0];
    },
    catalog_native_prep: function(date,pn_filter,pn_tb,pn_hi){
//      var node_ref = document.getElementsByClassName('catalog_search')[0].nextSibling;  // FF doesn't work.
      var node_ref = (site.whereami==='catalog')? document.getElementsByTagName('threads')[0].getElementsByTagName('aside')[0] :
                                                  document.getElementsByName('postcontrols')[0];
      cnst.tb_prep_for_embed(pn_tb);
      if (site.whereami==='catalog') {
////        var selector_native = document.getElementById('sort_by');
////        if (selector_native.selectedIndex!=0) {
////          selector_native.selectedIndex = 0;
////          var evt = document.createEvent('UIEvents');
////          evt.initUIEvent('change', false, true, window, 1);
////          selector_native.dispatchEvent(evt);
////        }
////        selector_native.style.display = 'none';
////        document.getElementById('image_size').addEventListener('change', site2['lain'].catalog_native_size_changed, false);
        var pn_tb_new = document.createElement('span');
        while (pn_tb.firstChild) pn_tb_new.appendChild(pn_tb.firstChild);
        pn_tb = pn_tb_new;
        pn_tb.appendChild(pn_tb.removeChild(pn_tb.childNodes[3]).firstChild);
        pn_tb.setAttribute('style','float:right');
      } else if (site.whereami==='page') {
        var pctrls = document.getElementsByName('postcontrols')[0];
//        for (var i=pctrls.childNodes.length-1;i>=0;i--) if (pctrls.childNodes[i].tagName==='HR') pctrls.removeChild(pctrls.childNodes[i]);
        pctrls.parentNode.insertBefore(document.createElement('hr'),pctrls.nextSibling);
      }
//      node_ref.parentNode.insertBefore(pn_hi,node_ref);
      if (site.whereami==='catalog') node_ref.parentNode.insertBefore(pn_tb,node_ref);
      else node_ref.parentNode.insertBefore(pn_tb,node_ref);
      node_ref.parentNode.insertBefore(pn_filter,document.getElementById('catalog'));
      var selector_catchan = pn_filter.getElementsByTagName('select')['catalog.indexing'];
      selector_catchan.setAttribute('style','float:left');
      if (site.whereami==='catalog') node_ref.parentNode.insertBefore(selector_catchan,node_ref);
      else pn_tb.childNodes[3].insertBefore(selector_catchan,pn_tb.childNodes[3].firstChild);
//      pn_tb.childNodes[0].setAttribute('style',pn_tb.childNodes[0].getAttribute('style')+';display:none');
//      pn_tb.childNodes[1].setAttribute('style',pn_tb.childNodes[1].getAttribute('style')+';display:none');

      node_ref.setAttribute('style','float:left');
      node_ref.parentNode.insertBefore(pn_tb.childNodes[3],node_ref.nextSibling);
//      if (site.whereami==='catalog') document.getElementById('catalog').innerHTML = ''; // clear all thread.
    },
    catalog_json2html3 : function(obj,board,thumb_url) {
      var th = document.createElement('article');
      var th_url = site2[obj.domain].make_url4([obj.domain,obj.board,obj.no,'thread_html'])[0];
      var tn_w = obj.tn_w || obj.posts[0].tn_w;
      var tn_h = obj.tn_h || obj.posts[0].tn_h;
      var tn_f = 150 / ((tn_w>tn_h)? tn_w : tn_h);
      var th_class_tn = (site2[obj.domain].historyAPI && pref.pref2.meguca.historyAPI)? 'history' : '';
      var th_class    = th_class_tn + ' ' + pref.script_prefix +'_link';
      var short_link = site2[obj.domain].short_link(obj.key, obj.nof_posts, 1, 'Last ', '');
      th.innerHTML = '<a target="_blank" rel="nofollow" href="' + th_url + '"' + ((th_class_tn)?' class="' + th_class_tn + '"' : '') +'>'+
                        '<img src="' + thumb_url + '" width="' + (tn_w * tn_f) + '" height="' + (tn_h * tn_f) + '" class="expanded">'+
                     '</a>'+
                     '<br>'+
                     '<small>'+
                       '<span title="Replies/Images">'+ (obj.nof_posts-1) + '/' + (obj.nof_files-1) + '</span>'+
                       '<span class="act expansionLinks">'+
                         '<a href="' + th_url + '" class="' + th_class + '">Expand</a>'+
//                         '] [<a href="' + th_url + '?last=100" class="' + th_class + '">Last 100</a>'+
                         ((short_link)? '] [' + short_link : '')+
                       '</span>'+
                     '</small>'+
                     '<br>'+
                     ((obj.sub)? '<h3>' + obj.sub + ' </h3>' : '')+
                     ((obj.com)? obj.com : '');
      return th;
    },
    mark_newer_posts: function(th,date,unmark, short_cut) {
      return site2['DEFAULT'].mark_newer_posts('meguca',th.getElementsByTagName('article'),date,null,unmark, short_cut);
    },
//    get_time_of_post_in_utc: function(post_pn){return this.parse_funcs.post_html.time_pn(post_pn);}, // TEMPORAL
////////    mark_newer_posts : function(nickname,posts,date,style_mark,style_unmark,class_or_tag,key,unmark){
//////////      var offset_top = 0;
////////      var marked_first_post = null;
////////      for (var i=posts.length-1;i>=0;i--) {
////////        var mark = date<site2[nickname].get_time_of_post_in_utc(posts[i]);
////////        var reply = posts[i];
//////////        posts[i] = posts[i].parentNode;
//////////        if (class_or_tag=='class') while (posts[i].className.search(key)==-1) posts[i] = posts[i].parentNode;
//////////        if (class_or_tag=='tag') while (posts[i].tagName.search(key)==-1) posts[i] = posts[i].parentNode;
////////        if (class_or_tag=='class') reply = posts[i].getElementsByClassName(key)[0];
////////        if (class_or_tag=='tag')  reply = posts[i].getElementsByTagName(key)[0];
////////        if (reply)
////////          if (mark) {
////////            reply.setAttribute('style',style_mark);
////////            if (unmark) reply.addEventListener('mouseover', site2[nickname].unmark_post_from_event, false);
//////////            offset_top = reply.offsetTop;
////////            marked_first_post = reply;
////////          } else reply.setAttribute('style',style_unmark);
////////      }
//////////      return offset_top;
////////      return marked_first_post;
////////    },
////////    unmark_post_from_event: function() {
////////      this.setAttribute('style','border: none');
////////      this.removeEventListener('mouseover', site2['common'].unmark_post_from_event, false);
////////    },


    prep_own_posts_event : function(e){
      if (e && e.key==='mine') site2['meguca'].prep_own_posts();
      if (window.name==='meguca') send_message('parent',[['OWN_POSTS', window.name, site3[window.name].own_posts['ALL']]]);
    },
    prep_own_posts_event_received : function(val){
      site3[this.nickname].own_posts['ALL'] = val;
//      for (var i in val) site3[this.nickname].own_posts['ALL'][i] = null;
    },
    prep_own_posts : function(bt){
      if (!site3[this.nickname].own_posts['ALL']) {
        site3[this.nickname].own_posts['ALL'] = {};
        var boards = ['/a/','/an/','/cr/','/g/'];
        for (var i=0;i<boards.length;i++) site3[this.nickname].own_posts[boards[i]] = Object.create(site3[this.nickname].own_posts['ALL']);
      }
      if (localStorage) {
        var nos = JSON.parse(localStorage['mine'] || '{}');
        for (var j in nos) site3[this.nickname].own_posts['ALL'][j] = null;
      }
    },
    wrap_to_parse: {
      get: site2['DEFAULT'].wrap_to_parse.get,
      posts: function(th){
        delete Object.getPrototypeOf(th.posts[0]).com; // PATCH
      },
    },
    short_link:function(name, nof_posts, num, kwd_head, kwd_tail){
      var url = this.make_url4(common_func.name2dbt(name))[0];
      var th_class = pref.script_prefix +'_link';
      return ((!num || num>1)? '<a href="' + url + '?last=50' + '" class="' + th_class + '">' + kwd_head + '50' + kwd_tail + '</a>' : '') +
             '<a href="' + url + '?last=100' + '" class="' + th_class + '">' + kwd_head + '100' + kwd_tail + '</a>';
    },
    catalog_json2html3_src: function(post){return (post.image)? '/static/src/'+post.image.src : undefined}, // TEMPORAL
//    catalog_json2html3_thumbnail: function(post){return (post.image)? '/static/thumb/'+post.image.thumb : undefined}, // TEMPORAL
    catalog_json2html3_thumbnail: function(post){
      return (post.image)? '/static/'+ ((post.image.spoiler!==undefined && !pref[cataLog.embed_mode].open_spoiler_image)? 'spoil/spoilers'+post.image.spoiler+'.png' :
                                        (post.image.thumb!==undefined)? 'thumb/' + post.image.thumb :
                                                                        'src/' + post.image.src) : undefined;
    },
    post_json2html_fname_server: function(post){return (post.image)? post.image.src : undefined;},
    post_json2html_fname: function(post){return (post.image)? post.image.imgnm : undefined;},
    popups_href2dbtp: function(href){ //, src, th){
//      if (href[0]==='#' && th) {
//        href = th.board+href;
//        src.setAttribute('href',href);
//      }
      var hrefs = href.split(/[\/#]/);
      var p = hrefs[hrefs.length-1];
      var t = hrefs[hrefs.length-2];
      var b = '/'+hrefs[hrefs.length-3]+'/';
      return ['meguca',b,t,p]
    },
    link_dbtp2href: function(dbtp){
      return dbtp[1] + dbtp[2] + '#' + dbtp[3];
    },
    time_offset: -5,
    parse_funcs : { // meguca
      'post_json' : {
        get no()  {return this.num;},
        get sub() {return this.subject;},
//        get name() {return this.name;},
        name:'Anonymous', // default value
        get txt() {return this.body;},
        get com() {return (this.body)? this.body.replace(this.anchor_regex,this.anchor_func) : '';},
        get filename() {return (this.image)? this.image.imgnm : undefined;},
        get w() {return (this.image)? this.image.dims[0] : undefined;},
        get h() {return (this.image)? this.image.dims[1] : undefined;},
        get tn_w() {return (this.image)? ((this.image.spoiler!==undefined && !pref[cataLog.embed_mode].open_spoiler_image)? 250 : this.image.dims[2]) : undefined;},
        get tn_h() {return (this.image)? ((this.image.spoiler!==undefined && !pref[cataLog.embed_mode].open_spoiler_image)? 250 : this.image.dims[3]) : undefined;},
        get fsize() {return (this.image)? this.image.size : undefined;},
        get ext() {return (this.image)? this.image.ext : undefined;},
        domain:'meguca',
//        type_html: site.whereami,
        get domain_html() {return site.nickname}, // mimic always
        get parse_funcs_html() {return site2[site.nickname].parse_funcs[site.whereami+'_html'];},
        anchor_regex: /(>>)([0-9]+)/g,
        pn: undefined, // stop prototype chain.
      },
      'thread_json' : {
        ths: function(obj, parse_obj){
          var proto_obj = {
            board: parse_obj.board,
            anchor_func: (function(){
              var htmls = ['<a href="' + parse_obj.board + parse_obj.thread + '#', '">&gt;&gt;', '</a>'];
              return function(str,ar,no){
                return htmls[0] + no + htmls[1] + no + htmls[2];
              };
            })(),
            get com() {return this.body;}, // PATCH
            __proto__:site2[parse_obj.domain].parse_funcs.post_json
          };
////          for (var i=0;i<obj.length;i++) obj[i].__proto__ = site2[parse_obj.domain].parse_funcs.post_json;
          var i=0;
          while (i<obj.length && obj[i].state===undefined) obj[i++].__proto__ = proto_obj; // 'state' shows that a post is being typed.
          if (i!==obj.length) obj.splice(i,obj.length-i);
          return [{posts: obj, // ext: obj[0].ext, tim:obj[0].time, obj:null,
                   nof_posts:obj.length,
                   key: parse_obj.domain + parse_obj.board + parse_obj.thread, no: parse_obj.thread,
                   __proto__:parse_obj}];
        },
        get_op_src: function(obj){return site2[obj.domain].protocol + '//' + site2[obj.domain].domain_url + '/static/'+ 'src/' + obj.posts[0].image.src;},
        op_img_url: function(obj){return site2[obj.domain].protocol + '//' + site2[obj.domain].domain_url + '/static/'+ site2['meguca'].catalog_json2html3_thumbnail(obj.posts[0]);},
//        op_img_url: function(obj){return site2[obj.domain].protocol + '//' + site2[obj.domain].domain_url + '/static/'+ // working code.
//                                         ((obj.posts[0].image.spoiler!==undefined)? 'spoil/spoilers'+obj.posts[0].image.spoiler+'.png' :
//                                          (obj.posts[0].image.thumb!==undefined)?   'thumb/' + obj.posts[0].image.thumb :
//                                                                                    'src/' + obj.posts[0].image.src);},
//        nof_posts: function(obj){return obj.posts.length;},
        nof_files: function(obj){return obj.posts[0].imgctr -1;}, // patch
////        nof_files: function(obj){
////          var num = 0;
////          for (var i=0;i<obj.posts.length;i++) if (obj.posts[i].image) num++;
////          return num;
////        },
        time: function(obj){return obj.posts[0].time;},
        time_posted: function(obj){return obj.posts[obj.posts.length-1].time;},
        time_created: function(obj){return obj.posts[0].time;},
        time_bumped: function(obj){
          var i=obj.posts.length-1;
          while (i>0) if (!obj.posts[i].email || obj.posts[i].email!=='sage') return obj.posts[i].time; else i++;
          return obj.posts[0].time;
        },
        sticky: function(th){return false;},
        com: function(obj){return obj.posts[0].body;},
        sub: function(obj){return obj.posts[0].sub;},
        name: function(obj){return obj.posts[0].name;},
        filename: function(obj){return obj.posts[0].image.imgnm;},
//        tn_w: function(obj){return obj.posts[0].tn_w;},
//        tn_h: function(obj){return obj.posts[0].tn_h;},

        type_com: 'txt',
//        type_com: 'html',
        time_unit: 1,

//        tn_as: function(th){return th.pn.getElementsByTagName('a');}, // the same as DEFAULT
        //        footer: function(th){return th.pn.getElementsByClassName('meta')[0];},

//        add_op_img_url: site2['DEFAULT'].parse_parts.add_op_img_url,
        add_op_img_url: function(posts,board,domain){
          for (var i=0;i<posts.length;i++)
            if (posts[i].image) posts[i].op_img_url = site2[domain].protocol + '//' + site2[domain].domain_url + '/static/thumb/' + posts[i].image.thumb;
        },

        footer: 'catalog_html',
        footer_clear: 'catalog_html',
        proto: 'DEFAULT.thread_json'
      },
      'catalog_html' : {
        footer: function(th){return th.pn.getElementsByClassName('counters')[0];}, // v3.
//        footer: function(th){return th.pn.getElementsByTagName('small')[0].getElementsByTagName('span')[0];}, // working code for v1, v2.
        footer_clear: function(th){th.footer.textContent = '';},
        ths: function(doc) {
          if (!pref.pref2.meguca.historyAPI) {
            var hist = doc.pn.getElementsByClassName('history');
            for (var i=hist.length-1;i>=0;i--) {
              if (hist[i].textContent==='Expand' || hist[i].textContent==='Last 100') hist[i].setAttribute('class',pref.script_prefix+'_link');
              else hist[i].removeAttribute('class');
            }
          }
          var ths = this.ths_array(doc,doc.pn.getElementsByTagName('article'));
          if (site.board==='/all/') for (var i=ths.length-1;i>=0;i--) ths[i].board = ths[i].pn.getElementsByTagName('a')[0].getAttribute('href').replace(/\d+$/,''); // for v3.
          return ths;
        },
        no : function(th){return th.pn.getElementsByTagName('a')[0].getAttribute('href').replace(/.*\//g,'');}, // 'replace' for ve.
//        no : function(th){return th.pn.getElementsByTagName('a')[0].getAttribute('href');},
        time_bumped: function(th){return undefined;},
        time_created : function(th){return undefined;},
        nof_posts: function(th){return parseInt(th.footer.textContent.split('/')[0],10);},
        nof_files: function(th){return parseInt(th.footer.textContent.split('/')[1],10);},
        sub: function(th){
          var sub = th.pn.getElementsByTagName('h3')[0];
          return (sub)? common_func.escape(sub.textContent) : undefined;
        },
        name: function(th){return undefined;},
        com: function(th){return th.pn.childNodes[th.pn.childNodes.length-1].textContent;},
        sticky: function(th){return false;},
////////        tn_as: function(th){return th.pn.getElementsByTagName('a');},
////////        tn_imgs: function(th){return (th.tn_as[0])? [th.tn_as[0].getElementsByTagName('imgs')[0]] : [];},
////////        class_thread: 'thread',
////////        class_thumbnail: 'thumb',
//////////        op_img_url: function(th){ // working code.
//////////          var img = th.pn.getElementsByTagName('img')[0];
//////////          return (img)? img.getAttribute('src') : undefined; // patch.
//////////        },
        op_img_url: function(th){
          var img = th.pn.getElementsByTagName('img')[0];
          return img && img.getAttribute('src') || '';},
        get_op_src: function(th){return th.op_img_url.replace(/thumb/,'src');}, // patch
        dynamic_image_hover: true,
        missing_info: 1,
        img2src: function(img, lth){
          if (!lth) lth = this.get_lth_from_node(img);
          if (!lth) return null;
          var src = img.src;
          if (lth.th && lth.th.posts[0].ext) src = src.replace(/thumb/,'src').replace(/\.\w+$/,lth.th.posts[0].ext);
          else if (lth.th.parse_funcs.missing_info) scan.scan_ui('image_hover', {tgts: [lth.key], options:{callback:function(){cataLog.image_hover_reentry(img);}, priority:6}}); // NEVER ACTIVATED because catalog.json is read always at initial
          return src;
        },
      },
      'post_html' : {
        time_pn: function(post_pn){
          var time_node = post_pn.getElementsByTagName('time')[0];
          return Date.parse(time_node.title || time_node.textContent) + (pref.localtime_offset - site2['meguca'].time_offset) * 3600000;}, // timezone -5
        pn_name: function(post){return post.pn.getElementsByClassName('name')[0];}, // same as vichan.
      },
    },
    general_event_handler:{
      page:{
        mouseover: function(e){}, // patch for test_mode['98']
      },
      catalog:{
//        mouseover: function(e){ // working code
//          var et = e.target;
//          var et_tagName = et.tagName;
//          if (et_tagName==='IMG')
//            if (pref[cataLog.embed_mode].image_hover && et.parentNode.tagName==='A') cataLog.image_hover_add.call(et, e);
//        },
        image_hover_check_mode: function(img){
          return img.parentNode.parentNode.parentNode.parentNode.id==='catalog'? 'catalog' : 'page';
        },
        recSearch_thread: function(tgt,ecT){
          while (tgt && tgt!=ecT) {
            if (tgt.classList && tgt.classList.contains('op')) return tgt;
            else tgt = tgt.parentNode;
          }
          return null;
        },
        __proto__: site2['DEFAULT'].general_event_handler.catalog
      },
    },
    favicon : {
      __proto__: site2['DEFAULT'].favicon,
      none: '/static/favicon.ico',
      reply: '/static/css/ui/unreadFavicon.ico',
      reply_to_me: '/static/css/ui/replyFavicon.ico',
    },
    make_tack: function(){
      var tack = document.createElement('div');
      tack.innerHTML = '<svg class="sticky" xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 8 8"><path d="M1.34 0a.5.5 0 0 0 .16 1h.5v2h-1c-.55 0-1 .45-1 1h3v3l.44 1 .56-1v-3h3c0-.55-.45-1-1-1h-1v-2h.5a.5.5 0 1 0 0-1h-4a.5.5 0 0 0-.09 0 .5.5 0 0 0-.06 0z"></path></svg>';
      return tack.childNodes[0];
    },
  };
  site2['meguca2'] = { // meguca.org v2
    home: 'https://meguca.org/assets/favicons/default.ico',
    components: {
      boardlist: '#banner', // '#board-navigation'
    },
    boards_json: undefined, // terminate prototype chain
    check_func: function(reentry){ // required to be a own property.
      var href = window.location.href;
      if (href.indexOf('/meguca.org/')!=-1) {
        site.whereami = (href.search(/[A-z]+\/(\?page=\d+)*$/)!=-1)? 'page'
                      : (href.search(/[0-9]+(\?last=\d+)*$/)!=-1)? 'thread'
                      : (href.search(/catalog\/*$/)!=-1)? 'catalog' : 'other';
        site.config('meguca.org',this.nickname, reentry);
        site.no = (site.whereami==='thread')? parseInt(href.replace(/.*meguca\.org\/\w*\/([0-9]+)/,'$1'),10) : '';
        if (site.whereami==='page') {
          var idx = href.indexOf('?page=');
          site.page = idx!=-1 && parseInt(href.substr(idx+6),10) || 0;
        } else site.page = null;
        if (reentry) return;
        site.max_page = 3;
        site.header_height = function(){
          var header = document.getElementById('banner');
          return (header)? header.offsetHeight : 0;
        }
        return true;
      } else {
//        this.prep_own_posts(); // make own_pxoosts structure WITH PROTOTYPE.
        return false;
      }
    },
    check_func_whereami: function(){
    },
////    url_boards_json : function(){return ['https://meguca.org/json/boardList', 'json'];}, // working code.
////    postprocess_board: function(val){
////      for (var i=0;i<val.length;i++) {
////        var bd = liveTag.mems.init({domain:this.nickname, board:'/'+val[i].id+'/'});
////        bd.o = i;
////        if (val[i].tags && val[i].tags.length!=0) liveTag.postprocess_board_add_btag(val[i].tags,bd);
////      }
////    },
    utilize_boards_json: true,
    url_boards_json : function(){return ['https://meguca.org/json/boardTimestamps', 'json'];}, // need to be debugged
    postprocess_board: function(val){
      var order = 0;
      for (var i in val) {
        var bd = liveTag.mems.init({domain:this.nickname, board:'/'+i+'/'});
        bd.o = order++;
        Object.defineProperty(bd,'max',{value:val[i], writable:true});
        if (bd.read_max===undefined) Object.defineProperty(bd,'read_max',{value:0, writable:true});
//        if (val[i].tags && val[i].tags.length!=0) liveTag.postprocess_board_add_btag(val[i].tags,bd);
      }
    },
    make_url4 : function(dbt){
      var url_prefix  = this.protocol + '//' + this.domain_url; // force to use https:
      if (dbt[3].substr(0,4)==='page' && dbt[2]==0) dbt[3] = 'catalog_json'; // dbt[2] is string, === can't be used.
//      if      (dbt[3]==='page_html')    return [url_prefix + ((dbt[2]!=0)? (parseInt(dbt[2],10)+1) :''), 'html'];
      return (dbt[3]==='catalog_json')? [url_prefix + '/json'+ dbt[1], 'json', 'meguca' + dbt[1] + 'j0'] :
             (dbt[3]==='thread_html')?  [url_prefix + dbt[1] + dbt[2], 'html'] :
             (dbt[3]==='thread_json')?  [url_prefix + '/json'+ dbt[1]+dbt[2], 'json'] : undefined;
    },
//    trim_list: 'force_init', // catalog_json is changed to have no posts. // this way is more optimized than fetching each thread when some threads are watched.
    catalog_get_native_area: function(){
      return document.getElementById((site.whereami==='catalog')? 'catalog'
                                   : (site.whereami==='page')?    'index-thread-container' : 'threads');
    },
    catalog_get_native_scroll_area: function(){
      return (site.whereami==='catalog')? document.getElementsByTagName('section')[1] : window;
    },
    catalog_native_prep_wait_loop_timeout: 100,
    catalog_native_prep_wait_loop: function(whereami, callback){
      if (--this.catalog_native_prep_wait_loop_timeout<0) return;
      if ((whereami==='catalog' && (!document.getElementsByName('sortMode')[0])) ||
          (whereami==='page' &&    (!document.getElementById('catalog-controls') || !document.getElementById('index-thread-container'))) ||
          (whereami==='thread' &&  (!document.getElementById('expand-images') || !document.getElementById('threads')))
         ) setTimeout(function(){this.catalog_native_prep_wait_loop(whereami,callback);}.bind(this),1000);
      else callback();
    },
    catalog_native_prep: function(date,pn_filter,pn_tb,pn_hi){
//      var node_ref = document.getElementsByClassName('catalog_search')[0].nextSibling;  // FF doesn't work.
//      var node_ref = (site.whereami==='catalog')? document.getElementById('threads').getElementsByTagName('aside')[0] :
      var node_ref = (site.whereami==='catalog')? document.getElementsByName('sortMode')[0]
                   : (site.whereami==='page')? document.getElementById('catalog-controls').getElementsByTagName('input')['search']
                   : document.getElementById('expand-images'); // .parentNode.nextSibling;
      if (site.whereami==='catalog' && node_ref.nextSibling===cataLog.components.catalog.indexing) return; // return if just focused, not entered from transition.
//      if (pn_tb.childNodes[3] && pn_tb.childNodes[3].ondblclick) cnst.tb_prep_for_embed(pn_tb);
//      if (site.whereami==='catalog' || site.whereami==='page') {
        if (!cataLog.components.initialized) {
          cnst.tb_prep_for_embed(pn_tb);
          var pn_tb_new = document.createElement('span');
          while (pn_tb.firstChild) pn_tb_new.appendChild(pn_tb.firstChild);
          pn_tb = pn_tb_new;
          pn_tb.setAttribute('style','float:right');
          pn_tb.setAttribute('style','float:right');
          cataLog.components.pn12_0 = pn_tb;
          cataLog.components.pn_hi = pn_tb.removeChild(pn_tb.childNodes[3]); //.firstChild;
          var redraw = function(){
////            console.log('redraw');
            cataLog.catalog_obj2.func_track_reset();
            cataLog.insert_myself(true);
            cataLog.show_catalog();
          }
//          var reentry_tap = function(e){
//////            console.log('reentry');
//            observer3.disconnect();
////            this.catalog_native_prep(null, pn_filter, pn_tb);
////            if (this.catalog_get_native_area()!=cataLog.components.initialized) { // doesn't work
////              console.log('found background refresh');
////              cataLog.components.initialized = this.catalog_get_native_area();
//          }; // .bind(this);
//          window.addEventListener('focus', reentry_tap, false);

          var updated_by_native = false;
          var observe_native_bg = function(e){
//            updated_by_native = true;
////            console.log('found an update in background');

            if (pref[site.whereami].embed) { // test
//              observer3.disconnect();
//              cataLog.catalog_obj2.masked = false;
              cataLog.general_event_handler.destroy();
//              cataLog.triage.off();
              cataLog.triage_parent_set();
              cataLog.general_event_handler = new cataLog.GEH(cataLog.parent);
              cataLog.general_event_handler.init();
              redraw();
              site2['meguca'].catalog_native_prep(null, pn_filter, pn_tb);
//              blur_tap();
            }

          };
          var observer3 = new MutationObserver(observe_native_bg);
//          var blur_tap = function(){
//////            console.log('start observe...');
////            observer3.observe(cataLog.parent, {childList: true}); // doesn't work
            observer3.observe(document.getElementById('threads'), {childList: true});
////            cataLog.catalog_obj2.masked = true;
//          };
//          window.addEventListener('blur', blur_tap, false);
          pref_func.settings.onchange_funcs['button_test'] = observe_native_bg; // test

          var loading_image = document.getElementById('loading-image');
          var skip_initial_call = loading_image.style.display!=='none';
          var observer_tap = function(e){
            if (e[0].target.style.display!=='none') {
              site2['meguca'].historyAPI_blocking = true;
              if (site.whereami==='thread') site2['meguca'].prep_own_posts(); // patch for IDB, but BUG, this has a racing condition.
            } else {
              site2['meguca'].historyAPI_blocking = false;
              if (!skip_initial_call) {
////                console.log('mascot off');
                cataLog.DIH.image_hover_remove();
                cataLog.general_event_handler.destroy();
//                cataLog.triage.off();
                for (var name in cataLog.threads) cataLog.remove_thread(name, true);
//                for (var name in cataLog.threads) if (cataLog.threads[name][1]) if (cataLog.catalog_obj2.func_hide(name)) cataLog.threads[name][1] = false;

                site2['meguca'].check_func(true);
                if (pref[site.whereami].embed) { // using site.whereami instead of cataLog.embed_mode
//                  cataLog.catalog_obj2.masked = false;
                  cataLog.set_embed_xxxx(); // this changes embed_mode
                  cataLog.triage_parent_set();
                  cataLog.general_event_handler = new cataLog.GEH(cataLog.parent);
                  cataLog.general_event_handler.init();
//                  if (!pref.test_mode['90']) {
                  if ((site.whereami==='catalog' || site.whereami==='page') && !pref.test_mode['90']) redraw();
                  site2['meguca'].catalog_native_prep(null, pn_filter, pn_tb);
//                  reentry_tap(); // WILL call show_catalog here, from pref3.catalog.filter.kwd.clear()
                } // else cataLog.catalog_obj2.masked = true;
                recovery.reentry();
                receive_message_emu();
              }
              skip_initial_call = false;
            }
          };
          var observer = new MutationObserver(observer_tap);
//          observer.observe(document.getElementById('page-container'), {childList: true});
          observer.observe(loading_image, {attributes: true});
////          window.addEventListener('popstate', function(event) {console.log("onpopstate: location: " + document.location + ", state: " + JSON.stringify(event.state));}, false); // doesn't work
//////          setTimeout(function(){require('state').page.onChange('thread', function(e){
//////            console.log('state_changed: ',e);
//////          });},30000);
////          setTimeout(function(){ // working code, but spec was changed on 2017.06.12
////            var test_func = function(e){console.log('state changed');};
////            var div = document.createElement('div');
////            div.id = 'CatChan_csi';
////            div.setAttribute('data-csi',0);
//////            div.textContent = 0;
//////            div.onclick = test_func; // can't call
////            site.script_body.appendChild(div);
////            var scr = document.createElement('script');
////            scr.setAttribute('type', 'application/javascript');
//////            scr.textContent = 'console.log("Hello");';
//////            scr.textContent = 'console.log(require("state"));';
//////            scr.textContent = 'var tgt_func = document.getElementById("CatChan_csi").onclick;'+
//////                              'require("state").page.onChange("thread", tgt_func);';
////            scr.textContent = 'var tgt = document.getElementById("CatChan_csi");'+
//////                              'function mutate(){tgt.textContent+=1;}'+
////                              'function mutate(){tgt.setAttribute("data-csi",parseInt(tgt.getAttribute("data-csi"),10)+1);}'+
////                              'require("state").page.onChange("thread", mutate);'+
////                              'require("state").page.onChange("page", mutate);'+
////                              'require("state").page.onChange("catalog", mutate);';
////            site.script_body.appendChild(scr);
////            site.script_body.removeChild(scr);
////            var observer2 = new MutationObserver(test_func);
////            observer2.observe(div, {attributes: true});
//////            observer2.observe(div.childNodes[0], {attributes: true, characterData: true});
//////            console.log('unsafeWindow: ');
//////            unsafeWindow.require('state').page.onChange('thread', function(e){
//////              console.log('state_changed: ',e);
//////            });
////          },10000);
        }
//      } else if (site.whereami==='page') {
////        var pctrls = document.getElementsByName('postcontrols')[0];
//////        for (var i=pctrls.childNodes.length-1;i>=0;i--) if (pctrls.childNodes[i].tagName==='HR') pctrls.removeChild(pctrls.childNodes[i]);
////        pctrls.parentNode.insertBefore(document.createElement('hr'),pctrls.nextSibling);
//      }
//      node_ref.parentNode.insertBefore(pn_hi,node_ref);
      if (site.whereami==='catalog') {
        node_ref.parentNode.appendChild(pn_tb);
        node_ref.parentNode.parentNode.insertBefore(cataLog.components.pn_hi, node_ref.parentNode);
      } else {
        node_ref.parentNode.insertBefore(pn_tb,node_ref);
        node_ref.parentNode.insertBefore(cataLog.components.pn_hi, node_ref);
      }
      if (site.whereami==='catalog') {
        var ctlg = document.getElementById('catalog');
        ctlg.parentNode.insertBefore(pn_filter,ctlg);
      } else node_ref.parentNode.insertBefore(pn_filter,document.getElementById('catalog'));
      if (site.whereami==='catalog') site2['DEFAULT'].catalog_native_prep_swap_sortSel(node_ref);
      else {
//        var selector_catchan = pn_filter.getElementsByTagName('select')['catalog.indexing'];
//        selector_catchan.setAttribute('style','float:left');
//        if (!cataLog.components.initialized) pn_tb.childNodes[3].insertBefore(cataLog.components.catalog.indexing, pn_tb.childNodes[3].firstChild);
        node_ref.parentNode.insertBefore(cataLog.components.catalog.indexing, node_ref.nextSibling);
//        node_ref.setAttribute('style','float:left');
      }
//      pn_tb.childNodes[0].setAttribute('style',pn_tb.childNodes[0].getAttribute('style')+';display:none');
//      pn_tb.childNodes[1].setAttribute('style',pn_tb.childNodes[1].getAttribute('style')+';display:none');
//      if (site.whereami!=='catalog' && !cataLog.components.initialized) node_ref.parentNode.insertBefore(pn_tb.childNodes[3],node_ref.nextSibling);
      if (site.whereami=='catalog' || site.whereami=='page') {
        document.getElementById('banner').style="height:auto";
        pref3.catalog.filter.kwd.init(document.getElementById('catalog-controls').getElementsByTagName('input')['search'], pn_filter);
      }
      cataLog.components.initialized = true; // this.catalog_get_native_area();
    },
//    catalog_native_prep: function(date,pn_filter,pn_tb,pn_hi){ // working code
//      //      var node_ref = document.getElementsByClassName('catalog_search')[0].nextSibling;  // FF doesn't work.
//      //      var node_ref = (site.whereami==='catalog')? document.getElementById('threads').getElementsByTagName('aside')[0] :
//      var node_ref = (site.whereami==='catalog')? document.getElementsByName('sortMode')[0] :
//            document.getElementById('expand-images').parentNode.nextSibling;
//      cnst.tb_prep_for_embed(pn_tb);
//      if (site.whereami==='catalog') {
//        var pn_tb_new = document.createElement('span');
//        while (pn_tb.firstChild) pn_tb_new.appendChild(pn_tb.firstChild);
//        pn_tb = pn_tb_new;
//        pn_tb.setAttribute('style','float:right');
//        pn_tb.setAttribute('style','float:right');
//      } else if (site.whereami==='page') {
//        var pctrls = document.getElementsByName('postcontrols')[0];
//        //        for (var i=pctrls.childNodes.length-1;i>=0;i--) if (pctrls.childNodes[i].tagName==='HR') pctrls.removeChild(pctrls.childNodes[i]);
//        pctrls.parentNode.insertBefore(document.createElement('hr'),pctrls.nextSibling);
//      }
//      //      node_ref.parentNode.insertBefore(pn_hi,node_ref);
//      if (site.whereami==='catalog') {
//        node_ref.parentNode.appendChild(pn_tb);
//        node_ref.parentNode.parentNode.insertBefore(pn_tb.removeChild(pn_tb.childNodes[3]).firstChild, node_ref.parentNode);
//      } else node_ref.parentNode.insertBefore(pn_tb,node_ref);
//      if (site.whereami==='catalog') {
//        var ctlg = document.getElementById('catalog');
//        ctlg.parentNode.insertBefore(pn_filter,ctlg);
//      } else node_ref.parentNode.insertBefore(pn_filter,document.getElementById('catalog'));
//      var selector_catchan = pn_filter.getElementsByTagName('select')['catalog.indexing'];
//      selector_catchan.setAttribute('style','float:left');
//      if (site.whereami==='catalog') node_ref.parentNode.insertBefore(selector_catchan,node_ref);
//      else pn_tb.childNodes[3].insertBefore(selector_catchan,pn_tb.childNodes[3].firstChild);
//      //      pn_tb.childNodes[0].setAttribute('style',pn_tb.childNodes[0].getAttribute('style')+';display:none');
//      //      pn_tb.childNodes[1].setAttribute('style',pn_tb.childNodes[1].getAttribute('style')+';display:none');
//
//      node_ref.setAttribute('style','float:left');
//      if (site.whereami!=='catalog') node_ref.parentNode.insertBefore(pn_tb.childNodes[3],node_ref.nextSibling);
//      if (site.whereami=='catalog') {
//        node_ref.style.display = 'none';
//        document.getElementById('banner').style="height:auto";
//        var search = document.getElementById('catalog-controls').getElementsByTagName('input')['search'];
//        var search2 = search.cloneNode(false);
//        search2.name = 'catalog.filter.kwd.str';
//        search2.oninput = cataLog.event_func;
//        search.parentNode.insertBefore(search2,search);
//        search.setAttribute('style','display:none');
//        pref3.catalog.filter.kwd.obj = [pn_filter.getElementsByTagName('input')['catalog.filter.kwd.str'], search2];
//        pref3.catalog.filter.kwd.clear();
//      }
//    },
    post_json2html: site2['4chan'].post_json2html,
    page_json2html3_skelton: site2['4chan'].page_json2html3_skelton,
    page_json2html3: site2['4chan'].page_json2html3,
    page_json2html3_replace_expander: site2['4chan'].page_json2html3_replace_expander,
    page_json2html3_add_omitted_info: site2['4chan'].page_json2html3_add_omitted_info,
    post_container: site2['4chan'].post_container,
    wrap_to_parse: site2['DEFAULT'].wrap_to_parse, // bypass meguca1
    catalog_json2html3_thumbnail: function(post){
      return (post.image)? this.protocol + '//' + this.domain_url_image + // fullpath is required for desktopNotification.
        ((post.image.spoiler!==undefined && !pref[cataLog.embed_mode].open_spoiler_image)? '/spoil/default.jpg' :
        (post.image.thumbType===14)? '/audio.png' :
        '/images/thumb/' + post.image.SHA1 + ((post.image.thumbType===0 || post.image.thumbType===undefined && post.image.fileType===0)? '.jpg' : '.png')) : undefined;
//        '/images/thumb/' + post.image.SHA1 + ((post.image.fileType===0)? '.jpg' : '.png')) : undefined;
    },
//    catalog_json2html3_src: (function(){
//      var fileType = ['jpg', 'png', 'gif', 'webm', 'pdf', 'svg', 'mp4', 'mp3', 'ogg'];
//      return function(post){return (post.image)? '/images/src/' + post.image.SHA1 + '.' + fileType[post.image.fileType] : undefined;};
//    })(),
    catalog_json2html3_src: function(post){
      return (post.image)? this.protocol + '//' + this.domain_url_image + '/images/src/' + post.image.SHA1 +
                             (post.ext || Object.getOwnPropertyDescriptor(this.parse_funcs.post_json_template, 'ext').get.call(post)) // for archive. It's before wrap. <- REALLY?
                         : undefined;},
//    catalog_json2html3_src: function(post){return (post.image)? '/images/src/' + post.image.SHA1 + (post.ext || Object.getOwnPropertyDescriptor(this.parse_funcs.post_json_template, 'ext').get.call(post)) :
//                                                                undefined;}, // for archive. It's before wrap.
//    catalog_json2html3_src: function(post){return (post.image)? '/images/src/' + post.image.SHA1 + post.ext : undefined;},
    post_json2html_fname_server: function(post){return (post.image)? post.image.SHA1 + ((post.image.fileType===0)? '.jpg' : '.png') : undefined;},
    post_json2html_fname: function(post){return (post.image)? post.filename + post.ext : undefined;},
    parse_funcs: {
      'page_html': { // for popup
        get_omitted_info: site2['4chan'].parse_funcs.page_html.get_omitted_info,
        set_omitted_info: site2['4chan'].parse_funcs.page_html.set_omitted_info,
        replace_omitted_info: site2['4chan'].parse_funcs.page_html.replace_omitted_info,
        replace_omitted_info2: site2['4chan'].parse_funcs.page_html.replace_omitted_info2,
      },
      'thread_json' : {
        ths: function(obj, parse_obj) {
          var th = this.prep_th_posts(obj);
          th.nof_posts = th.posts.length; // for not being reduced if posts are sliced.
          obj.__proto__ = parse_obj;
//          if (pref.catalog.filter.kwd.post) site2['meguca'].wrap_to_parse.posts(th); // patch for each posts' "com". // v3 // patched in catalog_filter_query_keyword.query_11
//          if (pref.catalog.filter.kwd.post) site2['DEFAULT'].wrap_to_parse.posts(th); // patch for each posts' "com". // v2
          return [th];
        },
        prep_th_posts: function(obj){ // API was changed on 2017.02.19.
          var th = Object.create(obj); // keep original as it is for archiving.
          if (th.sticky) th.sticky = true; // overwrite property of the same name before setting prototype to use polarity.
          th.board = '/' + obj.board +'/';
          obj.no = obj.id || obj.no; // '|| obj.no' for restoring from archive.
          delete obj.id;
          var posts = [obj];
////          var flag = false; // working code -2016.10.06
////          var max_no = 0;
////          for (var i in th.posts) {
          if (obj.posts) for (var i=0;i<obj.posts.length;i++) {
            var post = obj.posts[i];
//            if (pref.test_mode['72'] && post.editing) break; // static for live tagging and archiving, extraction will be done before finishing the posts.
            if (post.id) {
              post.no = post.id;
              delete post.id;
            }
            posts[posts.length] = post;
////            if (max_no>post.no) flag = true;
////            max_no = post.no;
          }
////          if (flag) posts.sort(function(a,b){return a.no - b.no;});
////          th.posts_obj = th.posts;
          th.posts = posts;
          return th;
        },
        get_op_src: function(obj){return site2[obj.domain].catalog_json2html3_src(obj.posts[0]);},
        op_img_url: 'DEFAULT.common', // function(th) {return site2['meguca'].catalog_json2html3_thumbnail(th, th.board);},
//        op_img_url: function(obj){return site2[obj.domain].protocol + '//' + site2[obj.domain].domain_url + site2['meguca'].catalog_json2html3_thumbnail(obj.posts[0]);},
//        add_op_img_url: site2['DEFAULT'].parse_parts.add_op_img_url,
        time_unit: 1000,
        type_com: 'txt',
//        posts_full: 'DEFAULT.catalog_json',
        posts_full: null,
        has_editing: true,
        posts_obj: function(th,no_in){
          var posts_obj = {};
          var i=th.posts.length;
          while (--i>=0) {
            var no = th.posts[i].no;
            posts_obj[no] = th.posts[i];
            if (no===no_in) break;
          }
          return posts_obj;
//          th.posts_obj = posts_obj;
//          return posts_obj[no_in];
        },
        key: 'DEFAULT.common',
      },
      'catalog_json': {
        ths: function(obj, parse_obj) {
          var ths = [];
          var page_base = parseInt(parse_obj.page || 0, 10);
          if (obj.threads) obj = obj.threads; // for v2
          for (var j=0;j<obj.length;j++) {
            var th = this.prep_th_posts(obj[j]);
            th.page = (page_base + Math.floor(j/15)) + '.' + j%15;
//            if (th.sticky) th.sticky = true; // overwrite property of the same name before setting prototype to use polarity.
//            th.board = '/' + th.board +'/';
//            obj[j].no = th.id;
//            delete obj[j].id;
//            th.posts = [th.__proto__];
//            th.posts_obj = {};
//            th.posts_obj[th.no] = th.posts[0];
            obj[j].__proto__ = parse_obj;
            ths[ths.length] = th;
          }
          return ths;
        },
//        footer: function(th){return th.pn.getElementsByClassName('meta')[0];},
//        posts: 'DEFAULT.catalog_json',
//        posts: function(th){
//          var posts = site2['DEFAULT'].parse_funcs.catalog_json.posts(th);
//          if (th.last_replies) posts = posts.concat(th.last_replies);
//          return posts;
//        },
//        has_editing: false,
        has_posts: true, // API was changed on 2017.02.19. // false,
//        missing_info: 1, // API was changed on 2017.02.19. // com is missing.
        proto: 'thread_json',
      },
      'shortCatalog_json_template': {
        proto: 'catalog_json_template'
      },
      'page_json_template': {
        proto: 'catalog_json_template'
      },
      'catalog_json_template': {
        dont_have_com: true,
        get nof_posts(){return this.postCtr;}, // v3
//        get nof_posts(){return this.postCtr+1;}, // v2
//        com: '', // doesn't have this. // changed.
//        get max(){return this.lastUpdated;},
        proto: 'thread_json_template'
      },
      'thread_json_template': {
        get time_posted(){return this.replyTime*1000;},
        get time_bumped(){return this.bumpTime*1000;},
        get time_created(){return this.time*1000;},
//        get nof_posts(){return this.posts.length;}, // remove editing posts. // BUG. reduced if posts are sliced.
        get nof_files(){return this.imageCtr;},
        get com(){return this.body;},
        proto: 'post_json_template'
      },
      'post_json': {
        anchor: function(board,op,no, cross, href){
          if (!href) href = ((cross)? '/all/' : board) + '#p' + no;
          return '<em>'+
                   '<a class="history post-link" data-id="' + no + '" href="' + href + '">&gt;&gt;' + no + '</a>'+
                   '<a class="hash-link history" href="' + href + '"> #</a> '+
                 '</em>';
        },
      },
      'post_json_template': (function(){
        var fileType = ['jpg', 'png', 'gif', 'webm', 'pdf', 'svg', 'mp4', 'mp3', 'ogg', 'zip', '7z', 'tar.gz', 'tar.xz', 'flac', 'noFile', 'txt'];
        return {
          get filename() {return (this.image)? this.image.name : undefined;},
          get w(){return (this.image)? this.image.dims[0] : undefined;},
          get h(){return (this.image)? this.image.dims[1] : undefined;},
          get tn_w(){return (this.image)? ((this.image.spoiler!==undefined && !pref[cataLog.embed_mode].open_spoiler_image)? 150 : this.image.dims[2] || 125) : undefined;},
          get tn_h(){return (this.image)? ((this.image.spoiler!==undefined && !pref[cataLog.embed_mode].open_spoiler_image)? 150 : this.image.dims[3] || 125) : undefined;},
          get fsize(){return (this.image)? this.image.size : undefined;},
          get ext(){return (this.image)? '.'+fileType[this.image.fileType] : undefined;},
          get sub(){return (this.subject)? common_func.escape(this.subject) : '';},
          get capcode(){return this.auth;},
          get md5(){return (this.image)? this.image.MD5 : undefined;},
          get sha1(){return (this.image)? this.image.SHA1 : undefined;},
          get country(){return (this.flag)? this.flag.toUpperCase() : undefined;},
          name: 'Anonymous',
          get txt(){return this.body;},
          get com(){
//            var txt2com = site2[site.nickname].parse_funcs.post_html.txt2com;
            var anchor_class = (site2[site.nickname].parse_funcs.post_html.txt2com_anchor_class)? '" class="' + site2[site.nickname].parse_funcs.post_html.txt2com_anchor_class : '';
            var anchor_regex = /(>>)([0-9]+)/g;
            var anchor_func_tgt = null;
            var anchor_func_1 = (site.nickname==='meguca')? site2['meguca'].parse_funcs.post_json.anchor
                                                          : function(board,op,no,cross){ // for v3
              return '<a href="' + ((cross)? '/cross/' : board) + op + '#p' + no + anchor_class + '">&gt;&gt;' + no + '</a>'; // URL is changed on 2017/05/30
            };
            function anchor_func(str,arrow,no){
              var links = anchor_func_tgt.links;
              var i=0;
              while (i<links.length && links[i].id!=no) i++; // link.no is string, != is used intentionally.
              return (i<links.length)? anchor_func_1(anchor_func_tgt.board, links[i].op, no, anchor_func_tgt.op!=links[i].op, null) // editing post isn't included in links.
                : str;
//              while (i<links.length && links[i][0]!=no) i++; // working code -2018.10.31
//              return (i>=links.length)? str
//                   : anchor_func_1(anchor_func_tgt.board, links[i][1], no, anchor_func_tgt.op!=links[i][1], null); // editing post isn't included in links.
            }
//            function anchor_func(board, str,arrow,no){ // v2
//              var link = this[no];
//              return (link)? '<a href="/' + link.board + '/' + link.op + '#' + no + anchor_class +
//                '">&gt;&gt;' + ((link.board!=board)? '&gt;/'+ link.board +'/' : '') + no + '</a>' : str; // links isn't provided while editing
//            }
            var spoiler_replace_txt = site2[site.nickname].parse_funcs.post_html.txt2com_spoiler_replace_txt || '<spoiler>$1</spoiler>';
            var quote_replace_txt = (site.nickname==='meguca')? '<em>$1</em>' : '<span class="quote">$1</span>';
            var c2t_count;
            function command2txt(str){
              return '<strong>' + str + ' (' + ((this[c2t_count])? this[c2t_count++].val : '') + ')</strong>';
            }
            Object.defineProperty(site2['meguca'].parse_funcs.post_json_template,'com',{get:function(){
                if (!this.body) return '';
                var com = common_func.escape_text(this.body);
                if (this.links) { // v3
                  anchor_func_tgt = this;
                  com = com.replace(anchor_regex,anchor_func);
                }
//                if (this.links) com = com.replace(anchor_regex,anchor_func.bind(this.links, this.board.slice(1,-1))); // v2
                com = com.replace(/(^>[^>].*$)/mg,quote_replace_txt);
                com = com.replace(/\*\*(.*?)((\*\*)|$)/mg,spoiler_replace_txt);
                if (this.commands) {
                  c2t_count = 0;
                  com = com.replace(/^#(pyu|flip|\d*d\d+|8ball)$/mg,command2txt.bind(this.commands));
                }
                com = com.replace(/(https*:\/\/[^\s]*)(\s|$)/mg,'<a href="$1" target="_blank">$1</a>$2');
                return com.replace(/\n/g,'<br>');
              }, enumerable:true, configurable:true});
            return this.com;}, // return Object.defineProperty(...).com doesn't work, because 'this' refers site2['meguca'].parse_funcs.post_json_template.
//          get com(){return (this.body)? site2[site.nickname].parse_funcs.post_html.txt2com((this.links)? this.body.replace(anchor_regex,anchor_func(this.links)) : this.body) : '';}, // BUG, /a/1179831(test thread) doesn't have links and cause error. // links isn't provided while editing.
//          get posts_editing(){
//            var posts_editing = {};
//            for (var i=0;i<this.posts.length;i++) if (this.posts[i].editing) posts_editing[this.posts[i].no] = this.posts[i];
//            return Object.defineProperty(this,'posts_editing',{value:posts_editing, writable:true, enumerable:true, configurable:true}).posts_editing;
//          },
          sticky: false,
          pn: undefined, // block getter
          get no(){return this.id;},
          time: undefined, // patch
          flag: undefined,
          flags: undefined,
          get parse_funcs_html(){
            Object.defineProperty(site2['meguca'].parse_funcs.post_json_template,'parse_funcs_html',
              {value:site2[site.nickname].parse_funcs[site.whereami+'_html'], writable:true, enumerable:true, configurable:true});
            return this.parse_funcs_html;},
          proto: 'DEFAULT.common'
        };
      })(),
    },
    mimic_always: true,
    post_com2txt: function(post){
      return (post.body)? post.body.replace(/\*\*([^(\*\*)\n]*)((\*\*)|$)/mg,' $1 ') : '';
    },
    proto: 'meguca1'
  };
  common_func.Object_modifyDescriptor(site2['meguca2'],'check_func',{writable:false}); // for reentry.

  site2['meguca'] = { // meguca.org v3
    domain_url_image: 'meguca.org/assets', // changed around 2018.04.01
//    domain_url_image: 'images.meguca.org/assets',
    check_func: site2['meguca2'].check_func, // needed as a own property.
//    url_boards_json: function(){return ['https://meguca.org/json/' + ((pref.pref2['meguca'].utilize_boards_json)? 'boardTimestamps' : 'boardList'), 'json'];},
    url_boards_json : function(){return ['https://meguca.org/json/board-list', 'json'];},
//    url_boards_json : function(){return ['https://meguca.org/json/boardList', 'json'];}, // working code before 2017.06.19
    postprocess_board: function(val){
      for (var i=0;i<val.length;i++) {
        var bd = liveTag.mems.init({domain:this.nickname, board:'/'+val[i].id+'/'});
        bd.o = i;
        if (val[i].tags && val[i].tags.length!=0) liveTag.postprocess_board_add_btag(val[i].tags,bd);
      }
    },
    utilize_boards_json: false,
    catalog_get_native_scroll_area: undefined, // always window.
//    spoiler_text: {
//      open_rule: 'del, del em {color: #fff!important;}',
//    },
    make_url4 : function(dbt){
      var url_prefix  = this.protocol + '//' + this.domain_url; // force to use https:
      var json_prefix = '/json/boards'; // '/json'; // working code before  2017.06.19
      return (dbt[3]==='catalog_json')? [url_prefix + json_prefix + dbt[1]+ 'catalog', 'json']
           : (dbt[3]==='page_json')?    [url_prefix + json_prefix + dbt[1]+ '?page='+dbt[2], 'json']
           : (dbt[3]==='thread_html')?  [url_prefix + dbt[1] + dbt[2], 'html']
           : (dbt[3]==='thread_json')?  [url_prefix + json_prefix + dbt[1]+dbt[2], 'json']
           : (dbt[3]==='page_html')?    [url_prefix + dbt[1], 'html'] : undefined;
    },
    historyAPI: false, // true, // changed on 2017.06.12 
    historyAPI_blocking: false,
    short_link:function(name, nof_posts, num, kwd_head, kwd_tail){
      var url = this.make_url4(common_func.name2dbt(name))[0];
      var th_class = 'history lastN-link ' + pref.script_prefix +'_link';
      return '<a href="' + url + '?last=100' + '" class="' + th_class + '">' + kwd_head + '100' + kwd_tail + '</a>';
    },
    wrap_to_parse: {
      get: site2['DEFAULT'].wrap_to_parse.get,
      posts: function(th, start){site2['DEFAULT'].wrap_to_parse.posts(th, start || th.localArchive && 1 || undefined, {op:th.no || th.id});},
//      posts: function(th, start){site2['DEFAULT'].wrap_to_parse.posts(th, start, {op:th.no || th.id});},
    },
    lth_init: function(th){
      liveTag.mems.init({board:'/cross/', domain:th.domain});
      Object.defineProperty(liveTag.mems['meguca'],'/cross/',{value:liveTag.mems['meguca']['/cross/'], configurable:true, enumerable:false, writable:true});
    },
    prep_own_posts: function(bt){
      if (window.opener && window.name==='meguca') setTimeout(this.prep_own_posts_IDB.bind(this),0); // wait to configure IDB module.
      else this.prep_own_posts_IDB();
    },
    prep_own_posts_IDB: function(bt){
      IDB.req_raw('meguca', 'meguca', 'mine', null, this.prep_own_posts_IDB_callback.bind(this), 'get_all'); // This has a racing condition, http request in subframe is faster than IDB usually.
    },
    prep_own_posts_IDB_callback: function(domain, board, no, result){
      var all = {};
      for (var i in result) all[result[i].id] = null;
      site3[this.nickname].own_posts = {ALL:all};
//      var boards = ['/a/','/an/','/cr/','/g/'];
//      for (var i=0;i<boards.length;i++) site3[this.nickname].own_posts[boards[i]] = all;
      if (window.opener && window.name==='meguca') this.prep_own_posts_event();
    },

    popups_post_pnode: function(pnode){
      while (pnode.tagName!=='ARTICLE' && pnode.parentNode) pnode = pnode.parentNode;
      return pnode;
    },
//    backlink_class: 'backlinks', // for popups_add_1
    add_backlinks_pn: function(pn, target){
      var bks = pn.getElementsByClassName('backlinks')[0];
      if (!bks) {
        bks = document.createElement('span');
        bks.setAttribute('class','spaced backlinks');
        pn.appendChild(bks);
        return {pn:bks, hrefs:{}};
      } else return {pn:bks, hrefs:this.add_backlinks_hrefs(bks, target)};
    },
    add_backlinks_hrefs: function(bks, target){
      var hrefs = {};
      if (!target) bks.innerHTML = '';
      else {
        var as = bks.getElementsByTagName('a');
        for (var j=0;j<as.length;j++) hrefs[as[j].getAttribute('href')] = null;
      }
      return hrefs;
    },
    add_backlinks_add_1: function(bks, dbtp, href){
      var blk = document.createElement('span');
      blk.innerHTML = site2['meguca'].parse_funcs.post_json.anchor(dbtp[1], dbtp[2], dbtp[3], null, href);
      blk = blk.childNodes[0];
//      blk.onclick = this.backlink_onclick;
//      blk.onmouseover = this.popups_post_entry;
      if (dbtp[0]!=='meguca' || pref.test_mode['91']) {
        blk.childNodes[0].onclick = this.backlink_onclick;
        blk.childNodes[1].onclick = this.backlink_onclick;
//        blk.childNodes[0].onmouseover = this.popups_post_entry;
//        blk.childNodes[1].onmouseover = this.popups_post_entry;
      }
      bks.pn.appendChild(blk);
    },
    add_backlinks: function(pn,backlinks,target, th){ // MUST CHANGE TO USE site2['DEFAULT'].add_backlinks, but meguca is down and I can't debugg it now, so I leave this.
      var bks = this.add_backlinks_pn(pn, target);
      for (var i=(target || 0);i<backlinks.length;i++) {
        var dbtp = this.popups_backlink2dbtpth(backlinks[i], th);
        var domain = dbtp[0];
        var href = site2[domain].link_dbtp2href_abs(dbtp);
//        if (domain!==site.nickname) href = site2[domain].absolute_link_1(href);
        if (bks.hrefs[href]!==null) this.add_backlinks_add_1(bks, dbtp, href);
        if (target) break;
      }
    },
    popups_href2dbtp: function(href){ //, src, th){
//      if (href[0]==='#' && th) {
//        href = th.board+th.no+href; // this.link_dbtp2href([th.domain, th.board, th.no, href.substr(2)]);
//        src.setAttribute('href',href);
//      }
      var hrefs = href.split(/[\/#]/);
      var p = hrefs[hrefs.length-1].substr(1); // remove 'p'
      var b = '/'+hrefs[hrefs.length-3]+'/';
      var t = hrefs[hrefs.length-2];
      if (!t) t = -1;
      return ['meguca',b,t,p]
    },
    toplevel_anchor_pos:2,
    link_dbtp2href: function(dbtp){
      return dbtp[1] + dbtp[2] + '#p' + dbtp[3];
    },

    popups_post_fetch: function(th, dbt){
      httpd.req({initiator:'popup',
                 tgts:[{url:'https://meguca.org/json/post/'+dbt[3], responseType:'json', tgt:dbt[0]+'/*/'+dbt[2]+'#'+dbt[3], data_type:'json', domain:th.domain}],
                 callback_1:site2[th.domain].popups_post_fetch_callback.bind(site2[th.domain]),
//                 INDICATOR: {shift:function(){}, report:function(){}},
                 IDX:0, FINISHED:0, SUC:0, max:1,
                 dbt:dbt,
                },8);
    },
    popups_post_fetch_callback: function(req,val, REQ){
      var post_0 = {domain:REQ.dbt[0], board:REQ.dbt[1], no:REQ.dbt[2], type_data:'json', domain_html:site.nickname, key:REQ.dbt[0]+REQ.dbt[1]+REQ.dbt[2]};
//      var post_0 = {domain:REQ.dbt[0], board:'/'+val.response.board+'/', no:REQ.dbt[2], type_data:'json', domain_html:site.nickname};
      delete val.response.board;
      var th = {posts:[post_0, val.response], __proto__:post_0};
      site2[th.domain].wrap_to_parse.posts(th);
      var lth = liveTag.mems.init(th);
//      var lth = liveTag.prep_tags(th);
      this.popups_fetched(th,lth, 1);
//      cataLog.format_html.prepare_html_post(th, th.posts[1]);
//      this.popups_add_1(th, th.posts[1], pref[cataLog.embed_mode].popup, lth.q, th.no===th.posts[1].no, false); // cut quote link.
//      if (this.popup_info && this.popup_info.key===REQ.dbt[0]+REQ.dbt[1]+REQ.dbt[2]+'#'+th.posts[1].no) this.popups_post_entry({target:this.popup_info.node, __proto__:this.popup_info});
    },
    post_json2html_imagesearch_href: {
      google: function(url){return 'https://www.google.com/searchbyimage?image_url='+url;},
      iqdb: function(url){return 'http://iqdb.org/?url='+url;},
      saucenao: function(url){return 'http://saucenao.com/search.php?db=999&amp;url='+url;},
      whatAnime: function(url){return 'https://whatanime.ga/?url='+url;},
      desustorage: function(md5){return 'https://desuarchive.org/_/search/image/'+md5;},
      exhentai: function(sha1){return 'http://exhentai.org/?fs_similar=1&amp;fs_exp=1&amp;f_shash='+sha1;},
    },
    post_json2html_imagesearch_1: function(provider,src_x,label){
      var href = this.post_json2html_imagesearch_href[provider](src_x);
      return '<a class="image-search ' + provider + '" target="_blank" rel="nofollow" href="' + href + '">' + label + '</a>';
    },
    post_json2html_imagesearch: function(pref_imgsearch,furl,md5,sha1){
      return ((pref_imgsearch.google)?             this.post_json2html_imagesearch_1('google'     ,furl,'G' ) : '')+
             ((pref_imgsearch.iqdb)?               this.post_json2html_imagesearch_1('iqdb'       ,furl,'Iq') : '')+
             ((pref_imgsearch.saucenao)?           this.post_json2html_imagesearch_1('saucenao'   ,furl,'Sn') : '')+
             ((pref_imgsearch.whatAnime)?          this.post_json2html_imagesearch_1('whatAnime'  ,furl,'Wa') : '')+
             ((pref_imgsearch.desustorage && md5)? this.post_json2html_imagesearch_1('desustorage',md5, 'Ds') : '')+
             ((pref_imgsearch.exhentai && sha1  )? this.post_json2html_imagesearch_1('exhentai'   ,sha1,'Ex') : '');
    },
    post_json2html: function(post, board, op, short_link, op_no) {
      var pn = document.createElement('div');
      var time_unit = (post.parse_funcs && post.parse_funcs.time_unit) || 1;
      var date = new Date((post.time || 0) * time_unit);
      var name = post.name || 'Anonymous';
      var file_header_html= '';
      var file_html= '';
      if (post.ext) {
        var fsize_str = (((post.fsize>1048576)? post.fsize/1048576 : post.fsize/1024)+0.005).toString();
        fsize_str = fsize_str.substr(0,fsize_str.indexOf('.')+3) + ((post.fsize>1048576)? ' MB' : ' KB');
//        var fname_server = site2[post.domain].post_json2html_fname_server(post);
//        var fname = site2[post.domain].post_json2html_fname(post);
        var furl = site2[post.domain].catalog_json2html3_src(post,board);
        var turl = site2[post.domain].catalog_json2html3_thumbnail(post,board);
        var tn_f = (op)? 1 : ((post.tn_w>post.tn_h)? post.tn_w : post.tn_h) / 150;
        file_header_html = '<figcaption class="spaced">'+
            '<a class="image-toggle act" hidden=""></a>'+
            ((pref[cataLog.embed_mode].imagesearch.use)? '<span class="spaced image-search-container">'+
              this.post_json2html_imagesearch(pref[cataLog.embed_mode].imagesearch, furl, post.md, post.sha1) + '</span>' : '')+
            '<span class="fileinfo">'+
              '<span class="filesize">' + fsize_str + '</span>'+
              '<span class="dims">' + post.w + 'x' + post.h + '</span>'+
            '</span>'+
            '<a href="' + ((post.domain==='meguca')? furl.replace(/images\.meguca\.org/,'meguca.org') : furl) + '" download="' + post.filename + post.ext + '">' + post.filename + post.ext + '</a>'+
//            '<a href="' + furl + '" download="' + post.filename + post.ext + '">' + post.filename + post.ext + '</a>'+
          '</figcaption>';
        file_html = '<figure>'+
            '<a target="_blank" href="' + furl + '">'+
              '<img src="' + turl + '" width="' + post.tn_w + '" height="' + post.tn_h + '">'+
            '</a>'+
          '</figure>';
      }
      pn.innerHTML = '<article id="p' + post.no + '" class="glass' + ((post.ext)? ' media' : '') + '">'+
          '<input type="checkbox" class="deleted-toggle">'+
          '<header class="spaced"><input type="checkbox" class="mod-checkbox hidden">'+
            '<b class="name">'+post.name+'</b>'+
            ((post.country)? '<img class="flag" src="/assets/flags/' + post.country.toLowerCase() + '.svg" title="' + post.country + '">' : '')+
            '<time>' + site2['common'].change_utc_to_local(date) + '</time>'+
            '<nav>'+
//              '<a class="history" href="' + board + op_no + ((post.domain==='meguca')? '?last=100' : '')) + '#p'+post.no + '">No.</a>'+
//              '<a class="history quote" href="/all/2025573?last=100#p2032325">2032325</a>'+
              '<a class="history" href="' + '#p'+post.no + '">No.</a>'+
              '<a class="history quote" href="#p' + post.no + '">' + post.no + '</a>'+
            '</nav>'+
            ((op)? '<span>'+
              '<span class="act">'+
                 '<a class="history expand-link" href="' + board + post.no + '">Expand</a>'+
              '</span>'+
              ((short_link)? '<span class="act">'+ short_link + 
//                '<a class="history lastN-link" href="/all/2114139?last=100">Last 100</a>'+
              '</span>' : '' )+
            '</span>' : '' )+
            '<a class="control">'+
              '<svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 8 8">'+
                '<path d="M1.5 0l-1.5 1.5 4 4 4-4-1.5-1.5-2.5 2.5-2.5-2.5z" transform="translate(0 1)"></path>'+
              '</svg>'+
            '</a>'+
          '</header>'+
          file_header_html+
          '<div class="post-container">'+
            file_html+
            '<blockquote>'+
//              '<em>'+
//                '<a class="history post-link" data-id="2032314" href="/all/2025573#p2032314">&gt;&gt;2032314</a>'+
//                '<a class="hash-link history" href="/all/2025573#p2032314"> #</a> '+ // there is a blank here.
//              '</em>'+
//              '<br>Well the grave has already been dug<br>Might as well hop in'+
              post.com+
            '</blockquote>'+
          '</div>'+
        '</article>';
      return pn.removeChild(pn.childNodes[0]);
    },

    
    post_container: function(pn){return pn},
    update_posts_remove: function(th_old,i,pnode){
      pnode.removeChild(th_old.posts[i].pn);
    },
    update_posts_insert: function(src,dst,i,j,pnode){
      var ref = (j<dst.length)? dst[j].pn : pnode.getElementsByTagName('aside')[0];// dst[dst.length-1].pn.nextSibling; // dst[dst.length-1].pn.nextSibling;
      if (!src[i].pn) src[i].pn = this.post_json2html(src[i], src[i].board);
      var tgt = src[i].pn;
      pnode.insertBefore(tgt, ref);
    },
    page_json2html3_skelton: function(obj, both) {
      var th = document.createElement('section');
      th.setAttribute('class','index-thread');
      th.setAttribute('data-id',obj.no);
      th.innerHTML = '<input type="checkbox" class="deleted-toggle">'+
                     '<aside class="act posting glass"><a href="'+ obj.board + obj.no + '?last=100#bottom">Reply</a></aside>';
      return (both)? [th,th.childNodes[1]] : th;
    },
    page_json2html3 : function(obj,board,thumb_url, assign_pn) { // TEMPORAL, USE thumb_url TO MIMIC.
      var doms = this.page_json2html3_skelton(obj, true);
      var th = doms[0];
      var ref = doms[1];
//      if (!obj.posts) obj.posts = {posts:[{}], _proto__:obj}; // obj.posts = [obj]; // test patch for catalog->page transition.
      var op = this.post_json2html((obj.posts && obj.posts[0])? obj.posts[0] : obj, board, true, site2[obj.domain].short_link(obj.key, obj.nof_posts, 2, 'Last ',''), obj.no);
//      if (!obj.posts) obj.posts = cataLog.threads[obj.key][4].slice(0,1); // test patch for catalog->page transition.
//      op.setAttribute('class','post op');
      th.insertBefore(op,ref);
      if (assign_pn || !obj.posts[0].pn) obj.posts[0].pn = op;
      if (obj.posts) {
        for (var i=1;i<obj.posts.length;i++) {
          var pn = this.post_json2html(obj.posts[i], board);
          th.insertBefore(pn,ref);
          if (assign_pn || !obj.posts[i].pn) obj.posts[i].pn = pn;
        }
        this.page_json2html3_add_omitted_info(obj,obj.posts,obj.posts);
      }
      return th;
    },
    page_json2html3_replace_expander : function(posts_old, idx, key) {
      var omit_info = this.parse_funcs['page_html'].get_omitted_info(posts_old[0]);
      if (omit_info) omit_info.appendChild(cnst.config_expander(key, idx));
    },
    page_json2html3_add_omitted_info : function(th,posts_old,posts) {
      var nof_files = 0;
      for (var i=0;i<posts.length;i++) nof_files += (posts[i].type_data==='html')? posts[i].pn.getElementsByClassName('figure').length :
                                                    (posts[i].filename)? 1 : 0;
      var nof_files_omitted = th.nof_files - nof_files;
      var nof_posts_omitted = th.nof_posts - posts.length;

      var omit_info = (posts_old)? this.parse_funcs['page_html'].get_omitted_info(posts_old[0]) : null;
      if (nof_posts_omitted!=0) {
        if (!omit_info) {
          omit_info = document.createElement('span');
          omit_info.setAttribute('class','omit');
          omit_info.setAttribute('data-omit',nof_posts_omitted);
          omit_info.setAttribute('data-image-omit',nof_files_omitted);
          omit_info.innerHTML = ' <span class="act"><a href="' + posts[0].no + '" class="history">See All</a></span>';
          if (th.domain!=='meguca' || pref[cataLog.embed_mode].use_expander_always) omit_info.appendChild(cnst.config_expander(th.key));
          if (posts_old) this.parse_funcs['page_html'].set_omitted_info(posts_old[0],omit_info);
        }
        omit_info.childNodes[0].textContent = nof_posts_omitted + ((nof_posts_omitted==1)? ' post' : ' posts') +
                                ((nof_files_omitted)? ' and ' + nof_files_omitted + ' image' + ((nof_posts_omitted!==1)? 's' : '') : '') + ' omitted ';
//        if (th.domain!==site.nickname) omit_info.childNodes[0].style.display = 'none';
      } else if (omit_info) omit_info.childNodes[0].textContent = 'Showing all posts.'; // if (omit_info && posts_old) posts_old[0].pn.removeChild(omit_info);
      return omit_info;
    },


    catalog_json2html3 : function(obj,board,thumb_url) {
      var th = document.createElement('article');
      th.id = 'p'+obj.no;
      th.setAttribute('class','glass media op' + ((obj.deleted)? ' deleted' : ''));
      th.setAttribute('data-id',obj.no);
      var th_url = site2[obj.domain].make_url4([obj.domain,obj.board,obj.no,'thread_html'])[0];
      if (thumb_url) {
        var tn_w = obj.tn_w || obj.posts[0].tn_w;
        var tn_h = obj.tn_h || obj.posts[0].tn_h;
        var tn_f = 150 / ((tn_w>tn_h)? tn_w : tn_h);
      }
      var th_class_tn = (site2[obj.domain].historyAPI && pref.pref2.meguca.historyAPI)? 'history' : '';
      var th_class    = th_class_tn + ((th_class_tn)? ' ':'') + pref.script_prefix +'_link';
      var short_link = site2[obj.domain].short_link(obj.key, obj.nof_posts, 1, 'Last ', '');
//      if (!thumb_url) thumb_url = site2[obj.domain].catalog_json2html3_thumbnail(obj, obj.board) || site2[obj.domain].catalog_json2html3_thumbnail(obj.posts[0], obj.board); // for reentry
      th.innerHTML = 
        '<input type="checkbox" class="deleted-toggle">'+
        ((thumb_url)? '<figure>'+
          '<a class="' + th_class_tn + '" href="' + board + obj.no + '">'+
          '<img width="' + (tn_w * tn_f) + '" height="' + (tn_h * tn_f) + '" class="catalog" src="'+ thumb_url + '"></a>'+
        '</figure>' : '' )+
        '<span class="spaced thread-links hide-empty">'+
          '<b class="board">' + board + '</b>'+
          '<span class="counters" title="Posts/Images">'+ (obj.nof_posts-1) + '/' + (obj.nof_files-1) +'</span>'+
          '<span class="act">'+
            ((obj.domain==='meguca')? '<a class="' + th_class_tn + ' lastN-link" href="' + board + obj.no + '?last=100">Last 100</a></span>' :
                                      '<a href="' + th_url + '" class="'+ th_class + ' lastN-link">Expand</a>'+
                                      ((short_link)? '] [' + short_link : ''))+
          '</span>'+
        '</span><br>'+
        ((obj.sub)? '<h3>' + obj.sub + ' </h3>' : '')+
        '<blockquote>' + ((obj.com)? obj.com : '') + '</blockquote>';
      return th;
    },
    mark_newer_posts: function(th_pn,date,unmark, short_cut, th) {
      var ths = (th)? [th] : site2['meguca'].wrap_to_parse.get(document, 'meguca', site.board, site.whereami+'_html', (site.whereami==='thread')? {thread:site.no} : null);
//      if (!th && th_pn!==document) return site2['meguca1'].mark_newer_posts(th_pn,date,unmark, short_cut); // patch.
//      if (!th) {
//        th = JSON.parse(document.getElementById('post-data').innerHTML); // JSON.parse(th_pn.getElementById('post-data').innerHTML);
//        th.posts = [th].concat(th.posts);
//        var pns = th_pn.getElementsByTagName('article');
//        for (var i=0;i<pns;i++) th.posts[i].pn = pns[i];
//      }
      var marked_first_post = null;
      for (var i=ths.length-1;i>=0;i--)
        marked_first_post = ths[i].posts[0].pn && this.mark_newer_posts_posts(ths[i].posts, date, unmark, short_cut) || marked_first_post; // ths[i].posts[0].pn for reentry.
      return marked_first_post;
    },
    parse_funcs: {
      'shortCatalog_json': {
        has_posts: false,
        proto: 'meguca2.catalog_json'
      },
      'catalog_json': {
        has_posts: false, // API was changed on 2017/5/24.
      },
      'catalog_html': {
        ths_json: 'thread_html',
        ths: function(doc) {
          var ths = site2['meguca2'].parse_funcs.catalog_html.ths(doc);
          var obj = this.ths_json(doc, ths.map(function(v){return v.pn;}), 'shortCatalog_json', 'catalog_html');
          for (var i=0;i<obj.length;i++) obj[i].page = Math.floor(i/15) + '.' + (i%15);
          return obj; //site2['meguca'].wrap_to_parse.get(obj, 'meguca', doc.board, 'shortCatalog_json');
//          setTimeout(function(){
//          cataLog.scan_boards_keyword_callback2('meguca,'+doc.board+',j0,shortCatalog_json', {date:Date.now(), status:200, response:obj},
//            ['reentry_data',Object.create(cataLog.scan_boards_keyword_callback2_default_args)]);
//          }, 0);
//          return ths; // REDUNDANT, pass twice.
//          return site2['meguca2'].parse_funcs.catalog_html.ths(doc);
        },
        get_omitted_info: function(){},
        set_omitted_info: function(){},
        pn_name: 'thread_html',
      },
      'page_json': {
        proto: 'meguca2.catalog_json',
      },
      'post_json': {
        pn: 'DEFAULT.post_json',
      },
      'page_html': {
        ths: function(doc) {
          var obj = this.ths_json(doc, document.getElementsByClassName('index-thread'), 'page_json', 'page_html');
//          var href = window.location.href;
//          var idx  = href.indexOf('?page=');
//          var page = (idx!=-1)? href.substr(idx+6) : 0; // SHOULD BE site.page;
          for (var i=0;i<obj.length;i++) obj[i].page = site.page + '.' + i;
          return obj;
        },
//        footer: function(th){return this.insert_footer4(th.pn.getElementsByClassName('deleted-toggle')[0]);},
        get_max_page: function(doc){
          var len;
          var pgn = doc.getElementsByClassName('pagination')[0];
          return pgn? (len = pgn.childNodes.length, (len<=1)? len : len-1) : 1;
        },
        proto: 'thread_html',
      },
      'thread_html': {
        ths_json: function(doc, pns, type_parse, type_html) {
          var obj = JSON.parse(doc.pn.getElementById('post-data').innerHTML);
          obj = site2['meguca'].wrap_to_parse.get(obj, 'meguca', doc.board, type_parse);
          var dic = {};
          for (var i=0;i<pns.length;i++) dic[pns[i].dataset.id] = pns[i];
          for (var i=0;i<obj.length;i++) {
            obj[i].pn = dic[obj[i].no];
            var posts_pns = obj[i].pn && obj[i].pn.getElementsByTagName('article');
            if (posts_pns) {
              for (var j=0;j<obj[i].posts.length;j++) obj[i].posts[j].pn = posts_pns[j];
              Object.defineProperty(obj[i], 'footer', {value:this.footer(obj[i]), configurable:true, enumerable:true, writable:true});
              Object.defineProperty(obj[i], 'type_mimic', {value:type_html, configurable:true, enumerable:true, writable:true});
            }
          }
//          Object.defineProperty(obj[0].__proto__.__proto__.__proto__, 'type_mimic', {value:type_html, configurable:true, enumerable:true, writable:true}); // BUG. this also effects *_json at next fetch.
          obj[0].__proto__.__proto__.__proto__.parse_funcs_html = site2['meguca'].parse_funcs[type_html];
          return obj;
        },
        ths: function(doc) {return this.ths_json(doc, [document.getElementById('thread-container')], 'thread_json', 'thread_html');},
        footer: function(th){return site2['DEFAULT'].parse_funcs.page_html.insert_footer4(th.pn.getElementsByClassName('deleted-toggle')[0]);},
        get_thread_links: function(th){return th.pn.querySelectorAll('.expand-link,.lastN-link,.'+pref.script_prefix+'_link');},
        get_omitted_info: function(post){
          return post.pn && post.pn.getElementsByClassName('omit')[0] || undefined;
//          var omit_info = post.pn && post.pn.lastChild; // post.pn for transition
//          return (omit_info && omit_info.classList.contains('omit'))? omit_info : undefined; // BUG, this refers backlinks
        },
        set_omitted_info : function(post, info){if (info) post.pn.appendChild(info);},
        replace_omitted_info : function(dst, src){dst.childNodes[0].textContent = src.childNodes[0].textContent;},
        replace_omitted_info2 : function(dst, src, th){
          if (!src) {
            var span = document.createElement('span');
            span.setAttribute('style','display:none');
            dst.insertBefore(span,dst.childNodes[1]);
            span.appendChild(dst.childNodes[0]);
            dst.childNodes[1].setAttribute('style','display:none');
          } else {
            if (dst.childNodes[1].style.display==='none') {
              dst.insertBefore(dst.childNodes[0].childNodes[0], dst.firstChild);
              dst.removeChild(dst.childNodes[1]);
              dst.childNodes[1].removeAttribute('style');
            }
            this.replace_omitted_info(dst,src);
          }
        },
//        replace_omitted_info2: site2['4chan'].parse_funcs.page_html.replace_omitted_info2,
        pn_name: function (post){return post.pn.getElementsByClassName('name')[0].childNodes[0];},
      },
      'thread_json': {
        prep_to_archive: function(obj){
          obj[0].posts = obj.slice(1);
          return obj[0];
        },
        proto: 'meguca2.thread_json',
      },
    },
    favicon : {
      __proto__: site2['DEFAULT'].favicon,
      none: '/assets/favicons/default.ico',
      reply: '/assets/favicons/unread.ico',
      reply_to_me: '/assets/favicons/reply.ico',
    },
    proto: 'meguca2'
  };
  common_func.Object_modifyDescriptor(site2['meguca'],'check_func',{writable:false}); // for reentry.

  site2['imeguca'] = {
    nickname: 'imeguca',
    domain_url: 'images.meguca.org',
    home: 'https://images.meguca.org/assets/favicons/default.ico',
    check_func: site2['DEFAULT'].check_func,
  };
}
if (pref.features.domains['lain'] || pref.features.domains['lainjp']) {
  site2['lain'] = { //lainchan.org // 5.1.3
    nickname : 'lain',
    home : site.protocol + '//lainchan.org/q/index.html',
//    home : site.protocol + '//lainchan.org',
    X_FRAME_OPTIONS: true,
    CONTENT_SECURITY_POLICY_FRAME: true,
    protocol: 'https:',
    domain_url: 'lainchan.org',
    postform_rules: null,
    features : {page: false, graph: true, setting2: false},
    boards_json:site2['DEFAULT'].generate_boards_json([['\u03bb',5],['diy',2],['sec',6],['tech',6],['inter',2],['lit',3],['music',3],['vis',3],['hum',3],['drg',3],['zzz',2],['layer',1],['q',7],['r',7]],3),
//    boards_json:{boards:[{board:'cyb', pages:7}, {board:'sci', pages:2}, {board:'tech', pages:7}, {board:'\u03bb', pages:7}, {board:'layer', pages:5}, {board:'zzz', pages:17}, {board:'w', pages:4}, {board:'feels', pages:7}, {board:'drg', pages:4}, {board:'lit', pages:7}, {board:'civ', pages:1}, {board:'diy', pages:7}, {board:'art', pages:7}, {board:'r', pages:9}, {board:'q', pages:3}, {board:'f', pages:2}, {board:'sec', pages:3}, {board:'cult', pages:4}]},
    check_func : function(){
      var href = window.location.href;
      if (href.indexOf(this.domain_url)===-1 || href.search(new RegExp(this.domain_url+'\/*$'))!=-1) return false;
//      if (href.indexOf(new RegExp(this.domain_url))!=-1) {
        site.whereami = (href.indexOf('/catalog')!=-1)? 'catalog'
                      : (href.indexOf('/res/')!=-1)? 'thread'
                      : (document.title==='404')? '404' 
//                      : (site.board==='/all/' || site.board==='/popular/')? 'other'
//                      : (!pref.test_mode['29'] && (site.board==='/all/' || site.board==='/popular/'))? 'other'
                      : 'page';
//                      : (href.search(/\/$|(index|[0-9]+)\.html|\/all$|\/popular$/)!=-1)? 'page'
//                      : 'other';
        if (site.whereami==='thread') site.no = parseInt(href.replace(/.*res\//,'').replace(/\.html/,''),10);
        site.config(this.domain_url, this.nickname);
        site.max_page = 7;
        site.header_height = function(){
          var header = document.getElementsByClassName('boardlist')[0];
          return (header)? header.offsetHeight : 0;
        }
        site.myself = site.no || 0;
        site.embed_to = (site.whereami==='thread' || site.whereami==='page')? {
          top: function(){return document.getElementsByName('postcontrols')[0];},
          bottom: function(){return document.getElementsByTagName('footer')[0];}
        } : (site.whereami==='catalog')? {
          top: function(){return document.getElementsByTagName('header')[0].nextSibling;},
          bottom: function(){return document.getElementsByTagName('footer')[0];}
        } : {};
        if (site.whereami==='thread' || site.whereami==='page') {
//          site.postform = document.getElementsByTagName('form')['post'].getElementsByTagName('tbody')[0];
          site.postform = document.getElementsByTagName('form')['post'];
          if (site.postform) {
//            site.postform_comment = document.getElementById('body');
            this.postform_prep();

//          var bar_bottom = document.getElementsByClassName('bottom')[0];
//////          site.root_body2 = bar_bottom.insertBefore(document.createElement('span'),bar_bottom.childNodes[1]); // working code.
////          site.root_body2 = document.getElementsByClassName('pages')[0];
////          site.root_body2.setAttribute('style','width:auto');
//////          site.root_body2 = document.getElementById('style-select');
          }
        }
//        pref.thread_reader.own_posts_tracker = true;
////////        setTimeout(function(){this.postprocess_board(this.boards_json)}.bind(this),0);
//        var ss = document.querySelector('link[href^="/stylesheets/"]');
        // http://stackoverflow.com/questions/2635814/javascript-capturing-load-event-on-link
        // But https://pie.gd/test/script-link-events/
        if (this.nickname==='lain') {
          styleSheet.add_to_watch(document.getElementById('stylesheet'));
          styleSheet.add_to_watch(document.getElementById('code_stylesheet'));
        }
//        var ss = document.getElementById('stylesheet'); // doesn't work because chrome and FF don't support onload event from link tag.
//        ss.addEventListener('load',styleSheet.styles_changed,false);
        return true;
//      } else return false;
    },
    styles: [['a.dotted', 'border-bottom:1px dashed;']],
//    catalog_threads_in_page : function(doc){return doc.getElementsByClassName('mix');},
    catalog_posts_in_thread : function(doc){return doc.getElementsByClassName('replyContainer');},
    max_page : function(){return 10;},
    all_boards: ['/popular/','/all/','/mega/','/random/', '/culture/','/psy/'],
    make_url4: function(dbt){
      return (site2['lain'].all_boards.indexOf(dbt[1])!=-1 && dbt[3]!=='catalog_html')? undefined : site2['vichan'].make_url4.call(this,dbt);
//      return (site2['lain'].all_boards.indexOf(dbt[1])!=-1 && dbt[3]!=='catalog_html')? undefined : this.__proto__.make_url4.call(this,dbt); // cause error from lainjp
    },

    catalog_native_prep: function(date,pn_filter,pn_tb,pn_hi){
//      var node_ref = document.getElementsByClassName('catalog_search')[0].nextSibling;  // FF doesn't work.
      var node_ref = (site.whereami==='catalog')? document.getElementsByClassName('threads')[0]
                                                : document.getElementsByName('postcontrols')[0];
      cnst.tb_prep_for_embed(pn_tb);
      if (site.whereami==='catalog') {
        var selector_native = document.getElementById('sort_by');
        if (selector_native.selectedIndex!=0) {
          selector_native.selectedIndex = 0;
          var evt = document.createEvent('UIEvents');
          evt.initUIEvent('change', false, true, window, 1);
          selector_native.dispatchEvent(evt);
        }
        selector_native.style.display = 'none';
        document.getElementById('image_size').addEventListener('change', site2['lain'].catalog_native_size_changed, false);
        var pn_tb_new = document.createElement('span'); // rip from div to span
        while (pn_tb.firstChild) pn_tb_new.appendChild(pn_tb.firstChild);
        pn_tb = pn_tb_new;
        var pn3 = pn_tb.removeChild(pn_tb.childNodes[3]);
        while (pn3.firstChild) pn_tb.appendChild(pn3.firstChild); // rip from div to span
//        pn_tb.appendChild(pn_tb.removeChild(pn_tb.childNodes[3]).firstChild);
        if (this.nickname==='lain') {
          document.getElementsByClassName('controls')[0].appendChild(pn_tb);
        } else {
          var threads0 = document.getElementsByClassName('threads')[0];
          threads0.parentNode.insertBefore(pn_tb,threads0);
        }
        node_ref.parentNode.insertBefore(pn_filter,node_ref);
      } else { // if (site.whereami==='page') {
        var pctrls = document.getElementsByName('postcontrols')[0];
//        for (var i=pctrls.childNodes.length-1;i>=0;i--) if (pctrls.childNodes[i].tagName==='HR') pctrls.removeChild(pctrls.childNodes[i]);
//        pctrls.parentNode.insertBefore(document.createElement('hr'),pctrls.nextSibling);
        if (this.nickname==='lain') {
          var blotter = document.getElementsByClassName('blotter')[0];
          var pn = document.createElement('div');
          pn.setAttribute('style','float:left');
          pn.appendChild(blotter.nextSibling.nextSibling);
          pn.appendChild(blotter.nextSibling.nextSibling);
          if (site.whereami==='page') pn.appendChild(document.createTextNode(' | '));
          blotter.parentNode.insertBefore(pn,blotter.nextSibling.nextSibling);
          pn.parentNode.insertBefore(pn_filter, pn.nextSibling);
          pn.parentNode.insertBefore(pn_tb, pn.nextSibling);
        } else {
          pctrls.parentNode.insertBefore(pn_filter,pctrls);
          pctrls.parentNode.insertBefore(pn_tb,pctrls);
        }
      }
//      node_ref.parentNode.insertBefore(pn_hi,node_ref);
//      if (site.whereami==='catalog') node_ref.previousElementSibling.appendChild(pn_tb);
//      if (site.whereami==='catalog') node_ref.previousSibling.appendChild(pn_tb);
//      else node_ref.parentNode.insertBefore(pn_tb,node_ref);
//      node_ref.parentNode.insertBefore(pn_filter,node_ref);
      var selector_catchan = pn_filter.getElementsByTagName('select')['catalog.indexing'];
      if (site.whereami==='catalog') selector_native.parentNode.insertBefore(selector_catchan,selector_native);
      else pn_tb.childNodes[3].insertBefore(selector_catchan,pn_tb.childNodes[3].firstChild);
//      pn_tb.childNodes[0].setAttribute('style',pn_tb.childNodes[0].getAttribute('style')+';display:none');
//      pn_tb.childNodes[1].setAttribute('style',pn_tb.childNodes[1].getAttribute('style')+';display:none');
////////      return site2['lain'].catalog_from_native(date,document,site.board,site.whereami+'_html');
    },
////    catalog_get_native_area: function(){
////      if (site.whereami==='catalog') return document.getElementById('Grid');
////      else {
////        var pc = document.getElementsByName('postcontrols')[0];
////        return pc.insertBefore(document.createElement('div'),pc.firstChild);
////      }
////    },

////////    catalog_from_native : function(date,doc,board,type) { // working code.
////////      return site2[this.nickname].wrap_to_parse.get(doc, this.nickname, board, type);
////////////      var parse_obj = {domain:this.nickname, board:board, parse_funcs:site2[this.nickname].parse_funcs[type], __proto__:site4.parse_funcs_on_demand};
////////////      var ths = {pn:doc, __proto__:parse_obj};
////////////      return ths.ths;
////////    },
//    catalog_get_native_area: function(){return document.getElementById('Grid');},
    catalog_native_size: (document.getElementById('image_size'))? document.getElementById('image_size').value : 'small',
    catalog_native_size_changed: function(){site2[site.nickname].catalog_native_size = this.value;},
    parse_funcs : { // lainchan
      'catalog_html' : {
        sticky: function(th){return false;}, // patch
        ths: function(doc){
          var ths = this.__proto__.ths(doc);
          if (site2['lain'].all_boards.indexOf(site.board)!=-1)
            for (var i=ths.length-1;i>=0;i--) ths[i].board = '/' + ths[i].pn.getAttribute('data-board') + '/';
          for (var i=0;i<ths.length;i++) ths[i].page = Math.floor(i/10) + '.' + i%10;
          return ths;
        },
      },
      'page_html':{
//        tn_as: function (th){
//          var as = [];
////          var files = th.pn.getElementsByClassName('op')[0].getElementsByClassName('file');
//          var files = th.pn.getElementsByClassName('files')[0].getElementsByClassName('file');
//          for (var i=0;i<files.length;i++) {
//            var as_tmp = files[i].getElementsByTagName('a');
//            if (as_tmp) for (var j=0;j<as_tmp.length;j++) if (as_tmp[j].getElementsByTagName('img')[0]) as[as.length] = as_tmp[j];
//          }
//          return as;
//        },
        ths: function(doc){
//          var ths = site2['vichan'].parse_funcs.page_html.ths(doc);
          var ths = this.__proto__.ths(doc);
          if (site2['lain'].all_boards.indexOf(site.board)!=-1) {
            for (var i=ths.length-1;i>=0;i--) {
              var key = site.nickname + '/' + ths[i].pn.getAttribute('data-board') + '/' + ths[i].no;
              if (cataLog.threads[key]) {ths.splice(i,1);continue;}
              ths[i].board = '/' + ths[i].pn.getAttribute('data-board') + '/';
            }
//            for (var i=0;i<ths.length;i++) {
////            for (var i=ths.length-1;i>=0;i--) {
//              var prev = ths[i].pn.previousSibling;
//              if (!prev || prev.tagName!=='H2') {ths.splice(i,ths.length-i);break;}
////              if (!prev || prev.tagName!=='H2') {ths.splice(i,1);continue;}
////              if (!prev || !prev.getElementsByTagName('a')[0]) {ths.splice(i,1);continue;}
//              ths[i].board = prev.getElementsByTagName('a')[0].textContent;
//              prev.classList.add(pref.script_prefix+'_hs');
////              prev.setAttribute('style','display:none');
////              ths[i].pn.insertBefore(prev,ths[i].pn.firstChild);
//            }
            if (ths.length===0) cataLog.show_catalog();
          }
          return ths;
        },
      },
      'catalog_json' : {
        time_unit: 1000,
      },
      'post_html' : {
        img2src: function(img){
          var src = img.parentNode.href;
          if (src.search(/.webm/)!=-1) src = src.replace(/.*player.php\?v=/,'').replace(/&t=.*/,'');
//              https://lainchan.org/player.php?v=/test/src/1449566174628.webm&t=1449422283293.webm&loop=1
          return src;
        }
      },

    },
    colorID: function(pn) {
      var id = pn.getElementsByClassName('poster_id')[0];
      if (id && id.style && !id.style.backgroundColor) {
        site2['vichan'].colorID(pn);
        var prev = id.previousSibling;
        id.textContent = 'ID: '+id.textContent;
        if (prev.textContent===' ID: ') prev.textContent = '';
      }
    },
    catalog_json2html3_thumbnail: function(obj, board) {
      return (obj.ext==='.jpg' || obj.ext==='.jpeg' || obj.ext==='.gif' || obj.ext==='.png' || obj.ext==='.pdf')? 'https://' + this.domain_url + board + 'thumb/' + obj.tim + '.png'
           : (obj.ext==='.epub')? 'https://' + this.domain_url + '/static/lain_epub.jpg' : '';
    },
////////    catalog_json2html3 : function(obj,board,thumb_url) {
////////      var th = document.createElement('div');
////////      th.setAttribute('class','mix');
////////      th.setAttribute('style','display: inline-block;');
//////////      if (obj.ext==='.gif' || obj.ext==='.png') obj.ext='.jpg';
////////      if (obj.ext==='.gif' || obj.ext==='.jpeg') obj.ext='.jpg';
////////      th.innerHTML = '<div class="thread grid-li grid-size-' + this.catalog_native_size + '">' +
////////                     '<a href="' + thumb_url + '">' +
////////                       '<img src="' + thumb_url +
////////                       '" id="img-' + obj.no +
////////                       '" data-subject="' + obj.sub +
////////                       '" data-name="' + obj.name +
////////                       '" data-muhdifference="" data-last-reply="" data-last-subject="" data-last-name="" data-last-difference=""' +
////////                       'class="' + board + ' thread-image" title="' + new Date(obj.last_modified*1000).toLocaleString() + ' '+obj.ext + '"></a>' +
////////                     '<div class="replies"><strong>R: ' + (obj.nof_posts-1) +' / I: ' + obj.nof_files +
//////////                     ((pref.catalog_footer_show_board_name)? ' '+board : '')
////////                     '</strong>' + 
////////                     ((obj.sub)? '<p class="intro"><span class="subject">' + obj.sub + '</span></p>' : '<br>') +
////////                     obj.com + '</div></div>';
////////      return th;
////////    },
    catalog_from_json3 : function(obj,board) {
      return site2[this.nickname].wrap_to_parse.get(obj, this.nickname, board, 'catalog_json');
////      var parse_obj = {domain:this.nickname, board:board, parse_funcs:this.parse_funcs['catalog_json'], __proto__:site4.parse_funcs_on_demand};
////      var ths = {obj:obj, __proto__:parse_obj};
////      return ths.ths;
    },
    favicon : {
      __proto__: site2['DEFAULT'].favicon,
      none: '/favicon.png',
      reply: 'png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAB3RJTUUH3wUcDCkWRBuw0wAAIABJREFUeNq8vXewZdl13vfb+8Sb08upX+ecZzABGASRAAkBAkGAGJCURMlVUsk0JZctV0muUpU4Fs2SXKLKLtM2y4ogZZkiAAJiFAGYCDMYzCBM6DDd09O5X84335P23v7j3Hf7dU/3YAYYale9evGec+5ee6/1rW99az9hjOG/5BBCSMACDKCMMUYIYcE+G65ZgEWpZBPZWSyKhD0fsImNJOOAEDFJEkMcI2VAsdgjikKk1GxamnFbs7SkALXj+hKQgNh53/ueS/S/lP3PGo44sOZCN4cTjWHiYSQ5FAphN7CyS2TkOvV6CJ+J4Aumfw9t3ubEir9oA/Tf2PYH/Qkwg58NH83QXJlA9WYw0TgqHkJSllAEshY4loUlQCrdnzxFgkRriA30gK7WdJCyhbDrCLGOtFeIxBK0631jwDPPwDPPmPsm+t7nSb+GajVPMz6J7hy30bNSMOxaFABHgNGGIFJsxZoFLPcNnOz3COpzqeGQ29f9YYb4kQywY1K5b2LZedP7/g5jjBZCSAqTFYKtXcThhMRMgd7lWcxIwdDs7l3HC7nceBJHKKUQGKQAYwzGwD32FAJhWdi2jRAyqjcb83fm597Qmi0MawoWVcKCwtrEcTewSitUJlfN4g+628/3zDOIZ5655/kKOM5h4visK3mPZ3Fw3749j6ITW27byoBGgLTYqjfmlte3LkQJL2ns58F/BdrrO9/zu2aA+yf0LYbZaZi+G/AhU8NJJon1QVuqU5bgQMa2pmZ3TR9xLFxbChxb0j11kB987p+8rWeqvHyZiS9/ndqffxfdCUiUQRkDWDTa7bWlpZVriWY1MdxRcE1r3sB1F5G5Otlanf/2r7XNr/6q7r+3Kpb1uFTqL2ccntg3M3m8mPPs5859/qH3/8CZn6cbxFy5dvuNIOF8ZKw/JON+nV5vub8beKtd8LYNcN/kp8uAD1mwKjkCXLqU9FfQfUY6YsOlAo6zD6Xe4wh9xhXsnpkaP1rKZ4ZsATKf4dnv/Pa76vqe/OivYC+toY1ACAvpuFy4ePHFKGE1NMzFSl7Hdi6TiCuU/S3qyobuB12pns454tTBvTP7l//h3+TWL/2Vt3W/p048zdJGvXFnafPFyDifB/dPoLN2v1f4kQywY1LTlX3kiM3iYpaeHiJUWVzXYAV1er0NINy2PIxmYWs3qMc9qR51LY4c3L/3vULHwndt3mplvZvjA6c/S73VIYhipHTIF4pcvfLGt2OYDxVXEmFdRXp5N+n+5Egl+9S+6bHRb75699meOvVZokihDSAMAvA9h2df+Y/33OeDZz7L4lqjd3tp/blQWf83qK8Dje25e5ARfqgB7pt8CQyDvQfMbomaBgpINJoNATeV614him4BGeCkLfmQZ/H+3VPjj2U9J6MfO/a23cu7Nc4c/DStXg9tNBiDJQSuZWE7DkGcrLi5UrPVDbwk7I5XM5Zz7vofD177+PGnSTT4GR/P8zEYgiAk6PVwJHz34hfuNfZ7f4k3Ll5f22iHX4u0/X/ywfd9j29+Uz9sJ7ylAXZAMwAPtzBL1HrSlbzfluydHB/d33rmvx5FCPR/98+udLrB7VDznUTa38CYUQf1Cd/ikf2zU4cKGZdvvfp5/kuPw7s/QaMTIi0bKQVaK7RKcC0oZlzyWZ9EGzYaHYIooZTPUinl0UYTRppqrcLM9ASjw1Vy2SwGaLa73J5b5NateeKgyytXvnSfO/oMr75+82ZH8a+0V/339DYXHwZPH2qA7cnvB9AMjnOCOP7LGYsPTYxUHrWF8V1HIqUEY0iShMRYzK1uvtaNOYcQwznfeSLnyPz0WI2XrvzBjzSBu37njxn++vdxVzaxm60B8EpKeRqPHOG1f/LLb/n6sdpPEiaGYiGHlDJ9Tq0QxlDMugyXszz3yn9k12//IRO/8R/ohjGtbo8gShiqVfngex/h0dNHqBTzCCHQCKIoZnVji3OvXeXlVy8i4pDvvnbvTji++2O8MbfyZyHWb6LUV3bA3XuC8gMNcK/bmfVg4bhE/XXf0h+fGC7tvrb05/f8fXZxle7ECAC14lO0Iw0Ysq5DIZtFSMNQOcdLl37/LSd69n/7DyhtUMqgjUmh5zbSFf3PZoBABxhYIpASLClJxmt8509/c4CQqp/4H+jGmlwmg+vYCCEwBjq9gFa7QzHncmvhP9/zLKcPfoq1epvRkWE+8N7TnDl+iEq5lF4/UQghyGRcNraa/PlzP+D5F1+iknV49pXfvQed6Sf/+q1WzL/Tuvy/Q307FtwDTd9kgDclTq57lCj5W77QP3tw99jUTv94/zi062PcWdlCIyjksuRzWbQytDodaiWfq7f/5J6/P/qPf4vSl79JEMVESoOQOK6N5/lkfY+M7+P5Hq7rYlsSKQUCgTYGpTRRHNELQnq9gF4vJAgC4jgCo/Fdm5zv0g0iljbbBJEi6/t4noOU6c6tN9ooFXNwZpjndkze9jh7+OcIlWHvnhmeeOQkB/ZO49g2qm8Ez3NZ3dji//3SV1hbXuKlS1+85/XH9nyMa/MrXwjI/Avi3svbCeFOA9hvjeX9KRlFf8WT+q/MfOpDU+e+8M9Tvzr7caIkAQSuY+HYFq1OwHy9jeu5lAsFstkMBuh0AixLUs5n+pP+f+H87lfoRQnCcRGlAtMT4wwNVRmqlKiUChTyOTIZD891sS0bKSVaK5RKkUhqBI1SiihJCMPUEK1Wh81Gg7WNBmvrm9TrDXrdEHSCNJooComTGK3TRRclipxnc+e//6sPnICXLn+RJ098lmtXb7K6tsUjp4/y5CPHKJfy9IKYOEmolkscPrCHjfV13nfys3z73O8NXp/3XRzJRJAkh2D8Aiwl9+dR9gNX/zPPwOc+57K4+H5b64/vnhiavfSFf87Yv/4ypV//NxRKeUZqZXIZn6XVTW7Nr7K22UQjKBazeK6HVpoojlEqwreh1ws4ffBnQdoUKjUOjY8wOlKlWi6Rz2fJ+B62bSGRqe/ThjCK0LYh63uUSwVcz0FpTRLru/7HpO5KaU2cJPR6Ac12l/XNJiur66ysrrO0ssri0hqNRhvLlhSyfroLhKBcyPLiL338oavwO+d/jzN/81dpf/scL3zvFdqdDk8+coLJ8WEEgkQpZibHyGazdBpb97zWqxSYmZo6fPn28rRmyerH04cbYGCdZ54RuO5+mUQ/OVTOnrh0+88ofO81yr/+b5mcGOXk4VlmxoYA+MZ3L7KwvEG5kCXRKWUQRimN0At6GJVQLmaxPZ9SucT05AT7dk9Tq5RSSBeGNFtt5uaXabQ6tDo9giAkUSl94zoOxXyW8ZEhdu+aYGykNvDjYPqxQCCEwLIkxUKOSqnArskxonCWjXqTWwtLvHHtDjdvzbO1tYUjoVzI3rNa32q8/Ln/qQ9nf5bvfv883W7IU4+fYs+uCRzbplTI4fs+zfq97vxbz/8Ojxz/+SpJUoKytc1HCSHEdiC2HwA5DUNDOdY3P5ixOTE8PpxdBMY+/Q/Yv3+GR0/uZ2q0htaay9fnmV9ep5z3WXjh37H/g3+HeruHSkKSJAGjKBTyzMxMcfjAbvbvnWZiZIggjHnp/Ou8fv026xt1ut0eYRSRJAqlU84H0U+2EUgBnuty5OAefuJ9Z9kzO4lBoJW6JzlXSqM0JEYjhEBIyVC1RKVSZN/sNLfuLPHyhde5eu0mnSB6x4js5Stf5skTn+X8xct0ej0+8sHHOLR3Fznfw3Fs9AMApdEaKXG1NmJACO4g/ew3rX4QtFrDjtSP7pudOnXu4u9zcv8nOTf3J3z6l/8pU2NDCCFZXt3k++evkUQR5658GYAL177M+87+AisrW/SMYGpyipPHDnFw7wyjIzWGqmXqjRbf+cEFnn3xFbrdXgoplQJjEFJgWVY6eYLUECY1RKvT5fIbNxiulZiZGsNzXSKtuTdPNBi9jfU0CLCExLEsKqUC2QMetWqR8dEhXjl3iWP7fob5z/8z6mcOv20jfOf87/Hek5/l1q07fO2bYFsWtT5CehCitKQEiKDxQLx/vwE0kCHhkGOxR40WxXaw+quf+PuMnzqA59gsrW3xyqWbrK3XKU+P3HPBsBuSyeU4MD3JyaMH2L9nhmq5iGNbOLbNwtIa33/1EiurGxRyWXzfTR9cpEynQNxd/UJgSYkUknAtotXp0ukF21s2hWri7rpJ2VJ2fG/QGHQftfiuy67JMQq5HBnf4/svX4Cn/0fq195ZjvL8ud/jyRNPMzc3zzee/wH7ds/Q6XRxLeteauL008xtNOYTLTdAKyGE+AyILwyomruc+D2wHhUe9ixqF7/9O6kVLcnYSJV8JkM3CLh+Z4k3bi5QyLq88Oy/upu2H/sMMRaHDu3jg+99lEdOHGakVkFKgVIKlSha7Q5b9Sa+56WB17KwLDmYaCEElpBYloUlJVprOr2ARClGhqrMTk9gWRZaax4Aod/00Yd9aK2JlUJrQ61S5LEzR3niPScpViqc3P+z79gdfef85yl4Dlev3uQbz7/E+sYWuYx7z9+0uwEr6xvXseybMJWQTv49idg9BjDGGDKZjJTMjvzMhw8NtpFjk8/62LbkztI6r1+fJ4kivrcj+3v82NN0Yjh0aD9PPXaag3tnyGR8lFbEcUKcKMDgeS7ZjI8l+9lU39WkHwbTT8RUogmDiFa7S6vdoVYr8+ipIxw9uBspBHrgft6Sx0IIgZSyH7gNcZKQKEWpkOPsiUM8duY4luvx+LGn37ERnnv1d8nYgrm5BRqNJmT9e37fjRSR5haK12A+vqfg8wADpL/Q2rEFQ87iKgCF778G/a3d7PR4/foCSysblKdHBy9874nP0ksMBw/u4QNPnmH/nmls26IXBCSJRgg5yF5r5SKT48P0wohur4fWeucCQGlNGMd0ugHdXoAQgsnxYd77nhM8cfYYQ9VyP0smpUHefi1jkIAliaYXRJSLBR45eZgjh/fTjhIe/+m/+46N8MKFz1MrZNBa091qDX7+vhOf4c7CysVI8TJEt/vu3fxwA4ShADyr3gSg9ehRlFJs1dtcujrH7fkVPEvywrP/GgB/fpVGL2Zm1xQffv97mJ0aI4kVYRj133AaUDGQKEOtWubY4X2USwXCMKbbDQjCkF4QEoQRQRgSRTFCQKlU4PDB3fz0h57gw089yvTkKEmi7vP177ia1yflDEEYUykXee97TlIbqhHdXvqRrnn+2h9QzGfZanb54CNpUnftztJ6N+ZFnMyL8JnuwwpZ9wdhA2hlCHfaxijNhat3aLZ76Djm3I6gtfepv83o1Djvf+I0u/oTFMXqHh8M6WqNkwTf9zh1dD/1RpPvv3qZzc0GJkk5H8uS+J5LuVRkanyEA3um2bt7itGhKq5jEycKbcwPdT1vzwgQJwmWJZkaH+HUsUM8/+IPePLE03zn/DtnbS9c+08c3fsz3F5c5/i+n+H1ZnBZW+6fUc5fYu0L5mF09IOoiNjAWtzqBYAPIKZHeP3ybVzXofjJD9zj9+NcjrMnj3Bk3yyJUkRxghDpyr//TWut0VpTLRX4wBNnmBgdZmFplW43wGDIZNKMd7haZWS4wlClSDaTAWMI4xilTerP3x2xAFIIVKKwbZtjh/Zy5dpNFufmf+Rrek+dZvOPvsVavbMRG/nHqOh5s7raTlUfD1ZK2PcxEYJSqaPb3Qt35hevnZz96WPnbv0Z63/9Y4R//39lpFLg1f/jHw5eUO+GvOfsIU4c3ottW3S6wWCLP2jIPqoxRjAyVGWoWqbT6dELQoxJA3Qu6+N7LkIIkiQhCEO0Tle99Q58/tsZUkq0MSSJYmy4yvTkGKvLK5Rfukz97OF3fL2XP/cMx/d+nHbYirHsG6ioLn7IdpVvoiIajRZKvNBLuLzebDcBKr/+bxiuFnl1R+HhsWNPU66UOXl0P7VKkV4QvsntPGzlGZNWlZJEkc34DNfKDA9VyOezgKDbC2m1u/SCqA8178LJ7Y93a2xfz3VspsdHKRQKHPhr/+hHvt6F639MwTVIlZzFK07fF3Pf0gDmriApuqWwvrjVCl4cH/pLtDoBI7XSfRAr4ciBvUyMDQMC1V+lDzKA2fFGd75xrfXAbcVxQhJvM556O9e65/l3GkDv+PrHNYpBY4xmqFamVCwQxPGPZdS9MxNjrq0/TNg5DfvdPgISD9oNDzIAQA/UN7sJf+plCpuOFHz7pf9wV3Fw4rN4mQyH9u8il/WJE/W2Jl9rjVIabczdYopI6QfHtvE9h4zvkcv45HMZshmfTMYnm/HwXRfXsbEtC9nnKQbX6ydlP6oRjAGlNYVchnw+i9I/3q567tX/SK2Q2etI9SGcpcPwzEPdgr0zCRPb1GJajtjCerXuea4q5iQ3d0ZppRmZGGJ8tIZlWURRnE7KjqGNwehUyialHGS80pL3ZagGpQ2J0ug4Xf3a3F0PabBMM2XLkti2hZBO3whgjEbptDaQfjZ9llS8rTxh8Cza4Lkuvu/96Bh3x5idHC3X27cejVXvFXjmSl8tIvou2LwVHZ3ePXNpRPbUARW2ve9fu1uyO/Er/xSEYHpihHw225+EFJ3cuwpFn04QSGkhAIUhimKiKCaM4hT7ByFBEBFGIVEcp4yo6sNN0kl0bAvXdfE8F99zyfgeGc/D8/q7wrawbAvLWOi+UbcR186M+IcpyaSUWJb9rhjg+Qtf5ODMR4/fWFg7G+M+C09eg2/q+7Nh+yHyExclHnVtzhYybnHnhXPPvgSux8ToELZtDdzJ9sRvv1lLWlhWP+CGEc12h61Gk816k3qjRavVodPp0usFRGFEHCeoJEH3XdTd60ksS2DbNrbj4HrpKs3nshQKOcqlItVKkUopTyGfw/c9HEeitUQlehBPdj7fg7cCGPr3NeJdCfDFnOd6DkfjxDyG+uad1LWnseBN9YB7R74ok/aTlYJ36PLX/+W9SYIy5PM+tUopXdXaDPy8lALbsrEsSRTHbG62WV3fYmVtk7W1TTY267SaLbrtHnEYksRJyun3iXRhdqSLYnsizHZZACPu1YO6vksmm6VYylOtlhgaqjA8XGOkWqZczJPxPcAiSRSJUgNh0/1GMP2fqUQRx/H2HX/s8f3L/4mDuz56/Nr82mOKzP8H21TufTFgx+rXzM56zC8fdOHk+Eht19LU6Jt8u+/7qUbGpDobKSS2nfr2OEnYqHdYWF7l5u1F5uaWWV/doNPuYJIEaQyOSN2KLyW2bWP1yTJJSlsIIfpzb/rlgLtIR2lDojVJkhA1QrqbTVYXQDgWmXyWWq3K5MQoM9NjTI2NUKkU8Fw3LZj0g/Y2tJVS9KlwgSUE3SCk2w0QvHswt+B7RVdyuCf1EZLxLVjq7YwF9n0aIS0KhSI6edK3mfBGqg/YqQLXcXEdZ1AStPqBtdXucmd+mfOvX+fqjds0NupYcYINZC2J67qp1txKA+o2/Sz63H569VRca7aLGdsxRexgTHf4+UQpYqWIlCKut1iot1mcW+LylQKTk2Ps3zvN3tkphmtlHNtJF5HSfaOm15SCvkqiRbPVwrXevYTP3jWOf3t+pBfGj5FtXDQd0+33K9zjggTQb2RwRy2RPHZg/55jL3z7cw90lrJfsRJS4NoOvSBgYWmNK9fvcPmNG7x+9TZhu0vVd6nksuQyHq7jpFWjvqzEGI0x3PX3fYKtF8d0wgjXsill/HvQsdmBXNIdZ+P3vYlWmjhO6IURrSBkc7FLY32Lxfklbtyc58C+WfbMTjJULeG6DnGSoiYwSCTGwPLaBs1mi5zvvWsGePGrv8Vjx54+8sqlG49E3e4fCiGW73o9gX1PLZhqARqHMzb7rEr+IWjBkKgU9zu2xWa9zRvXb3P56g1u3J7n+q0FVBCzq1ZmolxM+RZtSLQhVkl/lfcL6vT9ej9+GGPYaHfZ6vYYzmcpZz26UYLSCs+2cSxrkITpHRh+Gz3bjk3JcyiTI04Smt0eGwvLLC+ucvPmPEeO7OP4kX3MTI6Ry/gIAUpphBS0Ol3uLKzQ7fY4d+X331XKw7UFjsXuyFj7GBq6zsrKgB21t6GnMUYLrzghI/XYUCk/9sJz//ahWUsURYRRTLPd5Ts/OM+F197AtQzD5TwbuRz5nGCkkMP0y5lvgoIDt5JO/rYLaocha+0OnSimlPVohxFL9RaBShjO56jlsjhS9vX/g3rOIHKn0JNBebOcz1PKZekGEZtrWzz7re9x9dodnnjsBGeOH6RUyGM5NmC4PbfE4uIyst9M826O5179PcbL7xvutYJTutF4xRhzUwghjTHa3t7ZQiCwexOOxenJ8ZHhWw+1pqQXBJy7dJX1zTqLC8vsmaySy3q8cukmPlDJ+DiWJFb6Hu5e9LkF06/3bvNClhCEScJSo43AkHNtmr2IMFYkiaIXx6y2OjiWxVAu09f37UAw5q5q8a47S9UUQkqyGQ/HtmiHEfXlVb76tee5PbfMe99zguOH9tLp9Xjpwus0Gw2iz3zkL0QkPDM5Nr5x5daxKFAjwM2+yxd2H5lpqrUCm8le12X6+bfgw1+8+EWOH/gUX//2Dxgq5zm8e5Sx0Spv3FpidXmTqm3j2Vbfv6YB7i6CShGIFLK/Yg2WSBnJzU6XtXaHopcGynYQ0EOQsSySKGErism5DtVsBoQYtODEKiFSiozjDMRW27/UWtOLYywpybgONdfF6wVstbtcPHeJXrfLRr2JMYabt+bxLYtX/+f/5i/EAK1PfQjnf/l3u5XSU0KIl/oyRTFwQURM25IjEyNDM1fe4kL7/sW/p9MNyEnJ4b1jnDw4y+Ubi1y4dBNLafJFP8XU2vTpiXQ2gjhVJbt2ioIGnXJSsNUNWKg3MUrjijRIu1KQdV1KGZ8hIdjo9kiMJkoUrmNjSK8fKUUrCLGlxN+u/fapCIyhE0YDlJFxHPK+R8Z12Gi3uXXtFitrmxjLIul133Xfv3Nc+rVfYfw3f3ei1whmoVCG1gYg7cEM9Tq7bMGBYv6+0v59w/+t38evFHjyzCGOHpim0e7x2pXbNDeaTJTyqZKhr99UxiBMClXrvV6qGrYydzUzVup6mkFINuNzcGaUSsZPd48QVApZhqtFSsUCF28v8sbNRXpRhGvbA84kUZpuFJPzXHzHGWhrRN/NdaOYSCk8xyLrOilrKwXVfI5eHLO2tsFGL2C4VvwL71UYqpVHNtvLe0OpJ4nZ3A7CBrBR4bTjMj33G3//oRc4vu+TeBmPs8f3cWT/NI7jcP7KG8zNrZJ3bHKum/p8IwhVTJgoPNvCkK7EjOvg7MDYUgi22h0yOZ8Pnz3N40dmcW2LOFY4jk0h61MsZslVipS/e5H1rRb1tQal7N2y5LYBon4P6yDG9zsrw0TRiSLKsX9f/Jcp1PU9MIZuJ+D0oU/xyutf+gszgO/YWIJd6GQSuLjDAIWiTWtmcnz00Osfe+qBL370yM8RWhaH9k5z7MAMnudwa36N16/NoYKI0WJ+IIbCaFpBSKw1np0hiBOUNjiWhW1Zg9pBGMX0VMLpPbP8wkef5MDMaNrsoXTKfEqJ5dqIfI7puVVyWZ91tZUmaSKNIaFK6MVxKlPZAZa3A3yiNUGSxoltw6SxQ9GJYizLYqJcYqXZZmOjxamDP8urfaXfuz28SgEpGUMlY3BWwksq7Vp39KTtMG1LnAf7/f+HZi9i7+wExw7MUC7kaLZ6nL9ym8ZGk6LrkHGdPoMJYaJohxFaGxxpEcRJqqe3bO7mvLDV6VIs5nn0xH4OH5gmn8uQ8X0K+Sy5jI/tpH9va43blxnebdlIlQ1hoki2Wc+dGst+trxNYadFo7vsqDYp7G32InzHYaSQxxeSzc02Zw59+i/EAN9+4d8zOT520BZmjNHYxRgjARsdzNiC0Yel4Nnf+iIjQxWO7Z9hbKhCEMbMLW1w7cYCroFSxk/5tL4BOlFEpFO/KyQEcYIlBXb/+kIIEq1phRH7d0/w2LF9eLZNL4gIoogoTunqMIyJwggTxqh+rSDF/imEjbUmShLMTqVE/2ttDLFS5HM+tXIhzX7VDnq6v1BaQUisNDnPZbSQx0OwvtHgsR9BqPV2hmPJnNB6hNZiCSGQDA/bGDPlO85w1n/zBnj82NMYKTl5eJaJ0VRmuL7V4vK1ObqNDsU+J692KNW6UYQUgozjEClFO4oGRfV+vyadMMLL+pw5tpdDsxPoMMZsi7T6jlrKflFFShKdFl7S4GsGbkQDTr/1aMDri5TiiGJFrVJkcrSK7zupYmOHCDbRmkgpEqVR2lDIeIwWctjKsLRa532nfvFdN4DQClswQtwd5+xZWxLHNlqPzO7adezbF770JsjZDmN2z4yzf3YCz3Ho9AJuL65y9fo8Rcch6zn9mkBKFStjiJTCkRLHkrTDiFYQIZCpHFGmrqAdhOzZNcahPZNkMh5xkgwC886sOUWymiiKieMEQZoJK5O6Ht/3qJUKiP6k75TAREoxNlRmcqSS6opUcu/vE0WsEpTZPoQC8r7HaLGAiRULK5uc+Zu/+q4awLYEUlBDh+O89JIlqSeOJalh1JuWf+5ffolszufk4VmynouUgsX1Oleuz5N0Q8rZDLa0+0GVfn1AkyiN3V/t7SAkVgopGdRyY6VQEvZNj+JZFhsbTYSUO4sBb1Iu9IKAMEqQQtANI5rdAC0Fo8MVJoerg8rctsJaKUOsNVMjVcZqFSxLDmIAwpCYVKyb7BD5amMwiNQIhSxhL6D9599/d12QbeE5dhXFCGBJirIsoaz7q2N7PPH+v40ysGtyhMmRKkJApxdy7eYiC/Nr1HJZPMfp11LEwLUkOq1oSZkGugTI53zsvnTbmNR1KAytXsBWo0MYpdmqMHdh4o6iLVppWp2AMIxwHQtlDCvNNjGaSilHMedji5TeTqWQaYwxAqbHagyV84MJ3h5K31XZ6T4vnTbypvRF0fMYymRot3oc2fOJdw8JOTZTU5MHpDQyPKzMAAAgAElEQVRDqQFiarakIMy9JFRzYYVSIc/+mQlcxwYBNxZWuXFrCRElVLIZDGYQGLcJn8EqM6CMIZfz2T05jOfaaKNJtKIVRrieS62UZ7RWopD1U5piB+m8vZqlgChKqDd79IKYjGuTcR3CRJHpi7i2Wl16cZpwaZ2KAZTWuL7LzHiNYtZH9btpTJ+0UwYyGY9SPjegxMWAH0xr3NVshqLj0Gh0OH343UFGG5/4ILZjFbXWJUolS6LDimWRvb9UmmjNxGiVybEaxkC7F3Lhym221htUc1msHYhmJ18fK4XBECfp5+FqkQMz40hL0u6FbHV7dOKEY/um+eknjnPqwDQ53yVJ9L0qhf6ESCFp93psNlrEUYJrO0ggl/E5dmCGiZEKa/UmrSCg0evRCgKaQUA7ishmfUZrJTw31ZUOsuckzbRr1RIjtTJK9Q0gxaA8KfpK6qFcloyQrK03eer0jx+UL/363yOJIixJkUbDkiRJSYC7cyLPHPoU5VKeqbEaxZxPrBRXbiyyMLeKawSlbAZMv0F6R3ZpjCHuI4owSTBCMDZUYdf4EJHWLDXarLW65HI+H3//aU7s34VrWyRKD0qRO59jW7+5Xm+xsdXqnx0k2Gh3GRku85HHj3Pm4AyOFPi2jTGGbhyz1u5S74UUC9m0I7LvZrb7BGKVZtrDlSLVYn5Hs8e996ZfOi37HrY2zK9svSu7QKkECXmoZuR/9Ut/46NTk5NTO3U9nTBifLjKxHAVA6zXm5y/fBMTxgwXcrh2iigavR6tMERpnR6qhEldQaIIYwVCMjpUYd/MGNmMh1IpNTE5WuHoninyGZ84VgPy7J7d1K8VKgF3VjbZarRxhSSIY5pRxPvOHOTU/pl0IRgYLeYZLuYZKuTxLAvfdzi6b4pSpUiUGNCp/7UtiyhRZLMeY0NlCrn0rIjtJHLnLtzWuGYdm5LrEPVCTh381I8vh9QaIchCOyd37dr1WKVSGd4pfBVCMlwrUy0XaHcDrt1aYnO9Tt6xERhWGk0W6y0WGi1aYYhGI/uZaRAnhElCGCcYYLhS4MDuScaGy4MgNDM+TLVUQPcFWfIhuh0hIFKaG/NrdLsBSZKw3u6we3aMDz15AmnbvHZ9gdV6i14YEUUJcZQQRjHFvM8jh3dTzGVpdHq0u0FaWwhCNlsdCvkMUyMVPMfuo5+7G+B+CYslBTnXIW/bbGy1eOrMj+mK0uu7ZDM5mSvkp6//+i8Xt639xPv/NhnPpVrK47gW80vrvHblNkkvRCtNPQhoxhGBhFYco4xJGVDMAE+7rovGkJi0FWhycoR9sxMIWxIbw9RIFd9P/2abt7kfdkqZJm6dTsAbtxZZ22zQixW5Qo6//P4zHDu4i2YvYK3eAinoJAmNMGSj3SHWmunxIY7smcIGmu0OrX4+stnp0QxDJkerzIxWQetB9vwQ6RzKpDxWKeNhYsXGVvvHS8bSDxsTubYtrezKTz3Gnl8rpFBto0E241HMZ2g0O7z2xh1u31kmb9sEQCbnM1MrkgBXrs7jSQtbykGnesZ3GRqpsLJeJ9SKrO9RzOc4dWg3Xxl6hV4YM1It4br2jsM47tXoaG1wnJS0u3pniYvX51jaarJ7YoQPPXGcjz55kko2w6rZ4tCucXrBUdCGOE5odwMcx+LJ04cYHyqj4pSqnhyrYek0pmQqOc4c3k2tUiCMokFmfa9cMX2yuJ/XeJYkY9sUXYd2u8tjx5/muxc+/yNbQIAkxrKNMZG/uO4mffVzrBJKuSKuY3NncZ2rt5cQUlIZKlMbLjM9MczkWI2VjTpLc2u4QmIJQZCkjXj5rMfZI3t49ept2p0A2xI4wNnDuzl9eA+3FlcZqhRSgkzpQQJ1j/JBgCUtVupN/vz7F7mxuEZtqMSHnzrFz334MXZPDKPDmKFClp9+8iSPnthPN0nohTHtbo+s53Boaoyc59ALIk4dnCWb8VOI2u9DePL0IeaX1+kF0Q4eiR0QOP22FycopXBkqh0q+z6dZpt6o/Oj74ABHMPY7U577pFP/IPhcCpf3C4T5jIe2kCr08P3XU4c3cPeXWNMjtUYH6oQJ5q5xTV0kmB5HkLI1J8nimw+w9nDu4hVwrk35lBKg9HMTI/wkSeO89r1BSqlQiqG6p+Asg05tzvYtttT5xbXOPf6bcZrJT763lN8+sOPs296FJWkteJyPstQrUwsJT2lCJVCa40nJTkpkSqtnj12Yj9nj+/vM6kGS1oUCxluzq8QhHFaOxbi3hy8b4wgSQ2Qc9MikGdb5F2bThDx2LGn+e7Fd74LBuVsG20vLiy9XK/XHy34SXE7W3QdGylgenwoZRMrRQq5DK5tk/Fc2p0mm1stjNL9rpW7IikD7J4YIZfJ9Pt9JYkAxxiOzE7gWhZRHLO8usVouYBtS1S/8W47QElLDpr1zhyYZe9PjvLEyQNMDpfRKiHp09u2bRHFCUubDe6sbVFvdzHGUMr4TFRLTFSLZH23L7RKG8C3hde2EOkxObHqtz3dp4cTabN9rHQqn9xR+C94Hr1uj61m90dtSMAYEqSI7K9+9Wtfb62tTJUzzG7rfqy+9nKoUmJsqM+jqJQQC8OYVjeg1elh94vgWutUim4MRoBj2zx1+hATQ2VyWY/bc8tcvjbPa9fmWNtsYLRmuFLm1OHdvOfYHkbLRaI46ftGAVKCDTMzE/zcxBgzI1VyvksYhkRKYdkOriOZX9vihfPXeOXSDeqbDcIghcRGWBQqBY4f3MVTJ/ezd2oYKSVRmN5DCkHGdwmjmChJ0kUk7pPL9EUEWqcIz5EWRqRw1XdsfMuiE4Q8/tG/x4v/+TffcRAQECKSjn3j9p2Fkh127yZTfZm2TIsYYRT1uRIGarhYJfT6hfC0z0rv4OqhF0ZMjtcYrua5cmOBP/nWq/zBt15meXWLqu9Sdi0uJZpLb9wmVIaPfOBRcpUyaNU/qkCSkZJdYw7CcTBRTBRFGOnhZgFp0Wg1+Nr3LvONFy6gujFO0MVKYiwMa+2Aly5e51svX+b6nSU+8+H3cGzvNK5rkyQq7bQ3JoWucZIW83lzM5E2aUKpE0U3ivDdVLouhcC3LXphQnj9nTf1CSnR0MWy2jZCNRJDqHdYZ2dHSyojEYMaqzEpNxOEUX8HpIGqFyfoQWNGutVvzK/y+W+c4+uXlrm13OQDB2b56IlDuGGX23cWeOHmPH/67DmKu/fykb90CCuKQKeyFTPQi4JwwQW0UgjHIbAkL5y/wZ88+wrjToZf/Nj7Wb99k/rGRkqjGMOllU3+7I3bfP6b52iGmr/1ccmZw7NopQd0RLeXGiDnuINVv/MMY6U1iTF0k4SNbo+y8cl5LkYYPMvClZJWN3hHk3/ml/4Rie2gDC1sO5AkcktrutsV1YFL2XHi7s6zF7Qx/YRH4VgWUaxYaXao98L0oZXCsSUbq+s8f/4mLy/2EJkix0bLnB0qsDvvUXVtdlWLPDo1RmdllZdeuUS3G2K5HtJ2ENJCyNQIZvuIYimRto3l2HQ6PV743nmsVodDRR/ZaWIZRcZz8FybQsbn4HCZx6fHGK6NcH6px1fPzXFrtY7ju9hS0gsj2r0Q1a/WiR3hsX+8Id0wZHSozIceP87JE/toxHGaeBqTHj4iJWEYceQf/9bbNkD2pUs4ro/SbNGyEgnWVqJpbLeLSQlhFO/Q9fSz1P7W01oTRUl/JRmWGy0W600ilXL1SqXtQq/fXOTSUpNMZYSiDjhRyzPiSG7NL3L+ziJr3YDpWpmS0SzfnmNpeQW1rZbTCmE00hgkqbTF6FTDmWjD8sIyCzduMeJIhjzJzVu3uTC3zHO3Frm8VqcdRmQdh8MjFXYVs4yMTbHQtXj+9UXiTAk7m6XbC2i2Oqg+kBA7zqwQ/QjcDSJ2jQ/xyY++l89++ic4dnQPvUTRDWNcW6YyyURT/PI337YBgihmbW3jJsh1sJUEp6s0W8Jy2Pcbv41jWXSDMK0+DZjJgZ43TbhUQpIkNLsBbZWAnRa+LSEw2rDR7nFttUVbOYxWCuS6W4z7DraQnL+zyFdev8n55XW0EJRch7DVYWV9i2T7QAlzt+474IiMAcsi1Ial1U2iVoe8beFIwXqzxcvzy3z1jdu8urBGvRdiWZKS75KLOuyfGiVfG+HKYoO1EEy5QtsIGq0upt/8jbgLh7d3QKw14yMVTh3ezfvfc5QPP3EC1/foRXEqFujXMLpB+LYNEMYJm1ubcyCWYT2RYCdayvWtenNx9HN/iO85dHsRQRTvSJDMIDnRJm2O6AYh9TBiZLzGxHgNx7YGO+bWRpuNxMbLFfBMRNnE5GwLLQSrnR5X1jZZbLaJtcaWacEljJO0KUP0G2OEuPuxwzkoDL0wTieu38CXGMNGL2C906PeC+jFMaIvArCjgJJrMTI8hJEu1+dW6GUqtO0czV6EMHd3+qAfmbSwhBSMVksMZzxqrsOxPZOUSvn0aE2dUjCWkATh229rjRJNrFnHdhc4ckRJxr0EIeYWlpavBVFExnfpBSHtbpCynNtdJDswQhhFdMKQbCnLsUOzTI1UMcoMCui31hqE0qdcqWKiiJwtB4G8mvXZUysxXshhy1RaaLkOuUwG2b+NeHDiAkZjCUE2lwPLThs5jMFzbHaVixweqbGrUiDr2oOj7m0MJokZrtWo1Ua4cXuRduLS0B7NIMKWO/uR7x6VnyiFn0kZ06JrI6OIYtYn47uYvu5USoEt066g8suX314KICw0LGGbeS5dSiRLSzFSXo00S9tKNp0kNJrtQalwZwptjCGIYpCSg/um2TczRsZz+weapqr/1c0mWC7DIyPYdloz3sb4M6UCP7l/F49Oj5OxJR1lyBSLjI/UsNF9ZYR4cDupUvhSMDY6ilMq04oV3TAi77ocHR3iQ3umODM5Si2bTdumpNVnOg1Dw0MMjYywvlmn1+kwt7zJ6kaLrOOki4y7LbXGGIJtRcVIFd/3iBNNGCUkO+X2pIdLKaU59nf/2Q+d/KdO/BxBGG0qwxyl0gZgJJDgebcixfV2N6zHcYJnSZrtLq1uMKh8bd9UKY1AMD5S5fiBGfJZnzhK7lK4UhKHEba0GB8bpzY2zmYvohtEWEIwUshyenKEfUMV2t2AwHYZmZlhaHgIqXXKTj7goA8hBEalSdHw2AhT+/fTEBbzm5t4lmSimOPY+BB7h8rU8lkKvofRmmac4BeKjI+Nki8W6AYBd268waWLF1heXQdpDXZdX7RBL0qodyOGKyWGKkXsfgl0ebNBq9NF7qgVyL5Cz7R/eFbc7QVsNRpXtbbusLISAiLN0dvtOliXVjcarzXbHXIZhzBKz2jbyVcaY9BKUy3lOXFg1+D0xChOBrp/z3fJZlwEhpGRYQ4fO0HD9ri91aAbBGQcm7zrkCQxl5bXcUfGOXbqBNlcBqMeTg0PfqYUpYLPk+97Emt0gtdWt6h3utgSip5LznUo+h6uFKw2W3Qcn/HZWUaHh1O1dC/gW996jjvXX8WyOnSVIojSBDBVXCSst7u04gDHs1MxmW3R7IW8dmOBTruHbUmEFAOXtU3c/bDRCWNixTVs99a2hnj7n9soXP98rHl5YWW9blsSaXR6/qfW3D1MK/XzU6M1jh/chee56VFkJu001xjyuRzVahmtFbZlcfzkSfY++jh3lOTc4go31jZ4bX6ZF24vMm/lOPLE45w5fRRLJ4N+owd2KfYNY7TC1zGPP3qCMx/8S3QqY7y8sMrN1Q3Wmy2anS4bjSaXF5a5sNlm+uRZjp08hTCGer2O1nDx8g18Z4tHT2WoDgs2Oj16YUKzF7PZ65EpKfbtc4hUh26QSixvLq3z4rmr6FiRcex7GFxb9jVPbzEe/6lfZn2zsRYpLuLJmzvbVM0zz8Aznxu+Gt8KvrPW6HygG0TljO+BNiTKYFs2iUrQ2uD2OSLLSreuUunxkNoYEmPIF/OMDg+hVMLa2jqnTp3ks7/0N/hdBDde/QFrW920JdQvcPIjP8FPfewnmR4pIVp1BBIh3zqFRytMGDBUKvLJT34MbSTf+E9fpLVZZzNSFH2XVhQz11PI2QN88hd+kWNHj/Lyy6+yMHeHXRMjOBJ00GD3hODQPsmX/niLxWaMtA1jk5LTJ3IUcpKr1xVRolla3uAb373Ipat3KFoWvmMP+qO1AduSmPvOi3tTHfj2Eq0wmdNYl+nc/c8a2waQxtwMRD5/Keh1Xrx09Wbt1KG9k0E3pBcmjA5V6XRaqCS5R7Ww87PSBq2hUi6xZ3aSpfUOa2urSCk5e/o01UqVixfOc/vGDYS02HPwECdPHGKyoLG66cHi4od1hxqTblpjoLXBbG2YX/z5T7P/wAG+9+1nWb55g+WwR26szNkjx3jyAx/gxPHjWJbFlddfZ2V5gY/9/E9x7fYS//Z3ztFudfjkRybYaii++Kcr7B7P8POfGKZWEXzru21mx6ZxLJs/+MYP+NLXvoutFLm8N/A5WutUnec4bP7EYw997Pc99leZ32y2E8OruNZNEyVaICxAbfcHbJ9pfF1j/VEjUKe22sHk8uoa+UKBkeERiuUqnXaLMOhhtMECLNsenN+ptUEbKJWKHD28n/z8Kj0NWivyuTyHDx1kfGKCjc0thBAMVbIURBfRXcckCUJaOwCnfHAVw5hB44VJEqzeJtPFKqX3n2Xv3r2sra0TRSHZXJbJiQlmpiZxLIvzFy6wuTrHiSN7mD14kEs3FphbbHLtWp3xsQLve6TE8lpAN9DMLwfcmhfMLWQ5vjfLHz37Ei+++jqdeouRfKZfqzBYMqVlEjSu6/DKr/3Kw5OvepuVreaiUnyTYu62iO52udk7u/WNMR0hci9FJvjqlZtzZUuYA6VikeWVKnv2zmLZNu2mRRgGoDVaK4w2fXbPoISgWi0xPjVOdahKvREhoybGASMkpYxFabIGKoKwgWmvg4pT7kcY3tY/aBJ94a5lYeIA1VohnylxYraG2TsOwkJsy9h1gIoidGeVowfG2bd3mjAyvPD9S6i4ietZXLzSZXLY46efGuLbLzX402+t0e1Jsu4QOrrJ/NIqza02w/kMnm0P1HXaGCKl0YDvOg/3/R/5OzSCJA4SLuC6r5rNzcY9jdo7j6kRQgj27dtkcfEPu2H30PJmY6K8uJzPZH0q1QrDIzVsx6HdbBGHPYxO0qwxUfSURlmSkaEqGd9jtFZmtNjF6a2gkxZIpz8pCagIoQKE0f3Jv79k/Va1PO4GactKjzPo1DGdBkLaYLkYYfdJPBA6Zs9ohj3Tx0k0PPfciyzOXeLwPsnUSI21zYQ/+dYav/CxcfbP+nz3vGZuIWCsVKezuYVvCUaLWVzLSuFmXyURKU0vSbBsi/DsoYc+cu/qHe4srV0xUn6NKFrYPvCX/hly9zVqI7l2LaFavaLC8A9WNlujGW/tqUI+S+HGTfyMT6VcgoIk8X2SOMDeaNCLIrpJgvRchocq+JbEURqJhl4D0WsNXBVCYPqAW0h7RwH87f6LMvHmuJAkoPp9AtsldtEHeQIKnoP0Mrx84Qp/9pU/ZbK6zq6JIr1AcPVml6u3u8xOZjl9JM/pw0VWFxvkpMS3Zb+rRw5q1YJUrRGGEYFS5Io+L//2rz3E9/8idzq9TqB4Fcf5BmFYv/8csO0uSbPTFbG52SGb/fMgCIbnljfKGc857roupWLa6JDL5rAsC8/3cf1NsrksxUKWaqVILpfBMgYThhCGiH7L0l09hkBYNtgOCM3dyPtOjojp9xvrdPKFitMETvdlLgNvdpfFRUS0turcnlsg67YJui6bm5LmpoWrfF74fovRmsPosEu17OAoScZ1B3WBnf0NcaJoBhGJgGI+89CnXFtYY3WrfV4J9yuE4fyOlcbO42rud76pMbrdVfD+qEdYvDG3nPMcZ08um6FQKOBN+dj9wzryuSLHD+/H91wc12Wj0aSrFJ4UmDhBWHKAGtIVahBKYYQcuJAfDn8ejoqMUkildkgLxUB18P/3dmbLcV3XGf7OfPr06QlAYyImkqAocJBIkZREMVHZUmRbkWK5XOWKnRdw7vIAuWFSlSfIXa6cRFFKqoqjkktD5KgsUrLMQRwBkBgJNEDMU49nHnJxGiAJUwo1eVf1dddZa+211/7X2v8fN4f+I8dFlBXMQo5svo3xkQViz0GKDXQ5RVfGYHWjzqXrNRQtRpEFiLa7g80yM45x/QAviKi5LnXfx8jojH1B9D/z+GvcXt+a9yLOE4mf0GTM2g1vydxTNt0RnxR28sKRUiTdfLvu+53jd+ZfUWSp1zRNUoZBe3sRYshmM5x48hC9Xe2MT5cYvjXFE8cOU+jtQJDFJoq63XMVdiYTdsD3h0R+HN8/py7sUA/sjhEhUfAhDh+Y6nmA6gYhubUKRopsR5FcoYNaRcZAoCWXQpUFZEnA8jRGx2oIUoQhaMnzKpLSOooiHD/ADgM8BDYcF0kWyZsG0w+hvn/2B3/L0kbFtjwuRpL8WyJngYdobd6fgqL7hWXuE+MM8BkPZfnNuh+0jt2ZVzRd6zSazFSmaWKmU+iaQiGXwXI9hsdnuXb9Ft0tWQqmQdSw72X4bcIlQSSWxAcjf/fDAFF4kGn5IXzFgiCAJBPFCVAn3A+fCwKCJCLICrGs4Aki1WqDWqWBIcsUDY2cqSTT3HGMpgrU1xKsqbWQTFKEYYTrJ68pAyFGN1OkVAU5CDBUmen/+Kc/Mn7/v75DY2qela36zSDmNxjGNarVbaWJhzLnBl+kc9jcDS5BcMWXtNe3LFe8OjJxSlGUPlVVGRo6iGGk8P0QVVUZ3NvL9Owin3xyidZCjudPH8Mw0+C4zYHUxOix2Ew/uy51OyRZYqJUmtx2YoRoN+1YcxM1HQAJDB43+71IIqIkIUgifgzrdZvZyVnOnbvAxO0JDFVCURVsP2hKFcQ0XD8ZwtVUNEmi4frJsFkUE6sSLcU8XZ0tlGsOrudjqiIzDyF3LfzjvzB5d2XMCflvdP081WqZL5EylB9BeFgAXDPlXqjbUlhzQ+vC1ZE/U2Rlr6ZpHBjch6KqCSaezXD65BE+PHeJ9z74mEw2zbGjj2MaMnEYJodxnFQpO3kaHiD6i+KkWe6GMZKioMsSmiAkbcldgwM7Ix6yAs0XtqIQEwkCDgINx2Hp7jKXr43y0fmLXP78JpWNMoPF1kQTLIqQRIEgiKg20VpJFKg6LnU/IFIk8m1Z9g90M7i3mzAIOX9xFE2CqYdE//HBV5m6uzzT8MUPUI13cOr/78iE/Chn3cAAom2DHISjDvzKClg+f+Hay14QHhEFOHjwAKKUvJTs6+ni9InDXL4xxr+9/jbWT37ImWePk85kwHWJvaSbtY2eCvenF1HA80JGxu8wWVoklzUZ7Oth754ODE1NnNjsS+8AdKKYnDWKQixJ+H5AeWOL29MlPr9xi6uf32R6fJr11XXqDTuhSJPEHfiZ5vhh3XF2FJlSpk5Xdys9e9rp6y7S19VG3XY5d3GESrlKa0anfOLQAzZ6Yu/LTC6szdV93kfR/x2vPr1NyMGXqKk+igPi2Vk8oAwtDjgueIFP4P/+8k0nCKOTDcvh+LGj6HrC8zB0YB9+EDJ8e5r/+vX7zN1d5NTxIxzo30M6YyI2UU38AMKouTuSxjtxjCrJaKIIno/vuERBCGpibCQJQZZAlprgXIRr2SyublJaXGF+bpHpyRlGx6aYmpyhuraBFCQ9DkHXCIWkOxfHMWKT8bfueii6SkshQ19nG+3tBbo7CnS0FSgWspSrFldHphmbLJE3VD4dvidccejv/xlef5c7S+tTls8HyKk3eGJomCtXwm0mmm+kJ9y8Njez7lngLRlKLdA4AHwvJfOX+3qK/a/+6IWuY0cPkc3lkKVEeG1iZo4Ln49gux6HHtvPiSeH6NvXT76thZyZIqdrqLLCPQKgpEry/ACnORggyzJmOoUsy0mEhhENz6PiuFQbFlalRnV9g4XFZeZKCywsLLG4uMJUaYH5xTVyqkqbaeBFEWXbRVUUBloLyYsawPY8lmoNOnrbOTo0wEB3O7l0Cl1LLolb1QZ/uD7OlZuT6BIM37mnJPjc4Z+yVbfjmcW1204kvouk/ye+NbyN9d+b7/pmDhB2VUZCc+d0AXkk6bBM+AtTYehnr708eObZE3Q0tb6CIKRcrTExPc/U7F0sx6WlJU9/Xw/7+rrZ29NJe0cr6VwWSVOJmp0vRVUSoG9b+8Xz8V0fr9GgtllmaXWDu8trLK+uU9ksEzoWpiJQMHVyhkYYxgxP3+W9z26yVq6RT2koqozj+eiI9Bfy6IpMEEVsNWxqhPzohZMM7e9FFCTiOEKWRBqOx4Xr41wbmUKMQ0buM/6x/a8wt7xZrbn+qB+Lb6CY/4NbLZE8DOVhJefXcsAXrc5OIb2ygkgmo1Gzn5LF4Ie6wjMv/PlzZ04dG+LI0CC5bBY/CKlU66xtlFnf3GKzUsOyHHw/oGE5IAoUCjkKLXlkRUZTVQxDR9c14jim3rDY2KxSqdRxbQcpCsjoMm1Zg2IujaHIeJ6bEMPWLGq2hxPG2H5I1fYQZZFiPgNxxOTMAvPTd+nOZsikdOq2w6Zto7dm+KsXT9HVViCKEhbIjXKdS8NTjE2VkOOI65OJaMWpx37MWrnGerk2bfmciyTpPVT1Is88s8zHH2+nnYcqp36rDmiKEiSMxHSloHIQrOdViaeyOsWf/+ynLx4+uF/t7+3GMFKEYUi11mB9q0K5UqVas5hfWOHG7UnmFlbpbm/h+yeHyKYNbs8uMrO4jhcEWHbSxuxoybF/TzsHB7ro6cgjRVHi2EqdiuXihhCSlKWKpmOaBrlsIleVzxg0LJvfX7rJp+cu02mmKZgGq+Uq9TDk8PHHefHMMbKmQaVSZ3l1g5GJEndKS0SBiyGL+L5HpeFQsbz1rbp1xY/4NBL182RSN/i7rRpnH0AUHsn4j1wFffmYO2JCRixyR/sAAAURSURBVHpoFGZXPMG7umkHT/zqzV/PdBbSe/7mr3/+2kDfHtpac5jpFGY6RdBZxPV8Bnq7MAwdz7uG7zi0plROP7mfrUqZ335aIgwjDvZ1cPRADycO7+eJwT4KGYONWp2Z+VVmVsqsVC1iSSKbzdHekqeQz5Ix0xi6hqombCuqKqOoGplMJrkvRAmO5AYBRjbD0UMH6ejowHddNst1hm/fYWTsDr7nktYVrFDGCQR3frV80w24FkrS/5KRr1BxlthyHM4+AGbF8VeI6m/igF1Pnm75wDIBmxHGdN1z50orjVfffPvD0lNPHup/bH8fA71dtLXkSWkqmqqQNvRE+zGfYXhknI2ahZlNc/LoIKOTc4gx/OLlMzx5ZJBiWw7f8RibmOPS+CyrFRtVT9HZs4dCIUc+Y5I2UgkmJcs7fEEJzSVomkYul0VVtSaRR0AQg2noZIwUq6sbLC4uc2tsismpErZloWkqqKlocmbuou0zGoriZRTpJn5qgkq1vAtH+0qG317S2UTb8KumH2HXdktQmRMnRJaWIvBd4tgWRMJapSrMzEx7SErP2maZet1uEnPEKLJMIZ+ls9iKosjML29gux6dhSxD/V08ffQAr/zFM3T3dnJ3eYOPL47w2Y0pVmoumZYW9vb3MjjQQ09XkUIug6YqO3x1UVPTcJvIT1UUqrUGtyemwQ+QBKh5Ab4AEhFjE9MMj04wv7hOKMhYjjOxsVX+bHWz8qEdiR/HUvojUson7Ns3w9rdxs43fwPjf+0zYBfT+v09xPg+hyimSTYj8DgxP/BCThc7u0+1tbVme7s76O/roqu9SGshT0shSxAEXBuZ4NbtSY72d/Dy955m/2MDyJLAtevjfHDuc8bnVsm1FjgyNMhAb0K+ys4YfROA4552QRgmhBye6xGGEeN3Srzz/jnEho2pyKzaLg1iuooFHNezZ2dLY2HEchgzH0bMRkjjqNIYnrZKl2nxy186nD37tXL9d+GAR/rjk92CsVmnN4bngoiXvJijHXt6j6iaRrGtjZ6uDvp7u+jd046qKly+dovlpVVe+v6z/PgnLzE5foc33nyXxeUNHjswwJFDg7Tms0iSSBSGiTJeECZT2UEi8Oz5Po7j0bAsKtUaG5sVKtUaK+ubzC2uk1NUNFFg0/a4PXd3mDi6AZSQpBKCcIcgWEHPNVAzFaqnK3H8Vrhr13+jqP9WqqCvsv5BEMS30rTHOkdcnzNezPO6mT+up9IFRdVIm2naiy3093WhKCqj47Nk8zmee/Y4c6UFRoaH5wf7OxpPDe2rZrM5A9U8Uq7UaFgWVlPS3LIdLMuhYdlYjoNju9i2TaPewLJsfN9zFpeWrgYh44SsxqC5EXlflJcR5Y+QlDnU7AYnDlTi3/0uuD/Q7mvXxd+W4f+kDtj+mBMgO0X6w4CnIzjqBvS4Iflcodi2sra2JkjUNJklN0R1fXRZxBVF3D15caWnwHoUIK3VyUlaNpdtLbY7XqDOzM7UowgliBDiZlMsSl5SCeK9Qd9IFqlKApOixIjrsVF1UT1obzZKbgCNPy4s7qXV+DsylMyfaDU/wBcEYaZYZDnvcUEXGTB0is8/f+rxD37z3nAYYTs+diDgezFCHBJ3pqiLURSNLJO2XTJ+gLan28x2t/WvZ+JImJiaKcUhjqRSFwUqcUBDFXEVkcAVCUWBKAtYIpFdxi8cwr91awckmyIRq/Ob59j2JSpq/oi/4wj9P7/IIgF0b7ZzAAAAAElFTkSuQmCC',
      reply_to_me: 'png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAABmJLR0QAAAD/AMzVCQEJAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAB3RJTUUH3wUcDC4pvTwLKQAAIABJREFUeNq8vWeQZcd15/nLvPb5euV9V3vv0AAbAAnQSKQIkSIpUgQpaobSRszErlYzE7H6MLMRilhhR6s1MZrYjdBuKFYzo6UsRSNSokSKIpckLOHYDaC70QZtq8v7ev66zNwP99Xr6kY3CKCbeyMq6pV59+bLk3nM//zPSWGM4f/PSwghAQswgDLGGCGEBTtsuGQBFqWSTWRnsSgStnzAJjaSjANCxCRJDHGMlAHFYosoCpFSs2pphmzN3JwC1Kb7S0ACYvNzbxmXaL+U7e8a9jmw5EIzhxMNYuI+JDkUCmFXsLJzZOQy6+shfDaCr5n2M7R5mxMrftYCaH+wjS/aE2A6v+vbn6G6MIxqjWOiIVTci6RLQhHIWuBYFpYAqXR78hQJEq0hNtACmlrTQMoawl5HiGWkvUAk5qC+3hYGPPEEPPGEuWWibx5P+hq6u/NU48PoxkEbPSEFfa5FAXAEGG0IIsVarJnBct/Ayb5EsD6VCg65cd+fJoh3JYBNk8otE8vmh97yfxhjtBBCUhgpE6xtIQ6HJWYU9BbPYlwKeie2bjlYyOWGkjhCKYXAIAUYYzAGbpKnEAjLwrZthJDRerUyfX166g2tWcOwpGBWJcworFUcdwWrtEB5ZNHM/qS5Mb4nnkA88cRN4yvgOHuJ42Ou5D2exe4dO7Y9gE5suSErAxoB0mJtvTI1v7x2Oko4obGfA/8VqC9v/sz3TAC3TuhbXGazYNpqwIdMD04yQqx321IdsQS7MrY1OrFlbJ9j4dpS4NiS5pHd/ORL//5tjal88hzD3/whPT94Ed0ISJRBGQNYVOr1pbm5hUuJZjExXFdwSWvewHVnkbl1sj3r/Jt/Vje/+7u6/dm6sawHpVK/mHF4aMf4yMFizrOfee2rd3z+++/7PM0g5sKlyTeChFORsb5Fxv0hrdZ8ezfwVrvgbQvglslPlwEftGBRsg84ezZpr6BbhLTPhrMFHGcHSr3HEfo+V7B1fHRofymf6bUFyHyGp3/8p/dU9T382G9hzy2hjUAIC+m4nD5z5oUoYTE0TMVKXsZ2zpGIC3T5a6wrG5ofcKV6POeII7u3j++c/3e/wbUv/tLbet4jhx5nbmW9cn1u9YXIOF8F99vQWLpVK7wrAWya1HRl79tnMzubpaV7CVUW1zVYwTqt1goQbkgeBrKwthXUg55UD7gW+3bv3P5eoWPhuzZvtbLu5fX+o59jvdYgiGKkdMgXily88MazMUyHiguJsC4ivbybNH++v5x9ZMfY4MCTr94Y2yNHPkcUKbQBhEEAvufw9Ct/fdNzPnDf55hdqrQm55afCZX1f4P6IVDZmLvbCeGnCuCWyZdAH9jbwGyVqDGggESjWRFwVbnuBaLoGpABDtuSD3oWj24dHTqe9ZyMPn7gbauXe3Xdt/sz1FottNFgDJYQuJaF7TgEcbLg5krVWjPwkrA51J2xnNcu/0PnvQ8efJxEg5/x8TwfgyEIQoJWC0fCi2e+drOw3/tF3jhzeWmlHn4/0vb/xQfe9xJPPqnvtBPeUgCbXDMAD7cwQVR72JU8aku2jwwN7Hzj+vzAXXlJnPiZTv7erZ+g0giRlo2UAq0VWiW4FhQzLvmsT6INK5UGQZRQymcpl/JoowkjTXdPmfGxYQb6usllsxigWm8yOTXLtWvTxEGTVy584xZ19FlePX/1akPxn7TX/ee0Vmfv5J7aP23y2wY0g+McIqr9Ysbig8P95QdsYXxXxj/z1bvlz/6Bvh++jLuwil2tdcSWlPJU7t/H6//+N9/y/WvVJmFiKBY8pJQYA0ZCpA2RsbAchx+/8tds+dNvMf4Hf0kzjJlbXieIEnp7utm3ZycPHN1HuZhHCIFGEEUx27aM8Fq5i5OvnuH4/s/y4us3dsIzp77Gwa0f2/rG1MKjYVR5DZjb8BKFEGKzEOyfpnaE2OqDc0DG6td8i48P95W2Xpr9/s9koif+j79EaYNSBm1M6nq2JzwWECM6/pWoNslNLXL8m08iEUgJlpQkQz38+Dt/2PGQchkXEWsc28J1bITvYgw0WgGLa6ldAJj89U8w+eufAODo7k8TxXUc28a2BQKDkBJLSkyi8F2H3dtG6S0XwRiee+EEjx79VZ5+5cudzzP9N3+A//A/3xPH6n5N149hvXIbl/3NKuhNgZPr7idK/oUv9C/v3jo4ulk/pnc6dlcT/96DOwiimEhpEBLHtfE8n6zvkfF9PN/DdV1sSyKlQCDQxqCUJoojWkFIqxXQaoUEQUAcR2A0vmuT812aQcTcap0gUmR9H89zkFIipWS9UkepmN3jfTyzafI2rmN7f4VQGbZvG+eh+w+za/sYjm2jEoUQAs9zWVxZ46++8U8szc9x4uzXb3r/gW0f49L0wtcCMv+RuHVyIyDcHBvYb+3L+6Myin7Jk/qXxj/9wdHXvvYfUr068XGiJEllNL14d5Gy6zE2PERvbze95RLlUoFCPkcm4+G5LrZlI6VEa4VSqSeSCkGjlCJKEsIwFUSt1mC1UmFppcLS8irr6xVazRB0gjSaKAqJkxit00UXJYqcZ3P9v/u1247txLmv8/Chz3Hp4lUWl9a4/+h+Hr7/AF2lPK0gJk4SurtK7N21jZXlZd53+HM8+9pXOu/P+y6OZDhIkj0wdBrmklvjKPu2q/+JJ+BLX3KZnX3U1vrjW4d7J85+7T8w+J+/Sen3/wuFUp7+ni5yGf+uVc9HPvRe8vksGd/Dti0kMtV92hBGEdo2ZH2PrlIB13NQWpPE+kYMblJ1pbQmThJarYBqvcnyapWFxWUWFpeZW1hkdm6JSqWOZUsKWT/dBULQVcjywhc/fsfx/fjUV7jvN36X+rOv8fxLr1BvNHj4/kOMDPUhECRKMT4ySDabpVFZu+m9XrnA+Ojo3nOT82OaOattT8VbGWHRxkwErrtTJtHP93ZlD52d/C6Fl16n6/f/hJHhAQ7vnWB8sPee6P5s1qdaqzM1PU+l1qDWaBEEIYlK4RvXcSjmswz197J1yzCD/T0IIUg1pyH9OAIhBJYlKRZylEsFtowMEoUTrKxXuTYzxxuXrnP12jRra2s4EroK2ZtW61tdJ7/0P7bd2V/mxZdP0WyGPPLgEbZtGcaxbUqFHL7vU12/WZ0/9dyfcf/Bz3eTJCXosjbwqM2G2L6Ny2no7c2xvPqBjM2hvqG+7Cww+Jl/y86d4zxweCejAz1orTl3efquBfDlb36fZrNFGEUkiULpFPNBmA2/ASnAc1327d7Gz73vGNsmRjAItFI32TWlNEpDYjRCCISU9HaXKJeL7JgY49r1OU6ePs/FS1dpBNE7HuvJC9/k4UOf49SZczRaLT7ygePs2b6FnO/hODb6Nh690RopcbU2ogMIbgL95JtWPwhqtT5H6gd2TIweee3M33B456e4OPVt9u8eZ3SwFyEt5pfXefnUpbsWwMpqhVqjRRQlGMCyLBzHxnUcHMfBsS0saVFrNDn3xhVOnbtEkihsKVMwTghStDn9TEZvqCRFohXGpHBquVRg364JPvz+9/Doex/AzxU4sOOTdJ08947G++NTX6E773Ht2nW+/+SLXLo2DSL1wG4XU1lSAkRQuW3AdasADOCTsMex2KYGimLDWP3aJ36bob4ynmOzslbhlbNXWVpev2sB+J5LLuOTy2XIZTPkMj7ZjEvGc8lmPAr5LKViHomg1mjSaAUbWzZ11YRAiBso6U0/G9DGECcKpTS+67JlZJCHjh3k4eNH6e7pYfTx//4dj/m5175C0beZmprmR8/9hFfPXqTRaOJa1s3QxNHHWVlZm060XAGUEEJ8djPkfYsAOmoZFe71LHrOPPtnqRQtyWB/N/lMhmYQcPn6HG9cnaGQde9aALZlYVmpjy2FTHW5kFiWhSUlWmsarYBEKfp7u5kYG8ayLLTW3MaFftNX2+1Da02sFFobespFjt+3n4fec5hiuczhnb/8jsf941NfpeA5XLx4lR89d4LllTVymZvno94MWFheuYxlX4XRBBBfuwUdvUkAxhhDJpORkon+T354T2cbOTb5rI9tS67PLXP+8jRJFPHS61+7Bxkb0ujUtDH/diCmEk0YRNTqTWr1Bj09XTxwZB/7d29FCoHWmlscitsFlAghkFK2DbchThISpSgVchw7tIfj9x3Ecj0ePPD4Ox76M69+mYwtmJqaoVKpQvZmr7AZKSLNNRSvw3TMLav/VgGkf9DasQW9zmzq3xdefh0MCAHVRovzl2eYW1iha2zgnnhBWuvNCwClNWEc02gGNFsBQghGhvp473sO8dCxA/R2d7WjZJBSvpNcRicASxJNK4joKha4//Be9u3dST1KePCj/+odj//501+lp5BBa01zrdb5/fsOfZbrMwtnIsVJiCbbCLH56QIIQwF41noVgNoD+1FKsbZe5+zFKSanF/AsyfNP/+d7IoBmMyAIQ1pBSBBGBGFIFMUIAaVSgb27t/LRDz7Ehx95gLGRAZJEtTNj7zpF2gblDEEYU+4q8t73HKant4docu5d3fPUpb+jmM+yVm3ygfvToO7S9bnlZswLOJkX4LPNOyWy7NsYYa0M4WbZGKU5ffE61XoLHce8dunv7hkGlCiFSUzbA5L4nktXqcjoUD+7to2xfesoA73duI5NnCi0MT9V9bw9IUCcJFiWZHSonyMH9vDcCz/h4UOP8+NT7zxPcfrS37J/+yeZnF3m4I5Pcr4anNOW+1268mdZ+pq5Exx9OygiNrAU11oB4AOIsX7On5vEdR2Kn3r/Daz8wONw5vLdRcIfOE6zGWAwZDJpxNvX3U1/X5necpFsJgPGEMYxSptUn98bsgBSCFSisG2bA3u2c+HSVWan3n1s4z1ylNW/f4ql9cZKbOQ/oKLnzOJiPWV93J4pYd+CRAhKpYauN09fn569dHjiowdeu/Zdlv/5xwh/+3+nv1zg1f/z33XesN4M73oiHvvQw7SCEGMMnueSy/r4nosQgiRJCMIQrdNVb70Dnf92Likl2hiSRDHY183YyCCL8wt0nTjH+rG97zxQ+9ITHNz+cephLcayr6CidfFTtqt8k09SqdRQ4vlWwrnlar0KUP79/0Jfd5FXNyUejh94nK5y191DERmfvp4u+nrL5PNZQNBshdTqTVpB1HY1b7iTG1/36tq4n+vYjA0NUCgU2PXPfudd3+/05X+g4BqkSo7hFcdusblvKYCN/9QQXVNYX1+rBS8M9X6IWiOgv6d0i4uVsG/X9ntiA6I4IY4TkngD8dQbsdZN498sAL3p9d0KxaAxRtPb00WpWCCI7y7RtH18eNC19YcJG0dhp9v2gMTtdsPtBADQAvVkM+E7Xqaw6kjBsyf+8gbj4NDn8DIZ9uzccvdqQIgUfrBtfM8h43vkMj75XIZsxieT8clmPHzXxXVsbMtCijR40FqjlO4EZe9WCMaA0ppCLkM+n0Xpu/tMz7z61/QUMtsdqT6IM7cXnrijGrI3B2FiA1pM0xFrWK+ue56rijnJ1c1WWmn6h3sZGui5+0jYsVHakCiNjtPVr82N9ZAayzRStiyJbVsI6bSFAMZolE5zA+l300ZJxduKEzrRsjZ4rovve+/ex910TYwMdK3Xrz0Qq9Yr8MSFNltEtANC81ZwdPr0zNl+2VK7VFj3Xr70j51/OPRb/wsIwdhwP/ls9q4HeunaNEEQEUYhURyniKhqu5ukk+jYFq7r4nkuvueS8T0ynofntXeFbWHZFpax0Magdbo7NoK8zbDEW2SfkFJiWfY9EcBzp7/O7vHHDl6ZWToW4z4ND1+CJ/Wt0bB9uzww4KLEA67NsULGLW6+ce7pE+B6DA/0YtvWXQ/0ez94jiiMiOMElSRopTv6PR2XxLIEtm1jOw6ul67SfC5LoZCjq1Sku1ykXMpTyOfwfQ/HkWgtUYnu2JMb9xN3hkRoP9fcC0cXijnP9Rz2x4k5jnryeqraU1vwpnzAzVe+KJP6w+WCt+fcD//45iBBGfJ5n55y6Z7441fPX2EDSBdmU7goNibCbKQFMOJmPqjru2SyWYqlPN3dJXp7y/T19dDf3UVXMU/G9wCLJFFpwNc2ercKwbR/pxJFHMcbT7zr6+Vzf8vuLY8dvDS9dFyR+X9hA8q9xQZsWv2aiQmP6fndLhwe6u/ZMjd6M+ajjcH3/ZQjcw9WSrfnYbXBMskNKNm0043G3FiZKVZkSLQmSRKiSkhztcriDAjHIpPP0tPTzcjwAONjg4wO9lMuF/BcN02YtI32hmsrZQrQIQSWEDSDkGYzQHDv3NyC7xVdyd6W1PtIhtZgrrXZFtwUiBljtCgUiujkYd9m2Ovvvs1OFbiOi+s4cA8Gmsv4qY7u3D0l15qNZMaGvRKbENNNej5RilgpIqWI12vMrNeZnZrj3IUCIyOD7Nw+xvaJUfp6unBsJ11ESreFmt5TCtosiRrVWg3XuncBn71lCH9yur8VxsfJVs6Yhmm26xVuUkFtDpCQ4A5YIjm+a+e2A88/+6XbKku5kfSQd78DOvq+DbC14phGGOFaNqWMf5OQzSbPxbYlQtj47SFopYnjhFYYUQtCVmebVJbXmJ2e48rVaXbtmGDbxAi93SVc10mTNDoFKCUpYWt+aYVqtUbO9+6ZAF743h9x/MDj+145e+X+qNn8lhBi/obWE9g35YLpLkBlb8Zmh1XO38FbMCQq5cU498AIm7YjvqEOVupN1pot+vJZurIezShBaYVn2ziW1QnC9CYffsN7th2bkufQRY44Sag2W6zMzDM/u8jVq9Ps27eDg/t2MD4y2N55oJRGyDTbdn1mgWazxWsX/uaeQh6uLXAstkbG2kFv72UWFjro6EYyNbXKbjwsUcd7S/nB55/5kztGLVEUEUYx1XrzXmABHRXUCEOW6g0qQUikFfUwYmatwrXVdVabLRKtU/+/sxNS9dG2zalKSlKVJISgK59na38vo4U8zaU1nn7qJb7xrR/y4skzrFdrSCFwHRspYXJqjtnZeWS7mOZeXs+8+hWKOb9PGnWESqW/7QEJY4zplNIIgUC3hh2LoyND/X13lqakFQS8dvYi3/reM/dkgJYQRIlirlJHYMi5NtVWxMx6lShJaEUxi7UG1SDsTPZNHD9z43UnDmiTKoSUZDMeA6U8fb7H+vwi3/v+c3zzO09x8eoUnuuQKMWJ0+epViqEn/0IP4trfGRwyBYcIFD9G0MXQgi7vQs03T0FVpPtrsvYc2+Bh79w5usc3PVpfvjsT+jtyt+DyU8RydVGk6V6g6KXGsp6ENBCkLEskihhLYrJuQ7d2QwI0SnBiVVCpBQZx+mQrTb+qLWmFcdYUpJxHXpcF68VsFZvcua1s7SaTVbWqxhjuHptGt+yePV/+m9/JgKoffqDOP/b/7NVKT0qhDhBSlMUdif6jRizJfuG+3vHL7zFjXb8xz+n0QzIScne7YP3ABIWrDUDZtarGKVxRcr9dKUg67qUMj69QrDSbJEYTZQoXMfGYJBCEClFLQixpcTfyP22oQiMoRFGHS8j4zjkfY+M67BSr3Pt0jUWllYxlkXSat5z3b/5Ovt7v8XQH355uFUJJqDQBbUVQNobFplWY4st2FXMZ96S6uD/0d/glws8fN8e9u8au+uBhUlCNQjJZnx2jw9QzvipdyIE5UKWvu4ipWKBM5OzvHF1llYU4dp2BzNJlKYZxeQ8F99x2sFMGschBM0oJlIKz7HIug5KG4QUdOdztOKYpaUVVloBfT1FftZXb09X/2p9fnso9QgxqxtuqAFsVDjmuIxN/cFv3/EGB3d8Ci/jcezgDvbtHMNxnLse1Fq9QSbn8+FjR3lw3wSubRHHCsexKWR9isUsuXKRrhfPsLxWY32pQil7Iy25IYCoXcO64RnRrqwME0UjiuiK/Rt/a0McrmVT8j0whmYj4OieT/PK+W/8zATgOzaWYAs6GQHObBJAoWhTGx8ZGthz/mOP3PbND+z7FULLYs/2MQ7sGsfzHK5NL931oFoq4ei2CX71sYfZNT4AJkVGLUtiS4nl2oh8jrGpRXJZn2W1lgZpArQ2hCqhFccpTWWTc7tBQ0m0JkhSO7EhmNR2KBpRjGVZDHeVWKjWWVmpcWT3L/PqhW/+TATglQtIySAqGYRjEk4oG7Bw9IgNY7bEub3e/wuqrYh9u7ZwYNc4XYUcq5U6py5Msmd0kKK06CvmSXRawBbECfPVGo5lMVQssFivUwsiBgp5yrlMx51crFQpFvM8cGgne3eNkbEsVKI7k5QGSgJba1yRGuwbJRspNyhMFMkG6rkpqqTtDW1A2CA6qk0IgTZQD0NA0NWdob+QJ1mvsrpa5749n+Hk+XtvD559/s/ZPfHx3ZdnFgeTgdhl3jQlYKODcVswcKcQPPtHX6e/t8yBneMM9pYJwpipuRUuXZnBNVDK+CmeZlIBNKKISKd6V8hUIJYU2O37CyFItKYWRuzcOszxAzvwbJtWEBFEEVEcE0YxYRgThREmjFHtXEHqgqaTGGtNlCSYzUyJ9mttDLFS5HM+PV2FNPpVm+BpIExSAx4rTc5zGSjk8RAsr1Q4/i6IWm/nciyZE1r3U5stIQSSvj4bY0Z9x+nL+m/eAA8eeBwjJYf3TjA8UEZKwfJajXOXpmhWGhTbmLzaxFRrRhFSCDKOQ6QU9SjqJNXb9Zo0wggv63Pfge3smRhGhzFmg6TVVtRStpMqUpLoNPGSGl/TUSMacBz7RmKFNDjTxhDFip5ykZGBbnzfIYoTbqCOkGhNpBSJ0ihtKGQ8Bgo5bGWYW1znfUe+cM8FILTCFvQTN4c4dsyWxLGN1v0TW7YcePb0N97kctbDmK3jQ+ycGMZzHBqtgMnZRS5enqboOGQ9B91RrgJlDJFSOFLiWJJ6GFELIgQSS6ahq9KaehCybcsge7aNkMl4xEnSSVFuTqCkeWFNFMXEcYJAooxJG0Zoje979JQKaSS8CfPX7ckd7O1ipL+c8opUcvPfE0WsEpTZaEIBed9joFjAxIqZhVXu+43fvacCsC2BFPSgwyFOnLAk64ljSXow6k3LP/fH3yCb8zm8d4Ks5yKlYHZ5nQuXp0maIV3ZDLZMU4pik95OlMZur/Z6EBIrhZR0crmxUigJO8YG8CyLlZUqQsrNyYA3MRdaQUAYJUghaIYR1WaAloKBvjIjfd3t9OQGrCFQyhBrzWh/N4M9ZSxLtm1K6qMmJiXrJptIvtoYDCIVQiFL2Aqo/+Dle6uCbAvPsbtR9AOWpCi7JHTp9urYuB569F+iDGwZ6WekvxshoNEKuXR1lpnpJXpyWTzHaedSREe1JDrNaEmZGroEyOd87DZ125hUdSgMtVbAWqVBGKXRqjA33MTNgI9WmlojIAwjXMdCGcNCtU6MplzKUcz52CJlV0spOjbGCBgb7OlE7HrTzZW+wbLTbVw6LeRN4Yui59GbyVCvtdi37RP3zhNybEZHR3ZJaXpTAcT02JKCMDeDUNWZBUqFPDvHh3EdGwRcmVnkyrU5RJRQzmYwmI5h3MijdlaZAWUMuZzP1pE+PNdGG02iFbUwwvVcekp5BnpKFLI+2mz48aaz6tOEPERRwnq1RSuIybg2GdchTBSZNolrrdakFacBl9YG07YXru8yPtRDMeuj2tU0hhSiUAYyGY9SPteBxDc+hjEpA687m6HoOFQqDY7u/cw9EcDKJz6A7VhFrXWJUsmS6LBsWWRvTZUmWjM80M3IYA/GQL0VcvrCJGvLFbpzWaxNHs1maDlWCkNaFGEw9HUX2TU+hLQk9VbIWrNFI044sGOMjz50kCO7xsj5Lkmib2YptCdECkm91WK1UiOOElzbQbYTOQd2jTPcX2ZpvUotCKi0WtSCgGoQUI8islmfgZ4SnpvySjvRc5K6oz3dJfp7ulCqLQApOulJ0WZS9+ayZIRkabnKI0fv3iif/f1/TRJFWJIilYolSZKSAHfzRN6359N0lfKMDvZQzPnESnHhyiwzU4u4RlDKZsCQFkhvii6NMcRtjyJMEowQDPaW2TLUS6Q1c5U6S7UmuZzPxx89yqGdW3Bti0TpTipS3AQ3p8mf5fUaK2u1du8gwUq9SX9fFx958CD37R7HkQLftjHG0IxjlupN1lshxUI2rYhsq5mNOoFYpZF2X7lIdzG/qdjj5mcjUkZGl+9ha8P0wto92QVKJUjIQ3dG/ldf/PXHRkdGRjfj7I0wYqivm+G+bgywvF7l1LmrmDCmr5DDtVOPotJqUQtDlNZpUyVMqgoSRRgrEJKB3jI7xgfJZjyUUni2xchAmf3bRslnfOJYdcCzm3ZTO1eoBFxfWGWtUscVkiCOqUYR77tvN0d2jqcLwcBAMU9fMU9vIY9nWfi+w/4do5TKRaLEgE71r21ZRIkim/UY7O2ikEt7Rej2jtu8C2U745d1bEquQ9QKObL703efAtEaIchCPWdv2bLl+IVyuY9WdZP0JX09XXR3Fag3Ay5dm2N1eZ2CYyMwLFSq1IKQRhxzbeXtrYo7eXPNH/2njuF8M2kKIqW5Mr1EsxmQJAnL9QZbJwb54MOHkLbN65dnWFyvkS2JTketMIopdmW5f+9WirkslUaLejMgJy1aQchqrcHukR5G+8tMzS63vZ8bG+BWCoslBTnXIUgUK2s1HrnvCzxz8q/uKgkFuGQzOZkr5Mcu//5vFjek/dCj/5KM59JdyuO4FtNzy7x+YZKkFaKVZj0IqMYRgYRafC+adbyZ72/aXpQlJY1GwBvXZllardCKFblCjl989D4O7N5CtRWwtF4DKWgkCZUwZKXeINaasaFe9m0bxQaq9Qa1djyy2mhRDUNGBroZH+gGrTvR8x2ocyhjcCyLUsbDxIqVtfrdBWPpl42JXNuWVnbhF46z7fcKqau2UiGb8SjmM1SqDV5/4zqT1+fJ2zYBkMn5jPcUSYALF6fvwfS/+WetDY5jobTh4vU5zlyTWpIEAAAfZUlEQVSeYm6tytbhfj740EEee/gw5WyGRbPGni1DtIL9oA1xnFBvBjiOxcNH9zDU24WKU6h6ZLAHS6c2JVPOcd/erfSUC4RR1Imsb6YrpiOL23GNZ0kytk3RdajXmxw/+Dgvnv7qu5aAAEmMZRtjIn922U3a7OdYJZRyRVzH5vrsMhcn5xBSUu7toqevi7HhPkYGe1hYWWduaulebICbSLUbqsCSFgvrVX7w8hmuzC7R01viw48c4Vc+fJytw33oMKa3kOWjDx/mgUM7aSYJrTCm3myR9Rz2jA6S8xxaQcSR3RNkM37qorbrEB4+uofp+WVaQbQJR2KTC5z+2IoTlFI4MuUOdfk+jWqd9Urj3e+AjjuGseuN+tT9n/i3feFovkh79eUyHtpArdHC910O7d/G9i2DjAz2MNRbJk40U7NL6CS5JxmxDZdzo4Jtozx1anaJ185PMtRT4rH3HuEzH36QHWMDqESRJIqufJbeni5iKWkpRagUWms8KclJiVRp9uz4oZ0cO7izjaQaLGlRLGS4Or1AEMbtxL64OQZvCyNIUgHk3DQJ5NkWedemEUQcP/A4L5756rvd9QYbbc/OzJ1cX19/oOAnxY1o0XVspICxod4UTSwXKeQyuLZNxnOpN6qsrtUwd8vjBmxbotqFdxsGSlqyU6x3364Jtv/8AA8d3sVIXxdaJSRx0uYGWURxwtxqhetLa6zXmxhjKGV8hrtLDHcXyfpum2glQJhOEt8WIm2TE6t22dMtfDgBRqdMcK1UJ89sgILn0Wq2WKs272LXkyBFZH/ve9//YW1pYbQrw8QG78dqcy97yyUGe9s4ikoBsTCMqTUDao1W2i7gLq/lapOBriJRnLR1owApwYbx8WF+ZXiQ8f5ucr5LGIZESmHZDq4jmV5a4/lTl3jl7BXWVyuEQeoSG2FRKBc4uHsLjxzeyfbRPqSURGH6DCkEGd8ljGKiJEkZeOKmdFkbukgZ1hKBIy2MSN1V37HxLYtGEPLgY/+aF/7xD9+xERAQIpKGfWXy+kzJDps3gqk2TVumSYwwitpYCR02XKwSWu1E+F1zZl67zEfe/wC5chdolQ5NSDJSsmXQQTgOJoqJoggjPdwsIC0qtQrff+kcP3r+NKoZ4wRNrCTGwrBUDzhx5jJPnTzH5etzfPbD7+HA9jFc1yZJVFppbwytMCKKkzSZfxuHQJs0oNSJohlF+G5KXZdC4NsWrTAhfBcNS4SUaGhiWXUboSqJIdSbpHODf5lGiLINdW50r42ihCCM7okAvvP0axS3bucjH9qDFUWgDVLINlGpPSIXXEArhXAcAkvy/KkrfPvpVxhyMnzhY4+yPHmV9ZWVFEYxhrMLq3z3jUm++uRrVEPNv/i45L69E2ilO3BEs5UKIOe4nVW/uYex0prEGJpJwkqzRZfxyXkuRhg8y8KVklozeEef974v/g6J7aAMNWw7kCRyTWuaGxnVjTYAmzvubu69oI0hihLiSOFYd09NbCwscuKVszSbIZbrIW0HIS2ETIVgNloUS4m0bSzHptFo8fxLp7BqDfYUfWSjimUUGc/Bc20KGZ/dfV08ODZIX08/p+ZafO+1Ka4truP4LraUtMKIeitEtbN1YpN5bLc3pBmGDPR28cEHD3L40A4qcUwtDNHG4NgWjpSEYcS+/+GP3vbnzZ44i+P6KM0aNSuxwVpLNJWNcjEpIYzaNbmbOpBscOu11kRRWkghhGB3bw9ztTol36E742PnM/zP/+bzZFybb564zmTLpzk7yV5d5VBfF8JxWajU8KSg5LqUjGZ+coq5+QUK2yewhMCoBCFFSi3Z5KoKS5Jow/zMPDNXrtHvSHo9ydVrk0yuVpit1ujOZtjSVSDrOOztL7NW0yQDo8w0LZ47P8vIxARZFdJcXadaa6CUbtPjUyh6I5o2RtEMInZtGeRTj72XTMZDix9y/uxV7DCmlPVwpESFmuI3n4Sf0r1x4wqimKVq4yrIZbCVBKepNGvCctjxB3+KY1k0gzDNPnWQyQ6fN20NphKSJKHaDKirBOw08W0JgdGGlXqLS4s16sphoFwg11xjyHewheTU9Vn+6fxVTs0vo4Wg5DqEtQYLy2sk7dWOuZH37WBExoBlEWrD3OIqUa1B3rZwpGC5WuPk9Dzfe2OSV2eWWG+FWJak5LvkogY7RwfI9/RzYbbCUgimq0zdCCq1JqZd/I244Q5v7IBYa4b6yxzZu5VH37OfDz90CNf3aEUxApEmnQw0g7dfLx3GCatrq1Mg5mE5kWAnWsrltfXq7MCXvoXvOTRbEUEUbwqQTCc40SYtjmgGIethRP9QD8NDPTi21dkx11bqrCQ2Xq6AZyK6TEzOttBCsNhocWFpldlqnVhrbJkmXMI4SYsyRLswRmxi3W5SDgpDK4zTiWsX8CXGsNIKWG60WG8FtOIY0SYB2FFAybXo7+vFSJfLUwu0MmXqdo5qK0KYGzu9U49MmlhCCga6S/RlPHpchwPbRiiV8mlrTW3SwkEhCcK3D8lEiSbWLGO7M+zbpyRDXoIQUzNz85eCKCLju7SCkHozSFHOjSqSTT5CGEU0wpBsKcuBPROM9ndjlOkk0K8tVQilT1e5GxNF5GzZMeTdWZ9tPSWGCjlsmVILLdchl8kg248Rd4IrjMYSgmwuB5adFnIYg+fYbOkqsre/hy3lAlnX7qgSG4NJYvp6eujp6efK5Cz1xKWiPapBhC031yPfaJWfKIWfSRHTomsjo4hi1ifju5g271RKgS0FcZK87c5bRlhomMM205w9m0jm5mKkvBhp5sIkhYt1klCp1jupws0htDEmbXYqJbt3jLFjfJCM55Ikqq09BIurVbBc+vr7se00Z7zh44+XCvz8zi08MDZExpY0lCFTLDLU34ONbjMjboeMClAKXwoGBwZwSl3UYkUzjMi7LvsHevngtlHuGxmgJ5tFCoktrTbSaejt66W3v5/l1XVajQZT86ssrtTIOk66yNCdSkljDMEGo6K/G9/3iBNNGCUkidpEbUmbSymlOfCv/tefOvmPHPoVgjBaVYYpSqUV0ia+JHjetUhxud4M1+M4wbMk1XqTWjPoZL42HqqURiAY6u/m4K5x8lmfOEpuQLhSEocRtrQYGhyiZ3CI1VZEM4iwhKC/kOXoSD87esvUmwGB7dI/Pk5vXy9S6xSdvKXyZsMOGJUGRX2D/Yzu3ElFWEyvruJZkuFijgNDvWzv7aInn6XgexitqcYJfqHI0OAA+WKBZhBw/cobnD1zmvnFZZBWZ9e1SRu0ooT1ZkRfuURvuYjdToHOr1aoNZrITbkC2WbombdRK9FsBaxVKhe1tq6zsBAC7W539fo6WGcXVyqvV+sNchmHMIqoNZo3VQwaY9BK013Kc2jXlk73xChO2nYCPN8lm3ERGPr7+9h74BAV22NyrUIzCMg4NnnXIUlizs4v4/YPceDIIbK5TApt3AEa7vxOKUoFn4ff9zDWwDCvL66x3mhiSyh6LjnXoeh7uFKwWK3RcHyGJiYY6OtL2dKtgKeeeobrl1/Fsho0lSKI0gAwZVwkLNeb1OIAx7NTMpltUW2FvH5lhka9hW3JdnmW6RSIvJ1quUYYEysuYbvXNjjEG4fbKFz/VKw5ObOwvG5bEmk0YRR16qg2gDopJaMDPRzcvQXPc4mTFCcxOt3E+VyO7u4utFbYlsXBw4fZ/sCDXFeS12YXuLK0wuvT8zw/Ocu0lWPfQw9y39H9WDrp1BvdtkqxLRijFb6OefCBQ9z3gQ/RKA9ycmaRq4srLFdrVBtNVipVzs3Mc3q1ztjhYxw4fARhDOvr62gNZ85dwXfWeOBIhu4+wUqjRStMqLZiVlstMiXFjh0OkWrQDCK0NlydW+aF1y6iY0XGsW9CcG3Z5jy9xfXgL/wmy6uVpUhxBk92Gg/YgHniCXjiS30X42vBj5cqjfc3g6gr43ugDYky2JZNohK0NrhtjMiy0q2rVMrl1MaQGEO+mGegrxelEpaWljly5DCf++Kv82UEV179CUtrzbQk1C9w+CM/xy987OcZ6y8hausIZLok3iKERytMGNBbKvKpT30MbSQ/+tuvU1tdZzVSFH2XWhQz1VLIiV186le/wIH9+zl58lVmpq6zZbgfR4IOKmwdFuzZIfnGP6wxW42RtmFwRHL0UI5CTnLxsiJKNHPzK/zoxTOcvXidomXht9srmDaNxbYkJvvWXYTV5By1MJnSWOdo3DhZY0MA0pirgcjnzwatxgtnL17tObJn+0jQDGmFCQO93TQaNVSS3MRa2PxdaYPWUO4qsW1ihLnlBktLi0gpOXb0KN3lbs6cPsXklSsIabFt9x4OH9rDSEFjNdPG4uKnIRvGpJvWGKitMNHTxxc+/xl27trFS88+zfzVK8yHLXKDXRzbd4CH3/9+Dh08iGVZXDh/noX5GT72+V/g0uQcf/Jnr1GvNfjUR4ZZqyi+/p0Ftg5l+Pwn+ugpC556sc7E4BiOZfN3P/oJ3/j+i9hKkct7HZ2jtU7ZeY7D6s8dv+Ow33f815herdYTw6u41lUTJVogLEBt1Ads9DS+rLH+vhKoI2v1YGR+cYl8oUB/Xz/Frm4a9Rph0MJogwVYtt3p37lRl1UqFdm/dyf56UVaGrRW5HN59u7ZzdDwMCurawgh6C1nKYgmormMSRKEtDY5nPL2WQxjOoUXJkmwWquMFbspPXqM7du3s7S0TBSFZHNZRoaHGR8dwbEsTp0+zeriFIf2bWNi927OXplharbKpUvrDA0WeN/9JeaXApqBZno+4Nq0YGomy8HtWf7+6RO88Op5Gus1+vOZdq7CYMkUlknQuK7DK7/3W3cOvtbrLKxVZ5XiSYq5SRGJjndtb3K1hTGmIUTuRGSC7124OtVlCbOrVCwyv9DNtu0TWLZNvWoRhgFojdYKo00b3TMoIejuLjE0OkR3bzfrlQgZVTEOGCEpZSxKIz2gIggrmPoyqDjFfoThbR3Q1MYnpGVh4gBVWyCfKXFoogezfQiEhdigsesAFUXoxiL7dw2xY/sYYWR4/uWzqLiK61mcudBkpM/jo4/08uyJCt95aolmS5J1e9HRVabnFqmu1enLZ/Bsu8Ou08YQKY0GfPfOhSoPfuS/phIkcZBwGtd91ayuVm4q1N7cpkYIIdixY5XZ2W81w+ae+dXKcNfsfD6T9Sl3l+nr78F2HOrVGnHYwugkjRoTRUtplCXp7+0m43sM9HQxUGzitBbQSQ2k056UBFSEUAHC6Pbk35qyfqtcHjeMtGWl7Qwa65hGBSFtsFyMsNsgHggds20gw7axgyQannnmBWanzrJ3h2S0v4el1YRvP7XEr35siJ0TPi+e0kzNBAyW1mmsruFbgoFiFteyUnezzZKIlKaVJFi2RXhsz50LUC5e5/rc0gUj5feJopmNhr+0e8jdUqiN5NKlhO7uCyoM/25htTaQ8ZYeKeSzFK5cxc/4lLtKUJAkvk8SB9grFVpRRDNJkJ5LX28Z35I4SiPR0KogWrWOqkIITNvhFtLelAB/u0eUiTfbhSQB1a4T2Eixi7aTJ6DgOUgvw8nTF/juP32Hke5ltgwXaQWCi1ebXJxsMjGS5ei+PEf3FlmcrZCTEt+WOJaVGtlOMj1la4RhRKAUuaLPyT/9vTvo/i9wvdFqBIpXcZwfEYbrt/YB26iSNJtVEaurDbLZHwRB0Dc1v9KV8ZyDrutSKqaFDrlsDsuy8Hwf118lm8tSLGTpLhfJ5TJYxmDCEMIQYUya2+vwMQTCssF2QGhuWN530vbgRqNukgSh4jSA0+1mTR1tJjoJFEREbW2dyakZsm6doOmyuiqprlq4yuf5l2sM9DgM9Ll0dzk4SpJx3U5eYHN9Q5woqkFEIqCYz9xxlEszSyyu1U8p4f4TYTi9aaWxuV3Nrco3FUazuQje37cIi1em5nOe42zLZTMUCgW8UR+73awjnytycO9OfM/FcV1WKlWaSuFJgYkThCU7XkO6Qg1CKYyQHRXy092fO3tFRimkUpuohaLDOjBt0r8OQqTtkC+XKHb1cuHMDCYKsEwW384wVMiyuFLnpVdrOJ7BsQXojexg2800hjBOiBJNLQypxzHZgs/5O6z+43s+ybnltalI8zRaPkO7Y9at8FZaI3aDkGA2nfJg4MCktk79bT2OBy9cmfqYY1tj+XyeTDZLf38fGCgWCxw7vI+xoX4uXJ7k9NlLHDqyn/LYAMKWbRR1I+cqOsyETquS26x8Yzbz1Nu6XLx5jQiROkxG3cTquanVDSKNWkU2Q3Ggj1J5gFrFJougu5TBtQW2JWhGHq+fryEsTVZ4aXkVqWuttSaIE1oqIUKwEoRYtqQrn+XyfXtvY3j/G+ZWKq1mxIvasr+PDma4zVmbm1WQ3nywzKbDOBNiLijb/ko9TnrOX5lyPN8bzLY7U+XzefK5DL7nUC4VaIYRpy9c45VXzzLcXaScz6IbrRsafqPhkpAYS9688m8tDJDi5k7Lt+lXLIQAy0abFKgTm+FzIRCWRNgOxnaIhKRabVCrNMjaNn1Zj1LeSdncxuC5gvpSijX1lFMmhVKaME6rKRNh8PMZMq6DnSRkXZvLf/n7b5r8LX/6LRqXplhYq59KDH9PNvsK1erGSRO37Zyb3Omcw/ZuCEmSE7Hl/cVaM5Qnz7zxgOM4467rsnfvbrLZDHGscF2XHVvHuHxtlmeeeYmecolHHzpCNp+DIGwTUtNJN7Ktfm4J6jpNsmR6Umn7AACEvrXtWHsTtQUAKQxu2vleLIm0LIQliQ0s11tcu3iNp556gTfOvUHWtXBch1actA/qMDTCOCXhei6eZdEIY4IkIdYG41p093UxNNjNei0gjGLyruTqbZq7lv/9H3NxeuF8oPgmvv801eo6b3GUof02Dh4WQJjPhC/UW5aqhar5wskz73NsZ6vneezcsQ3HdVNMvFjgofsP8L2nXuI7332SQjHHkYN7yGdtjFKpMTapl9LR02xmxqWnIzVbEaEyWI6Db1t4QiDMZlhQ3PQeYTvQrrCVwqCFIEDQCALmpud5+ZXX+cHTL/LyT05RWVlnR19PeuaY1lhSkCSaahuttaSgGoTU4wTtWHT1Ftk+McyOrcOoRPH0i6/jWXDpNqv/6I6Pc2l6/mojlt/FzX6LoP5TKRP227F1ExPIVgvsRL0ewJeaCfNPv/DKY1GiDkgBu3fvRFpppeT46BAPHdvPy6+d58/+4m9pfuoXeO+DR8kVChCGmCjNZm2gp2KzepGCKFKcuXCFi5OzlIp5doyPsnVkgKznpkJskwY6AJ2Uqa1xHIxlEccJ6ytrnLs8yU9eO8vJn5zi8oXLLC8uU2+0sG0by5Id+Jk2/bAeBJ0TmTJ5n6HhHkZH+hkf7mN8qJd6K+SpF89QWa/SU/BZP7bvpjk6tPUxLs4sXa/H/COO/+dE9cu0G3LwFqepvh0BmGvXiIB16A4gCCFKYpL4uZdPBYnS9zeaAUePHMT30z4Pe3duI04Up89d5m++8Y9cn57lgaMH2LllhFwhj2yjmsQJKN3eHWlpEcbgWjaelBDFxEGIThS46WRjWQjbAttqg3OasNlidnGVydkFpq7PcvniVV4/f4lLF69SXVrBStIch/A9lEizc8YYJAKlDfUwwvFdussFxgd76e8vMzxQZqC3TF+5yHq1yckzlzl/cZKurMuzp28cXLHvd/4Q/uLbXJlbvtSM+S525q84tPc0J06oDR7DXZ0nLDafkMMTwFdtmOyGxk7gAxmbX9w22rfl4x/90NCRg/solkrYVnrw2htXr/PCT87QCiP27drOscN7Gd+2ha7ebkr5DCXfw7WdjW3QjnENUZwQtIkBtm2Tz2WwbTtdoUrTiCIqQUi10aRZqVFdXmFmdp7rkzPMzMwxO7vApckZpmaXKLkuvfkskdast0Jcx2Gip5xW1ACtKGKu1mBgrJ+DeyeYGO6nlMvge2mQuFZt8PyrFzhx6iK+Baev3DhJ8OH9n2at3jJXZ5fOBVp+G8v/MnHz9AbWf4PfdXcCELd4RqK9c4aALixrv4361bzD3s9+8rEd733wGAPts76SRLFerfHG5SkuXZvm/+vtzJbjqq4w/J359HS6W1JLak0tLHmQLTF4wIArrgAhCUVCUqlKheQFuMwrOG+SK6rgIpVKKoSQUNgJoRgCxpZsa7TUki21WupWnx7OPOSi28Y4SQUDZlWd61N7rbX3Xvtfe/+/5bj09eUoTYxxaGKER8aGGRzqJ5U1kDSVqNf5UlSlC/Td0X7xfHzXx+t0aNUb7FRr3KrsUanuY9YbhI5FWhHIp3WySY0wjJlfu8Wb719lr9Eil9BQVBnH89ERKeVz6IpMEEUcdGxahPzwudPMTI0jChJxHCFLIh3H44PPlri8sIoYhyzc4/zHp15is1Jvtlz/mh+Lr6Gk/4LbLNN9GMp/Kzm/UgD+lw0PC6ndXUQyGY2WfVIWgx/oCmef+84z5848PsPszDRZw8APQsxmm71ag/36AXWzhWU5+H5Ax3JAFMjns+T7csiKjKaqJJM6uq4RxzHtjkWt3sQ027i2gxQFZHSZASNJIZsiqch4nkuz3eGgZdGyPZwwxvZDmraHKIsUchmII1bWb7O1dosRI0MmodO2Heq2jd6f4cfPn6E4kCeKukIStUabj+ZXWVwtI8cRn610RSvOHHmZvUaL/UZrzfK5FEnSm6jqh5w9W+HixTvLzt0C+qEFoCdKIHQ3mmICzKNgnVclTho6hVd+/rPnTxydUkvjIySTCcIwpNnqsH9g0jCbNFsWW7d3uXJjhc3bVUYG+3j29AxGKsmNjW3Wt/fxggDL7rYxh/qyTI0OcnSyyNhQDimKuoE125iWixtCSLcsVTSddDpJ1kiR0DVymSQdy+afH13lvUsfM5xOkU8nqTaatMOQE08c4/lzj2Okk5hmm0q1xsJymZvlHaLAJSmL+L6H2XEwLW//oG194ke8F4n638kkrvDrgxYXvoAofCnnf+kq6P88bhG7ZKTHr8HGrid4n9bt4NHfvv679eF8avRXv3jlJ5MTowz0Z0mnEqRTCYLhAq7nMzleJJnU8bzL+I5Df0Ll6cemODAb/PW9MmEYcXRiiLnDY5w6McWj0xPkM0lqrTbrW1XWdxvsNi1iScIwsgz25cjnDDLpFEldQ1XlLs+pKqOoGplMpnteiLo4khsEJI0Mc8ePMjQ0hO+61Btt5m/cZGHxJr7nktIVrFDGCQR3q9q46gZcDiXpb2TkTzCdHQ4chwtfALPi+AGy+usE4L4nT9d9oEJAPSK51vbczfJu50ev//7t8snHjpeOTE0wOV5koC9HQlPRVIVUUu9qP+YyzC8sUWtZpI0Up+emubayiRjDL188x2Oz0xQGsviOx+LyJh8tbVA1bVQ9wfDYKPl8llwmTSqZ6GJSsnyXL6hLcwmappHNGqiq1iPyCAhiSCd1MskE1WqN7e0K1xdXWVktY1sWmqaCmohW1jc/tH2uhaL4MYp0FT+xjNls3IejPZDj75h0oatt+KDLj3DfdOuiMqdOiezsROC7xLEtiIQtsymsr695SMrYXr1Bu233iDliFFkmnzMYLvSjKDJblRq26zGcN5gpFXly7jAvfe8sI+PD3KrUuPjhAu9fWWW35ZLp6+OR0jjTk2OMFQvksxk0VelenYninn48d4n8VEWh2epwY3kN/ABJgJYX4AsgEbG4vMb8tWW2tvcJBRnLcZZrB433q3XzbTsSL8ZS6h0Syj84dGidvVudu2P+Gs7/ynvAfUzr9/YQ43sCoqTTGBmBY8R83wt5ujA8cmZgoN8YHxmiNFGkOFigP5+jL28QBAGXF5a5fmOFudIQL373SaaOTCJLApc/W+KtS/9iabNKtj/P7Mw0k+Nd8lXuXqPvAXC9blXc44n2wxDP9QjDiKWbZf7w50uIHZu0IlO1XTrEFAt5HNezNzbKi2FEJYzZCiM2IqQlVGkRT6tSTFu8+qrDhQtfaa1/GAH4Uj8+PSIk623GY3gmiHjBi5kbGh2fVTWNwsAAY8UhSuNFxkcHUVWFjy9fp7JT5YVnn+Lln77AytJNXnv9T2xXahw5PMns8Wn6cwaSJBKFYVcZr6cVGQZdgWfP93Ecj45lYTZb1OomZrPF7n6dze19soqKJgrUbY8bm7fmiaMrQBlJKiMINwmCXfRsBzVj0nzajOM3wvtm/dfK+m+kCnoQ+40giG+kGIx1Zl2fc17MeT2de0JPpPKKqpFKpxgs9FGaKKIoKteWNjByWZ556gk2y7dZmJ/fmi4NdU7OHGoaRjaJmp5tmC06loXVkzS3bAfLcuhYNpbj4Ngutm3TaXewLBvf95ztnZ1Pg5AlQqoxaG5EzhflCqL8DpKyiWrUOHXYjN99N7g30e5p18XflOO/1QDcGcwpkJ0CpTDgyQjm3IAxNySXzRcGdvf29gSJliaz44aoro8ui7iiiDuaE3fH8uxHAdJem6ykGVmjvzDoeIG6vrHejiKUIEKIe02xqPuSShA/v+gbySJNSWBFlFhwPWpNF9WDwV6j5ArQ+c/C4vNlNX5IjpL5lqw3AF8QhPVCgUrO4wNdZDKpUzh//syxt/745nwYYTs+diDgezFCHBIPJ2iLURQtVEjZLhk/QBsdSRsjA6X9TBwJy6vr5TjEkVTaooAZB3RUEVcRCVyRUBSIDMASiewGfv44/vXrd0GyVbpidX5vH7tziIp6H/FDztB/A168l/a1/nj6AAAAAElFTkSuQmCC'
    },
    proto : 'vichan'
  };
}
if (pref.features.domains['lainjp']) {
  site2['lainjp'] = { //lainchan.jp // ?.?.?
    nickname : 'lainjp',
    home : site.protocol + '//lainchan.jp/lainicon.ico',
    X_FRAME_OPTIONS: true,
    CONTENT_SECURITY_POLICY_DATAURI: true,
    CONTENT_SECURITY_POLICY_FRAME: true,
    protocol: 'https:',
    domain_url: 'lainchan.jp',
    postform_rules: null,
    features : {page: false, graph: true, setting2: false, postform:true},
    boards_json:site2['DEFAULT'].generate_boards_json([['cyb',2],['tech',2],['cult',2],['\u03bb',1],['\u03bc',1],['psy',1],['feels',1],['q',2],['r',1]],2),
    check_func: site2['lain'].check_func,
    components: {
      boardlist: '#overheader',
//      postform_comment: 'textarea[name="'+ pref.script_prefix + '_draft"]',
//      postform_submit: 'button[name="'+ pref.script_prefix + '_send"]',
      __proto__:site2['vichan'].components
    },
    parse_funcs: {
      catalog_html: {
        sticky: function(th){return th.pn.getElementsByTagName('strong')[0].textContent.search(/\(sticky\)/)!=-1},
        proto: 'lain.catalog_html'
      },
    },
    post_container: function(post_pn,no){return post_pn;},
    update_posts_remove: function(th_old,i,pnode,merge){
      var tgt = th_old.posts[i].pn;
      if (i==0 && tgt.classList.contains('op')) this.update_posts_insert_pack(tgt);
      else pnode.removeChild(tgt.nextSibling);
      pnode.removeChild(tgt);
    },
    catalog_json2html3_thumbnail: function(obj, board) {
      return (obj.ext==='.jpg' || obj.ext==='.jpeg' || obj.ext==='.gif' || obj.ext==='.png')? 'https://' + this.domain_url + board + 'thumb/' + obj.tim + '.png' :
             (obj.ext==='.pdf')? 'https://' + this.domain_url + '/static/pdf.png' : '';
    },
    favicon : {
      __proto__: site2['lain'].favicon,
      none: '/lainicon.ico',
    },
    proto: 'lain'
  };
}
if (window.location.href.search(/localhost/)!=-1) {
  pref.test_mode['94'] = true;
  pref.catalog.embed_page = false;
  pref.virtualBoard.scan_domains['dist'] = 'none';
}
if (pref.test_mode['94']) { // pref.features.domains['dist']) {
  site2['dist'] = { //distchan
    nickname: 'dist',
    domain_url: 'localhost',
    boards_json:site2['DEFAULT'].generate_boards_json([['a',1], ['undefined',1]],3),
    check_func: function(){ // must be owned.
      site2['DEFAULT'].check_func.call(this),
      site.postform = document.getElementsByClassName('postForm')[0];
    },
    make_url4 : function(dbt, trim_page){ // dbt[2] is string. // modified from 4chan.
      var url_prefix  = site.protocol + '//' + this.domain_url  + dbt[1];
      if (dbt[3]==='catalog_html' || (trim_page && dbt[2]==0 && dbt[3]==='page_json')) dbt[3] = 'catalog_json'; // catalog_html is a skelton.
      return (dbt[3]==='page_json')?       [url_prefix + (parseInt(dbt[2],10)+1) + '.json', 'json', (trim_page)? this.nickname+dbt[1]+'j0' : undefined] : // dbt[2] is string.
             (dbt[3]==='catalog_json')?    [url_prefix + 'catalog.json', 'json', this.nickname+dbt[1]+'j0'] :
             (dbt[3]==='thread_json')?     [url_prefix + dbt[2] + '.json', 'json'] :
             (dbt[3]==='page_html')?       [url_prefix + ((dbt[2]!=0)? (parseInt(dbt[2],10)+1) :''), 'html'] :
             (dbt[3]==='thread_html')?     [url_prefix + dbt[2], 'html'] : null;
    },
    parse_funcs: {
      other_html: {},
    },
    testPoster: (function(){
      var queue = [];
//      var post_func = DelayBuffer.prototype.delayed_do.bind(new DelayBuffer(function(){ // working code.
//        var area_com = document.getElementsByTagName('form')[0].getElementsByTagName('textarea')[0];
//        var button_submit = document.getElementsByTagName('form')[0].getElementsByTagName('input')[0];
//        var post = queue.shift();
//        if (post) {
////          console.log(post.com);
//          area_com.textContent = post.com;
////          button_submit.click();
//          setTimeout(submit,600);
//          if (queue.length>0) post_func();
//        }
//        function submit(){
//          button_submit.click();
//        }
//      }),1000);
      var pn_message = document.getElementsByClassName('message')[1];
      if (pn_message) {
        pn_message.innerHTML = '<div></div><div></div><div></div><div></div>';
        var pn_hist   = pn_fifo_factory(pn_message.childNodes[0]);
        var pn_makeThread = pn_fifo_factory(pn_message.childNodes[1]);
        var pn_prune  = pn_fifo_factory(pn_message.childNodes[2]);
        var pn_errors = pn_fifo_factory(pn_message.childNodes[3]);
      }
      var xhr_reqs = new Map();
      var xhr_frees = [];
      var a_update = document.getElementsByClassName('a_update')[0];
      var post_func = DelayBuffer.prototype.delayed_do.bind(new DelayBuffer(function(){
        var all_data = queue.shift();
        var op = all_data.op;
        var post = all_data.post;
        if (post) {
          if (post.no===op) post.new_thread = true; // patch for bug.
          var data = {type:'json', action:(post.new_thread)? 'makeThread' : (post.pruned)? 'prune' : 'post', board:post.board.slice(1,-1), thread:op, body:queue.length+': '+post.com, subject:post.sub, debug:op};
          if (post.com && post.com.indexOf(' is ')!=-1) data.tag = post.com.substr(post.com.indexOf(' is ')+4).split(/[\W]/)[0];
          var pn = document.createElement('div');
          var key = data.action+'/'+data.board+'/'+data.thread;
//          pn_messages.set(pn,key);
//          var xhr_events = xhr_events_factory(pn);
          var xhr = xhr_frees.shift() || new_xhr();
          xhr_reqs.set(xhr,{pn:pn, data:data});
          xhr.open('POST', '//localhost/post.php', true);
          xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
          xhr.send(EncodeHTMLForm(data));
          pn.textContent = timestamp()+': '+key+(data.tag? ' '+data.tag:'');
          var old = pn_hist(pn);
          if (old)
            if (old.textContent.indexOf('OK.')===-1) pn_errors(old);
            else if (old.textContent.indexOf('prune')!==-1) pn_prune(old);
            else if (old.textContent.indexOf('makeThread')!==-1) pn_makeThread(old);
        }
          function new_xhr(){
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load',  xhr_events, false);
            xhr.addEventListener('error', xhr_events, false);
            xhr.addEventListener('abort', xhr_events, false);
            xhr.responseType = 'json';
            return xhr;
          }
          
//          function xhr_events_factory(pn_in) {
//            var pn = pn_in;
//            return function(e) {
          function xhr_events(e) {
            var xhr = e.target;
            var myobj = xhr_reqs.get(xhr);
            var pn = myobj.pn;
            var data = myobj.data;
              var str = (xhr.status==200)? xhr.response && xhr.response.message : xhr.status;
              var str2 = pn.textContent;
              var str2_idx = str2.indexOf(': ')+2;
              str2 = [str2.slice(0,str2_idx), str2.slice(str2_idx)];
              if (str && str.indexOf('OK.')!=-1) {
                str2[1] = str2[1].replace(/(makeThread|post|prune)/,'');
                var str = str.split(' ');
                str[1] = str[1].slice(0,8);
                str[4] = str[4].slice(0,8);
                str[5] = 'op/sec,';
                str = str.join(' ');
              }
  //            if (str===null) str = 'null: '+data.action;
              pn.textContent = str2[0]+ timestamp() +': '+ str + str2[1];
//              pn_messages.delete(pn);
  //            if (xhr.status==200 && localStorage) localStorage['newPost'] = xhr.response.no;
              a_update.textContent = data.thread;
  //            a_update.click(undefined, op); // fail to pass;
              if (data.board===site.board.slice(1,-1) && data.action!=='prune') a_update.click();
              if (queue.length>0) post_func(pref.test_mode.num || 500);
            xhr_reqs.delete(xhr);
            xhr_frees.push(xhr);
//            }
          }
          function EncodeHTMLForm(data) {
            var data_out = [];
            var i=0;
            for(var key in data) data_out[i++] = encodeURIComponent(key) + '=' + encodeURIComponent(data[key]);
            return data_out.join('&').replace(/%20/g,'+');
          }
//        }
      },500));
      function timestamp(){
        var time = new Date();
        return time.toLocaleTimeString() + '.' + ('00' + time.getMilliseconds()).slice(-3);
      }
      function pn_fifo_factory(pn){
        var filled = false;
        return function(pn_add){
          pn.insertBefore(pn_add,pn.firstChild);
          if (filled) return pn.removeChild(pn.lastChild);
          else filled = pn.childNodes.length>=10;
          return null;
        };
      }
      return function entry_func(post, op){
        if (typeof(post)==='string') queue = queue.concat({post:{board:'/'+post.split('/')[1]+'/', pruned:true}, op:post.split('/')[2]});
        else if (post) queue = queue.concat({post:post, op:op});
        post_func(pref.test_mode.num || 500);
      }
    })(),
    features : {catalog: true},
    parse_funcs: {
      'catalog_json': {
        ths: function(obj, parse_obj) {
          var ths = [];
          var page_base = parseInt(parse_obj.page || 0, 10);
          for (var j=0;j<obj.length;j++) {
            var th = Object.create(obj[j]);
th.sub = obj[j].subject; // TEMPORAL
            th.board = '/' + obj[j].board +'/';
            th.page = (page_base + Math.floor(j/15)) + '.' + j%15;
            th.posts = [obj[j]];
            obj[j].__proto__ = parse_obj;
            ths[ths.length] = th;
          }
          return ths;
        },
        op_img_url: function(){return '/distchan.png';},
        key: function(th){return th.domain+th.board+th.no;},
        has_posts: false,
        __proto__: site2['meguca'].parse_funcs.catalog_json
      },
      'thread_json': {
        ths: function(obj, parse_obj){
          return site2['DEFAULT'].parse_funcs['thread_json'].ths({posts:obj, nof_posts:obj.length, board:'/'+obj[0].board+'/'}, parse_obj);
        },
        __proto__: site2['meguca'].parse_funcs.thread_json
      },
      __proto__: site2['meguca'].parse_funcs
    },
    catalog_json2html3: site2['meguca'].catalog_json2html3,
    __proto__: site2['4chan'], // proto: '4chan',
  };
}

////////  if (!site2['futaba']) site2['futaba'] = { // working code.
////////    nickname : 'futaba',
////////    check_func : function(){
////////      if (window.location.href.search(/2chan.net/)!=-1) { // futaba
////////        site.config('2chan.net','futaba');
////////        site.max_page = site2['futaba'].max_page_futaba[site.server_name + site.board];
////////        return true;
////////      } else return false;
////////    },
////////    max_page_futaba : {
////////      'may/b/' : 11,
////////      'jun/b/' : 10,
////////      'dec/b/' : 8,
////////    },
////////    max_page : function(bn){return site2['futaba'].max_page_futaba[bn];},
//////////    make_url : function(board,no){return ['http://'+site.server_name+'.2chan.net' + board + ((no==0)? 'futaba' : no) + '.htm', 'html'];},
////////    make_url4 : function(dbt){return ['http://'+site.server_name+'.2chan.net' + dbt[1] + ((dbt[2]==0)? 'futaba' : dbt[2]) + '.htm', 'html'];},
////////    get_ops : function(doc){
////////      var ops = [];
////////      var responds = doc.getElementsByClassName('hsbn');
//////////      for (var i=0;i<responds.length;i++) ops.push(responds[i].href.substr(-13,9)); // doesn't work for sub-docment.
//////////      for (var i=0;i<responds.length;i++) ops.push(responds[i].getAttribute('href').substr(-13,9)); // may
////////      for (var i=0;i<responds.length;i++) ops.push(responds[i].getAttribute('href').replace(/res\//,'').replace(/\.htm/,''));
////////      return ops;
////////    },
////////    get_posts : function(doc) {
////////      var posts = [];
////////      var inputs = doc.getElementsByTagName('input');
////////      for (var i=0;i<inputs.length;i++) if (inputs[i].value=='delete') posts.push(inputs[i].name);
////////      return posts;
////////    },
////////    format_thread : function(doc){return doc;},
////////  };


//if (pref.test_mode['18']) { // leak test about 8chan catalog in 4chan.
//  delete site2['8chan'].parse_funcs['catalog_html'].th_init;
//  delete site2['8chan'].parse_funcs['catalog_html'].th_destroy;
//}

//  for (var i in site2) {
//    if (i=='DEFAULT') continue;
//    for (var j in site2['DEFAULT'])
//      if (site2[i][j]===undefined) site2[i][j]=site2['DEFAULT'][j];
//  }
  for (var i in site2) {
if (pref.test_mode['94'] && i==='dist') continue;
    for (var j in site2[i].parse_funcs) {
      if (typeof(site2[i].parse_funcs[j])==='string') {
        var tgt = site2[i].parse_funcs[j];
        site2[i].parse_funcs[j] = site2[i].parse_funcs[tgt];
        continue;
      }
      for (var k in site2[i].parse_funcs[j]) { // working code.
        if (k!=='proto' && typeof(Object.getOwnPropertyDescriptor(site2[i].parse_funcs[j],k).value)==='string') { // skip getter.
//        if (k!=='proto' && typeof(site2[i].parse_funcs[j][k])==='string') {
          tgt = site2[i].parse_funcs[j][k].split('.');
////          if (tgt.length>1) site2[i].parse_funcs[j][k] = (tgt.length===3)? site2[tgt[0]].parse_funcs[tgt[1]][tgt[2]] : // working code.
////                                                                           site2[i].parse_funcs[tgt[0]][tgt[1]];
          var tgt_obj = (tgt.length===3)? site2[tgt[0]].parse_funcs[tgt[1]][tgt[2]] : // vichan.catalog_json.XXX
                        (tgt.length===2 && site2[i].parse_funcs[tgt[0]] && site2[i].parse_funcs[tgt[0]][tgt[1]])? site2[i].parse_funcs[tgt[0]][tgt[1]] : // catalog_json.XXX
                        (tgt.length===2 && site2[tgt[0]] && site2[tgt[0]].parse_funcs[tgt[1]] && site2[tgt[0]].parse_funcs[tgt[1]][k])? site2[tgt[0]].parse_funcs[tgt[1]][k] : // vichan.catalog_json
                        (tgt.length===1)? site2[i].parse_funcs[tgt[0]] && site2[i].parse_funcs[tgt[0]][k] : // catalog_json
                        null;
          if (tgt_obj) site2[i].parse_funcs[j][k] = tgt_obj;
        }
      }
////      if (i!=='DEFAULT' || j!=='common') { // working code.
////        var proto = (site2[i].parse_funcs[j].hasOwnProperty('proto'))? site2[i].parse_funcs[j].proto : (site2['DEFAULT'].parse_funcs[j] && i!=='DEFAULT')? 'DEFAULT.'+j : 'DEFAULT.common';
//////        if (pref.debug_mode['0']) site2[i].parse_funcs[j].proto = proto; // debug
////        proto = (proto.indexOf('.')==-1)? site2[i].parse_funcs[proto] : site2[proto.substr(0,proto.indexOf('.'))].parse_funcs[proto.substr(proto.indexOf('.')+1)];
////        site2[i].parse_funcs[j].__proto__ = proto;
//////        if (!pref.debug_mode['0']) delete site2[i].parse_funcs[j].proto;
////        delete site2[i].parse_funcs[j].proto;
////      }
      if (i!=='DEFAULT' || j!=='common') {
        var proto = (site2[i].parse_funcs[j].hasOwnProperty('proto'))? site2[i].parse_funcs[j].proto :
                    (site2[i].hasOwnProperty('proto') && i!=='DEFAULT')? site2[i].proto + '.' + j :
                    (site2['DEFAULT'].parse_funcs[j] && i!=='DEFAULT')? 'DEFAULT.'+j : 'DEFAULT.common';
//        var proto2= (site2[i].parse_funcs[j].hasOwnProperty('proto'))? site2[i].parse_funcs[j].proto : // old
//                    (site2['DEFAULT'].parse_funcs[j] && i!=='DEFAULT')? 'DEFAULT.'+j : 'DEFAULT.common';
//if (proto!==proto2) console.log(i+':'+j+', '+proto+', '+proto2+', '+(proto===proto2));
        proto = (j.substr(-9,9)==='_template' && proto==='DEFAULT.common')? site2['DEFAULT'].wrap_to_parse.get_getters() :
                (proto.indexOf('.')==-1)? site2[i].parse_funcs[proto] : site2[proto.substr(0,proto.indexOf('.'))].parse_funcs[proto.substr(proto.indexOf('.')+1)];
//        if (proto!==null) proto = (proto.indexOf('.')==-1)? site2[i].parse_funcs[proto] : site2[proto.substr(0,proto.indexOf('.'))].parse_funcs[proto.substr(proto.indexOf('.')+1)];
        site2[i].parse_funcs[j].__proto__ = proto;
        delete site2[i].parse_funcs[j].proto;
      }
    }
    if (i!=='DEFAULT') {
      proto = (site2[i].hasOwnProperty('proto'))? site2[i].proto : 'DEFAULT';
//      if (pref.debug_mode['0']) site2[i].proto = proto; // debug
      if (site2[i].parse_funcs) site2[i].parse_funcs.__proto__ = site2[proto].parse_funcs;
      if (site2[i].patch) site2[i].patch.__proto__ = site2[proto].patch;
      site2[i].__proto__ = site2[proto];
//      if (!pref.debug_mode['0']) delete site2[i].proto;
      delete site2[i].proto;
    }
  }
//  for (var i in site2) {
//    if (i==='DEFAULT' || i==='common') continue;
//    if (!site2[i].hasOwnProperty('prep_own_posts_event')) {
//      site2[i].prep_own_posts_event = site2[i].prep_own_posts_event.bind(site2[i]); // DOESN'T WORK, WHY??? MAY THIS BE CHROME'S BUG??? but I found a better solution.
//console.log('DEBUG: '+i);
//    }
//  }
//    site2['lain'].prep_own_posts_event = site2['lain'].prep_own_posts_event.bind(site2['lain']); // works correctly.
//    site2['KC'].prep_own_posts_event = site2['KC'].prep_own_posts_event.bind(site2['KC']);

//if (pref.debug_mode['0']) console.log(common_func.debug_show_proto('8chan:catalog_html',site2['8chan'].parse_funcs['catalog_html'])); // debug
//if (pref.debug_mode['0']) console.log(common_func.debug_show_proto('8chan:page_html',site2['8chan'].parse_funcs['page_html'])); // debug
//console.log(common_func.debug_show_proto('8chan_live:thread_html',site2['8chan_live'].parse_funcs['thread_html'])); // debug
//console.log(common_func.debug_show_proto('8chan:page_html',site2['8chan'].parse_funcs['page_html'])); // debug
//console.log(common_func.debug_show_proto('4chan:thread_html',site2['4chan'].parse_funcs['thread_html'])); // debug

//  for (var i in site2) if (i!=='DEFAULT' && i!=='common') {
//    var proto = site2[i].hasOwnProperty('proto')? site2[i].proto : false;
//    site2[i].__proto__ = (proto)? site2[proto] : site2['DEFAULT'];
//    if (proto) delete site2[i].proto;
//    for (var j in site2[i].parse_funcs) {
//      proto = site2[i].parse_funcs[j].hasOwnProperty('proto')? site2[i].parse_funcs[j].proto : false;
//      if (proto) proto = (proto.indexOf('.')==-1)? site2[i].parse_funcs[proto] : site2[proto.substr(0,proto.indexOf('.'))].parse_funcs[proto.substr(proto.indexOf('.')+1)];
//      site2[i].parse_funcs[j].__proto__ = (proto)? proto
//                                        : (site4.parse_funcs[j])? site4.parse_funcs[j] : site4.parse_funcs.common;
//      if (proto) delete site2[i].parse_funcs[j].proto;
//    }
//  }
//  for (var i in site4.parse_funcs) if (i!=='common') site4.parse_funcs[i].__proto__ = site4.parse_funcs.common;

//  if (  localStorage &&   localStorage[pref.script_prefix+'.pref']) pref_func.pref_overwrite(pref,JSON.parse(  localStorage[pref.script_prefix+'.pref']),true);
//  if (sessionStorage && sessionStorage.pref) pref_func.pref_overwrite(pref,JSON.parse(sessionStorage.pref),true);
//  pref_func.site2_json();
  site2['ALL'] = {};

  var site3 = {};
  for (var i in site2) if (i!=='DEFAULT' && i!=='common' && i!=='meguca1' && i!=='meguca2') {
    site3[i] = {boards: null, tags: {cs:[], ci:[]}, own_posts:{}};
    if (site2[i].hasOwnProperty('check_func')) {
      site2[i].check_func();
      delete site2[i].check_func; // reduce memory consumption.
    }
    site.nicknames.push(i);
    site2['ALL'][site2[i].domain_url] = i;
  }
  if (!site.embed_to['top']) site.embed_to['top'] = site.root_body && site.root_body.firstChild;
  if (!site.embed_to['bottom']) site.embed_to['bottom'] = site.root_body && site.root_body.lastChild;

  if (pref.pref2.KC.summer_time) site2['KC'].time_offset = 2;
  pref_func.site2_json(false,true,['site2','pref_func','site3']);

  if (window.top != window.self) {
    if (site.nicknames.indexOf(window.name)==-1 && window.name!==site.embed_frame) return; //don't run on frames or iframes
    for (var i in site2) if (site.nicknames.indexOf(i)!=-1 && i!=site.nickname) delete site2[i];
  }

  var pipe_name = pref.script_prefix + '.graph.' + site.board + '__pipe__';
  var info_raw  = site.nickname + site.board;

  if (!window.SharedWorker) {
    pref.info_server = false;
    pref.info_client = false;
  }
//  pref_func.str2obj('catalog_board_list_str');
//  pref_func.str2obj2(pref.catalog,'style_general_list_obj2',pref.catalog.style_general_list_str);
//  pref_func.str2obj2(pref.catalog.board,'ex_list_obj2',pref.catalog.board.ex_list_str);
  pref_func.obj_init();
  pref3.stats.use = pref.stats.use;
  pref3.stats.estimate_posts = pref.stats.estimate_posts;

  var notifier = (function(){
    var sound = (pref.features.notify.sound)? (function(){
      var audio;
      function make_beep(){
        var wav_str;
        if (pref.notify.sound.notify) {
          wav_str = [];
          var dl = header_prep_monaural8(pref.notify.sound.beep_length_f);
          data_prep_monaural8(pref.notify.sound.beep_freq,dl,pref.notify.sound.beep_volume_f);
          for (var i=0;i<wav_str.length;i++) if (wav_str[i].length==1) wav_str[i] = '0'+wav_str[i];
          audio = new Audio('data:audio/wav,%'+wav_str.join('%'));
        } else audio = null;

        function header_prep_monaural8(period) {
          var dl=Math.floor(period*44100);
          var header_size=46;
          header_add(0x52494646,4,1);     //riff
          header_add(dl+header_size,4,0); //size
          header_add(0x57415645,4,1);     //WAVE
          header_add(0x666d7420,4,1);     //fmt
          header_add(0x12,4,0);           //size of fmt
          header_add(0x01,2,0);           //linearPCM
          header_add(0x01,2,0);           //Stereo
          header_add(44100,4,0);          //44.1kHz
          header_add(44100,4,0);          //176400 bit/sec
          header_add(1,2,0);              //block size, 4Byte
          header_add(8,2,0);              //bit/sample
          header_add(0,2,0);              //size of ext
    //      header_add(0x66616374,4,1);     //fact
    //      header_add(4,4,0);              //size of fact
    //      header_add(0xdbcd5a00,4,1);     //data of fact
          header_add(0x64617461,4,1);     //data
          header_add(dl,4,0);             //size of data
          return dl;
  
          function header_add(val,num,big_endian) {
            if (big_endian==1) for (var i=0;i<num;i++) wav_str.push('');
            for (var i=0;i<num;i++) {
              if (big_endian==1) wav_str[wav_str.length-1-i] = (val%0x100).toString(16);
              else wav_str.push((val%0x100).toString(16));
              val = Math.floor(val/0x100);
            }
          }
        }
        function data_prep_monaural8(freq,period,vol){
          var pi2 = 3.141592654*2;
          vol *=127;
          for (var i=0;i<period;i++) {
            var val = Math.floor(Math.sin(pi2*freq*i/44100)*vol+0x80)%0x100;
            wav_str.push(val.toString(16));
          }
        }
      }
      make_beep();

      function make_beep_play(){
        make_beep();
        if (pref.notify.sound.notify && pref.notify.sound.src==='beep') audio.play();
      }
      function src_changed(){
        if (audio) audio.pause();
        if (this.name==='notify.sound.file') pref.notify.sound.src='file';
        if (pref.notify.sound.src==='beep') make_beep();
        else {
          var file = pref3.notify.sound.file;
          if (file) audio = new Audio(URL.createObjectURL(file.files[0]));
        }
        pref_func.settings.apply_pn13_1();
        if (pref.notify.sound.notify) audio.play();
      }
      pref_func.settings.onchange_funcs['notify.sound.beep_length_f'] = make_beep_play;
      pref_func.settings.onchange_funcs['notify.sound.beep_volume_f'] = make_beep_play;
      pref_func.settings.onchange_funcs['notify.sound.beep_freq'    ] = make_beep_play;
      pref_func.settings.onchange_funcs['notify.sound.beep_freq'    ] = make_beep_play;
      pref_func.settings.onchange_funcs['notify.sound.pause'        ] = function(){audio.pause();};
      pref_func.settings.onchange_funcs['notify.sound.notify'       ] = make_beep;
      pref_func.settings.onchange_funcs['notify.sound.file'         ] = src_changed;
      pref_func.settings.onchange_funcs['notify.sound.src'          ] = src_changed;

      return {
        play : function(){audio.play();},
      }
    })() : {play:function(){}};

    var favicon = (pref.features.notify.favicon)? (function(){
      var favicon = site2[site.nickname].favicon.get_favicon();
      var title = site2[site.nickname].favicon.get_title();
      var title_org = title.innerHTML;
      var favicon_current;
      var title_current;
      function favicon_set(favicon_next){
        if (favicon_current!==favicon_next) {
          var str = site2[site.nickname].favicon[favicon_next];
          if (str[0]!=='/') str = 'data:image/'+str;
          favicon.setAttribute('href',str);
          favicon_current = favicon_next;
        }
      }
//      var func_debug = function(e){for (var i=0;i<e.length;i++) console.log(e[i].target.href);};
//      new MutationObserver(func_debug).observe(favicon, {attributes:true});
//      function favicon_set(str){ // working code.
//        if (!favicon) favicon = site2[site.nickname].favicon.get_favicon();
//        if (str[0]!=='/') str = 'data:image/'+str;
//        favicon.setAttribute('href',str);
//      }

      function set(){
        var sum = new liveTag.CountNR();
        if (pref.liveTag.watch_all) {
          for (var d in liveTag.mems) {
            for (var b in liveTag.mems[d]) {
              if (liveTag.mems[d][b].nr<0) {
                var sum_sub = new liveTag.CountNR();
                for (var t in liveTag.mems[d][b]) sum_sub.count(liveTag.mems[d][b][t][2]);
                liveTag.mems[d][b].nrtm = sum_sub.nrtm;
                liveTag.mems[d][b].nr   = sum_sub.nr;
              }
//              sum.count([0x000c0000, (liveTag.mems[d][b].nrtm<<16) + liveTag.mems[d][b].nr]); // BUG, nr overflowed in 4chan.
              sum.nrtm += liveTag.mems[d][b].nrtm;
              sum.nr   += liveTag.mems[d][b].nr;
        }}} else {
          var threads = cataLog.threads;
          if (threads) for (var name in threads) sum.count(threads[name][19]);
        }
        if (pref.notify.favicon) {
          var favicon_next = (sum.nrtm!=0)? 'reply_to_me' :
                             (sum.nr!=0)?   'reply' :
                             'none';
          favicon_set(favicon_next);
        }
        if (pref.notify.title.notify) {
          if (sum.nr!=0 || !pref.notify.title.hide_zero) title_set(((pref.catalog.footer.nrtm)? sum.nrtm + '/' + sum.nr : '('+sum.nr+')') + ' - ');
          else title_set('');
        }
      }
      function title_set(str){
        if (title_current!==str) {
          title.innerHTML = str + title_org;
          title_current = str;
        }
      }
      return {
        set : new DelayBuffer(set, 200).get_binded_delayed_do(),
      } 
    })() : {set:function(){}};

    var desktop = (Notification && pref.features.notify.desktop)? (function(){
      function get_permission(){
        if (Notification.permission !== 'granted') {
          Notification.requestPermission(function (status) {
            if (Notification.permission !== status) {
              Notification.permission = status;
            }
          });
        }
        return Notification.permission==='granted';
      }
      get_permission();

//      var dtns = {};
      var dtns = [];
      var dtns_queue = [];
      function show(th,obj,num){
        if (pref.test_mode['94'] && site.nickname==='dist') return site2[site.nickname].testPoster((num>=0)? obj[num] : obj, th.no);
        if (dtns.length + dtns_queue.length < pref.notify.desktop.limit)
          if (Notification.permission === 'granted' || get_permission()) show_1(th,obj,num);
      }
//      function show(name,obj,num){ // working code.
//        if (dtns.length>pref.notify.desktop.limit) return;
//        if (Notification.permission === 'granted') show_1(name,obj,num);
//        else if (Notification && Notification.permission !== 'denied') {
//          Notification.requestPermission(function (status) {
//            if (Notification.permission !== status) {
//              Notification.permission = status;
//            }
//            if (status === 'granted') show_1(name,obj,num);
//          })
//        }
//      }
      var pn = document.createElement('div');
      function show_1(th,objs,num){
        var obj = (num>=0)? objs[num] : objs;
        obj = {icon: obj.op_img_url,
               body: obj.com || '',
               __proto__: obj};
        if (obj.reply_of_mine && pref.catalog_footer_ignore_my_own_posts) return;
        obj.title = ( // (obj.appear_thread)? 'Appear thread ' :
                     (obj.new_thread)? 'New Thread ' :
                     (obj.reply_to_me && pref.notify.desktop.reply_to_me)? '(You) in ' :
                      '') + (th.sub || th.key);
//        if (obj.tag) obj.tag = 'CatChan/' + obj.tag;
        obj.tag = pref.script_prefix+'/' + th.key + ', '+(objs.length-num-1);
        pn.innerHTML = obj.body;
//        var dtn = new Notification(obj.title,{tag:obj.tag, body:pn[brwsr.innerText], icon:obj.icon});
//        var dtn = new Notification(obj.title,{tag:obj.tag, body:pn[brwsr.innerText].trim(), icon:obj.icon}); // trim for KC
        obj.body = pn[brwsr.innerText].trim(); // trim for KC
        if (pref.notify.desktop.delay===0) show_1_queued(obj);
        else {
          dtns_queue[dtns_queue.length] = obj;
          show_1_queued_delayed(); // FF denies multiple notifications at a time.
        }
      }
      var show_1_queued_delayed = new DelayBuffer(show_1_queued, 200).get_binded_delayed_do();
      function show_1_queued(obj) {
        if (!obj) obj = dtns_queue.shift();
        var dtn = new Notification(obj.title, obj); // trim for KC
        dtn.onclick = win_focus;
//        dtn.onclose = close_1;
        var id = (pref.notify.desktop.lifetime!=0)? setTimeout(close_1, pref.notify.desktop.lifetime*1000) : null;
        dtns[dtns.length] = [dtn, id];
//console.log(dtns.length);
//        dtns[obj.tag] = dtn;
//        if (pref.notify.desktop.lifetime!=0) setTimeout(function(){dtn.close();delete dtns[obj.tag];},pref.notify.desktop.lifetime*1000); // can't call this in setTimeout without 'use strict'
        if (dtns_queue.length>0) show_1_queued_delayed();
      }
      function close_1(){dtns.shift()[0].close();}
      function win_focus(){window.focus();for (var i=dtns.length-1;i>=0;i--) if (dtns[i][0]===this || i==0) {if (dtns[i][1]) clearTimeout(dtns[i][1]);dtns.splice(i,1);break;}}
      function close_all(){while (dtns.length>0) {if (dtns[0][1]) clearTimeout(dtns[0][1]);close_1();}}
//      function win_focus(){window.focus();clearTimeout(dtns.shift()[1]);};
//      function close_all(){while (dtns.length>0) close_1();}
////      function win_focus(){window.focus()};
////      function close_all(){
////        for (var i in dtns) dtns[i].close();
////      }
      window.addEventListener('beforeunload', close_all, false);
      return {
        show : show,
      }
    })() : {show:function(){}};
    return {
      sound:   sound,
      favicon: favicon,
      desktop: desktop,
      changed: function(th, tgt_th19_4){
        if (pref.notify.favicon || pref.notify.title.notify) favicon.set();
//        if (!threads[name][19][5] && tgt_th19_4 && tgt_th19_4.length!=0) { // I think that tgt_th19_4 is redundant, but error occured, so patched.
          var sound_flag = false;
          var init = pref4.refresh.count<=1;
          var dt = (pref.notify.desktop.show_last)? 0 : tgt_th19_4.length-1;
          for (var i=tgt_th19_4.length-1;i>=0;i--) {
            if (pref.notify.sound.reply || (pref.notify.sound.reply_to_me && tgt_th19_4[i].reply_to_me)) sound_flag = true;
            if (i<=dt && pref.notify.desktop.notify)
              if (pref.notify.desktop.reply || (pref.notify.desktop.reply_to_me && tgt_th19_4[i].reply_to_me)) if (!init || !pref.notify.desktop.supp_init) desktop.show(th,tgt_th19_4,i, true);
          }
          if (pref.notify.sound.notify && sound_flag) if (!init || !pref.notify.sound.supp_init) notifier.sound.play();
//        }
//console.log(tgt_th19_4.length);
      },
////      changed: function(name,threads){
////        if (pref.notify.favicon) favicon.set(threads);
////        var sound_flag = false;
//////threads[name][19][5] = false; // for debug.
////        if (!threads[name][19][5] && threads[name][19][4] && threads[name][19][4].length!=0) { // I think that threads[name][19][4] is redundant, but error occured, so patched.
////          if (pref.notify.desktop.notify) {
////            var i = (pref.notify.desktop.show_last)? 0 : threads[name][19][4].length-1;
////            while (i>=0) {
////              if (i==0 || !pref.notify.desktop.show_last)
////                if (pref.notify.desktop.reply || (pref.notify.desktop.reply_to_me && threads[name][19][4][i].to_me)) desktop.show(name,threads[name][19][4],i);
////              i--;
////            }
////          }
////          for (var i=0;i<threads[name][19][4].length;i++) if (pref.notify.sound.reply || (pref.notify.sound.reply_to_me && threads[name][19][4][i].to_me)) sound_flag = true;
////        }
////        if (pref.notify.sound.notify && sound_flag) notifier.sound.play();
//////console.log(threads[name][19][4].length);
////      },
////      appeared: function(names,threads){ // working code.
//////        if (pref.notify.sound.notify) notifier.sound.play();
////        if (pref.notify.favicon || pref.notify.title.notify) favicon.set(threads);
////        var sound_flag = false;
////        for (var i=0;i<names.length;i++) {
////          var name = names[i];
//////          if (threads[name][19][0]<0) { // 'changed' shall not be issued.
//////            if (pref.notify.desktop.new_thread && threads[name][19][8]) desktop.show(name,[{new_thread:true, body:threads[name][0].innerHTML}],0);
////            var dbt = common_func.name2domainboardthread(name,true);
//////            if (pref.notify.desktop.notify && (pref.notify.desktop.appear || (pref.notify.desktop.new_thread && threads[name][19][8])))
////            if (pref.notify.desktop.notify &&   ((pref.notify.desktop.appear && !(threads[name][19][0]!==0 && (pref.notify.desktop.reply || pref.notify.desktop.reply_to_me)))
////                                              || (pref.notify.desktop.new_thread && threads[name][19][8])))
//////              desktop.show(name,[{new_thread:threads[name][19][8], body:threads[name][0].innerHTML, icon:site2[dbt[0]].get_op_image_url(threads[name][0],threads[name][18])}],0);
////              desktop.show(name,{new_thread:threads[name][19][8], body:threads[name][0].innerHTML, icon:threads[name][26]},-1);
////            if (pref.notify.sound.appear || (pref.notify.sound.new_thread && threads[name][19][8])) sound_flag = true;
////        }
////        if (pref.notify.sound.notify && sound_flag) notifier.sound.play();
////      }
      appeared: function(th, new_thread){
        var threads = cataLog.threads;
        if (pref.notify.favicon || pref.notify.title.notify) favicon.set(threads);
        var watch = liveTag.mems[th.domain][th.board][th.no][2];
        if (pref.notify.desktop.notify && ((pref.notify.desktop.appear && !(watch[0]!==0 && (pref.notify.desktop.reply || pref.notify.desktop.reply_to_me)))
                                            || (pref.notify.desktop.new_thread && new_thread)))
          desktop.show(th,{new_thread:new_thread, __proto__:th},-1);
        if (pref.notify.sound.notify && (pref.notify.sound.appear || (pref.notify.sound.new_thread && new_thread))) notifier.sound.play();
      }
    }
  })();

  var ports = {};
  var messages_to_send = {};
  var init_func = {};
  var receive_func = {};
  function make_port_parent(name,win){
    if (ports[name]) send_message(name,[['CLOSE']]);
    ports[name] = 'init';
    init_func[name] = function(e){initialize(e,name,win);};
    window.addEventListener('message', init_func[name], false);
    if (pref.debug_mode['0']) console.log(window.name + ': Waiting for connection from '+name+' ...');
    function initialize(e,name,win) {
      if (pref.debug_mode['0']) console.log(window.name + ': Connecting from '+e.data);
//      if (e.source==win) {
//      if (e.source==win && site2[e.data]) { // remove "{"name":"twttr:private:requestArticleUrl"}" from someone...
//      if (e.source==win && site.nicknames.indexOf(e.data)!=-1) { // remove "{"name":"twttr:private:requestArticleUrl"}" from someone... in Tampermonkey. // BUG.
//      if (e.source==win && new RegExp(site.nicknames.join('|')).test(e.data)) { // remove "{"name":"twttr:private:requestArticleUrl"}" from someone... in Tampermonkey.
      if ((e.source==win && new RegExp(site.nicknames.join('|')).test(e.data)) ||
          (e.source==site.embed_frame_win && site.whereami==='frame' && e.data.indexOf('CLOSE')==-1)) { // remove "{"name":"twttr:private:requestArticleUrl"}" from someone... in Tampermonkey.
        if (pref.debug_mode['0']) console.log(window.name + ': Connected successfully.');
        if (!brwsr.ff) init_receive_port(name,e.ports[0]);
        else init_receive_port(name,win);
        window.removeEventListener('message', init_func[name], false);
        delete init_func[name];
        if (messages_to_send[name]) {
          for (var i=0;i<messages_to_send[name].length;i++) if (send_message(name,messages_to_send[name][i][0], null, messages_to_send[name][i][1])) break;
          delete messages_to_send[name];
        }
        if (name=='_blank') send_message(name,[['CLOSE']]);
      } else if (pref.debug_mode['0']) console.log(window.name + ': FAIL.');
    }
  }
  function make_port_child(parent){
    if (pref.debug_mode['0']) console.log(window.name + ': Try to connect to parent...');
    if (!brwsr.ff) {
      var channel = new MessageChannel();
      init_receive_port('parent',channel.port1);
      parent.postMessage(window.name, '*', [channel.port2]); // Specification(order of arguments) was changed.
//      parent.postMessage(window.name, [channel.port2], '*'); // chrome 59 doesn't work this
    } else { // FF doesn't support channel messaging.
      init_receive_port('parent',parent);
      parent.postMessage(window.name, '*');
    }
  }
  function init_receive_port(name,port){
    ports[name] = port;
    receive_func[name] = function(e){receive_message(e,name);};
    if (!brwsr.ff) {
      port.addEventListener('message', receive_func[name], false);
      port.start();
    } else window.onmessage = receive_func[name];
  }
  function close_connection(name){
    if (!brwsr.ff) ports[name].close();
    ports[name].removeEventListener('message', receive_func[name], false);
    delete receive_func[name];
    delete ports[name];
  }
  function send_message(name,message,win,list){
    if (Array.isArray(message) && Array.isArray(message[0])) message = message[0]; // patch
//    if (typeof(val[0])==='string') val = [val];
//    if (!ports[name]) make_port_parent(name,win);
    if (win) make_port_parent(name,win);
    if (ports[name]==='init') { // chrome works at ==.
      if (!messages_to_send[name]) messages_to_send[name] = [];
      messages_to_send[name].push([message, list]);
    } else {
      if (!ports[name]) name='parent';
      if (pref.debug_mode['0']) console.log(window.name + ': Sent to '+name+': '+ JSON.stringify(message).substr(0,80));
      if (!brwsr.ff) ports[name].postMessage(message, list);
      else ports[name].postMessage(message,'*', list);
//      if (!brwsr.ff) ports[name].postMessage(JSON.stringify(val[i]));
//      else ports[name].postMessage(JSON.stringify(val[i]),'*');
      if (message[0]=='CLOSE') {close_connection(name); return true;} // fallback for chrome's removing extensions.
    }
  }
  var send_message_emu = [];
  function receive_message_emu() {
    while (send_message_emu.length>0) receive_message({data:send_message_emu.shift()},site.key);
  }
  function receive_message(e,name) {
    if (pref.debug_mode['0']) console.log(window.name + ': Received from '+name+': '+e.data.toString().substr(0,80));
    var val = e.data;
    var list = e.ports;
//    var val = JSON.parse(e.data);
    if (typeof(val)=='string') val=JSON.parse(val); // patch for GM.
    if (val[0]=='HTTPD') httpd.sub_funcs(val[1]);
    else if (val[0]=='IDB' && IDB) IDB.sub_funcs(val[1], list);
    else if (val[0]=='ARCHIVER' && archiver) archiver.sub_funcs(val[1]);
    else if (val[0]=='CLOSE') close_connection(name);
    else if (val[0]=='MARK' && val[1]>0) {
      var marked_first_post = (common_obj.thread_reader && pref.test_mode['16'])? common_obj.thread_reader.mark_newer_posts(val[1])
                                                        : site2[site.nickname].mark_newer_posts(document,val[1],pref.catalog.unmark_on_hover, true);
      if (marked_first_post) scrollTo(0,marked_first_post.offsetTop - site.header_height());
      else scrollTo(0,document.body.clientHeight - window.innerHeight);
      if (common_obj.thread_reader) common_obj.thread_reader.mark_posts_from_parent(val[1]);
    }
////    else if (val[0]=='SUBFRAME_INIT') http_req.remote();
////    else if (val[0]=='SUB_GET') http_req.sub_get(val[1]);
////    else if (val[0]=='SUB_ACK') http_req.sub_ack(val[1]);
////    else if (val[0]=='SUB_DEST') http_req.sub_dest(val[1]);
    else if (val[0]=='OWN_POSTS') {
      if (site2[val[1]].prep_own_posts_event_received) site2[val[1]].prep_own_posts_event_received(val[2]);
      else site3[val[1]].own_posts = val[2];
    } else if (val[0]=='TRIAGE') {
//console.log('receive: TRIAGE, '+val[1]+', '+val[2]+', '+val[3]);
//      if (catalog_obj && catalog_obj.catalog_func()!=null) catalog_obj.catalog_func().triage_exe_0(val[1],val[2],'',true,val[3]);
      if (catalog_obj && catalog_obj.catalog_func()!=null) catalog_obj.catalog_func().triage_exe_pipe(val[1]);
    } else if (val[0]=='UIP') {
      if (uip_tracker) uip_tracker.annotate_from_catalog(val[1]);
    }
else if (pref.test_mode['34'] && val[0]==='ECHO') setTimeout(function(){send_message(window.name? 'parent' : 'meguca',[['ECHO',val[1]]])},5000);
  }
//  function receive_message(e,name) { // working code for old http_req
//    if (pref.debug_mode['0']) console.log(window.name + ': Received from '+name+': '+e.data.toString().substr(0,80));
//    var val = JSON.parse(e.data);
//    if (typeof(val)=='string') val=JSON.parse(val); // patch for GM.
//    if (val[0]=='CLOSE') close_connection(name);
//    else if (val[0]=='MARK' && val[1]>=0) {
//      var offset_top = site2[site.nickname].mark_newer_posts(document,val[1]);
//      scrollTo(0,offset_top);
//    } else if (val[0]=='SUBFRAME_INIT') {
//      http_req.remote();
//    } else if (val[0]=='SUB_GET') {
//      http_req.get(val[1][0],val[1][1],val[1][2],val[1][3],val[1][4],val[1][5],val[1][6]);
//    } else if (val[0]=='SUB_ACK') {
//      iframes[name][1]--;
//      http_req.onload_local(val[1],val[2]);
//    }
//  }
  function close_all(){
    for (var name in ports) send_message(name,[['CLOSE']]);
  }
  window.addEventListener('beforeunload', close_all, false);
  if (window.opener) {
//console.log('child');
    make_port_child(window.opener);
////    for (var i in site2) // moved to before.
////      if (site2[i].nickname===window.name) {
////        for (var i in site.features) site.features[i] = false;
////        brwsr.sw_cache = null;
////        pref.cloudflare.auto_reload = false;
////        break;
////      }
    if (site2[window.name] && site2[window.name].prep_own_posts_event) {
      window.addEventListener('storage', site2[window.name].prep_own_posts_event, false);
      site2[window.name].prep_own_posts();
      site2[window.name].prep_own_posts_event();
    }
  }
  if (pref.cloudflare.auto_reload) {
    var cf_error = document.getElementsByClassName('cf-error-code');
    if (cf_error.length>0 && parseInt(cf_error[0].textContent,10)>=500) setTimeout(function(){location.reload();},pref.cloudflare.auto_reload_time*60000);
  }

//  var ports = {}; // working code for test
//  function make_port_parent(name, val){
//    ports[name] = val;
//    var port;
//    if (pref.debug_mode['0']) console.log('parent: '+name+', '+val);
//    window.onmessage = function(e) {
//      if (pref.debug_mode['0']) console.log('from child #unkown: '+e.data);
//      port = e.ports[0];
//      port.postMessage(JSON.stringify(['MARK',val]));
//      port.postMessage(JSON.stringify('CLOSE'));
//      port.close();
////      port.onmessage = function(e) {
////        if (pref.debug_mode['0']) console.log(e.data);
////        port.postMessage('received : ('+Date.now()+')');
////      }
//    }
//  }
//
//  function make_port_child(prt){
//    if (pref.debug_mode['0']) console.log('child :');
//    var channel = new MessageChannel;
//    var port = channel.port1;
//    prt.postMessage('Connection: ', [channel.port2], '*');
////    prt.postMessage('start', [channel.port2], '*');
////    setInterval(function() {port.postMessage('sent : ' + (+new Date));}, 2000);
////    port.onmessage = function(e) {if (pref.debug_mode['0']) console.log(e.data);};
//    port.onmessage = function(e) {
//      if (pref.debug_mode['0']) console.log(e.data);
//      var val = JSON.parse(e.data);
//      if (val[0]=='CLOSE') port.close();
//      else if (val[0]=='MARK' && val[1]>=0) {
//        var offset_top = site2[site.nickname].mark_newer_posts(document,val[1]);
//        scrollTo(0,offset_top);
//      }
//    };
//  }
//  if (window.opener) make_port_child(window.opener);

  var httpd = (function(){
    var iframes = {};
    var local = true;
    var parser = new DOMParser();
//    var serializer = new XMLSerializer();
    var xhrs = new Map();
    var xhrs_free = [];
    var xhrs_count = 0;
    var remote_opened = {};
    var remote_count = 0;
    var remote_reqs = {};
    var reqs = [];
    var reqs_waiting_finish = [];
    var pause = 0;
    var crawler_spawn   = new Watchdog(dispatch, pref.scan.crawler_idle_time_to_spawn);
    var xhrs_reqs = [];
    var crawler_timeout = new Watchdog(xhr_timeout, 30000);
    var health_indicator;
    function dispatch_if_idle(){
      if (!crawler_spawn.id) dispatch();
    }
    function dispatch(xhr, req_from){
      if (!pause) for (var p=8;p>=0;p--) if (reqs[p] && (xhrs_count<pref.scan.crawler || p==8)) {
        while (reqs[p][0] && reqs[p][0].tgts.length===0) reqs[p].shift();
        var req = reqs[p][0];
        var i=0;
        while (req && req.ERR_5xx && req_from!==req) req = reqs[p][++i];
        if (!req) continue;
        var req_1;
        if (!req.INDICATOR) {
          req.INDICATOR = health_indicator.shift('limegreen', req.initiator[0], req.initiator, p);
          req.INDICATOR.report({start:Date.now(), prog:req}); // make reference loop.
          req.IDX = 0;
          req.FINISHED = 0;
          req.SUC = 0;
          if (!req.max) req.max = req.tgts.length;
        }
        var req_1 = (req.get_tgt_func)? req.get_tgt_func(req) : {REQ:req, __proto__:req.tgts[req.IDX++]};
        if (req.IDX>=req.max) reload_reqs(req,p);
        xhrs_count++; // THIS CAN BE A SINK AND CAUSE DEADLOCK WHEN OVER X_FRAME_OPTIONS.
        if (req_1) {
          req.INDICATOR.report({tgt:req_1.tgt || url2tgt(req_1.url)});
          if (req_1.domain===site.nickname && !req_1.domain_xhr || pref.network.cross_domain!=='indirect') download_local(xhr, req_1);
          else {
            if (xhr) xhrs_free[xhrs_free.length] = xhr;
            download_remote(req_1);
          }
          if (pref.scan.crawler_adaptive) crawler_spawn.restart(pref.scan.crawler_idle_time_to_spawn);
          else if (xhrs_count<pref.scan.crawler) dispatch();
        } else {
          if (!(req.IDX<req.max && (req.refresh || req.found_threads<req.max_threads))) {
            reload_reqs(req,p);
            req.FINISHED += req.max - req.IDX;
            req.IDX = req.max;
          }
          setTimeout(function(){xhr_onload_1({type:'SKIPPED_TO_END'}, xhr, {REQ:req}, true, {date:Date.now(), status:200});},0);
        }
        return;
      }
      if (crawler_spawn.id) crawler_spawn.stop();
      if (xhr) xhrs_free[xhrs_free.length] = xhr;
    }
    function url2tgt(url){return url.substr(url.lastIndexOf('/')+1);}
    function reload_reqs(req,p){
      if (reqs[p] && reqs[p].length>1) reqs[p].shift();
      else reqs[p] = null;
      reqs_waiting_finish[reqs_waiting_finish.length] = req;
    }
    function download_remote(req){
      var domain = req.domain_xhr || req.domain;
      if (!iframes[domain]) {
        cnst.make_iframe(domain);
        iframes[domain] = window.open(site2[domain] && site2[domain].home || req.url, domain);
        send_message(domain,['HTTPD',['SUB_FRAME_INIT']],iframes[domain]);
      }
      remote_opened[domain] = null;
      remote_reqs[remote_count] = req;
      if (!req.archive) req.responseType = 'text';
      send_message(domain,['HTTPD',['SUB_GET',[{ID:remote_count++, url:req.url, responseType:req.responseType, domain:req.domain,
                                                board:req.board, no:req.no, key:req.key, archive:req.archive,
                                                to_file:req.to_file, to_idb:req.to_idb, kind:req.kind, timestamp:req.timestamp,// for archive
                                                domain_xhr:req.domain_xhr,
                                               }]]]);
    }
    function sub_get(args){
      download_local(undefined,args[0]);
    }
    var GM_XMLHttpRequestWrapper = function(){
      this.onload  = this.onload.bind(this);
      this.onerror = this.onerror.bind(this);
      this.onabort = this.onabort.bind(this);
    };
    GM_XMLHttpRequestWrapper.prototype = {
      open: function(method, url){
        this.method = method;
        this.url = url;
      },
      send: function(){
        this.response = null;
        GM_xmlhttpRequest(this);
      },
      onload: function(e){
        this.response = e.response;
        if (!this.response) // GM has 'response', this is for emulation.
          this.response = (this.responseType==='document')? new DOMParser().parseFromString(e.responseText, 'text/xml')
                        : (this.responseType==='json')? JSON.parse(e.responseText)
//                   : (this.responseType==='arraybuffer')? new DOMParser().parseFromString(e.responseText, 'text/xml')
//                   : (this.responseType==='blob')? new DOMParser().parseFromString(e.responseText, 'text/xml')
                        : e.responseText;
// GM has 'arraybuffer' from 3.2, // http://www.greasespot.net/2015/05/greasemonkey-32-release.html
// TM has 'arraybuffer' from ? // https://github.com/Tampermonkey/tampermonkey/issues/279
//        if (this.responseType==='arraybuffer') console.log(this.url+', '+this.response.byteLength);
        this.onXXX('load', e, xhr_onload);
      },
      onerror: function(e){this.onXXX('error',e, xhr_onload);},
      onabort: function(e){this.onXXX('abort',e, xhr_onload);},
      onXXX: function(type, result, callback){
        this.type = type;
        this.result = result;
        callback(this);
      },
      onXXX_factory: function(type, func){
        return function(result){this.onXXX(type, result, func);}.bind(this);
      },
      set onreadystatechange(v){this._onreadystatechange = (v)? this.onXXX_factory('readystatechange',v) : v;},
      get onreadystatechange(){return this._onreadystatechange || this.dummy_func;},
      set onprogress(v){this._onprogress = (v)? this.onXXX_factory('progress',v) : v;},
      get onprogress(){return this._onprogress || this.dummy_func;},
      dummy_func: function(){}, // for chrome emulation, it uses existence of property, not a value.
      get status(){return this.result && this.result.status || 1404;},
      get responseText(){return this.result.responseText;},
      get target(){return this;},
      result: null,
    };
    function download_local(xhr, req){
      if (!xhr) { 
        if (xhrs_free.length>0) xhr = xhrs_free.pop();
        else {
          if (pref.network.cross_domain==='GM') xhr = new GM_XMLHttpRequestWrapper();
          else {
            xhr = new XMLHttpRequest();
            xhr.onload  = xhr_onload;
            xhr.onerror = xhr_onload;
            xhr.onabort = xhr_onload;
          }
        }
      }
      xhrs.set(xhr, req);
      xhr.open('GET', req.url);
      xhr.responseType = req.responseType;
      xhr.send();
      xhr_timeout_start(xhr,Date.now(),req);
    }
    function xhr_timeout_start(xhr,date,req){
      req.TIMEOUT = ((req.TIMEOUT)? req.TIMEOUT : date) + pref.network.timeout*1000;
      xhrs_reqs[xhrs_reqs.length] = xhr;
      if (xhrs_reqs.length===1) crawler_timeout.restart(pref.network.timeout*1000);
    }
    function xhr_timeout_restart(xhr,date){
      var idx = xhrs_reqs.indexOf(xhr);
      if (idx<0) return true; // timeouted.
      xhrs_reqs.splice(idx,1);
      if (idx===0) {
        if (xhrs_reqs.length>0) {
          var timeout = xhrs.get(xhrs_reqs[0]).TIMEOUT - date;
          if (timeout>0) crawler_timeout.restart(timeout);
          else xhr_timeout();
        } else crawler_timeout.stop();
      }
    }
    function xhr_timeout(){
      var xhr = xhrs_reqs[0];
      if (pref.debug_mode['25']) console.log('xhr_timeout: '+xhr.readyState+', '+xhr.responseURL);
      if (!xhr.onreadystatechange) {
        xhr.onreadystatechange = xhr_onreadystatechange;
        xhr.onprogress = xhr_onreadystatechange;
        xhr_onreadystatechange({target:xhr});
      } else xhr_onload({target:xhr, type:'TIMEOUT'});
    }
    function xhr_onreadystatechange(e){
      var xhr = e.target;
      var req = xhrs.get(xhr);
      if (pref.debug_mode['25']) console.log('xhr_onreadystatechange: '+req.url+((e.type==='progress')? ': '+e.loaded+'/'+e.total:''));
      if (e.type==='progress') e.target.onreadystatechange = null;
      var date = Date.now();
      xhr_timeout_restart(xhr,date);
      xhr_timeout_start(xhr,date,req);
    }
    function xhr_onload(e){
      var xhr = e.target;
      var date = Date.now();
      if (xhr_timeout_restart(xhr,date)) return; // timeouted.
      xhr.onreadystatechange = null;
      xhr.onprogress = null;
      var req = xhrs.get(xhr);
      var valid = xhr.status===200 || xhr.status===304;
      var value = (xhr.responseType==='text')? {date: date, status: xhr.status, responseText: (valid)? xhr.responseText: null} :
                                               {date: date, status: xhr.status, response:     (valid)? xhr.response    : null};
      xhr_onload_1(e, xhr, req, valid, value);
    }
    function xhr_onload_1(e, xhr, req, valid, value){ // CACHE HIT ENTRY HERE
      if (local) {
        xhrs_count--;
        var end = ++req.REQ.FINISHED === req.REQ.IDX && req.REQ.IDX >= req.REQ.max;
        dispatch(xhr, (value.status<500)? req : null);
        if (end) end_proc_httpd(req.REQ);
        // CACHE WRITE CODE HERE
        if (valid) {
          req.REQ.SUC++;
          onload_local(req, value);
        } else {
          if (value.status>=500 && !req.REQ.ERR_5xx) req.REQ.ERR_5xx = setTimeout(
            (function(req){
              return function(){
                delete req.ERR_5xx;
                dispatch_if_idle();
              }})(req.REQ),30000);
          req.REQ.INDICATOR.report({err_str:(req.tgt||url2tgt(req.url))+'('+value.status+((e.type!=='load')? ':'+e.type : '')+')'});
          if (req.REQ.callback_1_fail) req.REQ.callback_1_fail(req, value, req.REQ);
        }
        if (end) end_proc_user(req.REQ, value.date);
        req.REQ = null; // cut reference loop for GC.
      } else {
        send_message('parent',['HTTPD',['SUB_ACK',[req.ID, {type:(req.archive)? 'ARCHIVE' : e.type}, valid, (req.archive)? {date:value.date, status:value.status, responseText:'', response:{}} : value]]]);
        xhrs_free[xhrs_free.length] = xhr;
        if (valid && req.archive) onload_archive(req, value);
      }
    }
    function sub_ack(args){
      var req = remote_reqs[args[0]];
      delete remote_reqs[args[0]];
      xhr_onload_1(args[1], undefined, req, args[2], args[3]);
    }
    function end_proc_httpd(req){ // called local only
      reqs_waiting_finish.splice(reqs_waiting_finish.indexOf(req),1);
      if (req.archive) req.TAR_FLUSH = remote_opened;
      free_xhrs();
    }
    function free_xhrs(){
      if (xhrs_count===0) {
        xhrs.clear();
        if (local) for (var domain in remote_opened) send_message(domain,['HTTPD',['SUB_FREE']]);
        remote_count = 0;
        remote_opened = {};
      } else for (var i=0;i<xhrs_free.length;i++) xhrs.delete(xhrs_free[i]);
      xhrs_free = [];
    }
    function onload_local(req,value) {
      if (req.responseType==='text') {
        if (req.data_type==='html') value.response = parser.parseFromString(value.responseText, 'text/html');
        else if (req.data_type==='json') value.response = JSON.parse(value.responseText);
      }
      req.REQ.callback_1(req, value, req.REQ);
//        req.REQ.callback(req.key, value, req.callback_arg);
    }
    function onload_archive(req, value){
      if (typeof(req.archive)==='string') {
        archiver.download_url4(value.response, req.archive);
        return;
      }
      if (req.from && local) delete archiver.list_all_obj_downloading[req.from];
      var ignore_domain = pref.network.cross_domain!=='indirect';
      if ((req.domain_xhr||req.domain)===site.nickname || ignore_domain) {
        var suffix = req.kind + '_'+ req.url.replace(/.*\//g,'');
        if (req.to_file) archiver.download_url3(value.response, req, suffix, req.timestamp);
        if (req.to_idb) if (!pref.test_mode['65'] || !local) IDB.req(req.domain, req.board, req.no, suffix, value.response, 'put');
      }
      if (local && req.REQ.TAR_FLUSH) { // remote doesn't have 'req.REQ'
//        if (check_timestamp_and_flush(req.timestamp)) // flush local
        archiver.tar.flush((xhrs_count===0)? undefined : req.timestamp);
        for (var domain in req.REQ.TAR_FLUSH) send_message(domain,['HTTPD',['SUB_TAR_FLUSH',[(xhrs_count===0)? undefined : req.timestamp]]]); // flush remote
      }
    }
    function onload_archive_fail(req, value){
      if (req.from) delete archiver.list_all_obj_downloading[req.from]; // patch, retry code should be here.
    }
    function check_timestamp_and_flush(timestamp){
      if (reqs[0] && reqs[0][0] && reqs[0][0].timestamp === timestamp && reqs[0][0].tgts.length>0) return false;
//      if (reqs[0] && reqs[0][0] && reqs[0][0].timestamp === timestamp) return false;
      for (var i=0;i<reqs_waiting_finish.length;i++) if (reqs_waiting_finish[i].timestamp===timestamp) return false;
      archiver.tar.flush((xhrs_count===0)? undefined : timestamp);
      return true;
    }
    function end_proc_user(req, date){
      if (req.callback) req.callback(req); // this must be prior to report({end:}), because somefunc reports err_str to indicator.
      req.INDICATOR.report({end:date});
    }
    function sub_tar_flush(args){
      archiver.tar.flush(args[0]);
    }
    function sub_frame_init(){local=false;}
    function pause_cancel(){
      if (pause>0) {
        if (--pause>0) pause_timeout.delayed_do();
      } else {
        pause_timeout.cancel();
        dispatch_if_idle();
      }
    }
    var pause_timeout = new DelayBuffer(pause_cancel,10000);
    var sub_funcs = {SUB_GET:sub_get, SUB_ACK:sub_ack, SUB_FREE:free_xhrs, SUB_TAR_FLUSH:sub_tar_flush, SUB_FRAME_INIT:sub_frame_init};
    return {
      req: function(reqs_in, priority){
        if (!reqs[priority]) reqs[priority] = [reqs_in];
        else reqs[priority].push(reqs_in);
        if (reqs_in.tgts.length!==0) dispatch();
      },
      req_add: function(reqs_in, priority){
        if (!reqs[priority] || reqs[priority].length===0) reqs[priority] = [reqs_in]; // BUG, destroy prototype.
        else reqs[priority][reqs[priority].length-1].tgts = reqs[priority][reqs[priority].length-1].tgts.concat(reqs_in.tgts);
        dispatch_if_idle();
      },
      check_timestamp_and_flush: check_timestamp_and_flush,
      onload_archive: onload_archive,
      onload_archive_fail: onload_archive_fail,
      sub_funcs: function(args){
        sub_funcs[args[0]](args[1]);
      },
      pause_req: function(){
        pause++;
        pause_timeout.delayed_do();
      },
      pause_cancel: pause_cancel,
      set_health_indicator: function(val){health_indicator = val;},
      get isLocal(){return local;},
    };
  })();

  var http_req = { // emulation of old interface for uip tracker.
    get: function (sender,key,url,callback,sw_cache,sw_cache_write,callback_arg, archived){
      var dbt = (key.indexOf(',')==-1)? common_func.name2dbt(key): key.split(',');
      if (url==='') url = site2[dbt[0]].make_url4(dbt);
      else if (typeof(url)==='string') url = [ url, 'raw'];
      key = dbt.join(',');
      httpd.req({initiator:key,
                 tgts:[{url:url[0], responseType:(url[1]==='html')? 'document' : (url[1]==='raw')? 'text' : url[1], tgt:key, data_type:url[1], domain:dbt[0]}],
                 callback_1:function(req,val){callback(key,val,callback_arg);},
                 INDICATOR: {shift:function(){}, report:function(){}},
                 IDX:0, FINISHED:0, SUC:0, max:1,
                },6);
    },
  };

////  var http_req = (function(){ // working code.
////    var iframes = {};
//////    var caches = {}; // prevent occuring multiple access to the same url in short time.
////    var local = true;
////    var parser = new DOMParser();
////    var serializer = new XMLSerializer();
//////    var doc;
//////    var pool; // object pool
////    var reqs = {};
////    var Req = function(sender){
////      this.sender = sender;
////      this.req = null;
////      this.httpd = new XMLHttpRequest();
////      this.httpd.onload  = Req.prototype.onload.bind(this);
////      this.httpd.onerror = this.httpd.onload;
////      this.httpd.onabort = this.httpd.onload;
////    }
////    Req.prototype.onload = function(){
//////      if (local) onload_local(this.sender,{date: Date.now(), __proto__:this.httpd},false); // cause illegal invocation, I don't know why.
////      if (local) {
////        if (this.httpd.responseType==='text') onload_text(this.sender,{date: Date.now(), status: this.httpd.status, responseText: this.httpd.responseText},false); // temporaly patch.
////        else onload_local(this.sender,{date: Date.now(), status: this.httpd.status, response: this.httpd.response},false);
////      } else send_message('parent',[['SUB_ACK',[this.sender,Date.now(),this.httpd.status,this.httpd.responseText]]]);
////    };
////    function get_make_Req(sender, req){
////      if (reqs[sender]===undefined) reqs[sender] = new Req(sender);
////      if (req) reqs[sender].req = req;
////      return reqs[sender];
////    }
////    function destroy_httpd(sender){
////      delete reqs[sender];
////    }
////////    function make_httpd(sender){ // working code.
////////      var httpd = new XMLHttpRequest();
////////      function httpd_events(){
//////////        if (local) onload_local(sender,{date: Date.now(), status: httpd.status, responseText: httpd.responseText},false);
////////        if (local) {
////////          if (httpd.responseType==='text') onload_local(sender,{date: Date.now(), status: httpd.status, responseText: httpd.responseText},false); // temporaly patch.
////////          else onload_local(sender,{date: Date.now(), status: httpd.status, response: httpd.response},false);
////////        } else send_message('parent',[['SUB_ACK',[sender,Date.now(),httpd.status,httpd.responseText]]]);
////////      }
////////      httpd.addEventListener('load',  httpd_events, false);
////////      httpd.addEventListener('error', httpd_events, false);
////////      httpd.addEventListener('abort', httpd_events, false);
////////      httpds[sender] = [httpd, httpd_events];
////////    }
////////    function destroy_httpd(sender){
////////      if (sender in httpds) {
////////        var httpd = httpds[sender][0];
////////        var httpd_events = httpds[sender][1];
////////        httpd.removeEventListener('load',  httpd_events, false);
////////        httpd.removeEventListener('error', httpd_events, false);
////////        httpd.removeEventListener('abort', httpd_events, false);
////////        delete httpds[sender];
//////////if (pref.test_mode['30']) console.log('destroyed: '+site.nickname+'/'+sender)
////////      }
////////    }
////    function make_iframe(domain,url){
//////      var ifrm = cnst.init('left:200px:bottom:200px:display:none:Show'); // working code.
////////      var ifrm = cnst.init('left:200px:bottom:200px:' + ((pref.debug_mode['0'])? '' : 'display:none:') + 'Show');
////////      var ifrm = cnst.init('left:200px:bottom:200px:Show');
//////      ifrm.innerHTML = '<iframe name=' + domain + '></iframe>';
////      cnst.make_iframe(domain);
//////      try {
////        iframes[domain] = window.open((site2[domain].home!=='')? site2[domain].home : url, domain);
////        send_message(domain,[['SUBFRAME_INIT']],iframes[domain]);
//////      } catch (e) {
//////        console.log('IFRAME OPEN ERROR'); // not debugged yet.
//////      }
//////      iframes[domain].onerror = function(){console.log('IFRAME OPEN ERROR');}; // can't catch
////    }
////    function onload_from_sw_cache_check(key,value,args) {
////      if (value!==null) {
//////        var date = value[0];
//////        var req_date = Date.now() - args[4]*1000;
//////        if (date>req_date) {onload_from_sw_cache(key,value,args);return;}
////        if (args[4]===true || value.date > Date.now() - args[4]*1000) {onload_text(args[0],value,true);return;} // date check.
////      }
////      get_req(args[0],args[1],args[2],args[3],false,args[5]);
////    }
////    function onload_text(sender,value,from_cache) {
////      if (reqs[sender]) { // for 8chan's 524 error(Origin Time-out)
////        if (reqs[sender].req.data_type==='html') {
////          value.response = parser.parseFromString(value.responseText, 'text/html');
//////          delete value.responseText;
////        } else if (reqs[sender].req.data_type==='json') {
////          value.response = (value.status==200)? JSON.parse(value.responseText) : value.responseText;
////        }
////        onload_local(sender,value,from_cache);
////      }
//////      value.response = null;
////    }
////    function onload_local(sender,value,from_cache) {
////      if (!reqs[sender]) return;
////      var req = reqs[sender].req;
//////      if (!from_cache && data_type==='html') {
//////        doc = parser.parseFromString(value.responseText, 'text/html');
//////        site2.common.remove_by_tagname(doc,'script');
//////        doc.getElementsByTagName('head')[0].innerHTML = '';
////////        value = {date:value.date, status:value.status, responseText:serializer.serializeToString(doc)};
//////      }
//////      if (!from_cache && cache_write) {
////////        caches[key] = [date, value.status, response_txt];
////////        setTimeout(function(){delete caches[key];},10000);
////////        if (pref.info_server && brwsr.sw_cache && value.status==200) brwsr.sw_cache.setItem(key,[date, response_txt]);
////////        if (pref.info_server && brwsr.sw_cache && value.status==200) brwsr.sw_cache.setItem(key,[date, value.status, response_txt]);
//////        if (pref.info_server && brwsr.sw_cache && value.status==200) {
//////          if (data_type==='html') value = {date:value.date, status:value.status, responseText:serializer.serializeToString(doc)};
//////          brwsr.sw_cache.setItem(key,value);
//////        }
//////      }
//////      if (data_type==='html') {value.response = doc; delete value.responseText;} // trial patch.
//////      else if (data_type==='json') {value.response = JSON.parse(value.responseText); delete value.responseText;}
//////      callback(key, value, callback_arg);
////
////      if (!from_cache && req.data_type==='html' && value.response) {
//////        site2.common.remove_by_tagname(value.response,'script');
//////        var dbt = common_func.name2domainboardthread(key,true);
////        var dbt = req.key.split(',');
////if (pref.test_mode['28']) {
////        site2[dbt[0]].preprocess_doc(value.response);
////}
////if (pref.test_mode['50'] && site2[dbt[0]].preprocess_doc2 && site2[dbt[0]].preprocess_doc2[dbt[3]]) site2[dbt[0]].preprocess_doc2[dbt[3]](value.response);
////if (pref.test_mode['4']) {
////  site2[dbt[0]].remove_posts(value.response,pref.test_mode.num);
////  site2.common.remove_double_br(value.response);
////}
////        if (value.response.getElementsByTagName('head')[0]) value.response.getElementsByTagName('head')[0].innerHTML = '';
////      }
//////var check_perf = ['http_req :', performance.now()];
////      if (!from_cache && req.cache_write) {
////        if (pref.info_server && brwsr.sw_cache && value.status==200) {
////          if (req.data_type==='html') site2.common.remove_by_tagname(value.response,'script');
////          var value_sw_cache = (req.data_type==='html')? {date:value.date, status:value.status, responseText:serializer.serializeToString(value.response)}
////                                                       : {date:value.date, status:value.status, responseText:JSON.stringify(value.response)};
//////check_perf.push(performance.now());
////          brwsr.sw_cache.setItem(req.key,value_sw_cache);
//////check_perf.push(performance.now());
////        }
////      }
////// https://github.com/rtomayko/rack-cache/issues/111 Cache hit gives 200 instead of 304 when behind Nginx, Nginx + StringEtag + chrome.
////if (pref.test_mode['48'] && value.status===304) console.log('onload_local: 304, '+req.key);
////      req.callback(req.key, value, req.callback_arg);
//////if (sender==='catalog') common_func.perf_out(check_perf);
////    }
////    function get_req(sender,domain,url,key,sw_cache,data_type, archived){
//////      if (caches[key]) setTimeout(function(){onload_local(sender,{date: caches[key][0], status: caches[key][1], responseText: caches[key][2]},true);},0); // this make racing condition at checking page in catalog.
////      if ((sw_cache===true || (typeof(sw_cache)==='number' && sw_cache!=0)) && brwsr.sw_cache)
////        brwsr.sw_cache.trygetItem(key,onload_from_sw_cache_check,[sender,domain,url,key,sw_cache,data_type]);
////      else {
////        if (domain==site.nickname || pref.catalog_cross_domain_connection=='direct') {
////          var httpd = get_make_Req(sender).httpd;
////          httpd.open('GET', url, true);
////          httpd.responseType = (archived)? 'text' : (data_type==='html')? 'document' : (data_type==='json')? 'json' : 'text';
////          httpd.send(null);
////        } else {
////          if (!iframes[domain]) make_iframe(domain,url);
////          send_message(domain,[['SUB_GET',[sender,domain,url,key,sw_cache,'text']]]);
////        }
////      }
////    }
////    return {
////      get: function (sender,key,url,callback,sw_cache,sw_cache_write,callback_arg, archived){
////        var dbt = (key.indexOf(',')==-1)? common_func.name2dbt(key): key.split(',');
////        if (url==='') url = site2[dbt[0]].make_url4(dbt);
////        else if (typeof(url)==='string') url = [ url, 'raw'];
////        key = dbt.join(',');
////        get_make_Req(sender, {url:url[0], callback:callback, key:key, sw_cache:sw_cache, sw_cache_write:sw_cache_write, callback_arg:callback_arg, data_type:url[1]});
////        get_req(sender,dbt[0],url[0],key,sw_cache,url[1], archived);
////      },
////////////      get: function (sender,key,url,callback,sw_cache,sw_cache_write,callback_arg){ // working code.
////////////        var dbt = cnst.name2domainboardthread(key,true);
////////////        key = dbt[0]+dbt[1]+dbt[2];
////////////        if (url==='')
////////////          if (dbt[2][0]==='c' || dbt[2][0]==='p' || dbt[2][0]==='j') url = site2[dbt[0]].make_url(dbt[1],parseInt(dbt[2].substr(1),10),dbt[2][0]);
////////////          else url = [site2[dbt[0]].make_url3(dbt[1],dbt[2]), (dbt[2][0]!=='t')? 'html' : 'json'];
////////////        if (typeof(url)==='string') url = [ url, 'raw'];
////////////        req[sender] = {url:url[0], callback:callback, key:key, sw_cache:sw_cache, sw_cache_write:sw_cache_write, callback_arg:callback_arg, data_type:url[1]};
////////////        get_req(sender,dbt[0],url[0],key,sw_cache,url[1]);
////////////      },
////      close:   function(sender){
////        destroy_httpd(sender);
////        if (!pref.test_mode['30']) for (var domain in iframes) send_message(domain,[['SUB_DEST',[sender]]]);
////      },
////      sub_dest: function(args){destroy_httpd(args[0]);},
////      sub_get: function(arg){get_req(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5]);},
////      sub_ack: function(arg){
////        var value =  {date: arg[1], status: arg[2], responseText: arg[3]};
////        onload_text(arg[0], value, false);
////if (pref.test_mode['34']) send_message('meguca',[['ECHO',arg]]);
////      },
////      remote : function(){local=false;}
////    };
////  })();

//  var http_req = (function(){ // working code, but chokes when and err occur.
//    var reqs = [];
//    var caches = {}; // prevent occuring multiple access to the same url in short time.
//    var httpd = new XMLHttpRequest();
//    var httpd_events = function(){onload_local(httpd.status,httpd.responseText);}; // for local
//    httpd.addEventListener('load',  httpd_events, false);
//    httpd.addEventListener('error', httpd_events, false);
//    httpd.addEventListener('abort', httpd_events, false);
//    
//    function onload_local(status,response_txt) {
//      var req = reqs[0];
//
//      if (req[1]!=null) req[1](status, response_txt);
//        if (pref.info_server && brwsr.sw_cache)
//          brwsr.sw_cache.setItem(req[2]+req[3]+req[4],JSON.stringify([Date.now(), response_txt]));
//
//      prep_next();
//    }
//    function prep_next() {
//      reqs.shift();
//      if (reqs.length!=0) req_get(true); // javascript doesn't allow multiphe threads in a program, so this works well.
//    }
//    function req_get(force) {
//      if (!force && reqs.length>=2) return;
//      var url = reqs[0][0];
//      if (reqs[0][2]==site.nickname || pref.catalog_cross_domain_connection=='direct') {
//        httpd.open('GET', url, true);
//        httpd.send(null);
//      } else {
//        var domain = reqs[0][2];
//        if (!iframes[domain]) {
////          iframes[domain] = [window.open(url,domain), 0];
////          var ifrm = cnst.init('left:300px:bottom:300px:Show');
//          var ifrm = cnst.init('left:300px:bottom:300px:display:none:Show');
//          ifrm.innerHTML = '<iframe name=' + domain + '></iframe>';
//          iframes[domain] = [window.open(url,domain), 0];
//          send_message(domain,[['SUBFRAME_INIT']]);
//        }
//        send_message(domain,[['SUB_GET',reqs[0]]]);
//        iframes[domain][1]++;
//      }
//    }
//    return {
//      get: function(url,callback,domain,board,page,sw_cache,sender){
//        reqs.push([url,callback,domain,board,page,sw_cache,sender]);
//        req_get(false);
//      },
//      remote: function(){
//        httpd.removeEventListener('load',  httpd_events, false);
//        httpd.removeEventListener('error', httpd_events, false);
//        httpd.removeEventListener('abort', httpd_events, false);
//        httpd_events = function(){
//          send_message('parent',[['SUB_ACK',httpd.status, httpd.responseText]]);
//          prep_next();
//        };
//        httpd.addEventListener('load',  httpd_events, false);
//        httpd.addEventListener('error', httpd_events, false);
//        httpd.addEventListener('abort', httpd_events, false);
//      },
//      onload_local: onload_local
//    };
//  })();

  var cnst = (function(){
    var opts = new WeakMap();
    var tb_funcs = {
      op_p: function(e){
        var s = e.currentTarget.parentNode.style;
        var op = parseFloat(s.opacity) || 1;
        s.opacity = (e.target.name==='op_p')? ((op+0.1>=1)? 1 : op+0.1)
                                            : ((op-0.1<=0.1)? 0.1: op-0.1);
      },
      roll_toggle: function(e, options){
        if (options.cn.style.display=='none') this.rolldown(options);
        else this.rollup(options);
      },
      roll_if_auto: function(e, from_start){
        var options = opts.get(e.currentTarget);
        if (!options) return; // for popup
        if (from_start) {
          if (options.auto_roll && options.cn.style.display!=='none') {
            this.rollup(options);
            options.auto_unroll = true;
          }
        } else if (options.auto_unroll && options.cn.style.display==='none') {
          this.rolldown(options);
          options.auto_unroll = false;
        }
      },
      rolldown: function(options){
        options.tb.style.width = '';
        options.cn.style.display = ''; // for dollchan
        if (options.rolldown) options.rolldown.call(options.this_obj);
      },
      rollup: function(options){
        options.tb.style.width = options.tb.offsetWidth + 'px'; // for dollchan
        options.cn.style.display = 'none'; // for dollchan
        if (options.rollup) options.rollup.call(options.this_obj);
      },
      top: function(e, options){
        this.maximize(options.pn, options.tb, options.cn, e.target.name, options, e.target);
      },
//    var state_arr = ['top','bottom','float','max']; // ['top','bottom','max','float']; // changed 2018.03.30, probably a bug.
      maximize: function(pn,tb,cn, req, options, button_pressed){
        var state = options.maximize_state;
        var now = state[0];
  //      if (options.before_maximize) options.before_maximize(state_str, now);
        state[5].style.display = null;
        var cns = (options.maximize_tgt || cn).style; 
        if (now==='float') state = [req, pn.style.left, pn.style.top, cns.width, cns.height, button_pressed, pn.style.right, pn.style.bottom];
        else {state[0] = req; state[5] = button_pressed;}
        if (req==='max') {
          var header_height = site.header_height();
          common_func.overwrite_prop(pn.style, {left:'0px', top:header_height + 'px', position:'fixed', resize:'none', zIndex:pref.style.zIndex});
          common_func.overwrite_prop(cns,
            {width: document.documentElement.clientWidth + 'px', height: document.documentElement.clientHeight - tb.offsetHeight - header_height + 'px', resize:'none'});
        } else if (req==='float'){
          common_func.overwrite_prop(pn.style, {left:state[1], top:state[2], position:'fixed', resize:'both', right:state[6], bottom:state[7], zIndex:pref.style.zIndex});
//          common_func.overwrite_prop(cns, {width:state[3], height:state[4], resize:'both'});
          common_func.overwrite_prop(cns, options.maximize_float_style_pnch1 || {width:state[3], height:state[4], resize:'both'});
        } else {
          var ref = site.embed_to[req]; // 'top' or 'bottom'
          if (ref){
            if (typeof(site.embed_to[req])=='function') ref = site.embed_to[req] = site.embed_to[req](); // lazy evaluation
            common_func.overwrite_prop(pn.style, {left:'auto', top:'auto', position:'relative', resize:'none', right:'auto', bottom:'auto', zIndex:null});
//            common_func.overwrite_prop(pn.style, options.maximize_embed_style_pn || {left:'auto', top:'auto', position:'static', resize:'none'});
            common_func.overwrite_prop(cns, options.maximize_embed_style_pnch1 || {width:'auto', height:'auto', resize:'none'});
//            common_func.overwrite_prop(cns, {width:'auto', height:'auto', resize:'none'});
            ref.parentNode.insertBefore(pn,ref);
          }
        }
        button_pressed.style.display = 'none';
        options.maximize_state = state;
        if (options.maximize) options.maximize.call(options.this_obj, req, now);
      },
      exit: function(e, options){
        if (options.exit) options.exit.call(options.this_obj,e);
        else cnst.div_destroy(options.pn, true);
      },
      settings: function(e, options){
        if (!pref.test_mode['102'] && !options) return; // patch for embed
        var btn = (e.target.tagName==='BUTTON')? e.target : e.target.parentNode;
        var tgt = opts.get(btn) || options.cn.childNodes[0];
        tgt.style.display = (tgt.style.display==='none')? null : 'none';
        cnst.toggleButton(btn);
      },
    };
    tb_funcs.op_m = tb_funcs.op_p;
    tb_funcs.bottom = tb_funcs.top;
    tb_funcs.float = tb_funcs.top;
    tb_funcs.max = tb_funcs.top;
//    tb_funcs.filter = tb_funcs.settings;
    function tb_clicks(e){
      var et = e.target;
      var func = (e.type==='click')? et.tagName==='BUTTON' && tb_funcs[et.name] || et.parentNode.tagName==='BUTTON' && tb_funcs[et.parentNode.name]
                                   : (et.tagName==='DIV' || et.tagName==='SPAN') && tb_funcs['roll_toggle']; // double click
      if (func) {
        e.stopPropagation();
        func.call(tb_funcs, e, opts.get(e.currentTarget.parentNode));
      }
    }
    function ev_to_close(e){
      e.stopPropagation();
      tb_funcs.exit.call(tb_funcs, e, opts.get(e.currentTarget.parentNode));
    }
//    function tb_dblclick(e){
//      if (e.target.tagName==='DIV' || e.target.tagName==='SPAN') tb_funcs['roll_toggle'](e);
//    }
    function tack_float(e){
      var obj = opts.get(e.currentTarget);
      (obj && obj.float || cnst.tack_float_nSblgs)(e);
    }
    function tack_dock(e){
      var obj = opts.get(opts.get(e.currentTarget.parentNode).tack);
      (obj && obj.embed || cnst.tack_dock_nSblgs)(e);
    }

    function tb_mousedown2(e){
      prep_drag(e, e.currentTarget.parentNode.parentNode);
    }
    function tb_mousedown(e){
      prep_drag(e, e.currentTarget.parentNode);
    }
//    function flip_top(s){
//      return bottom2top(s,{offsetHeight:0});
//    }
    function bottom2top(s,pn){ // can be used as top2bottom also.
      return document.documentElement.clientHeight - parseInt(s, 10) - pn.offsetHeight;
    }
    function right2left(s,pn){
      return document.documentElement.clientWidth - parseInt(s, 10) - pn.offsetWidth;
    }
    function div_mousedown(e){
      if (!pref.proto.popup2_resize || !div_resize_on_border(e))
        if (!(pref.proto.popup2_sel==='sel' || mouse_cursor_on_text(e)))
          if (!pref[cataLog.embed_mode].thumbnail.hover.dragfloat || !cataLog.DIH || !cataLog.DIH.hover_ex) prep_drag(e, e.currentTarget);
    }
    var resize_tlbr = null;
    function div_resize_on_border(e){
      var ecT = e.currentTarget;
      var s = ecT.style;
      var top = e.clientY - ((s.top)? parseInt(s.top, 10) : bottom2top(s.bottom,ecT));
      var left = e.clientX - ((s.left)? parseInt(s.left, 10) : right2left(s.right,ecT));
      var bottom = ecT.offsetHeight - top;
      var right = ecT.offsetWidth - left;
      var tlbr = [top, left, bottom, right];
      for (var i=0;i<4;i++) if (tlbr[i]<=pref.proto.popup2_resize_bw) {
        for (var j=0;j<4;j++) tlbr[j] = (tlbr[j]<=pref.proto.popup2_resize_cw)? parseInt(window.getComputedStyle(ecT)[j%2?'width':'height'],10) : null;
        document.body.addEventListener('mouseup', div_mouseup_resize, false);
//        document.body.addEventListener('mousemove', div_mousemove_resize, false); // NOT STABLE, causes mouseout.
        document.body.addEventListener('dragend', div_mouseup_resize, false);
        document.body.addEventListener('drag', div_mousemove_resize, false);
        drag_sx = e.screenX;
        drag_sy = e.screenY;
        tlbr.push(parseInt(s.top,10), parseInt(s.left,10), parseInt(s.bottom,10), parseInt(s.right,10), ecT);
        resize_tlbr = tlbr;
        e.stopPropagation();
        ecT.draggable = true;
//        ecT.style.cursor = (tlbr[0] && tlbr[1] || tlbr[2] && tlbr[3])? 'nwse-resize'
//                         : (tlbr[0] && tlbr[3] || tlbr[2] && tlbr[1])? 'nesw-resize'
//                         : (tlbr[0] || tlbr[2])? 'row-resize': 'col-resize';
        return true;
      }
      return false;
    }
    function div_mousemove_resize(e){
      if (e.screenX===0) return; // BUG of chome??? Last event contains error value.
      var tlbr = resize_tlbr;
      var pn = tlbr[8];
      var s = pn.style;
      var dx = e.screenX - drag_sx;
      var dy = e.screenY - drag_sy;
      if (tlbr[0]) {s.height = tlbr[0] - dy + 'px'; if (s.top)    s.top    = tlbr[4] + dy + 'px';}
      if (tlbr[1]) {s.width  = tlbr[1] - dx + 'px'; if (s.left)   s.left   = tlbr[5] + dx + 'px';}
      if (tlbr[2]) {s.height = tlbr[2] + dy + 'px'; if (s.bottom) s.bottom = tlbr[6] - dy + 'px';}
      if (tlbr[3]) {s.width  = tlbr[3] + dx + 'px'; if (s.right)  s.right  = tlbr[7] - dx + 'px';}
      e.stopPropagation();
    }
    function div_mouseup_resize(e){
      var ecT = e.currentTarget;
      ecT.removeEventListener('drag', div_mousemove_resize, false);
      ecT.removeEventListener('dragend', div_mouseup_resize, false);
//      ecT.removeEventListener('mousemove', div_mousemove_resize, false);
      ecT.removeEventListener('mouseup', div_mouseup_resize, false);
      e.stopPropagation();
      ecT.draggable = false;
      resize_tlbr = null;
//      ecT.style.cursor = null;
    }
    function prep_drag(e, pn){
      pn.draggable = true;
      pn.addEventListener('dragstart', div_dragstart_dynamic, false);
      pn.addEventListener('mouseup', div_mouseup, false);
      e.stopPropagation();
    }
    function div_mouseup(e){
      e.currentTarget.removeEventListener('mouseup', div_mouseup, false);
      e.currentTarget.draggable = false;
    }
    function mouse_cursor_on_text(e){
      if (e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA' || e.target.tagName==='SELECT') return true;
      if (pref.proto.popup2_sel==='move') return false;
      var et_cn = e.target.childNodes;
//      if (et_cn.length===1) return et_cn[0].nodeType===3; // textNode
      var range = new Range();
      for (var i=0;i<et_cn.length;i++) {
        var tx = (et_cn[i].tagName==='BUTTON' || et_cn[i].tagName==='SELECT')? 0 : pref.proto.popup2_sel_tolerance;
        range.selectNode(et_cn[i]);
        var rects = range.getClientRects();
        for (var j=0;j<rects.length;j++) {
          var rect = rects[j];
          if (rect.bottom>e.clientY && e.clientY>=rect.top)
            if (rect.left-tx < e.clientX && e.clientX < rect.right+tx) return true;
        }
      }
      return false;
    }
    var drag_sx;
    var drag_sy;
//    var drag_cursor_style;
    var root_body = document.body;
    function div_dragstart_dynamic(e){ // with tb or popup
      e.currentTarget.removeEventListener('dragstart', div_dragstart_dynamic, false);
      e.currentTarget.removeEventListener('mouseup', div_mouseup, false);
      tb_funcs.roll_if_auto(e, true);
      div_dragstart(e, true)
    }
    function div_dragstart(e, dynamic){ // static
      var cT = e.currentTarget;
//      if (this.pn) this.pn.removeEventListener('dragstart', this.event_funcs.dragstart, false);
      drag_sx = e.screenX;
      drag_sy = e.screenY;
//      drag_cursor_style = pn.style.cursor;
//      pn.style.cursor = 'move';
      e.dataTransfer.setData('text/plain', ''); // for FF. CH doesn't require this.
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.dropEffect = 'move';
//      e.preventDefault();
      e.stopPropagation(); // prevent from invoking twice when legend on chart is moved.
      cT.style.opacity = 0.4;
//      div_dragend_caller = this;
      cT.addEventListener('dragend', (dynamic)? div_dragend_dynamic : div_dragend, false);
      root_body.addEventListener('dragover',div_dragover,false);
    }
    function div_dragover(e){ // http://www.html5rocks.com/ja/tutorials/dnd/basics/
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    }
//    var div_dragend_caller;
    function div_dragend_dynamic(e){
      div_dragend(e, true);
      tb_funcs.roll_if_auto(e, false);
      e.currentTarget.draggable = false;
    }
    function div_dragend(e, dynamic){
      root_body.removeEventListener('dragover',div_dragover,false);
      var cT = e.currentTarget;
      var s = cT.style;
      cT.removeEventListener('dragend', (dynamic)? div_dragend_dynamic : div_dragend, false);
      if (s.left) s.left  = (parseInt(s.left ,10) + e.screenX - drag_sx) + 'px';
      else        s.right = (parseInt(s.right,10) - e.screenX + drag_sx) + 'px';
      if (s.bottom) s.bottom = (parseInt(s.bottom,10) - e.screenY + drag_sy) + 'px';
      else          s.top =    (parseInt(s.top   ,10) + e.screenY - drag_sy) + 'px';
//      if (div_dragend_caller.dragend) div_dragend_caller.dragend.call(div_dragend_caller.this_obj,e); // isn't used anymore.
//      div_dragend_caller = null;
      s.opacity = 1;
      e.stopPropagation();
    }
    function div_scroll(e){
      var val = (!brwsr.ff)? e.wheelDelta : -e.detail*40;
      var s = e.currentTarget.style;
      if (s.bottom) s.bottom = (parseInt(s.bottom,10) - val) + 'px'; // from bottom.
      else s.top = (parseInt(s.top,10) + val) + 'px';
      e.preventDefault();
    }
    var tile = {
      left   : 0,
      bottom : 0,
      last_pn: null, // CAUTION. grep last pn permanently.
    };
    return {
      init3: function(obj){
        return this.init(obj.func_str,null,null,null,null,obj.pn_st, obj);
      },
      init2: function(obj){
        return this.init(obj.func_str,obj.rolldown_func,obj.rollup_func,obj.exit_func,obj.maximize_func,obj.pn_st);
      },
      init: function(func_str,rolldown_func,rollup_func,exit_func,maximize_func,site_settings, options){
        var options_is_given = (options!==undefined);
        if (options===undefined) options = { // options WILL BE this.
          rolldown: rolldown_func,
          rollup: rollup_func,
          exit: exit_func,
          maximize: maximize_func,
        };
        var pn = document.createElement('span');
        options.pn = pn; // must be prior to 'tb_press'
        if (site_settings) {
          pn.textContent = ' '+func_str.replace(/.*:button:/,'').replace(/:.*/,'');
          pn.setAttribute('style','cursor:pointer');
          site_settings.appendChild(document.createTextNode(' '));
          site_settings.appendChild(pn);
          return pn;
        }
//        var pn = document.createElement('div');
        if (!pn.style) pn.style = {};
        pn.style.position = 'fixed';
        pn.draggable = true;
        pn.style.padding = '0px';
        pn.style.zIndex = pref.style.zIndex;
        pn.style.float = 'left'; // for embed_to_top/bottom
        pn.style.display = 'inline-block';
        var funcs = func_str.split(':');
        var i=0;
        if (funcs[0]!='pop') {
//          pn.style.background = '#e5ecf9';
//          pn.style.color = '#000000';
//          pn.style.fontWeight = 'normal';
//          pn.style.border = '1px solid blue';
//          pn.style.border = 'none';
        } else {
          var pop = true;
          pn.addEventListener(brwsr.mousewheel, div_scroll, false);
          pn.name = 'catalog_pop';
          i=1;
          pn.draggable = false;
        }
        pn.setAttribute('class', pref.script_prefix+'_window');
//        var rollup_func_tb = null;
        var tgt = pn;
        while (i<funcs.length) {
          var arg = funcs[i++];
          if (arg=='tb') {
            pn.setAttribute('class', pref.script_prefix+'_titleBar');
            pn.innerHTML = pref_func.format_html_str('<div style="height:auto;overflow:hidden">' +
                '<div style="float: left"><BTN"roll_toggle,-"><BTN"op_m,&lt;"><BTN"op_p,&gt;"><span style="width:16px;display:inline-block"></span></div>' +
                '<div style="float: right"><BTN"top,^"><BTN"bottom,v"><BTN"float,o" style="display:none"><BTN"max,[]"><BTN"exit,X"></div>' +
                '<div></div>' +
              '</div>' +
              '<div class="' + pref.script_prefix + '_window" style="margin: 0px 3px 3px 3px;clear:both"></div>');
            var tb = pn.childNodes[0];
            var cn = pn.childNodes[1];
//            tb.childNodes[2].style.height = tb.childNodes[0].offsetHeight + 'px';
//            tb.childNodes[0].style.cursor = 'move';
//            tb.childNodes[2].style.cursor = 'move';
//            rollup_func_tb = function(){rollup(pn,pn.childNodes[1], options);};
//            tb.childNodes[0].childNodes[0].onclick = rollup_func_tb;
//            tb.childNodes[0].childNodes[1].onclick = function(){opacity(pn, false);};
//            tb.childNodes[0].childNodes[2].onclick = function(){opacity(pn, true);};
//            tb.childNodes[0].childNodes[3].ondblclick = rollup_func_tb;
//            tb.childNodes[2].ondblclick = rollup_func_tb;
            options.maximize_state = ['float',null,null,null,null,tb.childNodes[1].childNodes[2]];
//            options.maximize_state_str = 'float';
//            tb.childNodes[1].childNodes[0].onclick = function(){maximize(pn,tb,0, options);}; // can reduce footprint if 'prototype' is used.
//            tb.childNodes[1].childNodes[1].onclick = function(){maximize(pn,tb,1, options);};
//            tb.childNodes[1].childNodes[2].onclick = function(){maximize(pn,tb,2, options);};
//            tb.childNodes[1].childNodes[3].onclick = function(){maximize(pn,tb,3, options);};
//            tb.childNodes[1].childNodes[4].onclick = (options.this_obj)? options.exit.bind(options.this_obj) : options.exit;
//            if (brwsr.ff) {
            pn.draggable = false;
//            tb.childNodes[0].draggable = true;
//            tb.childNodes[2].draggable = true;
//            }
            tgt = pn.childNodes[1];
            tb.onclick = tb_clicks;
            tb.ondblclick = tb_clicks;
//            tb.ondblclick = tb_dblclick;
            tb.childNodes[0].onmousedown = tb_mousedown2; // these will be removed.
            tb.childNodes[1].onmousedown = tb_mousedown2;
            tb.childNodes[2].onmousedown = tb_mousedown2;
            tb.onmousedown = tb_mousedown;
            options.tb = tb;
            options.cn = cn;
            opts.set(pn,options);
          } else if (arg=='ftb') {
            tb.childNodes[0].removeChild(tb.childNodes[0].childNodes[0]);
            pn.insertBefore(cn,tb);
            var s = tb.style;
            s.position = 'absolute';
            s.top = '0px';
            s.width = '100%';
            cn.style.margin = '3px';
            tb.classList.add(pref.script_prefix+'_autoTp');
            var pf = pref[cataLog.embed_mode].thumbnail.hover;
            if (pf.df_dblC) cn.ondblclick = ev_to_close;
            tb.ondblclick = ev_to_close;
            if (pf.df_mW) pn['on'+brwsr.mousewheel] = div_scroll;
          } else if (arg=='tb_press') {
            var btn = funcs[i++];
            if (btn!=='float') tb_clicks({target:tb.getElementsByTagName('button')[btn], currentTarget:tb, type:'click', stopPropagation:function(){}});
          } else if (arg=='embed') {
            tb.childNodes[0].onmousedown = null; // overwrite
            tb.childNodes[1].onmousedown = null;
            tb.childNodes[2].onmousedown = null;
            tb.onmousedown = null;
          } else if (arg=='bottom_top') {
            this.bottom_top(pn);
          } else if (arg=='txt' || (brwsr.ff && arg=='button')) {
            tgt.appendChild(document.createTextNode(funcs[i++]));
            tgt.style.cursor = 'pointer';
            tgt.style.padding = '2px 5px 2px 5px';
          } else if (arg=='button') {
            tgt.innerHTML = '<input type="button" value="' + funcs[i++] + '">';
//            tgt.innerHTML = '<button draggable="true">' + funcs[++] + '</button>';
            tgt.style.padding = '0';
            tgt.style.border = '0';
            tgt.style.background = 'none';
          } else if (arg=='Show2') {
            if (site.root_body!==site.root_body2 && site.root_body2) {
              pn.style.position = 'static';
              site.root_body2.appendChild(pn);
            } else site.root_body.appendChild(pn);
          } else if (arg=='Show') site.script_body.appendChild(pn);
//          } else if (arg=='Show') site.root_body.appendChild(pn);
          else if (arg=='tile' || arg=='tile2') {
            if (funcs[i++]=='set') {
              if (funcs[i]=='left') {tile[funcs[i]] = parseInt(pn.style[funcs[i]].replace(/px/,''),10) + pn.offsetWidth;i++;}
              else {tile[funcs[i]] = parseInt(pn.style[funcs[i]].replace(/px/,''),10) + pn.offsetHeight;i++;}
            } else if (arg==='tile') {pn.style[funcs[i]] = tile[funcs[i]]+'px';i++;} // tile:get
            else {pn.style[funcs[i]] = tile[funcs[i]]+parseInt(funcs[i+1],10)+'px';i+=2;} // tile2:get
            
//            console.log(tile);
          } else tgt.style[arg] = funcs[i++];
        }
//        options.event_funcs = {};
        if (tb || pop) pn.addEventListener('mousedown', div_mousedown, false);
        else pn.addEventListener('dragstart', div_dragstart, false);
//        options.event_funcs.dragstart = div_dragstart.bind(options);
//        pn.addEventListener('dragstart', options.event_funcs.dragstart, false);
        tile.last_pn = pn;
//        options.rollup_func_tb = rollup_func_tb;
        if (options_is_given) return options;
        return pn;
//        return (rollup_func_tb)? [pn,rollup_func_tb] : pn;
      },
      tile_set_bottom: function(){if (tile.last_pn) tile.bottom = tile.last_pn.offsetHeight;},
      tile_set_left: function(){if (tile.last_pn) tile.left = tile.last_pn.offsetWidth;},
//      top2bottom: bottom2top,
      left2right: right2left,
//      flip_top: flip_top,
      bottom_top: function(pn){
        var s = pn.style;
        if (s.bottom) {
          s.top = bottom2top(s.bottom,pn) + 'px';
          s.bottom = null;
        }
        if (s.right) {
          s.left = right2left(s.right,pn) + 'px';
          s.right = null;
        }
      },
      void_func: function(){},
      div_mousedown: div_mousedown,
      div_dragstart: div_dragstart,
      div_scroll: div_scroll,
      div_destroy: function(pn,child_of_body, options){
//        pref_func.tooltips.remove_hier(pn);
//        pref_func.tooltips.remove_root(pn);
        if (child_of_body) pn.parentNode.removeChild(pn);
        if (pn.name || opts.has(pn)) pn.removeEventListener('mousedown', div_mousedown, false);
        else pn.removeEventListener('dragstart', div_dragstart, false);
//        pn.removeEventListener('dragstart', (options)? options.event_funcs.dragstart : div_dragstart, false);
        if (pn.name) pn.removeEventListener(brwsr.mousewheel, div_scroll, false);
        return null;
      },
      tb_prep_for_embed: function(tb){
        tb.childNodes[0].innerHTML = '';
        tb.childNodes[1].innerHTML = '';
//        tb.childNodes[0].draggable = false;
//        tb.childNodes[3].ondblclick = null;
//        tb.childNodes[3].draggable = false;
        tb.childNodes[3].removeAttribute('style');
        tb.ondblclick = null;
        tb.onmousedown = null;
        tb.childNodes[2].onmousedown = null;
      },
      add_to_tb: function(pn,str){
        var pn_2 = document.createElement('div');
        pn_2.style.float = 'right'; // doesn't work on FF
        pn_2.style.resize = 'none';
        pn_2.style.overflow = 'visible';
        pn_2.innerHTML = str;
        pn.childNodes[0].insertBefore(pn_2,pn.childNodes[0].childNodes[pn.childNodes[0].childNodes.length-1]);
//        if (brwsr.ff) pn.childNodes[0].childNodes[2].setAttribute('style','float: right');
        if (brwsr.ff) pn_2.setAttribute('style','float: right');
        return pn_2;
      },
      show_hide: function(pn,pn2, pn3){
        if (pn.style.display=='none') {
          pn.style.display='';
          if (pn2) pn2.style.height = parseInt(pn2.style.height.replace(/px/,''),10) - pn.offsetHeight + 'px'; // May not work? It depends on the timing of invoking rendering engine. Chrome is ok.
          if (pn3) pn3.style.top    = parseInt(pn3.style.top.replace(/px/,''),10)    + pn.offsetHeight + 'px';
        } else {
          if (pn2) pn2.style.height = parseInt(pn2.style.height.replace(/px/,''),10) + pn.offsetHeight + 'px';
          if (pn3) pn3.style.top    = parseInt(pn3.style.top.replace(/px/,''),10)    - pn.offsetHeight + 'px';
          pn.style.display='none';
        }
      },
//      rollup: function(tb,pn){rollup(tb,pn,cnst.void_func,cnst.void_func);},
      name2domainboardthread: common_func.name2domainboardthread,
//      name2domainboardthread: function(name,fill){
//        var thread = name.replace(/[^\/]*\//g,'');
//        var domain = name.replace(/\/.*/,'');
//        var board  = name.replace(new RegExp('^'+domain),'').replace(new RegExp(thread+'$'),'');
//        if (thread==domain)
//          if (thread.search(/[^0-9]/)!=-1) thread ='';
//          else domain = '';
//        if (fill) {
//          if (domain==='') domain = site.nickname;
//          if (board==='') board = site.board;
//        }
//        return [domain,board,thread];
//      },
      get_time: function(){
        var now = new Date();
        var hour = now.getHours();
        var min = now.getMinutes();
        var sec = now.getSeconds();
        if(hour<10) hour = '0' + hour;
        if(min<10)  min  = '0' + min;
        if(sec<10)  sec  = '0' + sec;
        return hour + ':' + min + ':' + sec;
      },
      make_destroy: function(parent,key,func_make,func_destroy){
        if (!parent[key]) parent[key] = func_make();
        else parent[key] = func_destroy();
      },
      make_popup: function(parent,tgt,html,onchange_func){
        parent[tgt] = cnst.init('left:0px:tile:get:bottom:Show:tb',cnst.void_func,cnst.void_func, function(){
            parent[tgt] = cnst.div_destroy(parent[tgt], true);
          },cnst.void_func);
        parent[tgt].childNodes[1].innerHTML = html;
        pref_func.add_onchange(parent[tgt].childNodes[1],onchange_func);
      },
      make_iframe: function(name){
        if (site2[name] && site2[name].X_FRAME_OPTIONS && pref.network.overXFO || site2[site.nickname].CONTENT_SECURITY_POLICY_FRAME && pref.network.overCSPF) {
//           setTimeout(function(){window.focus();},2000); // this doesn't effect.
          return;
        }
        var ifrm = document.createElement('iframe');
        ifrm.name = name;
        ifrm.setAttribute('style','display:none');
        site.script_body.appendChild(ifrm);
        return ifrm;
      },


      subscribe: function(container, tgt){ // for [] container.
        container.push(tgt);
      },
      unsubscribe: function(container, tgt){
        var idx = container.indexOf(tgt);
        if (idx!=-1) container.splice(idx,1);
      },
      foreach: function(container, func){
        for (var i=0;i<container.length;i++) func(container[i]);
      },
      auto_shrink_board_selector: (function(){
        var sels = [];
        function focus(){
          this.removeAttribute('style');
          for (var j=0;j<this.length;j++) {
            this.options[j].text = pref.catalog_board_list_obj[j][0].key;
            color(this.options[j],j);
          }
        }
        function blur(){
          for (var j=0;j<this.length;j++)
            if (j!=this.selectedIndex) this.options[j].text = '';
          color(this,this.selectedIndex);
        }
        function prep(sel, idx){
          if (idx===undefined) idx = sel.selectedIndex;
          sel.length=0;
          for (var j=0;j<pref.catalog_board_list_obj.length;j++) {
            sel.length++;
            sel.options[sel.length-1].text = pref.catalog_board_list_obj[j][0]['key'];
          }
          sel.selectedIndex = (idx>=sel.length)? 0 : idx;
          sel.onblur();
        }
        function color(pn,idx){
          if (pref3.stats.use && (pref.stats.auto_acquisition || pref.stats.auto_acquisition_all) && stats.query_auto_acquisition(idx)) pn.setAttribute('style','background:#b5fbda');
          else pn.removeAttribute('style');
        }
        return {
          setup: function(sel, idx){
            sel.onfocus = focus;
            sel.onblur = blur;
            prep(sel, idx);
            cnst.subscribe(sels,sel);
          },
          str_changed: function(){
            cnst.foreach(sels,prep);
          },
          destroy: function(sel){
            cnst.unsubscribe(sels,sel);
          },
          color: function(){
            cnst.foreach(sels,function(inst){color(inst,inst.selectedIndex);});
          },
        };
      })(),
      auto_shrink_selector: (function(){
        var options = Object.create(null);
        function focus(){
          var opts = options[this.getAttribute('name')];
          for (var j=0;j<this.length;j++) if (this.options[j].text==='') this.options[j].text = opts[j];
        }
        function blur(){
          var opts = [];
          for (var j=0;j<this.length;j++) {
            opts[j] = this.options[j].text;
            if (j!=this.selectedIndex) this.options[j].text = '';
          }
          options[this.getAttribute('name')] = opts;
        }
        return function(sel){
          sel.onfocus = focus;
          sel.onblur = blur;
          sel.onblur();
        };
      })(),
      config_expander: (function(){
        function make_opts(){
          var num = pref[cataLog.embed_mode].t2h_num_of_posts;
          return ['Same as the page', pref[cataLog.embed_mode].t2h_L + ' posts', pref[cataLog.embed_mode].t2h_M + ' posts',
                  num + ' posts', num + ' + all unread posts', 'All unread posts', 'All'];
        }
        function focus(){
          var opts = make_opts();
          for (var j=0;j<this.length;j++) if (this.options[j].text==='') this.options[j].text = opts[j];
        }
        function blur(){
          for (var j=0;j<this.length;j++) if (j!=this.selectedIndex) this.options[j].text = '';
        }
        return function(key, idx){
          var sel = document.createElement('select');
          sel.className = pref.script_prefix + '_expander';
          sel.setAttribute('data-key',key);
          sel.length = 7;
          if (idx===undefined) idx = 0;
          sel.selectedIndex = idx;
          sel.options[idx].text = (idx===0)? 'Expand...' : make_opts()[idx];
          sel.onfocus = focus;
          sel.onblur = blur;
//          sel.onblur();
          return sel;
        };
      })(),
      icons: {
        filter: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcAQAAAABaduI5AAAAAnRSTlMAAQGU/a4AAABUSURBVAjXY/j///8HBjAx////CQz8//8zMLD//8fAwPz/DwND4/8fAgwH/n8wYHhQ/6CA4YP9gQ8MP+QbPzD84Wf+wPCPnx2ol5+fLKJfHmovnAAAn79HiYOE2q8AAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMTAtMjlUMDI6MTM6MzkrMDk6MDBxKtFiAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE1LTEwLTI5VDAyOjEzOjM5KzA5OjAwAHdp3gAAAABJRU5ErkJggg==',
        settings: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcAQAAAABaduI5AAAAAnRSTlMAAQGU/a4AAABWSURBVAjXdY6xDcAgDAQvGzAKG2QllykiwWgexWxgKQ2dI4yULs1X9/dPWHMyHrudYZegvVQ6FBQqdqrgzRwLF0ZM4YjJfySS8K4tQaq2dOlzKCe/By9fz0MDWLKIZgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNS0xMC0yOVQwMjowMzowNiswOTowMMhjeagAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTUtMTAtMjlUMDI6MDM6MDYrMDk6MDC5PsEUAAAAAElFTkSuQmCC',
        refresh: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcAQAAAABaduI5AAAAAnRSTlMAAQGU/a4AAABmSURBVAjXbY6xDYAwDASfijLegBUYLRuAlCIljITEAowQNnCZIspjQ0tzkvX6e4NKBREudIw7KgaBTqugLEVwUwWnI9HOzMNh6UarhR+8QWaXD4nNBW02VY0ujdAA9SH1yXfcYG88J0BH+yT9vZAAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMTAtMjhUMjM6NDg6MDYrMDk6MDASyn1kAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE1LTEwLTI4VDIzOjQ4OjA2KzA5OjAwY5fF2AAAAABJRU5ErkJggg==',
        img: function(src){return '<img src="' + src + '" style="width:14px;height:14px">';},
        button_settings: function(){return '<button type="button" name="settings">'+this.img(this.settings)+'</button>';},
      },
      toggleButton: function(pn){
        if (pn.style && pn.style.border) pn.style.border = '';
        else pn.style.border = 'inset 2px';
      },
//      toggleButton: (function(){
//        var style_str = 'width:14px;height:14px';
//        return function(name,icon){
//          var button = document.createElement('button');
//          button.src = cnst.icons[icon];
//          button.setAttribute('style',style_str);
//          return button;
//        };
//      })(),
      createElement: function(html){
        var pn = document.createElement('div');
        pn.innerHTML = html;
        return (pn.childNodes.length===1)? pn.childNodes[0] : pn.querySelectorAll('*'); // return static array.
      },
      set_tack_float: function(pn, func_float, func_embed){
        if (func_float || func_embed) opts.set(pn, {float: func_float, embed: func_embed});
        pn.onclick = tack_float;
        return pn;
      },
      tack_float_nSblgs: function(e, all){
        var ecT = e.currentTarget;
        var tgt = ecT.nextSibling;
        var left = tgt.offsetLeft - tgt.scrollLeft;
        var tgt_p = tgt.parentNode;
        var scrollTop;
        while (tgt_p && !scrollTop) {scrollTop = tgt_p.scrollTop; tgt_p = tgt_p.parentNode;}
        var top = tgt.offsetTop - (scrollTop||0);
        var obj = cnst.init3({func_str:'left:'+left+'px:top:'+top+'px:overflow:hidden:Show:tb', exit:tack_dock, tack:ecT});
        obj.cn.innerHTML = '<div style="display: none"></div><div></div>';
        var dst = obj.cn.childNodes[1];
        tgt.parentNode.insertBefore(obj.pn,tgt);
        dst.appendChild(tgt);
        if (all) while (obj.pn.nextSibling) dst.appendChild(obj.pn.nextSibling);
        ecT.style.display = 'none';
        return obj;
      },
      tack_dock_nSblgs: function(e){
        var pn = e.currentTarget.parentNode;
        var obj = opts.get(pn);
        var tack_p = obj.tack.parentNode;
        var ref = obj.tack.nextSibling;
        var src = obj.cn.childNodes[1];
        while (src.firstChild) tack_p.insertBefore(src.firstChild,ref); // all childrens are retrieved always.
        obj.tack.style.display = null;
        cnst.div_destroy(pn, true);
        return obj.tack;
      },
      tack_dock_e2tack: function(e){
        var pn = e.currentTarget.parentNode;
        return opts.get(pn).tack;
      },
//      set_target_of_button: function(button, tgt){
//        opts.set(button, tgt);
//      },
    };
  })();

////  function Cnst2(func_str,funcs_args){ // rolldown, rollup, exit, maximize // test for prototype base coding.
////    var pn = document.createElement('div');
////    if (!pn.style) pn.style = {};
////    pn.style.position = 'fixed';
////    pn.draggable = true;
////    pn.style.padding = '0px';
////    var funcs = func_str.split(':');
////    var i=0;
////    if (funcs[0]!='pop') {
////      pn.style.background = '#e5ecf9';
////      pn.style.color = '#000000';
////      pn.style.fontWeight = 'normal';
////      pn.style.border = '1px solid blue';
//////      pn.style.border = 'none';
////    } else {
////      pn.addEventListener(brwsr.mousewheel, div_scroll, false);
////      pn.name = 'catalog_pop';
////      i=1;
////    }
////    this.pn = pn;
////
////    var tgt = pn;
////    var funcs = func_str.split(':');
////    while (i<funcs.length) {
////      var arg = funcs[i++];
////      if (arg=='tb') {
////        pn.style.background = '#b5ccf9';
////        pn.innerHTML = '<div>' +
////          '<div style="float: left"><button name="rollup">-</button><button name="opacity,-0.1"><</button><button name="opacity,0.1">></button><span>&emsp;</span></div>' +
////          '<div style="float: right"><button name="embed_top" style="display:inline">^</button><button name="embed_bottom" style="display:inline">_</button><button name="float" style="display:none">o</button><button name="maximize" style="display:inline">[]</button><button name="exit">X</button></div>' +
////          '<div></div>' +
////          '</div>' +
////          '<div style="background: #e5ecf9; margin: 0px 3px 3px 3px"></div>';
////        var tb = pn.childNodes[0];
////        tb.childNodes[2].style.height = tb.childNodes[0].offsetHeight + 'px';
////        tb.childNodes[2].ondblclick = (function(myself){return function(){myself.button_click("rollup");};})(this);
//////        tb.childNodes[0].childNodes[3].ondblclick = tb.childNodes[2].ondblclick;
////        pn.draggable = false;
////        tb.childNodes[0].draggable = true;
////        tb.childNodes[2].draggable = true;
////        tb.childNodes[0].style.cursor = 'move';
////        tb.childNodes[2].style.cursor = 'move';
////        tgt = pn.childNodes[1];
////        this.tb = tb;
////        this.opacity = 1;
////        this.rolluped = false;
////        this.state = ['float'];
////        this.button_click_event = (function(myself){return function(){myself.button_click.call(myself,this.name);};})(this);
////        this.funcs = {};
////        common_func.overwrite_prop(this.funcs,funcs_args);
////        var buttons = pn.getElementsByTagName('button');
////        for (var j=0;j<buttons.length;j++) buttons[j].onclick = this.button_click_event;
////        this.pn_1 = pn.childNodes[1];
////      } else if (arg=='txt' || (brwsr.ff && arg=='button')) {
////        tgt.appendChild(document.createTextNode(funcs[i++]));
////        tgt.style.cursor = 'pointer';
////        tgt.style.padding = '2px 5px 2px 5px';
////      } else if (arg=='button') {
////        tgt.innerHTML = '<input type="button" value="' + funcs[i++] + '">';
//////        tgt.innerHTML = '<button draggable="true">' + funcs[++] + '</button>';
////        tgt.style.padding = '0';
////        tgt.style.border = '0';
////        tgt.style.background = 'none';
////      } else if (arg=='Show2') {
////        if (site.root_body!==site.root_body2 && site.root_body2) {
////          pn.style.position = 'static';
////          site.root_body2.appendChild(pn);
////        } else site.root_body.appendChild(pn);
////      } else if (arg=='Show') site.root_body.appendChild(pn);
////      else if (arg=='tile') {
////        if (funcs[i++]=='set') {
////          if (funcs[i]=='left') {this.tile[funcs[i]] = parseInt(pn.style[funcs[i]].replace(/px/,''),10) + pn.offsetWidth;i++;}
////          else {this.tile[funcs[i]] = parseInt(pn.style[funcs[i]].replace(/px/,''),10) + pn.offsetHeight;i++;}
////        } else {pn.style[funcs[i]] = this.tile[funcs[i]]+'px';i++;}
////      } else tgt.style[arg] = funcs[i++];
////    }
////    pn.addEventListener('dragstart', this.div_dragstart, false);
//////    pn.addEventListener('dragstart', this.div_dragstart, true);
////    pn.addEventListener('dragend', this.div_dragend, false);
////  }
////
////  Cnst2.prototype = {
////    tile : {lef: 0, bottom: 0},
////    button_click : function(name){
////      if (name.indexOf('opacity')!=-1) {
////        this.opacity += parseFloat(name.substr(name.indexOf(',')+1),10);
////        if (this.opacity>1) this.opacity = 1;
////        else if (this.opacity<0.1) this.opacity = 0.1;
////        this.pn.style.opacity = this.opacity;
////      } else if (name.indexOf('rollup')!=-1) {
////        if (this.rolluped) {
////          this.tb.style.width = ''; // means 'auto'
////          this.pn_1.style.display = ''; // for dollchan
////          if (this.funcs.rolldown) this.funcs.rolldown();
////        } else {
////          this.tb.style.width = this.tb.offsetWidth + 'px'; // for dollchan
////          this.pn_1.style.display = 'none'; // for dollchan
////          if (this.funcs.rollup) this.funcs.rollup();
////        }
////        this.rolluped = !this.rolluped;
////      } else if (['embed_top','embed_bottom','float','maximize'].indexOf(name)!=-1) {
////        common_func.overwrite_prop(this.tb.childNodes[1].getElementsByTagName('*')[this.state[0]].style,{display:'inline'});
////        if (this.state[0]=='float') this.state = [name, this.pn.style.left, this.pn.style.top, this.pn.childNodes[1].style.width, this.pn.childNodes[1].style.height];
////        else this.state[0] = name;
////        if (name=='maximize') {
////          var header_height = site.header_height();
////          common_func.overwrite_prop(this.pn.style, {left:'0px', top:header_height + 'px', position:'fixed', resize:'none'});
////          common_func.overwrite_prop(this.pn.childNodes[1].style,
////            {width: document.documentElement.clientWidth + 'px', height: document.documentElement.clientHeight - this.tb.offsetHeight - header_height + 'px', resize:'none'});
////        } else if (name=='float'){
////          common_func.overwrite_prop(this.pn.style, {left:this.state[1], top:this.state[2], position:'fixed', resize:'both'});
////          common_func.overwrite_prop(this.pn.childNodes[1].style, {width:this.state[3], height:this.state[4], resize:'both'});
////        } else {
////          var ref = site.embed_to[(name==='embed_top')?'top':'bottom'];
////          if (ref){
////            common_func.overwrite_prop(this.pn.style, {left:'auto', top:'auto', position:'static', resize:'none'});
////            common_func.overwrite_prop(this.pn.childNodes[1].style, {width:'auto', height:'auto', resize:'none'});
////            ref.parentNode.insertBefore(this.pn,ref);
////          }
////        }
////        common_func.overwrite_prop(this.tb.childNodes[1].getElementsByTagName('*')[this.state[0]].style,{display:'none'});
////        if (this.funcs.maximize) this.funcs.maximize();
////      } else if (name==='exit') this.funcs.exit();
////    },
////    drag_sx: null,
////    drag_sy: null,
////    div_dragstart: function(e){
//////    var drag_cursor_style;
////      this.drag_sx = e.screenX;
////      this.drag_sy = e.screenY;
//////      drag_cursor_style = pn.style.cursor;
//////      pn.style.cursor = 'move';
////      e.dataTransfer.setData('text/plain', ''); // for FF. CH doesn't require this.
//////      e.preventDefault();
//////      e.stopPropagation();
////    },
////    div_dragend: function(e){
////      if (e.currentTarget.style.left!='') e.currentTarget.style.left   = (parseInt(e.currentTarget.style.left.replace(/px/,''))   + e.screenX - this.drag_sx) + 'px';
////      else e.currentTarget.style.right = (parseInt(e.currentTarget.style.right.replace(/px/,''))   - e.screenX + this.drag_sx) + 'px';
////      if (e.currentTarget.style.bottom!='') e.currentTarget.style.bottom = (parseInt(e.currentTarget.style.bottom.replace(/px/,'')) - e.screenY + this.drag_sy) + 'px'; // from bottom.
////      else e.currentTarget.style.top = (parseInt(e.currentTarget.style.top.replace(/px/,'')) + e.screenY - this.drag_sy) + 'px';
//////      pn.style.cursor = drag_cursor_style;
////    }
////  }

  var timer_obj;
  var chart_obj;
  var setting_obj;
  var post_form_obj;
//  var wafd = null;
  var catalog_obj;
  var cnst_obj = (function(){
    site.script_body = document.createElement('div');
    site.script_body.className = pref.script_prefix;
    site.script_body.innerHTML = '<div style="display:none"></div><div></div>';
    site.popup_body = site.script_body.childNodes[1];
    site.root_body.appendChild(site.script_body);
    if (site.features.postform && pref.features.postform && !(site.postform!=null || site2[site.nickname].postform.activation)) {
      var draft = document.createElement('div');
      draft.innerHTML = '<div><textarea style="height:5em;display:none" cols="20" name="' + pref.script_prefix + '_draft"></textarea><button name="' + pref.script_prefix + '_send" style="display:none">send</button></div>'; // <div> was added for tack_float
      site.script_body.appendChild(draft);
      draft = draft.childNodes[0];
      site.components['postform_comment'] = draft.childNodes[0];
      site.postform = site.components['postform_comment']; // redundant. need to be cleaned up.
      site.components['postform_submit'] = draft.childNodes[1];
    }
    if (site.settings) {
      site.settings.innerHTML = '<span>[CC</span><span></span>]';
      site.settings.setAttribute('style','float:right;');
      var pn_st = site.settings.childNodes[1];
      site.settings.childNodes[0].setAttribute('style','cursor:pointer');
      site.settings.childNodes[0].onclick = function(){cnst.show_hide(pn_st);};
      site.settings.childNodes[1].setAttribute('style','display:none');
    }
    if (site.features.setting && pref.features.setting) {
      var pn13 = cnst.init2({func_str:'left:0px:bottom:0px:button:settings:Show2:tile:set:left',pn_st:pn_st});
      pn13.addEventListener('click', pref_func.settings.show_hide, false);
    }
    if (site.features.catalog && pref.features.catalog) {
      if (!pref.catalog.embed_page || site.whereami!=='page') {
        var pn12_str = (pref.catalog.embed && site.whereami==='catalog')? 'Frame' : 'Catalog';
        var pn12 = cnst.init2({func_str:'tile:get:left:tile:get:bottom:button:'+pn12_str+':Show2:tile:set:left',pn_st:pn_st});
      }
      catalog_obj = make_catalog_obj(pn12);
    }
    if (!pref.test_mode['94']) cnst.tile_set_left();
    if (site.features.graph && pref.features.graph && pref3.stats.use) {
      var pn1 = cnst.init2({func_str:'tile:get:left:tile:get:bottom:button:Graph:Show2:tile:set:left',pn_st:pn_st});
      chart_obj = make_chart_obj(pn1);
    } else chart_obj = make_chart_obj(null);
    if (site.features.setting2 && pref.features.setting2) {
      var pn8 = cnst.init2({func_str:'tile:get:left:tile:get:bottom:button:settings2:Show2:tile:set:left',pn_st:pn_st});
      setting_obj = make_setting_obj(pn8);
    }
    if (site.features.postform && pref.features.postform && (site.postform!=null || site2[site.nickname].postform.activation)) {
//      wafd = make_wafd();
      var pn9 = cnst.init2({func_str:'tile:get:left:tile:get:bottom:button:' +((draft)? 'Draft' : 'PostForm')+ ':Show2:tile:set:left',pn_st:pn_st});
      post_form_obj = make_post_form_obj(pn9);
    }
    if (site.features.debug && pref.features.debug) {
      var pn_debug_button = cnst.init2({func_str:'tile:get:left:tile:get:bottom:button:debug:Show2:tile:set:left',pn_st:pn_st});
      make_debug_obj(pn_debug_button);
//  var pn_debug_out    = cnst.init('left:200px:bottom:50px:txt:debug_out');
    }
    if (site.features.page && pref.features.page) {
//      var pn0 = cnst.init('tile:get:left:tile:get:bottom:txt:init:Show2:tile:set:bottom');
      var pn0 = cnst.init2({func_str:'tile:get:left:tile:get:bottom:txt:init:Show2',pn_st:pn_st});
      timer_obj  = make_timer_obj(pn0);
    }
    cnst.tile_set_bottom();
    if (site.features.catalog && pref.features.catalog) if (pref.catalog.board.board_tags_same) pref_func.settings.onchange_funcs['tag.same_tag_refresh']();
  })();

  function make_uip_tracker (){
    var base_thread = site2[site.nickname].wrap_to_parse.get(document, site.nickname, site.board, 'thread_html', {thread:site.no})[0];
//    site.thread = site.get_ops(document)[0];
//    var url = site.protocol + '//a.4cdn.org' + site.board +'thread/' + site.thread + '.json';
//    var url2= site.protocol + '//a.4cdn.org' + site.board +'catalog.json';
//    var url = site2[site.nickname].get_json_url_thread(site.board,site.thread);
    var url2= site2[site.nickname].get_json_url_catalog(site.board);
    var key = site.nickname + site.board + site.no;
    var post_uip = [];
    var last_updated = [0,1,1]; //no,posts,uips
    var posts_old = {};
    var waste_count = 0;
    var interval = (pref.uip_tracker.interval>10)? pref.uip_tracker.interval : 10; // 0; // prevent from causing inifinite loop when !uip_first in annotate_from_catalog.
    var uip_tracker_id;
    uip_check();
//    function uip_check(){http_req.get('uip',key,url,uip_show,false,false);}
    function uip_check(){
      uip_tracker_id = null;    
      site2[site.nickname].uip_check(uip_show, sage_detect);
    }

    var threads = {};
    var threads_req = {};
    var threads_req_mutex = true;
    var threads_opened = {};
    function uip_auto_open(key,value){
//      var obj = JSON.parse(response_txt);
      var obj = site2[site.nickname].parse_json_catalog(value.responseText);
      threads['max'] = 0;
      for (var i=0;i<obj.length;i++) {
        for (var j=0;j<obj[i].threads.length;j++) {
          var no = obj[i].threads[j].no;
          threads[no] = {};
          threads[no].sub = obj[i].threads[j].sub;
          threads[no].com = obj[i].threads[j].com;
          if (threads['max']<no) threads['max']=no;
        }
      }
      uip_auto_open_check();
      threads_req_mutex = true;
    }
//    if (pref.debug_mode['0']) { // for debug
////      window.addEventListener('load',function(){console.log(new Date().toLocaleTimeString()+': load_event');},false); // can't get.
////      window.addEventListener('DOMSubtreeModified',function(){console.log(new Date().toLocaleTimeString()+': DOMSubtreeModified');},false); // get too much because of root.
//      site2[site.nickname].catalog_threads_in_page(document)[0].addEventListener('DOMSubtreeModified',function(){console.log(new Date().toLocaleTimeString()+': DOMSubtreeModified');},false); // ok.
//    }

    var observer = new MutationObserver(uip_show_from_doc);
    observer.observe(base_thread.pn, {childList: true});
    function add_dom_event_listener(){
      observer.observe(base_thread.pn, {childList: true});
    }
    function remove_dom_event_listener(){
      observer.disconnect();
    }
//    function add_dom_event_listener(){ // obsolete function. see https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events
//      base_thread.pn.addEventListener('DOMSubtreeModified',uip_show_from_doc,false);
//    }
//    function remove_dom_event_listener(){
//      base_thread.pn.removeEventListener('DOMSubtreeModified',uip_show_from_doc,false);
//    }
    add_dom_event_listener();
    function uip_auto_open_check(){
      var kwd = pref.uip_tracker.auto_open_kwd;
      if (kwd==='') kwd = '.*';
      for (var i in threads_req) {
        if (threads[i] && i>site.no && threads_opened[i]===undefined) {
          var flag = false;
          flag |= threads[i].sub  && threads[i].sub.search(kwd) !=-1;
          flag |= threads[i].name && threads[i].name.search(kwd)!=-1;
          flag |= threads[i].com  && threads[i].com.search(kwd) !=-1;
if (pref.debug_mode['0']) console.log('auto_opener: '+i+': '+flag);
//          if (flag) window.open(site2[site.nickname].make_url3(site.board,i), site.domain+site.board+i);
          if (flag) {
            window.open(site2[site.nickname].make_url4([site.nickname, site.board, i, 'thread_html'])[0], '_blank');
//            window.open(site2[site.nickname].make_url3(site.board,i), '_blank');
            threads_opened[i] = i;
          }
          delete threads_req[i];
        } else if (threads['max']>i) delete threads_req[i];
      }
      if (Object.keys(threads_req).length!=0 && threads_req_mutex) {
        threads_req_mutex = false;
        http_req.get('uip_auto',key,url2,uip_auto_open,false,false);
      }
    }
    function uip_show(key,value){ // from http
      uip_show_2(key,value,true);
    }
    function uip_show_from_doc(key,value){ // from document
 //     uip_show_2(Date.now(),1200,'',false);
     uip_show_3();
    }
    function uip_show_3(){  // show
      if (post_uip.length==0) return;
      remove_dom_event_listener();
      for (var i=0;i<post_uip.length;i++) {
        var tgt_uip = post_uip[i];
        var tgt_post = site2[site.nickname].uip_tgt_post(tgt_uip[0]);
        if (tgt_post) {
          var pn_uip = document.createElement('span');
          pn_uip.innerHTML = ' (<span>'+tgt_uip[2]+'</span>)';
          if (tgt_uip[4]) pn_uip.childNodes[1].setAttribute('style',pref.uip_tracker.highlight_str);
          if (pref.uip_tracker.posts) {
            var pn_posts = document.createElement('span');
            pn_posts.innerHTML = '<span>'+ tgt_uip[1] +'</span>' + ((tgt_uip[5] && pref.uip_tracker.deletion.show)? '('+(
              pref.uip_tracker.deletion.link? tgt_uip[5].map(function(v){return '<a href="#p'+v+'" class="quotelink">&gt;&gt;'+v+'</a>';}) : tgt_uip[5]).join()+')' : '') + '/';
            if (tgt_uip[3]) pn_posts.childNodes[0].setAttribute('style',pref.uip_tracker.highlight_str);
            pn_uip.insertBefore(pn_posts,pn_uip.childNodes[1]);
          }
          if (tgt_uip[5] && (pref.uip_tracker.deletion.name || pref.uip_tracker.deletion.addName || pref.uip_tracker.deletion.post))
            for (var j=0;j<tgt_uip[5].length;j++) sage_annotate({no:tgt_uip[5][j]},pref.uip_tracker.deletion,true);
          var post_nums = site2[site.nickname].uip_post_num(tgt_post);
          post_nums[post_nums.length-1].appendChild(pn_uip);
          if (!pn_first && i==0) pn_first = [pn_uip, tgt_uip];
          post_uip.splice(i--,1);
        }
      }
//      sage_detect(); // require to merge this with catalog, format_html.update_draw runs after this and removes style of post.pn.
      add_dom_event_listener();
    }
    function uip_show_2(key,value,from_http){ // from http and doc
//console.log(new Date(value.date).toLocaleTimeString()+', IN, '+from_http);
      waste_count++;
      if (value.status==200) {
//        var obj = JSON.parse(value.responseText);
        var obj = site2[site.nickname].parse_json_thread(('response' in value)? value.response : JSON.parse(value.responseText),from_http);
        var nof_posts = obj.posts.length;
        var uips = obj.posts[nof_posts-1]['unique_ips'] || last_updated[2];
        var last_no = obj.posts[nof_posts-1]['no'];
        if (last_updated[0]!=last_no || last_updated[1]!=nof_posts || last_updated[2]!=uips) {
if (pref.debug_mode['31']) console.log(new Date(value.date).toLocaleTimeString()+', '+last_no+', '+nof_posts+', '+uips);
          var posts_new = {};
          for (var i=0;i<obj.posts.length;i++) posts_new[obj.posts[i].no] = null;
          if (pref.uip_tracker.auto_open && pref.uip_tracker.auto_open_th<=nof_posts && last_updated[0]!=0) { // last_updated[0]!=0 blocks initial trial.
            var pn_test = document.createElement('span');
            var i=obj.posts.length-1;
            while (i>=1 && posts_old[obj.posts[i].no]===undefined) i--;
            while (++i<obj.posts.length) {
              pn_test.innerHTML = obj.posts[i].com;
              var pn_a = pn_test.getElementsByTagName('a');
              for (var j=0;j<pn_a.length;j++) {
                var tgt = pn_a[j].textContent.match(/>>([0-9]+)$/);
                if (!tgt) continue; else tgt = tgt[1];
                if (posts_new[tgt]!==undefined || posts_old[tgt]!==undefined) continue;
//              var flag = true;
//              var tgt = pn_a[j].textContent.substr(2);
//              for (var k=0;k<nof_posts.length;k++) if (obj.posts[k].no==tgt) {flag=false;break;}
////              if (flag) console.log('auto_opener: '+tgt);
                threads_req[tgt] = tgt;
              }
            }
            uip_auto_open_check();
          }
          var post_hilight = (obj.posts.length<last_updated[1] || obj.posts[last_updated[1]-1]['no']!=last_updated[0]);
          if (pref.uip_tracker.deletion.show || pref.uip_tracker.deletion.name || pref.uip_tracker.deletion.addName || pref.uip_tracker.deletion.post) {
            var posts_deleted = [];
            for (var i in posts_old) if (posts_new[i]===undefined) posts_deleted[posts_deleted.length] = i;
if (pref.debug_mode['31'] && posts_deleted!=='') console.log('uip_deleted '+posts_deleted);
          }
          last_updated = [last_no,nof_posts,uips,post_hilight,last_updated[2]!=uips, (posts_deleted.length!=0)? posts_deleted : null];
          post_uip.push(last_updated);
          waste_count = 0; // pass here always at first.
          posts_old = posts_new;
        }
        uip_show_3();
      }
      if (pref.uip_tracker.on) {
        if (from_http) {
          interval = (waste_count==0 || !pref.uip_tracker.adaptive)? ((pref.uip_tracker.interval>10)? pref.uip_tracker.interval : 10) // waste_count===0 always at initial.
                   : (waste_count%8==0)? ((interval>=1800)? 3600 : interval*2)
                   : interval;
//          if (pref.uip_tracker.adaptive){
//            if (waste_count==0) interval = 0;
//            else if (waste_count>=8) {
//              waste_count=0;
//              interval = (interval>=1800)? 3600 : interval*2;
//            }
//          } else interval = 0;
//          if (interval==0) interval = (pref.uip_tracker.interval>10)? pref.uip_tracker.interval : 10;
//          if (value.status!=404) setTimeout(uip_check,interval*1000);
          var p0 = (value.status==200)? obj.posts[0] : null;
          if (value.status!=404 && (!p0 || (!p0['archived'] && !p0['closed']))) uip_tracker_id = setTimeout(uip_check,interval*1000);
          else uip_tracker_destroy();
        }
      } else uip_tracker_destroy();
    }
    var pn_first = null;
    function annotate_from_catalog(vals){
      var uip_first = (pn_first)? pn_first[1] : (post_uip.length!=0)? post_uip.splice(0,1)[0] : null;
      for (var i=0;i<vals.length;i+=3) post_uip[post_uip.length] = [vals[i], vals[i+1], vals[i+2], false, vals[i+1]==vals[i+2] || i>=3 && vals[i+2]!=vals[i-1], null];
      if (!uip_first) {
        last_updated = post_uip[post_uip.length-1]; // RACING CONDITION. this is faster than network access usually.
        pn_first = true;
      } else {
//        console.log('Hit: uip_tracker: racing condition');
        var uip_last = post_uip[post_uip.length-1];
        if (uip_last[0]!=uip_first[0] || uip_last[1]!=uip_first[1] || uip_last[2]!=uip_first[2])
          post_uip[post_uip.length] = uip_first.slice(0,3).concat(false, uip_last[2]!=uip_first[2], null);
        if (pn_first) pn_first[0].parentNode.removeChild(pn_first[0]);
      }
      uip_show_3();
    }
    var sage_done = {};
    var sage_scheduled = {};
    function sage_detect(th){
      for (var i in sage_scheduled) if (sage_annotate(sage_scheduled[i])) delete sage_scheduled[i];
      if (!th || !th.posts) return;
      for (var i=th.posts.length-1;i>=1;i--)
        if (th.posts[i].email==='sage' && sage_done[th.posts[i].no]===undefined) sage_annotate(th.posts[i]);
        else break;
      // patch for 4chan's bug.
      // 4chan send corrupted data sometimes. Bump oerder and posts are NOT synchronized, posts may be dropped around before 1s from generation.
      // You can see this by comparing Last-Modified in http header with timestamp of posts. I saw 3 sec delay so far.
      // In this situation, threads in top orders are seen as overevaluated. Just bumped, but there are no new posts.
      // This bug requires re-evaluation of sage, so I can't use stateful fast approach.
      if (pref.uip_tracker.sage.patch_bug) { // patch for 4chan's bug.
        for (var i=th.posts.length-1;i>=1;i--)
          if (th.posts[i].email!=='sage')
            if (sage_done[th.posts[i].no]===null || sage_scheduled[th.posts[i].no]) {
              if (pref.debug_mode['30']) console.log('OVERDETECTION: '+th.posts[i].no);
              if (sage_done[th.posts[i].no]===null) sage_annotate(th.posts[i], {name_str:'', addName_str:'OVERDETECTED_', post_str:'', __proto__:pref.uip_tracker.sage});
              delete sage_scheduled[th.posts[i].no];
              delete sage_done[th.posts[i].no];
            } else break;
      }
    }
    function sage_annotate(post, pref_obj, deletion){
      var pn = site2[site.nickname].uip_tgt_post(post.no);
      if (pn) {
        var pn_name = site2[site.nickname].parse_funcs['post_html'].pn_name({pn:pn, __proto__:post});
        if (!pref_obj) pref_obj = pref.uip_tracker.sage;
        if (pref_obj.name) pn_name.setAttribute('style',pref_obj.name_str);
        if (pref_obj.addName) pn_name.textContent = pref_obj.addName_str + pn_name.textContent;
        if (pref_obj.post) pn.setAttribute('style',pref_obj.post_str);
        if (!deletion) sage_done[post.no] = null;
        return true;
      } else if (!deletion) sage_scheduled[post.no] = post;
    }
    function uip_tracker_destroy(){
      remove_dom_event_listener();
      uip_tracker = null;
//if (pref.debug_mode['0'] && uip_tracker===null) console.log('uip_tracker: stopped, '+value.status);
    }
    return {
      get_id: function(){return uip_tracker_id;},
      annotate_from_catalog: annotate_from_catalog
//      annotate_from_catalog: function(arg){setTimeout(annotate_from_catalog.bind(null, arg), 10000);} // for test
    }
  }
  var uip_tracker=null;
  setTimeout(uip_tracker_init,1); // patch for LiveTag.
  function uip_tracker_init(){
    if (uip_tracker===null && site.features.uip_tracker && pref.features.uip_tracker && site.isthread && pref.uip_tracker.on) uip_tracker = make_uip_tracker();
    else if (!pref.uip_tracker.on) {
      if (uip_tracker) clearTimeout(uip_tracker.get_id());
      uip_tracker = null;
    }
  }

  function make_thread_reader(){
    site.myself = site2[site.nickname].get_ops(document)[0]; // patch, will be changed to site.no.
//    var base_thread = site2[site.nickname].catalog_threads_in_page(document)[0];
    var name = site.nickname+site.board+site.myself;
//    var dbt = common_func.name2domainboardthread(name);
    var dummy = {sticky:null};
    var threads = {};
    threads[name] = [];
////////    threads[name][8]  = [0,0,0,0];
    threads[name][19] = liveTag.mems.init({domain:site.nickname, board:site.board, no:site.myself})[2]; // prepare data structures.
    threads[name][19][0] = 0x000f0000; // start watching, init.
//    threads[name][19] = [1,0,0,0,null,true,-1,0,true];
    var favicon_obj = [];
////////    var buf_id = null;
////////    function updated_buf(){if (!buf_id) buf_id = setTimeout(updated,100);}
//    var posts = {};
////////    var nof_posts = 0;
//    var init = true;
////////    var time_lastpost = 0;
////////    var num_of_children = 0;
////////    var myself_th = {pn:base_thread, post_no_last:-1,
////////      domain:site.nickname, board:site.board, parse_funcs:site2[site.nickname].parse_funcs['thread_html'], __proto__:site4.parse_funcs_on_demand};
////////    var site_live = site.nickname + ((site2[site.nickname+'_live'])? '_live' : '');
////////    var myself_th = site2[site.nickname].wrap_to_parse.get(document, site.nickname, site.board, 'thread_html',
////////                      {thread:site.myself, parse_funcs:site2[site_live].parse_funcs['thread_html']})[0];
//    var parse_obj = {domain:site.nickname, board:site.board,
//                     parse_funcs:site2[site_live].parse_funcs['thread_html'],
//                     __proto__:site4.parse_funcs_on_demand};
//    var myself_th = {pn:base_thread, __proto__:parse_obj};
//    var myself_th = {pn:base_thread, domain:site.nickname, board:site.board,
//                     parse_funcs:site2[site_live].parse_funcs['thread_html'],
//                     __proto__:site4.parse_funcs_on_demand};
////////    var regexp_anchor    = />>[0-9]+/g;
////////    var regexp_anchor_cb = />>>\/[0-9A-z_\+]+\/[0-9]+/g;
////////    var remake_own_posts = true;



    var own_posts_tracker = function(){
      var get_flag = true;
      function get_my_posts_no(){
        get_flag = true;
      }
      function update_own_posts(posts,init){
        if (posts.length==0) {get_flag = false; return;} // clearing get_flag for watching thread which may not have any new posts in lainchan, a conflict may occur in KC...  // length check for KC.
        if (get_flag) {
          var key = pref.script_prefix + '.own_posts.' + site.board + site.myself;
          var own_posts = JSON.parse(localStorage[key] || "[]");
          var my_posts = [];
          if (!init) {
            my_posts[0] = posts[posts.length-1];
            own_posts[own_posts.length] = my_posts[0].no;
            localStorage[key] = JSON.stringify(own_posts);
          } else {
            var i = 0;
            var j = posts.length-1;
            while (i<own_posts.length) {
              while (j>0 && own_posts[i]>posts[j].no) j--;
              if (own_posts[i]===posts[j].no) my_posts[my_posts.length] = posts[j];
              i++;
            }
          }
          for (var i=0;i<my_posts.length;i++) {
            var pn_name = my_posts[i].parse_funcs_html.pn_name(my_posts[i]);
            if (pref.thread_reader.show_own_post_by==='plain') pn_name.parentNode.insertBefore(document.createTextNode(' (You)'), pn_name.nextSibling);
            else pn_name.innerHTML = pn_name.innerHTML + ' (You)';
          }
          get_flag = false;
        }
        for (var i=0;i<posts.length;i++) site2[site.nickname].check_reply.add_you(posts[i]);
      }
      function event_submit(){
        if (this.name==='post') get_my_posts_no();
      }
      return {
        update_own_posts: update_own_posts,
        get_my_posts_no: get_my_posts_no,
        event_submit: event_submit,
      }
    };
    if (pref.thread_reader.own_posts_tracker) {
      own_posts_tracker = own_posts_tracker();
      if (!site.components.postform_submit) window.addEventListener('submit', own_posts_tracker.event_submit, false); // doesn't work....
    } else {
      own_posts_tracker = null;
//      if (!site.components.postform_submit) window.removeEventListener('submit', own_posts_tracker.event_submit, false);
    }

////////    var ignore_old = pref.catalog_footer_ignore_my_own_posts; // patch for showing (You), don't discard my post...
////////    pref.catalog_footer_ignore_my_own_posts = false;
////////    updated(true);
////////    pref.catalog_footer_ignore_my_own_posts = ignore_old;
////////
//////////    threads[name][19][5] = false; // modified in check_reply
////////    common_func.set_value_to_root(threads[name][19],'5',false);
////////    function remake_own_posts_flag(){remake_own_posts = true;}
////////    function add_event_to_submit(pn){pn.addEventListener('click', remake_own_posts_flag, false);}
////////    function remove_event_from_submit(pn){pn.addEventListener('click', remake_own_posts_flag, false);}
//    function add_event_to_submit(pn){pn.addEventListener('click', site2[site.nickname].check_reply.remake_own_posts, false);}
//    function remove_event_from_submit(pn){pn.addEventListener('click', site2[site.nickname].check_reply.remake_own_posts, false);}
    function add_event_to_submit(pn){
      pn.addEventListener('click', site2[site.nickname].check_reply.remake_own_posts, false);
      if (own_posts_tracker) pn.addEventListener('click', own_posts_tracker.get_my_posts_no, false);
    }
    function remove_event_from_submit(pn){
      pn.removeEventListener('click', site2[site.nickname].check_reply.remake_own_posts, false);
      if (own_posts_tracker) pn.removeEventListener('click', own_posts_tracker.get_my_posts_no, false);
    }
////////    function updated(init){
////////      buf_id = null;
//////////console.log('called');
////////      if (pref.thread_reader.check_num_of_children) {
////////        if (num_of_children>=myself_th.pn.childNodes.length) return; // KC doesn't work by this, because all of children are not posts.
////////          num_of_children = myself_th.pn.childNodes.length;
////////      }
////////////      myself_th.parse_funcs['pop_post_prep'](myself_th);
////////      site2[site.nickname].check_reply.check(myself_th, threads[name][19]);
////////      delete myself_th.posts;
////////////////      nof_posts += threads[name][19][7]; // patch
////////      for (var i=0;i<threads[name][19][4].length;i++)
////////        threads[name][19][4][i].pn.addEventListener('mouseover', favicon_check, false);
//////////console.log('length:'+threads[name][19][4].length);
////////

//////////      threads[name][19][1] = 0;
////////      threads[name][19][4] = [];
////////      var flag_first = true;
////////      var post_no_last_new = myself_th.post_no_last;
////////      myself_th.parse_funcs['pop_post_prep'](myself_th);
////////      while (1) {
////////        myself_th.post = myself_th.parse_funcs['pop_post'](myself_th);
////////        if (myself_th.post && myself_th.post.post_no>myself_th.post_no_last) {
////////      
//////////      for (var i=base_thread.childNodes.length-1;i>=0;i--) { // num of posts is changed by hover and inline.
//////////        var classname = base_thread.childNodes[i].className;
//////////        if (classname && classname.indexOf('post')!=-1 && classname.indexOf('reply')!=-1) { // remove popuped posts.
//////////          var id = base_thread.childNodes[i].id;
//////////          if (!(id in posts)) {
////////          if (flag_first) {
////////            post_no_last_new = myself_th.post.post_no;
////////            if (remake_own_posts) {
////////              site2[site.nickname].prep_own_posts(); // couldn't get an event from myself, so don't miss posts from my thread.
////////              remake_own_posts = false;
////////            }
////////            time_lastpost = myself_th.post.time;
////////            flag_first = false;
////////          }
////////          nof_posts++;
//////////          posts[id] = id;
//////////          var post = myself_th.post.pn; // temporal
////////          if (!init) {
//////////            var post = base_thread.childNodes[i];
//////////            var image = post.getElementsByClassName('post-image');
//////////            image = (image[0])? image[0].src : undefined;
//////////            var body = post.getElementsByClassName('body')[0].innerHTML;
////////            var to_me  = false;
////////            var anchors = regexp_anchor.exec(myself_th.post.com);
////////            if (anchors!==null) {
////////              for (var j=0;j<anchors.length;j++) {
////////                var tgt = anchors[j].substr(2);
////////                if (site3[site.nickname].own_posts[dbt[1]+tgt]===null) {to_me = true; break;}
////////            }}
////////            if (!to_me) {
////////              anchors = regexp_anchor_cb.exec(myself_th.post.com);
////////              if (anchors!==null) {
////////                for (var j=0;j<anchors.length;j++) {
////////                  var tgt = anchors[j].substr(3);
////////                  if (site3[site.nickname].own_posts[tgt]===null) {to_me = true; break;}
////////            }}}
//////////            var anchors = body.match(/&gt;&gt;[0-9]+/g);
//////////            if (anchors) {
//////////              for (var j=0;j<anchors.length;j++) {
//////////                var tgt = anchors[j].substr(8);
//////////                if (site3[site.nickname].own_posts[dbt[1]+tgt]===null) {to_me = true; break;}
//////////            }}
//////////            if (!to_me) {
//////////              anchors = body.match(/&gt;&gt;&gt;\/[0-9A-z_\+]+\/[0-9]+/g);
//////////              if (anchors) {
//////////                for (var j=0;j<anchors.length;j++) {
//////////                  var tgt = anchors[j].substr(12);
//////////                  if (site3[site.nickname].own_posts[tgt]===null) {to_me = true; break;}
//////////            }}}
////////            threads[name][19][4].unshift(
////////              {icon: myself_th.post.op_img_url,
////////               body: myself_th.post.com,
////////               time: myself_th.post.time,
//////////               icon: image,
//////////               body: body,
//////////               time: Date.parse(post.getElementsByTagName('time')[0].getAttribute('datetime')) - pref.localtime_offset*3600000,
////////               to_me: to_me,
////////               offsetTop: myself_th.post.pn.offsetTop});
////////            if (to_me) threads[name][19][1]++;
////////          }
////////          myself_th.post.pn.addEventListener('mouseover', favicon_check_event, false);
//////////            if (time_lastpost<threads[name][19][4][0].time) time_lastpost=threads[name][19][4][0].time;
//////////          } else break;
//////////        }
//////////      }
////////
////////        } else break;
////////      }
////////      myself_th.post_no_last = post_no_last_new;

////////
////////      if (!init) {
//////////      if (init) {init=false;buf_id=null;return;}
////////////////        threads[name][8][2]  = nof_posts;
//////////        for (var i=0;i<threads[name][19][4].length;i++) favicon_obj.push([threads[name][19][4][i].pn.offsetTop,threads[name][19][4][i]]);
//////////        for (var i=threads[name][19][4].length-1;i>=0;i--) favicon_obj.push([threads[name][19][4][i].pn.offsetTop,threads[name][19][4][i]]);
////////        for (var i=threads[name][19][4].length-1;i>=0;i--) favicon_obj.push(threads[name][19][4][i]);
//////////        threads[name][19][2] = nof_posts - favicon_obj.length;
////////        threads[name][19][2] = favicon_obj.length;
////////
//////////      if (!init) { // merge with mark_newer_posts. MIGHT CAUSE UNSTABLITY???
//////////        var nof_posts = site2[site.nickname].get_posts(document).length; // works well in static.
//////////        threads[name][8][2] = nof_posts;
//////////        site2[site.nickname].check_reply_to_me(name,dbt,threads[name][19], document, threads[name][8], dummy);
//////////        for (var i=0;i<threads[name][19][4].length;i++) favicon_obj.push([site2[site.nickname].get_post_offsetTop(document,nof_posts-1-i),threads[name][19][4][i]]);
////////
////////        if (threads[name][19][4].length!=0) notifier.changed(name, threads[name][19][4]);
////////      }
////////      if (own_posts_tracker && cataLog.embed_mode!=='thread') own_posts_tracker.update_own_posts(threads[name][19][4],init); // PATCH
//////////      if (own_posts_tracker) own_posts_tracker.update_own_posts(threads[name][19][4],init);
////////    }

    function mark_posts_from_parent(time){
      time /= site2[site.nickname].parse_funcs.thread_html.time_unit;
      ignore_scroll = true;
      if (favicon_obj[0] && favicon_obj[0].time<time) { // not debugged this path, usually doesn't occur.
        var i = 1;
        while (i<favicon_obj.length && favicon_obj[i].time<=time) i++;
        favicon_obj_trim({target:favicon_obj[i-1].pn});
      } else {
        var site_live = site.nickname + ((site2[site.nickname+'_live'])? '_live' : '');
        var th = site2[site.nickname].wrap_to_parse.get(document, site.nickname, site.board, 'thread_html',
                   {thread:site.no, parse_funcs:site2[site_live].parse_funcs['thread_html']})[0];
        var end = th.posts.length;
        if (favicon_obj[0]) while (end>0 && th.posts[end-1].time>=favicon_obj[0].time) end--;
        var i=end;
        while (i>0 && th.posts[i-1].time>time) th.posts[--i].pn.addEventListener('mouseover', favicon_obj_trim, false);
        favicon_obj = th.posts.slice(i,end).concat(favicon_obj);
      }
    }
    function updated(new_posts, init){ // called from catalog
      for (var i=new_posts.length-1;i>=0;i--) {
        new_posts[i].pn.addEventListener('mouseover', favicon_obj_trim, false);
        favicon_obj.push(new_posts[i]);
      }
      threads[name][19][1] = (threads[name][19][1]&0xffff0000) + favicon_obj.length;
//      if (new_posts.length!=0) notifier.changed(name, new_posts);
      if (own_posts_tracker) own_posts_tracker.update_own_posts(new_posts,init);
    }
//    function favicon_check_event(){
//      this.removeEventListener('mouseover', favicon_check_event, false);
//      favicon_check();
//    }
    var ignore_scroll = false;
    var ref_height_checked = 0;
    function favicon_check(e){
      if (this===window && ignore_scroll) {ignore_scroll = false; return;}
      if (favicon_obj.length==0) return;
      var ref_height = brwsr.document_body.scrollTop;
      if (ref_height<=ref_height_checked) return;
      else ref_height_checked = ref_height;
      ref_height += window.innerHeight -50;
      favicon_obj_trim(e,ref_height);
    }
    function favicon_obj_trim(e,ref_height){
      var time;
      while (favicon_obj.length!=0) {
        if (ref_height && favicon_obj[0].pn.offsetTop>ref_height) break;
        var tgt = favicon_obj.shift();
        tgt.pn.removeEventListener('mouseover', favicon_obj_trim, false);
        time = tgt.time * site2[site.nickname].parse_funcs['post_json'].time_unit;
//        if (pref['thread'].mark_new_posts) site2['DEFAULT'].unmark_post(tgt.pn);
//        if (pref['thread'].mark_new_posts) tgt.pn.setAttribute('style','border:none');
        if (e.currentTarget===tgt.pn) break;
      }
      if (time) {
        threads[name][19][1] = favicon_obj.length;
//        threads[name][19][0] = time;
        for (var i=0;i<favicon_obj.length;i++) if (favicon_obj[i].reply_to_me) threads[name][19][1]+=0x10000;
        notifier.favicon.set(threads);
        if (pref.thread_reader.sync && window.opener) send_message('parent',[['TRIAGE',[name,'WATCH','',false,time]]]);
      }
    }
    function mark_newer_posts(time){
      var retval = null;
      var i=0;
      while (i<favicon_obj.length && favicon_obj[i].time < time) i++;
      if (i<favicon_obj.length) retval = favicon_obj[i].pn;
      while (i<favicon_obj.length) {
        favicon_obj[i].marked = true;
//        favicon_obj[i].pn.setAttribute('style','background:yellow');
        favicon_obj[i].pn.setAttribute('style','border:2px solid red');
        i++;
      }
      ignore_scroll = true;
      return retval; // scroll will be done.
    }

    var triage;
    var buttons = document.createElement('div');
    buttons.innerHTML =
      '<div>'+
        '<button name="thread_reader.buttons.B" type="button">B</button>'+
        '<button name="thread_reader.buttons.UB" type="button">UB</button>'+
        ((window.opener)? '<button name="thread_reader.buttons.X" type="button">X</button>'+
                          '<button name="thread_reader.buttons.v" type="button">v</button>' : '')+
      '</div>';
    var buttons_collection = buttons.getElementsByTagName('*');
    buttons_collection['thread_reader.buttons.B'].onclick  = function(){common_func.modify_bookmark(name,true)};
    buttons_collection['thread_reader.buttons.UB'].onclick = function(){common_func.modify_bookmark(name,false)};
    if (window.opener) {
      buttons_collection['thread_reader.buttons.X'].onclick = function(){triage_exe('KILL','');};
      buttons_collection['thread_reader.buttons.v'].onclick = function(){triage_exe('TIME','');};
    }
//    var th_link = document.getElementById('thread-links');
//    th_link.parentNode.insertBefore(buttons,th_link);
    var pn_ref = (typeof(site.embed_to['bottom'])==='function')? site.embed_to['bottom']() : site.embed_to['bottom'];
    pn_ref.parentNode.insertBefore(buttons,pn_ref);
    if (window.opener && pref.thread_reader.triage) {
//      var triage_all = common_func.make_triage({onclick:triage_event, wheelpatch:false});
//      triage_str = triage_all.str;
//      th_link.parentNode.insertBefore(triage_all.pn,th_link);
      triage = new common_func.Triage(pref.catalog_triage_str,{onclick:triage_event, wheelpatch:false, name:'thread_reader_triage'});
      buttons.appendChild(triage.pn);
    }
    pref_func.tooltips.add_root(buttons);

    function triage_event(){
      var flds = this.name.split(',');
      var i = parseInt(flds[0].replace(/[^\(]*\(/,''),10);
      var j = parseInt(flds[1].replace(/\).*/,''),10);
//      var i = parseInt(flds[0],10);
//      var j = parseInt(flds[1],10);
      triage_exe(triage.str[i][j],triage.str[i][j+2]);
    }
    function triage_exe(com0,com1){
      send_message('parent',[['TRIAGE',[name,com0,com1,true, site2['DEFAULT'].check_reply.get_checked_time(threads[name][19])]]]);
      if (pref.thread_reader.triage_close) window.close();
    }

//    window.addEventListener('storage', site2[site.nickname].prep_own_posts_event, false); // can't catch events from this thread.
    if (pref.notify.favicon) window.addEventListener('scroll', favicon_check, false);
//    base_thread.addEventListener('DOMSubtreeModified',updated_buf,false);
//    base_thread.addEventListener('DOMNodeInserted',updated_buf,false);
////////    var observer = new MutationObserver(updated_buf);
////////    observer.observe(myself_th.pn, {childList: true});

//    threads[name][19][3] = --threads[name][19][0];threads[name][19][0]--;updated(); // debug
//    if (site.components.postform_submit) add_event_to_submit(site.components.postform_submit);
    function setup_submit(inst_submit, postform_submit){
      if (!inst_submit && pref.thread_reader.own_posts_tracker && postform_submit) {
        add_event_to_submit(postform_submit);
        inst_submit = postform_submit;
      } else if (inst_submit && (!pref.thread_reader.own_posts_tracker || !postform_submit)) {
        remove_event_from_submit(inst_submit);
        inst_submit = null;
      }
      return inst_submit;
    }
    var inst_submit  = setup_submit(null, site.components.postform_submit);
    var inst_submit2 = setup_submit(null, site.components.postform_submit2);
////////    window.addEventListener('storage', remake_own_posts_flag, false);
    window.addEventListener('storage', site2[site.nickname].check_reply.remake_own_posts, false);

    return {
      mark_newer_posts: mark_newer_posts,
      destroy : function(){ // destroy
        pref_func.tooltips.remove_root(buttons);
//        base_thread.removeEventListener('DOMSubtreeModified',updated_buf,false);
//        base_thread.removeEventListener('DOMNodeInserted',updated_buf,false);
        observer.disconnect();
////////        window.removeEventListener('storage', remake_own_posts_flag, false);
        window.removeEventListener('storage', site2[site.nickname].check_reply.remake_own_posts, false);
        if (inst_submit ) remove_event_from_submit(inst_submit);
        if (inst_submit2) remove_event_from_submit(inst_submit2);
        return null;
      },
      setup_submit2: function(){inst_submit2 = setup_submit(inst_submit2, site.components.postform_submit2);},
      own_posts_tracker: own_posts_tracker,
      updated: updated,
      mark_posts_from_parent: mark_posts_from_parent,
    }
  }
  function thread_reader_init(){
    if (common_obj.thread_reader===null && site.features.thread_reader && pref.features.thread_reader && site.whereami==='thread' && pref.thread_reader.use) common_obj.thread_reader = make_thread_reader();
    else if (!pref.thread_reader.use && common_obj.thread_reader) common_obj.thread_reader = common_obj.thread_reader.destroy();
  }
//  setTimeout(thread_reader_init,0); // call after making liveTag, and for safety, used setTimeout. (thirad_reader_init contains DOM access, it may fail).



  var liveTag = {
    pn : null,
    pn_summary : null,
//    pn_filter_rexp : null,
    active: {pk:0, in:0, ex:0},
    tags_ci: null, // refers tags.__proto__
    tags : Object.create(Object.create(null)),
                                // tags[TAG] = {key:, num;, mems:, cbx:{pk:, in:, ex:}, (tgts:,) pn:, pn_num:, // summary tree
                                //              ur:};
//  mems : Object.create(null), // member tree : mems[domain][boards][no] = [[[],{},' '], [[],{}], threads_name_19];
                                //   [0]:fixed, [1]:bumped, [x][0]:tags, [x][1]:keys, [0][2]:string,
                                //   [2]:threads[name][19]
                                //     [0]:time_of_checked, [1]:num_of_unread_replies_TO_ME, [2]:num_of_unread_replies,
                                //     [3]:time_of_checked_time_internal, [4]:args_for_desktop_notification, [5]:init,
                                //     [6]:time_of_checked_old, [7]:num_of_checked_posts, [8]:inital_loop,
                                //     [9]:tag_temp, [10]:num_of_posts
    mems : Object.create(null, {  //  CAUTION. USED ALWAYS EVEN IF pref.liveTag.use===false
      getFromName: {value: function(name) {
        var dbt = common_func.fullname2dbt(name);
        return (dbt[2])? this[dbt[0]][dbt[1]][dbt[2]] : this[dbt[0]][dbt[1]];}},
//      exist: {value: function(th) {
//        return this[th.domain] && this[th.domain][th.board] && this[th.domain][th.board][th.no];}},
      init: {value: (function(){
        function prep_domain(th){
////        if (this[th.domain]===undefined) this[th.domain] = Object.create(null, {proto:{value:Object.create(this.acc, {domain:{value:th.domain}})}, // working code.
////                                                                                pfunc:{value:Object.create(null)}});
////        if (!th.board) return this[th.domain];
////
////        if (this[th.domain][th.board]===undefined) {
////          this[th.domain][th.board] = Object.create(this[th.domain].proto,
////                                                     {proto:{value:Object.create(this[th.domain].proto,
////                                                                                  {board:{value:th.board},
////                                                                                   btag:{value:'#'+th.board.substr(1,th.board.length-2)}})},
////                                                      nr:{value:0, writable:true}, nrtm:{value:0, writable:true}, nr_dirty:{value:false, writable:true},
////                                                      u:{value:0, writable:true}, board:{value:th.board}, read_time:{value:0, writable:true},
////                                                     });

          this[th.domain] = Object.create(Object.create(this.acc, {domain:{value:th.domain}}),
                                          {p:{value:Object.create(null)}, // pool of parse_funcs
//                                         u:{value:0, writable:true}, // for 'add_domain'
                                          });
          if (site2[th.domain].lth_init) site2[th.domain].lth_init(th); 
        }
        function prep_board(th){
          var btag = '#'+th.board.substr(1,th.board.length-2);
          if (liveTag.tags[btag] && liveTag.tags[btag].ref_tag === btag) btag = liveTag.tags[btag].ref_tag; // force to use the same reference.
          this[th.domain][th.board] = Object.create(Object.create(Object.getPrototypeOf(this[th.domain]),
                                                                  {board:{value:th.board},
                                                                   btag:{value:btag, writable:true}}),
                                                    {nr:{value:0, writable:true},
                                                     nrtm:{value:0, writable:true},
//                                                     nr_dirty:{value:false, writable:true},
                                                     u:{value:0, writable:true},
//                                                     read_time:{value:0, writable:true},
                                                     o:{value:null, writable:true}, // for 'add_domain' // order
//                                                     f:{value:0, writable:true}, // for 'add_domain'
                                                     p:{value:{}, configurable:true, writable:true}, // pool of parse_funcs
                                                     pgs:{value:null, writable:true}, // for 'add_domain' // max pages
                                                     d:{value:0, writable:true}, // flags
                                                     // s:   for statistics
                                                     // sr:  for statistics
                                                     // srt: for statistics
                                                    });
          if (pref.liveTag.inherit_board_name) {
            liveTag.update_tags_in_th_sub([], {}, [btag], {}, 1, null, 0, this[th.domain][th.board]);
//            liveTag.update_boardlist_1(btag); // for passive virtual boarding. // BUG. don't update new tags.
            liveTag.update_pn_buf.delayed_do();
          }
        }
        function prep_thread(th){
//          this[th.domain][th.board][th.no] = {1:undefined, 2:[0,0,0,0,null,true,-2, 0, true, [], 1],  // init [10] as 1.// working code.
//                                              u:0, no:th.no,
//                                              __proto__:Object.getPrototypeOf(this[th.domain][th.board])};
          var bd = this[th.domain][th.board];
          bd[th.no] = Object.create(Object.getPrototypeOf(bd),{ // 28/324 for 1,2,u,no,tl.
                                                                // 28/240 for 1,2,u,no.
                                                                // 28/236 for 1,2,u,no,tl. (1===null)
                                                                // 28/152 for   2,u,no.
            '1':{value:undefined, writable:true},
            '2':{value:[0x00830000, 0, 0]}, // 16/48 Bytes each. (header/all=header+contents)
////                                               '2':{value:Object.create(this.watch,{ // 4,5,7,9 are shared for reducing memory consumption. // working code. // 28/116 Bytes each.
////                                                 '0':{value:0x00010000, writable:true},
////                                                 '1':{value:0, writable:true},
////                                                 '2':{value:0, writable:true},
//////                                                 '3':{value:0, writable:true},
//////                                                 '6':{value:-2, writable:true},
//////                                                 '8':{value:true, writable:true},
//////                                                 '10':{value:-1, writable:true}
////                                               })},
            u:{value:0, writable:true}, // require 32Bytes/instance, 2.5% memory increase/instance.
            no:{value:th.no, writable:true},
            // s: for statistics
            // th:  thread data, aka th.
            // ta:  live thread, 'posts' contains all live posts.
            // pd:  posts_deleted
            // ed_p: editing posts
            // ed_t: editing tags
            // ed_u: update timestamp for editing posts,
            // sID: stats of IDs
          });
//          var btag = bd[th.no].btag; // redundant
//          liveTag.key_dirty[(pref.liveTag.ci)? btag.toLowerCase() : btag] = null;
//          var btag2 = bd[th.no].btag2;
//          if (btag2) for (var i=0;i<btag2.length;i++) liveTag.key_dirty[(pref.liveTag.ci)? btag2[i].toLowerCase() : btag2[i]] = null;
        }
        return function(th) {
          if (this[th.domain]===undefined) prep_domain.call(this,th);
          if (!th.board) return this[th.domain];
          if (this[th.domain][th.board]===undefined) prep_board.call(this,th);
          if (!th.no) return this[th.domain][th.board];
          if (this[th.domain][th.board][th.no]===undefined) prep_thread.call(this,th);
          return this[th.domain][th.board][th.no];
        }
      })()},
//      watch: {value: Object.create(null, {  //'1':{value:undefined, writable:true, configurable:true}, // default value of 1.
//                                          '4':{value:null, writable:true},
//                                          '5':{value:true, writable:true},
//                                          '7':{value:0, writable:true},
//                                          '9':{value:[], writable:true},
//                                         })},
      acc: {value: Object.create(null, {  // to reduce memory consumption.
        0: {
////          get: function() {return (pref.liveTag.inherit_board_name && pref.liveTag.lock_board_name)? [this.btag] : null;}, // working code.
////          set: function(val) {if (!pref.liveTag.inherit_board_name || !pref.liveTag.lock_board_name || val.length>=2) // inherit and lock ensures val.length>=1
////                 Object.defineProperty(this,'0',{value:val, enumerable:true, configurable:true, writable:true}); // works.
//////                 this.mems[this.domain][this.board][this.no]  = [val, this[1], this[2]];
////               },
////        },
          get: function() {
            var tag = this.btags;
            if (this.tl) tag = (tag)? tag.concat(this.tl) : this.tl;
            return tag || [];
          },
          set: function(val) {
            var ref = this.btags;
            if (ref) {
              if (pref.liveTag.ci) ref = ref.map(function(v){return v.toLowerCase();});
//              if (pref.liveTag.ci) for (var i=0;i<ref.length;i++) ref[i] = ref[i].toLowerCase(); // BUG, ref may original, not shallow copy.
              for (var i=0;i<val.length;i++) if (ref.indexOf((pref.liveTag.ci)? val[i].toLowerCase() : val[i])!=-1) val.splice(i--,1);
            }
            if (val.length>0) this.tl = val;
            else if (this.tl!==undefined) delete this.tl;
          },
        },
        t: {get: function(){return this[1];}}, // TEMPORAL
        key: {get: function(){return this.domain + this.board + ((this.no)? this.no : '');}},
        tag: {get: function(){return (this[0] || []).concat(this[1] || []);}},
        tags:{get: function(){return (this[0] || []).concat(this[1] || []);}}, // renaming function. use this later.
//        tag: {get: function(){
//          var tag0 = this[0];
//          var tag1 = this[1];
//          return (tag0 && tag1)? tag0.concat(tag1) : (tag0)? tag0 : (tag1)? tag1 : null;
//        }},
        btags: {get: function(){
          var tag = (pref.liveTag.inherit_board_name && pref.liveTag.lock_board_name)? [this.btag] : null;
          if (pref.liveTag.inherit_board_tags && pref.liveTag.lock_board_tags && this.btag2) tag = (tag)? tag.concat(this.btag2) : this.btag2;
          return tag;}},
        watched:  {get: function(){return  this[2][0]&0x000c0000;}}, // see 'check_reply'
        time_checked: {get: function(){return  this[2][2];}},
        archived: {get: function(){return (this[2][0]&0x00700000) >> 20;},
                   set: function(v){this[2][0] = this[2][0] & 0xff8fffff | ((v&0x07)<<20);}},
        posts_saved:{get: function(){return (this[2][0]&0x02000000) >> 25;},
                     set: function(v){this[2][0] = this[2][0] & 0xfdffffff | ((v&0x01)<<25);}},
        force_ar: {get: function(){return (this[2][0]&0x00500000) >> 20;}}, // init or rescan
        rescan_dp:{get: function(){return (this[2][0]&0x01000000) >> 24;},
                   set: function(v){this[2][0] = this[2][0] & 0xfeffffff | ((v&0x01)<<24);}},
        nrtm:     {get: function(){return (this[2][1]) >> 16;}},
        nr:       {get: function(){return  this[2][1]&0x0000ffff;}}, // set directly in check_reply.check_1 and thread_reader.favicon_obj_trim
        nof_posts:{get: function(){return  this[2][0]&0x0000ffff ;},
                   set: function(v){this[2][0] = (this[2][0] & 0xffff0000) + v;}},

        LS_synced: {get: function(){return this.d&0x00000001;},
                    set: function(v){this.d = (this.d&0xfffffffe) | (v&0x01);}},
        IDB_synced:{get: function(){return (this.d&0x00000002) >> 1;},
                    set: function(v){this.d = (this.d&0xfffffffd) | ((v&0x01)<<1);}},
      })}
    }),
//    mems_obj_accessors: { // to reduce memory consumption.
//      get 0() {return (this._btag)? ((this._0)? [this.btag].concat(this._0) : [this.btag]) : this._0;}, // _0 is null at initial, and will never back to null after once promoted to [].
//      set 0(val) {if (val[0]===this.btag) {
//                     this._btag = true;
//                     val.shift();
//                   } else this._btag = false;
//                   this._0 = (val.length!=0)? val : null;
//                 }
//    },
    postprocess_board_add_btag: function(tags,bd){
      for (var j=0;j<tags.length;j++) {
        tags[j] = '#'+tags[j].replace(/[&<>'"#]/g,'');
        if (tags[j].length>pref.liveTag.maxstr) tags.splice(j--,1);
      }
      var flag = bd.btag2 && bd.btag2.length===tags.length;
      if (flag) for (var j=0;j<tags.length;j++) if (tags[j]!==bd.btag2[j]) {flag = false;break;}
      if (!flag) {
        for (var j=0;j<tags.length;j++) if (liveTag.tags[tags[j]] && liveTag.tags[tags[j]].ref_tag===tags[j]) tags[j] = liveTag.tags[tags[j]].ref_tag; // force to use the same pointer to reduce memory consumption.
        Object.defineProperty(Object.getPrototypeOf(bd),'btag2',{value:tags, writable:true});
        if (pref.liveTag.inherit_board_tags) {
          liveTag.inherit_board_tags_changed_1(tags, bd);
//          for (var j=0;j<tags.length;j++) liveTag.update_boardlist_1(tags[j]); // for passive virtual boarding. // BUG. don't update new tags.
//          for (var j=0;j<tags.length;j++) liveTag.update_pn_buf.delayed_do(); // called in liveTag.inherit_board_tags_changed_1
        }
      }
    },
    retag: function(lth, scan){
      if (scan) {
        scan.list_nup.add_scan(lth);
        lth[2][0] |= 0x00020000;
      }
      var th = {com:lth.tags.join(' '), parse_funcs:{type_com:'txt'}, __proto__:lth}; // patch
      liveTag.prep_tags(th, lth.tag); // lth.tag returns a shallow copy, this is ok.
      if (cataLog.threads[lth.key]) cataLog.Footer.update_force(lth.key,lth);
    },
    retag_db: DelayBuffer.prototype.delayed_do.bind(new DelayBuffer(function(){if (cataLog.catalog_filter_changed) cataLog.catalog_filter_changed();}, 10)),
    inherit_board_name_changed: function(){
      for (var d in this.mems) for (var b in this.mems[d]) this.inherit_board_tags_changed_1([this.mems[d][b].btag], this.mems[d][b], !pref.liveTag.inherit_board_name);
////      if (!pref.liveTag.inherit_board_name) this.delete_tags_buffered();
    },
    inherit_board_tags_changed: function(){
      for (var d in this.mems) for (var b in this.mems[d]) if (this.mems[d][b].btag2) this.inherit_board_tags_changed_1(this.mems[d][b].btag2, this.mems[d][b], !pref.liveTag.inherit_board_tags);
////      if (!pref.liveTag.inherit_board_tags) this.delete_tags_buffered();
    },
    inherit_board_tags_changed_1: function(tags, bd, remove){
      for (var i=0;i<tags.length;i++) this.retag_in_th_sub(tags[i], bd, remove); // must before 'this.retag'.
      for (var j in bd) {
        var th_key = bd.domain + bd.board + bd[j].no;
        this.retag(bd[j], remove && bd[j].tag.length >= pref.liveTag.max);
      }
      this.retag_db();
      this.update_pn_buf.delayed_do();
    },
    ex_list_changed: function(){ // on demand remove only. When you remove a piece of list, reload is required.
      if (pref.liveTag.ex_list) {
        for (var d in this.mems) for (var b in this.mems[d]) for (var t in this.mems[d][b]) {
          var lth = this.mems[d][b][t];
          var tags_len = lth.tag.length;
          if (this.exclude_tags(d+b+t, lth, true)) this.retag(lth, tags_len>=pref.liveTag.max);
////          if (scan.list_nup[th.key]===undefined) {
////            var ex_list = pref_func.merge_obj5(d+b+t,pref.liveTag.ex_list_obj5,null);
////            if (ex_list) {
////              var flag = false;
////              var tag = this.mems[d][b][t];
////              for (var k=0;k<ex_list.length;k++) { // CAUTION. LIMIT CHANGABLE TAG OR ISSUE REDUNDANT ACCESS.
////                for (var j=0;j<2;j++) {
////                  if (tag[j]) for (var i=0;i<tag[j].length;i++) if (ex_list[k].test(tag[j][i])) {
////                    this.delete_tags(tag[j][i],d+b+t);
////                    tag[j].splice(i--,1);
////                    flag = true;
////                  }
////                }
////              }
////              if (flag) {
////                scan.list_nup[d+b+t]=3;
////                tag[2][9] = 'retag';
////              }
////            }
////          }
        }
////        cataLog.catalog_liveTag_scan_threads_delayed_do();
//        this.update_pn_buf.delayed_do();
      }
    },
    exclude_tags: function(key, tag, remove){
      var ex_list = pref_func.merge_obj5a(key,pref.liveTag.ex_list_obj5,null);
      if (ex_list) {
        var flag = false;
        for (var k=0;k<ex_list.length;k++) { // CAUTION. LIMIT CHANGABLE TAG OR ISSUE REDUNDANT ACCESS.
          for (var j=0;j<2;j++) {
            if (tag[j]) for (var i=tag[j].length-1;i>=0;i--) if (ex_list[k].test(tag[j][i])) {
//            if (tag[j]) for (var i=0;i<tag[j].length;i++) if (ex_list[k].test(tag[j][i])) { // BUG, cause infinite loop when ex_list refers btag(board's tag).
              if (remove) this.delete_tags(tag[j][i],key);
              tag[j].splice(i,1);
//              tag[j].splice(i--,1);
              flag = true;
            }
          }
        }
      }
      return flag;
    },
    key_dirty: Object.create(null),
//    key_dirty_creation: Object.create(Object.create(null)),
//    key_dirty: null, // {__proto__:key_dirty_creation},
////    tags_mems: Object.create(null, { // working code.
////      keys_obj: {get: function(){ // working code.
////        var keys = Object.create(null);
////        for (var i in this) {
////////////if (!pref.test_mode['23']) { // test_mode['23'] is meaningless, because String is handled by reference.
////////////          var val = this[i];
////////////} else {
////////////          var val = this.search_from_dic(this[i]);
////////////}
////          if (i[i.length-1]==='/') {
////            var dbt = common_func.fullname2dbt(i);
////            for (var j in liveTag.mems[dbt[0]][dbt[1]]) keys[i+j] = this[i];
////          } else keys[i] = this[i];
////        }
////        return keys;
////      }},
////      keys_length: {get: function(){
////        var len = 0;
////        for (var i in this) {
////          if (i[i.length-1]==='/') {
////            var dbt = common_func.fullname2dbt(i);
////            len += Object.keys(liveTag.mems[dbt[0]][dbt[1]]).length;
////          } else len++;
////        }
////        return len;
////      }},
////////////      search_from_dic: {value: function(no){for (var i in this.dic) if (this.dic[i]==no) return i;}},
////////////      clean_up_dic: {value: function(){
////////////        var keys = {};
////////////        for (var i in this) keys[this[i]] = null;
////////////        for (var i in this.dic) if (keys[this.dic[i]]!==null) delete this.dic[i];
////////////      }},
////    }),
    tags_array_old : [],
    tags_proto: {pk:false, in:false, ex:false, pn:null,
      mems_keys_obj: function(){ // working code.
        var keys = {};
        for (var i of this.mems.keys())
          if (i.no===undefined) for (var j in i) keys[i[j].key] = this.mems.get(i);
          else keys[i.key] = this.mems.get(i);
        return keys;
      },
      mems_keys: function*(){ // iterator is slow in chome because iterator is not optimized.
        for (var i of this.mems.keys())
          if (i.no===undefined) for (var j in i) yield i[j];
          else yield i;
      },
      mems_keys_length: function(){
        var len = 0;
        for (var i of this.mems.keys())
//          if (i.no===undefined) len += Object.keys(i).length; // slow???
          if (i.no===undefined) for (var j in i) ++len;
          else ++len;
        return len;
      },
      mems_keys_length_and_set_top: function(){
        var len = 0;
        var keys = {};
        for (var i of this.mems.keys()) {
          var key = this.mems.get(i);
          if (keys[key]===undefined) keys[key] = 0;
          if (i.no===undefined) for (var j in i) {++keys[key];++len;} // working code.
          else {++keys[key];++len;}
//          if (i.no===undefined) {
//            if (Object.keys(i).length===0) {++keys[key];++len;} // TEST for passive virtual boarding. // TEMPORAL PATCH // empty boards goes high.
//            if (Object.keys(i).length===0) {if (len===0) {++keys[key];++len;}} // TEST for passive virtual boarding. // TEMPORAL PATCH // tag which has only 1 thread goes down.
//            else for (var j in i) {++keys[key];++len;}
//          } else {++keys[key];++len;}
        }
        for (var j in keys) if (keys[j]>keys[this.key] || (keys[j]==keys[this.key] && j<this.key)) this.key = j;
        if (this.key===this.ref_tag) this.key = this.ref_tag; // get the same reference to reduce memory consumption.
        return len;
      },
      mems_boards: function(){
        var tgts = {};
        for (var j of this.mems.keys()) tgts[j.key.substr(0,j.key.lastIndexOf('/')+1)]=null;
        return tgts;
      },
    },
    scan_regex : /#[^#, \.:;\n\|"<>&]+(?=[#, \.:;\n\|"<>&]|$)/g, // ATTENTION. REFER function prep_tag_str();
////    update_tags_in_th_sub: function(tags, keys, src, keys_fix, num, th, ur, btag){ // working code for obj.
////      var count = tags.length;
////      var i = 0;
////      while (count<num && i<src.length) {
////        var k = src[i++];
////        var k_ci = (pref.liveTag.ci)? k.toLowerCase() : k;
////        if (k_ci===k) k_ci=k; // to reduce memory consumption.
////        if (keys_fix[k_ci]===undefined) {
////          if (keys[k_ci]===undefined) {
////            keys[k_ci] = k; // discarded every time, so needless to think about reference of 'k'.
//////            tags[count++] = k;
////            if (this.tags[k]===undefined) {
////              if (this.tags_ci[k_ci]===undefined) {
////////////if (!pref.test_mode['23']) {
////                this.tags_ci[k_ci] = {key:k, mems:Object.create(this.tags_mems), ref_tag:k,
//////                                    pk:false, in:false, ex:false, // moved to prototype
////                                      pn:null, pn_num:0, ur:ur, __proto__:this.tags_proto};
////////////} else {
////////////                this.tags[k] = {key:k, mems:Object.create(this.tags_mems, {dic:{value:{}, writable:true}, dic_no:{value:0, writable:true}}),
////////////                                cbx:{pk:false, in:false, ex:false}, pn:null, pn_num:0, ur:ur};
////////////}
////                if (this.tags[k]===undefined) this.tags[k] = this.tags_ci[k_ci];
////              } else this.tags[k] = this.tags_ci[k_ci];
//////              this.tags[k].tgts[k] = null;
////            }
////////            this.tags[k].mems[name] = k;
////            var mems = this.tags[k].mems;
////////////if (!pref.test_mode['23']) {
////////////            var val = k;
////////////} else {
////////////            if (mems.dic[k]===undefined) {mems.dic[k]=mems.dic_no++;} // to reduce memory consumption, use dictionary.
////////////            var val = mems.dic[k];
////////////}
////            if (k===this.tags[k].ref_tag) k = this.tags[k].ref_tag; // get the same reference to reduce memory consumption. This makes major of members see 'btag'.
////            else for (var j in mems) if (k===mems[j]) {k=mems[j]; break;}
////            if (k!==btag) {
////              if (mems[th.key]!==k) this.key_dirty[k_ci] = null; // cases are changed or a new tag is added. 'if (keys[k_ci]!==k)' ensures (pref.liveTag.ci===true).
////              mems[th.key] = k; // write always to force to use the same reference to reduce memory.
////            }
////            tags[count++] = k;
////          }  // else if (keys[k_ci]!==k) this.tags[this.tags_ci[k_ci]].key_dirty = true; // case is changed. 'if (keys[k_ci]!==k)' ensures (pref.liveTag.ci===true).
////        }
////      }
////      return i;
////    },
    update_tags_in_th_sub: function(tags, keys, src, keys_fix, num, th, ur, bd, clean){
      var count = tags.length;
      var i = 0;
      while (count<num && i<src.length) {
        var k = src[i++];
        var k_ci = (pref.liveTag.ci)? k.toLowerCase() : k;
        if (k_ci===k) k_ci=k; // to reduce memory consumption.
        if (keys_fix[k_ci]===undefined) {
          if (keys[k_ci]===undefined) {
            keys[k_ci] = k; // discarded every time, so needless to think about reference of 'k'.
            if (this.tags[k]===undefined) {
              if (this.tags_ci[k_ci]===undefined) {
                if (this.key_dirty[k_ci]===null) { // fallback for rare case, Case of deleted alerady.
                //  Since tags_array_old ISN'T synchronized with tas.tags_ci,
                //  the same key would be duplicated in tags_array_old when deletion, creation, deletion and creation(4 operations) were in a timeslot. This would be a bug.
                  this.update_pn(); // synchronize them now.
                }
////                this.tags_ci[k_ci] = {key:k, mems: new Map(), ref_tag:k, // not optimized
////                                      pn:null, pn_num:0, ur:ur, __proto__:this.tags_proto};
                var mems_map = new Map(); // consumes 16 Bytes per content, but I can't reduce.... If this is changed to Set, 2.5% reduce in 8chan, but 0.5% in 4chan.(estimated)
                this.tags_ci[k_ci] = {key:k, mems: mems_map, ref_tag:k, // optimized in V8
                                      num:0, ur:ur, __proto__:this.tags_proto};
//                                      pn:null, pn_num:0, ur:ur, __proto__:this.tags_proto};
//                if (k!==k_ci) this.tags[k] = this.tags_ci[k_ci]; // this is equiavlent to 'if (this.tags[k]===undefined)' because this.tags.__proto__ === this.tags_ci // moved to later and was consolidated.
                this.tags_array_old[this.tags_array_old.length] = this.tags_ci[k_ci];
//                this.key_dirty_creation[k_ci] = null; // for pickup in 'update_pn'
//                if (pref.debug_mode['3']) console.log('Added: '+k);
              }
              if (k!==k_ci) { // this is equiavlent to 'if (this.tags[k]===undefined)' because this.tags.__proto__ === this.tags_ci
                this.tags[k] = this.tags_ci[k_ci];
                if (this.tags_ci[k_ci].sb===undefined) this.tags_ci[k_ci].sb = [k]; // subscribe for deletion
                else this.tags_ci[k_ci].sb[this.tags_ci[k_ci].sb.length] = k;
              }
            } // 'else' isn't required because this.tags.__proto__ === this.tags_ci
            var mems = this.tags[k].mems;
            if (k===this.tags[k].ref_tag) k = this.tags[k].ref_tag; // get the same reference to reduce memory consumption. This makes major of members see 'btag'.
            else for (var j in mems) if (k===mems.get(j)) {k=mems.get(j); break;}
//            if (k!==btag) {
            if (!mems.has(bd)) {
              var me = (th===null)? bd : bd[th.no];
              var val = mems.get(me);
              if (val===undefined || val!==k) this.key_dirty[k_ci] = null; // a new tag is added or cases are changed. 'if (keys[k_ci]!==k)' ensures (pref.liveTag.ci===true).
              mems.set(me,k); // write always to force to use the same reference to reduce memory.
            } else if (!clean) this.key_dirty[k_ci] = null; // board tag is hit. Case may be changed in case of board tag.
            tags[count++] = k;
          }
        }
        if (th===null) {
          if (this.tags_reserved[k_ci]!==undefined || this.tags_ci[k_ci]['pk']) this.tags_reserved_found_scan(k_ci, true, this.tags_reserved[k_ci], this.tags_ci[k_ci]['pk'], bd);
        } else if (this.tags_reserved[k_ci]!==undefined) this.tags_reserved_found(k_ci, true, this.tags_reserved[k_ci]);
      }
      return i;
    },
    retag_in_th_sub: function(tag, bd, remove){
      if (remove) {
        if (this.tags[tag]) this.delete_tags(tag, bd.key); // , true);
      } else { // consolidate
        this.update_tags_in_th_sub([], {}, [tag], {}, 1, null, 0, bd);
        var mems = this.tags[tag].mems;  
        for (var t in bd) if (mems.has(t)) mems.delete(t);
      }
    },
    update_tags_in_th: function(src_new, src_old, keys_fix, num, th, watch, bd){
      var ur = this.generate_ur(watch[1]); // moved to here from 'extract_tags' because 'prep_tags' needs this when it has tags_old.
      var tags = [];
      var keys = {};
      this.update_tags_in_th_sub(tags, keys, src_new, keys_fix, num, th, ur, bd);
      if (src_old) {
        var i = this.update_tags_in_th_sub(tags, keys, src_old, keys_fix, num, th, ur, bd);
        while (i<src_old.length) {
          var k = src_old[i++];
          var k_ci = (pref.liveTag.ci)? k.toLowerCase() : k;
          if (keys_fix[k_ci]===undefined) {
            if (keys[k_ci]!==k) this.key_dirty[k_ci] = null; // case is changed, or removed. 'if ((k_ci in keys) && keys[k_ci]!==k)' ensures (pref.liveTag.ci===true).
            if (keys[k_ci]===undefined) this.delete_tags(k,th.key);
          }
        }
      }
      for (var i in keys_fix) this.check_update_tags_color(keys_fix[i],ur);
      for (var i=0;i<tags.length;i++) this.check_update_tags_color(tags[i],ur);
//      this.update_pn();
//      this.update_pn_buf.delayed_do();
//      return [tags, keys, false];
      src_new = null;
      this.keys_fix = keys;
      return tags;
    },
    remove_tags_in_th: function(dbt){
      var lth = this.mems[dbt[0]][dbt[1]][dbt[2]];
      if (!lth) return;
      var tags = lth.tags;
      for (var i=0;i<tags.length;i++) this.delete_tags(tags[i],lth.key);
      var btags = lth.btags;
      if (pref3.stats.use) stats.thread_removed(dbt);
      if (lth.q) lth.q = null; // cut cyclic reference, lth.q.__proto__  = lth
      if (lth.nr && (pref.notify.favicon || pref.notify.title.notify)) notifier.favicon.set();
      delete this.mems[dbt[0]][dbt[1]][dbt[2]];
      if (btags) for (var i=0;i<btags.length;i++) {
        this.key_dirty[(pref.liveTag.ci)? btags[i].toLowerCase() : btags[i]] = null;
        if (pref.liveTag.style) this.update_ur_1(btags[i]); // btags are updated here, AFTER deleting lth.
      }
      this.update_pn_buf.delayed_do();
//      if (pref.debug_mode['3']) console.log('remove: '+name);
//      if (pref.debug_mode['3']) {
////        var th_count = 0;
////        for (var d in this.mems) for (var b in this.mems[d]) for (var t in this.mems[d][b]) th_count++;
////        console.log('remove: '+name+', '+tags.tag+', tags_ci+tags: '+Object.keys(this.tags_ci).length+'+'+Object.keys(this.tags).length+', threads:'+th_count);
//        for (var i in this.tags_ci) for (var j of this.tags_ci[i].mems.keys()) if (j===tags) console.log('ERROR: tags_ci['+i+'].mems has a reference to a deleted thread.');
//      }
    },
    delete_tags: function(tag,name){ // , buffered_deletion){
//      delete this.tags[tag].mems[name];
      var tag_ci = (pref.liveTag.ci)? tag.toLowerCase() : tag;
      this.key_dirty[tag_ci] = null;
//      delete this.key_dirty_creation[tag_ci];
      if (this.tags[tag]) {
        if (this.tags[tag].mems.delete(this.mems.getFromName(name)) && pref.liveTag.style) this.update_ur_1(tag); // only thread's tag is updated here. see remove_tags_in_th.
//        this.tags[tag].mems.delete(this.mems.getFromName(name));
//        if (pref.liveTag.style) this.update_ur_1(tag); // BUG. btags can't be updated here synchronously, because ur is generated by enumerating lths, which will be deleted AFTER here.
//      if (Object.keys(this.tags[tag].mems).length==0) {
        if (this.tags[tag].mems.size==0) {
          var pn = this.tags[tag].pn;
          if (this.tags[tag].pn!==null) this.pn.removeChild(this.tags[tag].pn); // CAUSE ERROR, WHY??? // because of multiple deletion orz. this.tags[tag].pn === this.tags_ci[tag_ci].pn in this case, because this.tags[X] refers prototype which is this.tags_ci[Y]
//          if (this.tags[tag].pn!==null) if (this.tags[tag].pn.parentNode===this.pn) this.pn.removeChild(this.tags[tag].pn);
//          delete this.tags[tag].tgts[tag];
          for (var i in this.active) if (this.tags[tag][i]) this.active[i]--;
          var subscribers = this.tags_ci[tag_ci].sb;
          if (subscribers) for (var i=0;i<subscribers.length;i++) delete this.tags[subscribers[i]];
          delete this.tags_ci[tag_ci];
////          delete this.tags[tag];
//////          if (pref.liveTag.ci) for (var i in this.tags) if (!this.tags[i]) delete this.tags[i]; // tags are not removed in 'update_tags_in_th_sub' if cases are changed.
//////          for (var i in this.tags) if (this.tags[i]===this.tags_ci[tag_ci]) delete this.tags[i]; // TOO SLOW
////          if (!buffered_deletion) { // BUFFERED DELETION MUST BE EXECUTED ATOMICALLY, NO ACCESS TO this.taga BEFORE EXECUTION OF DELETION IS NOT ALLOWED.
////            var keys_tags = Object.keys(this.tags);
////            var tags_ci_obj = this.tags_ci[tag_ci];
////            for (var i=0;i<keys_tags.length;i++) if (this.tags[keys_tags[i]]===tags_ci_obj) delete this.tags[keys_tags[i]];
//////            if (this.tags_ci[tag_ci].pn) this.pn.removeChild(this.tags_ci[tag_ci].pn); // BUG, CAUSED AN ERROR, because of documentfragment??? // because of multiple deletion orz.
////            delete this.tags_ci[tag_ci];
////          } else {
////            if (!this.delete_tags_buffered_list) this.delete_tags_buffered_list = new Set();
////            this.delete_tags_buffered_list.add(this.tags_ci[tag_ci]);
////          }
          if (pref.debug_mode['3']) console.log('Remove: '+tag);
        }
      }
    },
////    delete_tags_buffered_list: null,
////    delete_tags_buffered: function(){
////      if (!this.delete_tags_buffered_list) return;
////      var keys_tags = Object.keys(this.tags);
////      for (var i=0;i<keys_tags.length;i++) if (this.delete_tags_buffered_list.has(this.tags[keys_tags[i]])) delete this.tags[keys_tags[i]];
////      for (var i in this.tags_ci) if (this.delete_tags_buffered_list.has(this.tags_ci[i])) {
//////        if (this.tags_ci[i].pn) this.pn.removeChild(this.tags_ci[i].pn); // because of multiple deletion orz.
////        delete this.tags_ci[i];
////      }
////      this.delete_tags_buffered_list = null;
////    },
    check_update_tags_color: function(tag, ur){ // checks 0->1 only.
      var ur_old = this.tags[tag].ur;
      this.tags[tag].ur |= ur;
//      if (pref.debug_mode['4']) if (ur_old!=ur) console.log('ur: '+tag+', '+ur_old+' <- '+ur);
      if (~ur_old & ur) this.update_tag_node(tag);
    },
    rm_404: function(domain, board, nos){
      if (this.mems[domain] && this.mems[domain][board]) {
        var mems = this.mems[domain][board];
        for (var i in mems) if (nos[i]===undefined) this.rm_404_1(domain, board, i);
      }
    },
    rm_404_1: function(domain, board, no, from_IDB){
      if (!from_IDB) {
        if (!pref.test_mode['65']) if (pref.archive.IDB.auto_clean) IDB.req(domain, board, no, 'pruned_time', Date.now(), 'check_clean');
        if (!pref.test_mode['67']) archiver.clean_list(domain, board, no);
        if (!pref.test_mode['65'] && pref.archive.IDB.auto_restore && cataLog.threads[domain+board+no]) cataLog.restore_th_from_IDB(domain, board, no);
      }
      cataLog.remove_thread(domain+board+no);
      this.remove_tags_in_th([domain,board,no]);
      if (pref[cataLog.embed_mode].deleted_posts.auto_clean) site2[domain].clean_up_deleted_posts_1(board + no);
    },
//    find_friend_tag_ci: function(tag){
//      var tag_l = tag.toLowerCase();
//      for (var i in liveTag.tags) if (tag!==i && tag_l===liveTag.tags[i].key.toLowerCase()) return i;
//      return null;
//    },
    tooltip: function(e, str){
      var tag;
      var et = e.target;
      if (et.type==='checkbox') {
        var suffix = et.name.substr(-2,2);
        tag = et.getAttribute('name').slice(0,-3);
        str += ((suffix==='pk')? 'Fetch' : (suffix==='in')? 'Show' : 'Hide') + ' threads which have ' + tag + '.'
      } else {
        tag = et.getAttribute('name');
        str += tag + ': ' + liveTag.make_info(tag) +'<br>';
//        for (var i in liveTag.tags[tag].mems) str += i + ', ';
        var myDomain = new RegExp('^'+site.nickname);
        for (var i of liveTag.tags[tag].mems.keys()) str += i.key.replace(myDomain,'') + ', ';
      }
      return str;
//      pref_func.tooltips.show_1.call(et, e, str, null, et.type!=='checkbox');
    },
    boardlist_click_entry: function(e){
      if (!e.ctrlKey) {
        e.preventDefault();
        var tag = this.textContent;
        liveTag.cbx_changed(tag, pref.liveTag.click_func_bl, null, this);
      }
    },
    generate_ur: function(info){
      return ((info>>16)!=0)? 3 : ((info&0x0000ffff)!=0)? 1 : 0;
    },
    CountNR: (function(){
// [ForInStatement is not fast case]
// http://www.html5rocks.com/en/tutorials/performance/mystery/?redirect_from_locale=ja
      var CountNR = function(){
        this.nrtm = 0;
        this.nr   = 0;
        this.nth  = 0;
      }
      CountNR.prototype = {
        count: function(th){
          if (th[0]&0x000c0000) {
            var nr = th[1]&0x0000ffff;
            if (nr) {
              this.nrtm += th[1]>>16;
              this.nr   += nr;
              this.nth++;
            }
          }
        }
      }
      return CountNR;
    })(),
    update_ur: function(name,ur,all_case){
      var dbt = common_func.fullname2dbt(name);
      var tag = this.mems[dbt[0]][dbt[1]][dbt[2]];
      this.mems[dbt[0]][dbt[1]].nr = -1;
//      var tag = this.mems.getFromName(name);
      for (var j=0;j<2;j++) if (tag[j]) for (var i=0;i<tag[j].length;i++) 
        if (!all_case) {if (this.tags[tag[j][i]]) this.check_update_tags_color(tag[j][i],ur);}
        else this.update_ur_1(tag[j][i]);
    },
    update_ur_1: function(tag){ // subfunc of 'count_ur'
      var ur_old = this.tags[tag].ur;
      var ur = 0;
if (!pref.test_mode['24']) {
      var mems_objs = this.tags[tag].mems_keys_obj(); // working code.
      for (var i in mems_objs) {
//        var info = this.mems.getFromName(i)[2];
        var info = this.mems.getFromName(i);
        if (info) ur |= liveTag.generate_ur(info[2][1]);
      }
} else {
      for (var i of this.tags[tag].mems_keys())
        ur |= liveTag.generate_ur(i[2][1]);
}
      if (ur_old!=ur) {
        this.tags[tag].ur = ur;
        this.update_tag_node(tag);
      }
    },
//    count_ur: function(tag){
//      var nums = this.count_ur_sub(tag);
//      var friends = Object.create(null);
//      friends[tag] = null;
//      if (pref.liveTag.ci) {
//        var tag_l = tag.toLowerCase();
//        for (var i in liveTag.tags) {
//          if (tag!==i && tag_l===liveTag.tags[i].key.toLowerCase()) {
//            friends[i]=null;
//            if (this.tags[i].ur_cs===null) this.count_ur_sub(i);
//            for (var j=0;j<4;j++) nums[j] += this.tags[i].ur_cs[j];
//          }
//        }
//      }
//      for (var i in friends) this.tags[i].ur = nums;
//      return nums;
//    },
//    count_ur_sub: function(tag){
    count_ur: function(tag){
      var nof_th = 0;
      var bds = {};
      var counter = new this.CountNR();
if (!pref.test_mode['24']) {
      var mems_objs = this.tags[tag].mems_keys_obj(); // working code.
      for (var i in mems_objs) {
        var dbt = common_func.fullname2dbt(i);
        var info = this.mems[dbt[0]][dbt[1]][dbt[2]][2];
        if (info) counter.count(info);
        bds[dbt[0]+dbt[1]] = null;
      }
      nof_th = this.tags[tag].mems_keys_length();
} else {
      for (var i of this.tags[tag].mems_keys()) {
        counter.count(i[2]);
        bds[i.domain+i.board] = null;
        nof_th++;
      }
}
      var nof_bds = Object.keys(this.tags[tag].mems_boards()).length;
      return [counter.nrtm, counter.nr, counter.nth, nof_th, Object.keys(bds).length, nof_bds];
    },
    make_info: function(tag){
      var nums = liveTag.count_ur(tag); // must exec every time because every update are NOT exact.
      return 'U: '+nums[0]+'/'+nums[1]+'/'+nums[2]+' / T: '+nums[3]+' / B: '+nums[4]+'/'+nums[5];
    },
    tag_onmouseover: function(e){
//      var et = e.target;
//      if (pref.liveTag.info) pref_func.tooltips.show_1.call(et, e, liveTag.make_info(et.textContent), null, true);
      return liveTag.make_info(e.target.textContent);
    },
    cbx_changed: function(tag, func, no_scan, node_in_boardlist){
      var obj = this.tags[tag];
      var inv_in = func==='pkin' || func==='in' || (func==='inex' && !(this.tags[tag]['in']===false && this.tags[tag]['ex']===true));
      var inv_pk = func==='pkin' && obj['pk']===obj['in'];
      var inv_ex = func==='ex' || (func==='inex' && !(obj['in']===false && obj['ex']===false));
      if (inv_in) this.cbx_emulate_inv(tag, 'in', no_scan); // 'in' must be processed first to prevent auto set.
      if (inv_pk) this.cbx_emulate_inv(tag, 'pk', no_scan); // 'in' is NOT changed here.
      if (inv_ex) this.cbx_emulate_inv(tag, 'ex', no_scan);
      if (cataLog.catalog_filter_changed) cataLog.catalog_filter_changed();
      this.update_tag_node(tag, node_in_boardlist);
    },
//    cbx_changed: function(tag, func, no_scan, node_in_boardlist){ // working code
//      if (func==='pkin') {
//        if (this.tags[tag]['pk'] !== !this.tags[tag]['in']) {
//          this.tags[tag]['pk'] = !this.tags[tag]['in'];
//          if (this.tags[tag].pn!==null) this.tags[tag].pn.childNodes[0].checked = this.tags[tag]['pk'];
//          this.cbx_onchange(tag,'pk', no_scan); // 'in' is upped automatically when pk goes 0 -> 1.
//        }
//        if (this.tags[tag]['in'] !== this.tags[tag]['pk']) {
//          this.tags[tag]['in'] = this.tags[tag]['pk'];
//          if (this.tags[tag].pn!==null) this.tags[tag].pn.childNodes[1].checked = this.tags[tag]['in'];
//          this.cbx_onchange(tag,'in');
//        }
//      } else {
//        var in_old = this.tags[tag]['in'];
//        if (func==='in' || (func==='inex' && !(this.tags[tag]['in']===false && this.tags[tag]['ex']===true))) {
//          this.tags[tag]['in'] = !this.tags[tag]['in'];
//          if (this.tags[tag].pn!==null) this.tags[tag].pn.childNodes[1].checked = this.tags[tag]['in'];
//          this.cbx_onchange(tag,'in');
//        }
//        if (func==='ex' || (func==='inex' && !(in_old===false && this.tags[tag]['ex']===false))) {
//          this.tags[tag]['ex'] = !this.tags[tag]['ex'];
//          if (this.tags[tag].pn!==null) this.tags[tag].pn.childNodes[2].checked = this.tags[tag]['ex'];
//          this.cbx_onchange(tag,'ex');
//        }
//      }
//      this.cbx_onchange_after();
//      this.update_tag_node(tag, node_in_boardlist);
//    },
//    filter_onchange_entry : function(e){liveTag.filter_onchange(this, e);},
    filter_onchange: function(pref_obj, init){
      pref_obj.rexps = common_func.kwd_prep_regexp(pref_obj);
//      this.pn_filter_rexp = (pref.catalog.filter.tag_search.str==='')? null : new RegExp(pref.catalog.filter.tag_search.str, (pref.liveTag.ci)? 'i': undefined);
////      for (var i in this.tags) // working code.
////        if (this.tags[i].pn!==null) this.tags[i].pn.style.display = (this.pn_filter_rexp===null || this.pn_filter_rexp.test(i))? '' : 'none';
      if (!init) this.update_pn(pref_obj === pref.catalog.filter.tag_search);
    },
////    set_reserved_tags: function(tags,set){ // working code
////      for (var i=0;i<tags.length;i++) {
////        var tag = tags[i];
////        var tag_ci = (pref.liveTag.ci)? tag.toLowerCase() : tag;
////        if (this.tags_ci[tag_ci]) {
////          if (this.tags_ci[tag_ci]['pk']!=set) this.cbx_changed(tag_ci,'pkin', true);
////          this.update_tag_node(tag_ci);
////          tags.splice(i--,1);
////        }
////      }
////    },
    tags_reserved: Object.create(null),
    tags_reserved_found_scan: function(tag_ci,set, func_pk, pk, bd){
      if (func_pk || pk) {
        scan.list_nup.add_board(bd,0);
        scan.scan('b',bd.domain);
      }
      if (func_pk!==undefined) this.tags_reserved_found(tag_ci,set, func_pk);
    },
    tags_reserved_found: function(tag_ci,set, func_pk){
      if (this.tags_ci[tag_ci][(func_pk)?'pk':'in']!=set) this.cbx_changed(tag_ci,(func_pk)?'pkin':'in', true);
      delete this.tags_reserved[tag_ci];
    },
    tags_reserved_init: function(tags,set){
      this.tags_reserved = Object.create(null);
      var bds_pickup = {};
      for (var i=0;i<tags.length;i++) {
        var tag_pk = tags[i][1]==='#'; // ##tag for 'pkin', #tag for 'in'
        var tag_ci = (pref.liveTag.ci)? tags[i].toLowerCase() : tags[i]; // tags_ci must be used becase tags in blist is raw, the tag may not exist in liveTag.tags[tag].
        if (tag_pk) tag_ci = tag_ci.substr(1);
        if (this.tags_ci[tag_ci]) {
          this.tags_reserved_found(tag_ci,set,tag_pk);
          if (set && tag_pk) {
            var bds = liveTag.tags_ci[tag_ci].mems_boards();
            for (var bd in bds) bds_pickup[bd] = null;
          }
        } else if (set) this.tags_reserved[tag_ci] = tag_pk;
      }
      return bds_pickup;
    },
    update_pn_last_filter_active: false,
    sort_func: function(a,b){return b.num - a.num || b.mems.size - a.mems.size || ((b.key > a.key)? -1:1);},
    update_pn_disp_func: function(rexps, key){
      if (rexps===null) return 0;
      for (var i=0;i<rexps.length;i++) if (rexps[i].test(key)) return 1; // match any
      return 0;
    },
    update_pn_buf: null,
    update_pn: function(from_filter){
      if (this.pn===0) return; // trap for thread_reader.
      if (this.pn===null) {
        this.pn = document.getElementsByName('catalog.filter.tag_list')[0];
        if (this.pn) {
          this.pn.style.height = '16px';
          this.pn.style.width = '250px';
          this.pn_summary = this.pn.previousSibling.childNodes[0];
          this.pn.onchange = this.cbx_onchange_entry;
          this.filter_onchange(pref.catalog.filter.tag_search, true);
        } else {
          this.pn = 0;
          return;
        }
      }
      this.update_pn_1_lazy.cancel();
      this.update_pn_1(from_filter, true);
    },
    update_pn_pos: null,
    update_pn_1_lazy: null, // bound later, update_pn_1.bind(liveTag,true)
    update_pn_1: function(from_filter, from_initial){
//      if (this.reserved) { // worning code
//        this.set_reserved_tags(this.reserved,true);
//        if (this.reserved.length===0) this.reserved = null;
//      }

////      var tags_array = []; // working code.
//////      var keys = {};
//////      for (var i in this.tags) // patch, this can be removed if this.tags is fully overlayed at pref.liveTag.ci. // PATCHES CAN BE REMOVED
//////        if (keys[i]!==null) {
//////          keys[i] = null;
//////          tags_array[tags_array.length] = {key:i, num:Object.keys(this.tags[i].mems).length};
//////        }
//////      if (pref.liveTag.ci) {
//////        for (var i=0;i<tags_array.length;i++) { // search major key
//////          keys = {};
//////          var mems = this.tags[tags_array[i].key].mems;
//////          for (var j in mems) keys[mems[j]] = (keys[mems[j]] || 0) +1;
//////          for (var j in keys) if (keys[j]>keys[tags_array[i].key]) tags_array[i].key = j;
//////        }
//////      }
////
////      if (pref.liveTag.ci) {
////        for (var i in this.key_dirty) { // set major key
////          var tag_obj = this.tags_ci[(pref.liveTag.ci)? i.toLowerCase() : i];
////          if (tag_obj) {
////            var keys = {};
////            var mems = tag_obj.mems;
////            for (var j in mems) keys[mems[j]] = (keys[mems[j]] || 0) +1;
////            var key_old = tag_obj.key;
////////////if (!pref.test_mode['23']) {
////            for (var j in keys) if (keys[j]>keys[tag_obj.key]) tag_obj.key = j;
////////////} else {
////////////            for (var j in keys) if (keys[j]>keys[tag_obj.key]) tag_obj.key = tag_obj.mems.search_from_dic(j);
////////////            mems.clean_up_dic();
////////////}
////            if (key_old!==tag_obj.key) if (tag_obj.pn) tag_obj.pn.childNodes[3].textContent = Object.keys(tag_obj.mems).length + ': ' + tag_obj.key;
////          }
////        }
////      }
////      this.key_dirty = Object.create(null);
////      for (var i in this.tags_ci) tags_array[tags_array.length] = {key:this.tags_ci[i].key, num:this.tags_ci[i].mems_keys_length(),
////                                                                   disp: (this.pn_filter_rexp===null || !this.pn_filter_rexp.test(this.tags_ci[i].key))? 0 : 1};
////      tags_array.sort(this.sort_func);

//      var tags_array = this.tags_array_old; // working code.
//      for (var i=0;i<tags_array.length;i++) {
//        var key = tags_array[i].key;
//        var k_ci = (pref.liveTag.ci)? key.toLowerCase() : key;
//        if (this.key_dirty[k_ci]===null) {
//          delete this.key_dirty[k_ci];
//          if (this.tags_ci[k_ci]) {
//            tags_array[i].num = (pref.liveTag.ci)? this.tags_ci[k_ci].mems_keys_length_and_set_top() : this.tags_ci[k_ci].mems_keys_length();
//            if (key!==this.tags_ci[k_ci].key) {
//              if (this.tags_ci[k_ci].pn) this.tags_ci[k_ci].pn.childNodes[3].textContent = tags_array[i].num + ': ' + this.tags_ci[k_ci].key;
//              tags_array[i].key = this.tags_ci[k_ci].key;
//            }
//          } else {
//            tags_array.splice(i--,1);
//            continue;
//          }
//        }
//        if (from_filter) tags_array[i].disp = this.update_pn_disp_func(pref.catalog.filter.tag_search.rexps, tags_array[i].key);
//      }
//      for (var i in this.key_dirty)
//        if (this.tags_ci[i]) {
//          var tags_ary_num = (pref.liveTag.ci)? this.tags_ci[i].mems_keys_length_and_set_top() : this.tags_ci[i].mems_keys_length(); // sets key
//          tags_array[tags_array.length] = {key:this.tags_ci[i].key, num:tags_ary_num,
//                                           disp: this.update_pn_disp_func(pref.catalog.filter.tag_search.rexps, this.tags_ci[i].key)};
//        }
//      tags_array.sort(this.sort_func);
//      this.key_dirty = Object.create(null);

      var tags_array = this.tags_array_old;
      var dirty_count = 0;
      var dirty_count_deleted = 0;
      for (var k_ci in this.key_dirty) { // must enumerate item in prototype.
        if (this.tags_ci[k_ci]) {
          this.tags_ci[k_ci].num = (pref.liveTag.ci)? this.tags_ci[k_ci].mems_keys_length_and_set_top() : this.tags_ci[k_ci].mems_keys_length();
//          delete this.key_dirty_creation[k_ci]; // may be respawned, typically by IDB.
        } else dirty_count_deleted++; // CAUTION, this incudes count of creation.
        dirty_count++;
      }
//      for (var k_ci in this.key_dirty_creation) if (this.tags_ci[k_ci]) tags_array[tags_array.length] = this.tags_ci[k_ci];
      if (dirty_count || pref.test_mode['73']) tags_array.sort(this.sort_func);

////      for (var i in this.tags) tags_array[tags_array.length] = {key:i, num:Object.keys(this.tags[i].mems).length, mems:{}}; // working code.
//////      for (var i in this.tags) { // working code, moved to 'delete_tags'.
//////        var num = Object.keys(this.tags[i].mems).length;
//////        if (num==0){
//////          if (this.tags[i].pn!==null) this.pn.removeChild(this.tags[i].pn);
//////          delete this.tags[i];
//////          if (pref.debug_mode['3']) console.log('Remove: '+i);
//////        } else tags_array[tags_array.length] = {key:i, num:num, mems:{}};
//////      }
////
////      tags_array.sort(this.sort_func);
////
////      if (pref.liveTag.ci) {
////        var tags_ci = Object.create(null);
////        for (var i=0;i<tags_array.length;i++) {
////          var key = tags_array[i].key.toLowerCase();
////          if (!(key in tags_ci)) tags_ci[key] = i;
////          else {
////            var src = this.tags[tags_array[i].key];
////            var ref = this.tags[tags_array[tags_ci[key]].key];
////            var dst = tags_array[tags_ci[key]];
////            for (var j in src.mems) if (!(j in ref.mems)) dst.mems[j] = null;
////            dst.num = Object.keys(ref.mems).length + Object.keys(dst.mems).length;
////            tags_array[i].num = 0;
//////            src.pk = ref.pk;
//////            src.in = ref.in;
//////            src.ex = ref.ex;
//////            ref.ci[tags_array[i].key] = null;
////////            src.ci = {};
////            if (src.pn!==null) { // force to remake to reflect changes next time.
////              if (src.pn!==null) this.pn.removeChild(src.pn);
////              src.pn=null;
////              src.pn_num=0;
////            }
////          }
////        }
////        tags_array.sort(this.sort_func);
////      }
//////      if (pref.debug_mode['3']) console.log(JSON.stringify(tags_array));

      if (dirty_count) from_initial = true;
      var exam_pn = from_filter || this.update_pn_pos;
      var limit = pref.liveTag.lazy_each;
      var rexps = pref.catalog.filter.tag_search.rexps;
      var historical_filter_active = rexps || this.update_pn_last_filter_active;
      if (historical_filter_active || dirty_count_deleted) {
        var docfrag = (rexps && this.pn.firstChild)? null : document.createDocumentFragment();
        var pos_insert = (from_initial)? 0 : this.update_pn_pos[0];
        var pf_boards = pref.catalog.filter.tag_search.show_nof_boards;
        for (var i=(from_initial)? 0 : this.update_pn_pos[1];i<tags_array.length;i++) {
          var key = tags_array[i].key;
          var key_ci = (pref.liveTag.ci)? key.toLowerCase() : key;
          var dirty = (key_ci in this.key_dirty);
          var tag_obj = this.tags_ci[key_ci];
          if (tag_obj) {
            if (historical_filter_active) {
              var pn = tag_obj.pn;
              if (exam_pn || dirty) {
                var disp = this.update_pn_disp_func(rexps, key_ci);
                if (disp===0) {
                  if (pn!==null) {
                    this.pn.removeChild(pn);
                    tag_obj.pn = null;
                  }
                } else {
                  if (pn!==null) {
                    if (dirty) tag_obj.pn.childNodes[3].textContent = tag_obj.num + ': ' + key;
                    if (limit>0) if (this.pn.childNodes[pos_insert]!==pn) {
                      this.pn.insertBefore(pn, this.pn.childNodes[pos_insert] || null);
                      if (--limit==0) this.update_pn_pos = [pos_insert+1,i+1];
                    }
                  } else if (limit>0) {
                    pn = document.createElement('div');
                    pn.setAttribute('name',key);
                    pn.innerHTML = 
                      '<input type="checkbox" name="' + key_ci + '.pk" ' + ((tag_obj['pk'])? 'checked' : '') + '>' + 
                      '<input type="checkbox" name="' + key_ci + '.in" ' + ((tag_obj['in'])? 'checked' : '') + '>' + 
                      '<input type="checkbox" name="' + key_ci + '.ex" ' + ((tag_obj['ex'])? 'checked' : '') + '>' +
                        tag_obj.num +(pf_boards? '/'+Object.keys(this.tags[key].mems_boards()).length:'')+': ' + key; // same in popup_filter
                    tag_obj.pn = pn;
                    if (docfrag) docfrag.appendChild(pn);
                    else this.pn.insertBefore(pn, this.pn.childNodes[pos_insert] || null);
                    if (--limit==0) this.update_pn_pos = [pos_insert+1,i+1];
                  }
                  pos_insert++;
                }
              } else if (pn) pos_insert++;
            }
          } else tags_array.splice(i--,1); // for deleted tags, they weren't removed in 'delete_tags'.
          if ((dirty_count<=0 || dirty && --dirty_count<=0) && (!historical_filter_active || limit<=0)) break;
        }
        if (limit<=0 && this.update_pn_pos[1]<tags_array.length) this.update_pn_1_lazy.delayed_do(pref.liveTag.lazy_delay);
        else this.update_pn_pos = null;
        if (docfrag) this.pn.appendChild(docfrag);
        this.pn_summary.textContent = (rexps)? pos_insert+'/'+tags_array.length : '';
      }

//      var historical_filter_active = pref.catalog.filter.tag_search.rexps.length!=0 || this.update_pn_last_filter_active; // working code.
//      if (historical_filter_active || dirty_count_deleted) {
//        if (pref.debug_mode['34']) {console.time('update_pn');console.time('update_pn2');}
//        var docfrag = (pref.catalog.filter.tag_search.rexps.length!==0 && this.pn.firstChild)? null : (pref.test_mode['74'])? this.pn.cloneNode() : document.createDocumentFragment();
//        var pos_insert=0;
//        for (var i=0;i<tags_array.length;i++) {
//          var key = tags_array[i].key;
//          var key_ci = (pref.liveTag.ci)? key.toLowerCase() : key;
//          var dirty = (key_ci in this.key_dirty);
//          var tag_obj = this.tags_ci[key_ci];
//          if (tag_obj) {
//            var pn = tag_obj.pn;
//            if (from_filter || dirty) {
//              var disp = this.update_pn_disp_func(pref.catalog.filter.tag_search.rexps, key_ci);
//              if (pn!==null) {
//                if (disp===0) { // for passive virtual boarding.
// //            if (tags_array[i].num===0 || tags_array[i].disp===0) {
//                  this.pn.removeChild(pn);
//                  tag_obj.pn = null;
//                } else {
//                  if (dirty) tag_obj.pn.childNodes[3].textContent = tag_obj.num + ': ' + key;
//                  if (this.pn.childNodes[pos_insert]!==pn) this.pn.insertBefore(pn, this.pn.childNodes[pos_insert] || null);
//                  pos_insert++;
//                }
//              } else if (disp==1) { // for passive virtual boarding.
//    //          } else if (tags_array[i].num!=0 && tags_array[i].disp==1) {
//                pn = document.createElement('div');
//                pn.setAttribute('name',key);
////                pn = document.createElement('span');
//                pn.innerHTML = ((pref.test_mode['101'])? '<span>P</span><span>I</span><span>E</span>'
//                                : '<input type="checkbox" name="' + key_ci + '.pk" ' + ((tag_obj['pk'])? 'checked' : '') + '>' +
//                                '<input type="checkbox" name="' + key_ci + '.in" ' + ((tag_obj['in'])? 'checked' : '') + '>' +
//                                '<input type="checkbox" name="' + key_ci + '.ex" ' + ((tag_obj['ex'])? 'checked' : '') + '>') +
//                  tag_obj.num + ': ' + key;
////                               '<span name="' + key + '">' + tag_obj.num + ': ' + key + '</span><br>';
//                if (docfrag) docfrag.appendChild(pn);
//                else this.pn.insertBefore(pn, this.pn.childNodes[pos_insert] || null);
//                pos_insert++;
////                this.pn.insertBefore(pn, this.pn.childNodes[pos_insert++] || null);
//                tag_obj.pn = pn;
//              }
//            } else if (pn) pos_insert++;
//          } else {
//            tags_array.splice(i--,1); // for deleted tags, wasn't checked in 'delete_tags'.
////            if (--dirty_count_deleted<=0 && !historical_filter_active) break; // redundant.
//          }
//          if (dirty && --dirty_count<=0 && !historical_filter_active) break;
//        }
//        if (pref.debug_mode['34']) console.timeEnd('update_pn');
//        if (docfrag) { // no effect
//          if (pref.test_mode['74']) { // no effect
//            this.pn.parentNode.replaceChild(docfrag, this.pn);
//            this.pn = docfrag;
//          } else this.pn.appendChild(docfrag);
//        }
//        if (pref.debug_mode['34']) console.timeEnd('update_pn2');
//        this.pn_summary.textContent = (pref.catalog.filter.tag_search.rexps.length!==0)? pos_insert+'/'+tags_array.length : '';
//      }

////      var j=0;
//      var pos_insert=0; // working code.
//      for (var i=0;i<tags_array.length;i++) {
//        var key = tags_array[i].key;
//        if (!this.tags[key]) {tags_array.splice(i--,1);continue;} // for deleted tags, didn't checked in 'delete_tags'.
//        var num = tags_array[i].num;
//        var num_old = this.tags[key].pn_num;
//        if (num!==num_old || from_filter) {
//          var str = num + ': ' + key;
//          this.tags[key].pn_num = num;
//          var pn = this.tags[key].pn;
//          if (pn!==null) {
//            if (tags_array[i].disp===0) { // for passive virtual boarding.
////            if (tags_array[i].num===0 || tags_array[i].disp===0) {
//              this.pn.removeChild(pn);
//              this.tags[key].pn = null;
//            } else {
//              this.tags[key].pn.childNodes[3].textContent = str;
////              if (this.tags_array_old[j] && key===this.tags_array_old[j].key) j++;
////              else {
//              if (this.pn.childNodes[pos_insert]!==pn) this.pn.insertBefore(pn, this.pn.childNodes[pos_insert] || null);
//              pos_insert++;
////                this.pn.insertBefore(pn, this.pn.childNodes[pos_insert++] || null);
////                if (pref.debug_mode['3']) console.log('Insert: '+((num>num_old)?'promote: ':'demote: ')+key+', '+num_old+' -> '+num+', '+i+', '+j+', '+num_of_skip);
////                if (num<num_old) num_of_skip--;
////              }
//            }
//          } else if (tags_array[i].disp==1) { // for passive virtual boarding.
////          } else if (tags_array[i].num!=0 && tags_array[i].disp==1) {
//            pn = document.createElement('span');
//            pn.innerHTML = '<input type="checkbox" name="' + key + '.pk" ' + ((this.tags[key]['pk'])? 'checked' : '') + '>' + 
//                           '<input type="checkbox" name="' + key + '.in" ' + ((this.tags[key]['in'])? 'checked' : '') + '>' + 
//                           '<input type="checkbox" name="' + key + '.ex" ' + ((this.tags[key]['ex'])? 'checked' : '') + '>' +
//                           '<span name="' + key + '">' + str + '</span><br>';
//            pn.childNodes[0].onchange = this.cbx_onchange_entry;
//            pn.childNodes[1].onchange = this.cbx_onchange_entry;
//            pn.childNodes[2].onchange = this.cbx_onchange_entry;
////            pn.childNodes[0].onmouseover = this.tooltip;
////            pn.childNodes[1].onmouseover = this.tooltip;
////            pn.childNodes[2].onmouseover = this.tooltip;
////            pn.childNodes[3].onmouseover = this.tooltip;
////            pn.style = {};
////            pn.style.display = (this.pn_filter_rexp===null || this.pn_filter_rexp.test(key))? '' : 'none';
//            this.pn.insertBefore(pn, this.pn.childNodes[pos_insert++] || null);
//            this.tags[key].pn = pn;
////            for (var j in this.tags[key].tgts) this.tags[j].pn = pn;  // PATCHES CAN BE REMOVED
//          }
//        } else if (tags_array[i].disp==1) pos_insert++;
//////        } else { // tracking // working code.
//////          while (j<this.tags_array_old.length && key!==this.tags_array_old[j].key) {
//////            if (this.tags[this.tags_array_old[j].key] && this.tags[this.tags_array_old[j].key].pn_num==this.tags_array_old[j].num) num_of_skip++; // removed(to be 0) while waiting or not processed yet(demote)
////////            if (pref.debug_mode['3']) {
////////              var debug_str = this.tags_array_old[j].key+', '+this.tags_array_old[j].num+', '+num_of_skip;
////////              if (this.tags[this.tags_array_old[j].key]===undefined) console.log('Removed: '+debug_str);
////////              else if (this.tags[this.tags_array_old[j].key].pn_num==this.tags_array_old[j].num) console.log('Skip: '+debug_str);
////////            }
//////            j++;
//////          }
//////          j++;
//////        }
//      }
      this.tags_array_old = tags_array;
      this.key_dirty = Object.create(null);
//      this.key_dirty_creation = Object.create(Object.create(null));
//      this.key_dirty = Object.create(this.key_dirty_creation);

//      if (pref.debug_mode['3']) { // CHECKER, working code.
//        var flag = true;
//        var dom = [];
//        for (var i=0;i<tags_array.length;i++) {
//          if (tags_array[i].num==0) break;
//          var tgt = this.pn.childNodes[i].childNodes[3].textContent;
//          var key = tgt.replace(/[^:]+: /,'');
//          dom[dom.length] = key;
//          if (tags_array[i].key!==key) {
//            var j=0;
//            while (j<tags_array.length && tags_array[j].key!==key) j++;
//            if (j==tags_array.length) j=-1;
//            var k=0;
//            while (k<this.tags_array_old.length && this.tags_array_old[k].key!==key) k++;
//            if (k==this.tags_array_old.length) k=-1;
//            console.log('ERROR: '+tgt+', should be '+j+', but '+i+', '+k+' in old');
//            flag = false;
//          }
//        }
//        if (!flag) {
//          console.log(tags_array);
//          console.log(dom);
//          console.log(this.tags_array_old);
//        }
//      }

//      this.pn.innerHTML = '';
//      for (var i=0;i<tags_array.length;i++) if (tags_array[i].num!=0) {
//        var item = document.createElement('span');
//        var key = tags_array[i].key;
//        var str  = tags_array[i].num + ': ' + key;
//        item.innerHTML = '<input type="checkbox" name="' + key + '.pk" ' + ((this.tags[key].pk)? 'checked' : '') + '>' +
//                         '<input type="checkbox" name="' + key + '.in" ' + ((this.tags[key].in)? 'checked' : '') + '>' +
//                         '<input type="checkbox" name="' + key + '.ex" ' + ((this.tags[key].ex)? 'checked' : '') + '>' +
//                         '<span name="' + key + '">' +  str + '</span><br>';
//        item.childNodes[0].onchange = this.cbx_onchange_entry;
//        item.childNodes[1].onchange = this.cbx_onchange_entry;
//        item.childNodes[2].onchange = this.cbx_onchange_entry;
//        item.childNodes[3].onmouseover = pref_func.tooltips.show;
//        this.pn.appendChild(item);
//      }
      if (pref.virtualBoard.show && !from_filter) this.update_boardlist();
      this.update_pn_last_filter_active = rexps;
    },
    popup_filter: (function(){
      var oninput_funcs = {
        'catalog.filter.tag_search.str': function(){liveTag.filter_onchange(pref.catalog.filter.tag_search);},
        __proto__: pref_func.settings.oninput_funcs.__proto__
      };
      var onchange_funcs = {
        'catalog.filter.tag_search.re': oninput_funcs['catalog.filter.tag_search.str'],
        'catalog.filter.tag_search.show_nof_boards': function(){
          var pf_boards = pref.catalog.filter.tag_search.show_nof_boards;
          for (var i=0;i<liveTag.tags_array_old.length;i++) {
            var key = liveTag.tags_array_old[i].key;
            var tag_obj = liveTag.tags[key];
            if (tag_obj && tag_obj.pn) tag_obj.pn.childNodes[3].textContent = tag_obj.num +(pf_boards? '/'+Object.keys(liveTag.tags[key].mems_boards()).length:'')+': ' + key; // same in update_pn_1
          }
        },
        __proto__: oninput_funcs
      };
      return {
        html:
          '<div style="float:left">'+
            '<input type="checkbox" name="catalog.filter.tag"> Tag :'+
          '</div>'+
          '<div style="float:left">'+
            '<div>'+
              ' Fetcn / In / Out / Threads / Tag '+
              '<ITBL25"catalog.filter.tag_search.str" placeholder="Search tags...">'+
  //            ' <ICBX"catalog.filter.tag_search.ci">CI'+
              ' <ICBX"catalog.filter.tag_search.re">RE'+
            '</div>'+
            '<div><span></span>'+pref_func.settings.html_funcs.rollup(
              '<IC"catalog.filter.tag_search.show_nof_boards">Show number of boards<br>'+
              '<BTN"tagB.shown_t_pk,T"><BTN"tagB.shown_t_in,T"><BTN"tagB.shown_t_ex,T"> Toggle checkboxes of shown tags<br>'+ // span for not being wrapped by label.
              '<BTN"tagB.shown_c_pk,C"><BTN"tagB.shown_c_in,C"><BTN"tagB.shown_c_ex,C"> Clear checkboxes of shown tags<br>'+
              '<BTN"tagB.all_c_pk,C"><BTN"tagB.all_c_in,C"><BTN"tagB.all_c_ex,C"> Clear checkboxes of all tags')+'<br></div>'+
            '<div style="overflow:auto;resize:both;float:left" name="catalog.filter.tag_list"></div>'+
            pref_func.settings.html_funcs.rollup('<div style="clear:both">'+
              '<BTN"tag2bList,Add"> selected tags to the last of board group<br>'+
              '1,Label: <ITBL20"catalog.filter.tag2bList.label" placeholder="default: topmost tag"><br>'+
              '1,<IR"catalog.filter.tag2bList.by,tag">By tag<br>'+
              '1,<IR"catalog.filter.tag2bList.by,board">By board<br>'+
            '</div>')+
  //          '<a name="SHOW" style="cursor:pointer" data-str="[\u25b2]">[\u25bc]</a>'+
  //          '<div name="SUB" style="clear:both;display:none">TEST</div>'+
          '</div>'+
          '<div style="clear:both"></div>', // for floating
        oninput_funcs: oninput_funcs,
        onchange_funcs: onchange_funcs,
        popup: function(){
          if (liveTag.pn) return;
          var exit_func = function(){
            pref_func.tooltips.remove_root(popup.pn);
            liveTag.pn = null;
            cnst.div_destroy(popup.pn, true);
          };
          var popup = cnst.init3({func_str:'top:0px:left:0px:Show:tb', exit:exit_func});
          popup.cn.innerHTML = pref_func.format_html_str(liveTag.popup_filter.html);
          pref_func.add_onchange(popup.cn,onchange_funcs, oninput_funcs);
          pref_func.apply_prep(popup.pn, false);
          pref_func.tooltips.add_root(popup.pn);
          liveTag.update_pn(true);
        },
      };
    })(),
    cbx_all_onchange: function(e){
      var et = e.target;
      var clear = et.name.substr(-4,1)==='c';
      var prop = et.name.substr(-2,2);
      var all = et.name.substr(-8,3)==='all';
      var tgts_all = null;
      for (var tag_ci in liveTag.tags_ci) {
        var obj = liveTag.tags_ci[tag_ci];
        if (all || obj.pn) if (!clear || obj[prop]) {
          liveTag.cbx_emulate_inv(tag_ci, prop, true);
          liveTag.update_tag_node(tag_ci);
          if (prop==='pk' && obj[prop]) {
            var tgts = liveTag.tags_ci[tag_ci].mems_boards();
            if (!tgts_all) tgts_all = tgts;
            else for (var b in tgts) tgts_all[b] = tgts[b];
          }
        }
      }
      if (tgts_all && Object.keys(tgts_all).length!=0) scan.scan_ui('refresh_tag', {tgts: tgts_all, options:{callback:function(){scan.scan('t');}, priority:6}});
      if (cataLog.catalog_filter_changed) cataLog.catalog_filter_changed();
    },
    cbx_emulate_inv: function(tag, prop, no_scan){
      var obj = this.tags[tag];
      var val = !obj[prop];
      obj[prop] = val;
      if (obj.pn!==null) obj.pn.childNodes[prop==='pk'? 0 : prop==='in'? 1 : 2].checked = val;
      this.cbx_onchange(tag, prop, val, no_scan);
    },
////    cbx_onchange_entry : function(e){liveTag.cbx_onchange(this, e, true);},
////    cbx_onchange : function(sender, e, from_cbx){ // working code.
////      var prop = sender.name.substr(-2,2);
//////      var val = e.target.checked;
////      var val = sender.checked;
////      var tag = sender.name.substr(0,sender.name.length-3);
    cbx_onchange_entry: function(e){
      var et = e.target;
      var tag = et.name.slice(0,-3);
      var prop = et.name.substr(-2,2);
      liveTag.tags[tag][prop] = et.checked;
      liveTag.cbx_onchange(tag, prop, liveTag.tags[tag][prop]);
      if (cataLog.catalog_filter_changed) cataLog.catalog_filter_changed();
      liveTag.update_tag_node(tag);
    },
    cbx_onchange : function(tag, prop, val, no_scan){
      this.active[prop] += (val)? 1 : -1;
      if (prop==='pk') {
        if (val && !this.tags[tag]['in']) this.cbx_emulate_inv(tag, 'in');
//        if (val && !this.tags[tag]['in']) {
//          this.tags[tag]['in'] = true;
//          this.active['in'] += 1;
//          if (this.tags[tag].pn!==null) this.tags[tag].pn.childNodes[1].checked = true;
////          this.update_pn_buf.delayed_do();
//        }
//        var tgts = {};
////        var now = Date.now();
////        var prev = now - pref.liveTag.pickup_interval*1000;
////        for (var i in this.tags)
////          if (this.tags[i]['pk'] && (this.tags[i]['pk']==='true' || this.tags[i]['pk']<prev)) {
////            this.tags[i]['pk']=now;
////            for (var j in this.tags[i].mems) tgts[j.substr(0,j.lastIndexOf('/')+1)]=null;
////          }
////        if (val) for (var i in this.tags[tag].tgts) for (var j in this.tags[i].mems) tgts[j.substr(0,j.lastIndexOf('/')+1)]=null; // working code.
////        if (val) for (var j in this.tags[tag].mems) tgts[j.substr(0,j.lastIndexOf('/')+1)]=null;
//        if (val) for (var j of this.tags[tag].mems.keys()) tgts[j.key.substr(0,j.key.lastIndexOf('/')+1)]=null; // working code.
        if (val && !no_scan && catalog_obj && catalog_obj.catalog_func()!=null) {
          var tgts = this.tags[tag].mems_boards();
          if (Object.keys(tgts).length!=0) scan.scan_ui('refresh_tag', {tgts: tgts, options:{callback:function(){scan.scan('t');}, priority:6}});
        }
      }
      if (prop==='in' || prop==='ex') {
        if (this.active['in']+this.active['ex']===((val)? 1 : 0)) {
//        if (this.active['in']===((val)? 1 : 0)) {
          pref.catalog.filter.tag = val; // may toggle twice if func==='inex', but leave this because func==='inex' isn't used so much.
          if (pref_func.mirror_targets.pn12_0_4)
            pref_func.apply_prep(pref_func.mirror_targets.pn12_0_4.getElementsByTagName('input')['catalog.filter.tag'],false);
        }
      }
//      if (catalog_obj && catalog_obj.catalog_func()!=null) catalog_obj.catalog_func().catalog_filter_changed();
    },
    add_tags_to_boardlist: function(){
      var tags = liveTag.tags_array_old;
      var label = pref.catalog.filter.tag2bList.label || (tags.filter(function(v){return v.in;})[0] || tags.filter(function(v){return v.pk;})[0] || tags.filter(function(v){return v.ex;})[0]).key;
      var str_ary;
      if (pref.catalog.filter.tag2bList.by==='tag') str_ary = [
        tags.filter(function(v){return v.in;}).map(function(v){return v.key;}).join(','),
        tags.filter(function(v){return v.pk;}).map(function(v){return '#'+v.key;}).join(','),
        tags.filter(function(v){return v.ex;}).map(function(v){return '!'+v.key;}).join(',')];
      else {
        var obj_in = tags.filter(function(v){return v.in;}).map(function(v){return v.mems_boards();});
        var obj_pk = tags.filter(function(v){return v.pk;}).map(function(v){return v.mems_boards();});
        var obj_ex = tags.filter(function(v){return v.ex;}).map(function(v){return v.mems_boards();});
        var obj = {};
        for (var i=0;i<obj_in.length;i++) for (var j in obj_in[i]) obj[j] = null;
        for (var i=0;i<obj_pk.length;i++) for (var j in obj_pk[i]) obj[j] = null;
        for (var i=0;i<obj_ex.length;i++) for (var j in obj_ex[i]) delete obj[j];
        str_ary = Object.keys(obj);
      }
      pref_func.settings.onchange_funcs['tag.add_to_list'](label +' ,'+ str_ary.filter(function(v){return v;}).join(','));
    },
    search_by_tags : function(lth){
      var retval = !this.active.in;
      var tags = lth.tags; // all tags in an array
      if (this.active.in)           for (var i=0;i<tags.length;i++) if ((tags[i] in this.tags) && this.tags[tags[i]]['in']) {retval = true; break;}
      if (retval && this.active.ex) for (var i=0;i<tags.length;i++) if ((tags[i] in this.tags) && this.tags[tags[i]]['ex']) {retval = false; break;}
      return retval;
    },
//    search_by_tags : function(tags){ // working code.
//      var retval = !this.active.in;
//      if (this.active.in)           for (var j=0;j<2;j++) if (tags[j]) for (var i=0;i<tags[j].length;i++) if ((tags[j][i] in this.tags) && this.tags[tags[j][i]]['in']) {retval = true; break;}
//      if (retval && this.active.ex) for (var j=0;j<2;j++) if (tags[j]) for (var i=0;i<tags[j].length;i++) if ((tags[j][i] in this.tags) && this.tags[tags[j][i]]['ex']) {retval = false; break;}
//      return retval;
//    },
    keys_fix: null, // to reduce memory consumption.
    prep_tags : function(th, tags_old){ // prepare tag holder and extract tags in op. 'tags_old' for retag.
//      if (this.mems[th.domain] && this.mems[th.domain][th.board] && this.mems[th.domain][th.board][th.no]) return this.mems[th.domain][th.board][th.no];
//      else {
      var lth = this.mems.init(th);
      var tag = lth;
      if ((tag[2][0]&0x00010000) || tags_old) {
        var watch = tag[2];
        if (watch[0]&0x00010000) {
          if (!pref.test_mode['64'] && pref[cataLog.embed_mode].deleted_posts.merge) archiver.prep_deleted_posts(th,lth);
          if (!pref.test_mode['67']) archiver.check_op(th, lth);
          if (pref.liveTag.watch_all && th.time_created) cataLog.set_watch_time_thread(th.key, cataLog.embed_mode, th.time_created, th.time_posted, th, watch);
          watch[0] = (watch[0]&0xfffe0000);
        }
//        if (pref.liveTag.watch_all && th.time_created) { // working code.
//          var time_watch = catalog_obj.catalog_func().get_watch_time_of_a_thread(th.key, th.time_created, th.time_posted || th.time_bumped, true);
//          if (time_watch) site2[th.domain].check_reply.set_watch_time(watch, time_watch);
//        }
////        if (tag[2][0]===-1) tag[2][0]=1; // patch. This may be redundant.
//        if (tag[2][0]&0x00010000) tag[2][0] &= 0xfffe0000; // there is a path which doesn't throuth 'check_reply'. // redundant, do it in 'check_reply.check_t1_op'
////        if (watch[0]!==0) tag[2][2]=1; // PATCH with BUG, if op contains replies to me, this way can't find it until the thread gets new replies.

        var tags_b = [[],[]]; // first time only.
        var tag_idx;
        if (pref.liveTag.inherit_board_name) { // working code.
          tag_idx = (pref.liveTag.lock_board_name)? 0 : 1;
          tags_b[tag_idx][0] = '#'+th.board.replace(/\//g,'');
        }
        if (pref.liveTag.inherit_board_tags && tag.btag2) {
          tag_idx = (pref.liveTag.lock_board_tags)? 0 : 1;
          tags_b[tag_idx] = tags_b[tag_idx].concat(tag.btag2);
        }
        var extracted_tags = site2[th.domain].check_reply.check_t1_op(th); // extracting tags in op is redundant when tags are NOT locked, but locked extracting is only here, so this can't be removed.
        if (extracted_tags.length!=0) {
          tag_idx = (pref.liveTag.lock_tags_in_op)? 0 : 1;
          tags_b[tag_idx] = tags_b[tag_idx].concat(extracted_tags);
//          tags_b[tag_idx] = extracted_tags.concat(tags_b[tag_idx]);
        }
        this.exclude_tags(th.key, tags_b);
        if (tags_old) for (var i=0;i<2;i++) if (tags_old[i]) tags_b[i] = tags_b[i].concat(tags_old[i]);
        if (th.parse_funcs.has_editing && th.posts[0].editing && tags_b[0].length!=0) tags_b[0] = this.extract_tags_trim_editing(th, tag, tags_b[0]);
        if (tags_b[0].length!=0) tag[0] = this.update_tags_in_th(tags_b[0], null, {}, (tags_b[0].length < pref.liveTag.max)? tags_b[0].length : pref.liveTag.max, th, watch, this.mems[th.domain][th.board]); // update this.keys_fix
        if (tags_b[1].length!=0) this.extract_tags(th, tags_b[1], this.keys_fix);
        else {
          if (tag[1]!==null) tag[1] = null;
          this.update_pn_buf.delayed_do();
        }
      }
      return tag;
    },
    update_tags_in_editing_posts: function(th, lth, ed_f){ // called only when th.parse_funcs.has_editing === true.
      var posts_obj = th.parse_funcs.posts_obj(th,lth.ed_t[lth.ed_t.length-1].no);
      var flag_added = false;
      for (var i=lth.ed_t.length-1;i>=0;i--) if (typeof(lth.ed_t[i])!=='string') {
        var post = posts_obj[lth.ed_t[i].no];
        if (post && !post.editing) {
          if (pref.liveTag.from==='post' || post.no==th.no) {
            site2[th.domain].wrap_to_parse.posts({posts:[post], __proto__:th});
            var extracted_tags = site2[th.domain].check_reply.check_t1_op(post);
            if (extracted_tags.length!=0) flag_added = true;
            lth.ed_t = lth.ed_t.slice(0,i).concat(extracted_tags).concat(lth.ed_t.slice(i+1));
          } else lth.ed_t.splice(i,1);
          ed_f[ed_f.length] = post;
        }
      }
      if (ed_f.length==0) return undefined;
      if (pref.debug_mode['24']) console.log(th.key+': retag_req: '+extracted_tags+', '+flag_added+', '+(lth.ed_t && lth.ed_t.map(function(v){return (typeof(v)==='string')? v : v.no+'('+v.time+')';})));
      if (lth.ed_t.length==0) {
        lth.ed_t = null;
        return undefined;
      }
      return (flag_added)? this.extract_tags(th, lth.ed_t, null, null, true) : // has extracted_tags always.
        (extracted_tags)? this.extract_tags_trim_editing(th, lth, lth.ed_t, true) && undefined : // return undefined for not update intentionally.
        undefined;
    },
    extract_tags_trim_editing: function(th, lth, extracted_tags, retag_editing){
      var ex_tags_keep = null;
      for (var i=extracted_tags.length-1;i>=0;i--) if (typeof(extracted_tags[i])!=='string') { // tags are reverse ordered.
        if (!ex_tags_keep) ex_tags_keep = extracted_tags.slice(0,i+1);
        extracted_tags.splice(i,1);
      }
      if (ex_tags_keep || retag_editing) {
        lth.ed_t = (retag_editing || !lth.ed_t)? ex_tags_keep : ex_tags_keep.concat(lth.ed_t); // reverse order
        if (pref.debug_mode['24']) console.log(th.key+ ': lth.ed_t: '+ (lth.ed_t && lth.ed_t.map(function(v){return (typeof(v)==='string')? v : v.no+'('+v.time+')';})));
      }
      return extracted_tags;
    },
    extract_tags : function(th, extracted_tags, keys_fix, clean, retag_editing){
      var tag = this.mems[th.domain][th.board][th.no];
      if (th.parse_funcs.has_editing) extracted_tags = this.extract_tags_trim_editing(th, tag, extracted_tags, retag_editing);
      if (!keys_fix) {
        this.keys_fix = {};
        var t0 = tag[0]; // runs getter 1 times only.
        if (t0!==null && t0.length!=0) {
          if (pref.liveTag.ci) for (var i=0;i<t0.length;i++) this.keys_fix[t0[i].toLowerCase()] = t0[i];
          else for (var i=0;i<t0.length;i++) this.keys_fix[t0[i]] = t0[i];
        }
      }
      var tag_1 = this.update_tags_in_th(extracted_tags, tag[1], this.keys_fix, pref.liveTag.max-tag[0].length, th, tag[2], this.mems[th.domain][th.board], clean);
      if (tag_1.length!=0 || (tag[1] && tag[1].length!==0)) tag[1] = tag_1;
      this.update_pn_buf.delayed_do();
      this.keys_fix = null;
//      else if (ur>=0) {
//        for (var j=0;j<2;j++) {
//          var tgt = tag[j];
//          for (var i=0;i<tgt.length;i++) this.check_update_tags_color(tgt[i],ur);
//        }
//      }
      return tag;
    },
    tags_boardlist: null,
    update_boardlist: function(force_redraw){
////      if (!site3[site.nickname].bds && site3[site.nickname].boards) { // working code.
//////        site3[site.nickname].bds = {};
////        for (var i=0;i<site3[site.nickname].boards.length;i++) site3[site.nickname].bds['/'+site3[site.nickname].boards[i].board+'/'] = null;
////      }
//      if (site.components.boardlist && site3[site.nickname].bds) {
      if (site.components.boardlist) {
        if (this.tags_boardlist===null) {
          this.tags_boardlist = [];
          pref_func.settings.onchange_funcs['virtualBoard.search.show'](null, true);
          this.filter_onchange(pref.virtualBoard.search, true);
        }
        var i=0;
        var flag = force_redraw;
        var p = 0;
        var j=0;
        var p_remove = pref.virtualBoard.p_board==='both' && pref.virtualBoard.p_remove;
        var sv_rexps = pref.virtualBoard.search.show && pref.virtualBoard.search.rexps; // search valid and rexps
        while (j<pref.virtualBoard.max && i<this.tags_array_old.length) {
//        while (i<pref.virtualBoard.max+p && i<this.tags_array_old.length) {
          var key = this.tags_array_old[i].key;
          if (p_remove && (('/'+key.substr(1)+'/') in this.mems[site.nickname])) p++;
          else if (!sv_rexps || this.update_pn_disp_func(sv_rexps, (pref.liveTag.ci)? key.toLowerCase() : key)) {
            if (this.tags_boardlist[j]!==key) {
              this.tags_boardlist[j] = key;
              flag = true;
            }
            j++;
          }
          i++;
        }
        if (j!=this.tags_boardlist.length) {this.tags_boardlist.splice(j,this.tags_boardlist.length-j); flag=true;}
        if (flag) site2[site.nickname].show_boardlist(this.tags_boardlist.slice(), this.boardlist_click_entry);
      }
    },
//    update_boardlist_1: function(tag){ // working code, but too slow.
//      var pn = this.update_tag_string([tag].concat(this.tags_boardlist), ' / ', this.boardlist_click_entry);
//      site2[site.nickname].show_boardlist(pn);
//    },
    update_boardlist_1: (function(){
      var buf = [];
      var delayed_do = new DelayBuffer(
        function(){
          var tags = Object.create(null);
          for (var i=0;i<buf.length;i++) tags[liveTag.tags_ci[(pref.liveTag.ci)? buf[i].toLowerCase() : buf[i]].key] = null;
//          var pn = liveTag.update_tag_string(Object.keys(tags).concat(liveTag.tags_boardlist), ' / ', liveTag.boardlist_click_entry); // slow in 8chan.
          site2[site.nickname].show_boardlist_physical_board(Object.keys(tags), liveTag.boardlist_click_entry);
          buf = [];
        }, 500).get_binded_delayed_do();
      return function(tag) {
        if (site.components.boardlist) {
          buf[buf.length] = tag;
          delayed_do();
        }
      };
    })(),

//    refresh_end_proc: function(){
//      for (var i in this.tags) if (this.tags[i].ur_cs===null) this.count_ur_sub(i);
//      for (var i in this.tags_update_state) this.tags[i].ur = null;
//      for (var i in this.tags_update_state) {
//        if (this.tags[i].ur===null) this.count_ur(i);
//        this.update_tag_node(i);
//      }
//      this.tags_update_state = Object.create(null);
//    },
    update_tag_node: function(tag, node_in_boardlist){
      if (cataLog.threads!==null) {
////if (!pref.test_mode['24']) {
        var keys = liveTag.tags[tag].mems_keys_obj(); // runs getter only 1 time. // working code.
        for (var name in keys)
          if (cataLog.threads[name] && cataLog.threads[name][24] && cataLog.threads[name][24][3])
            this.update_tag_node_1(cataLog.threads[name][24][3].getElementsByClassName(pref.script_prefix+'_tag'),keys[name]);
////} else {
////        for (var i of this.tags[tag].mems_keys()) {
////          var name = i.key;
////          if (cataLog.threads[name] && cataLog.threads[name][24] && cataLog.threads[name][24][3])
////            this.update_tag_node_1(cataLog.threads[name][24][3].getElementsByClassName(pref.script_prefix+'_tag'), this.tags[tag].mems.get(i)); // can't get tag when i is derived from board.
////        }
////}
      }
      tag = this.tags_ci[(pref.liveTag.ci)? tag.toLowerCase() : tag].key;
      if (node_in_boardlist) this.color_tag_node(node_in_boardlist, tag);
      else if (this.tags_boardlist && this.tags_boardlist.indexOf(tag)!=-1) this.update_tag_node_1(site.components.boardlist.getElementsByClassName(pref.script_prefix+'_tag'), tag);
    },
//    update_tag_node: function(tag, node_in_boardlist){ // working code.
//      if (catalog_obj && catalog_obj.catalog_func()!=null) {
//        var threads = catalog_obj.catalog_func().threads;
//        for (var t in liveTag.tags[tag].tgts) 
//          for (var name in liveTag.tags[t].mems) 
//            if (threads[name] && threads[name][24] && threads[name][24][3]) this.update_tag_node_1(threads[name][24][3].getElementsByClassName(pref.script_prefix+'_tag'),tag);
//      }
//      if (node_in_boardlist) this.color_tag_node(node_in_boardlist, tag);
//      else if (this.tags_boardlist.indexOf(tag)!=-1) this.update_tag_node_1(site.components.boardlist.getElementsByClassName(pref.script_prefix+'_tag'), tag);
//    },
    update_tag_node_1: function(pns, tag){
      var tag_ci = tag.toLowerCase();
      for (var j=0;j<pns.length;j++) {
        var txt = pns[j].textContent;
        if (txt===tag || (pref.liveTag.ci && txt.toLowerCase()===tag_ci)) {
          this.color_tag_node(pns[j],tag);
          break;
        }
      }
    },
    color_tag_node : function(node, tag){
      var style_str = (this.tags[tag]['ex'])? pref.liveTag.style_ex_str :
                      (this.tags[tag]['in'])? pref.liveTag.style_in_str :
                      (!pref.liveTag.style || this.tags[tag].ur<=0)? null :
                      (this.tags[tag].ur>=2)? pref.liveTag.style_urtm_str : pref.liveTag.style_ur_str;
      if (style_str) node.setAttribute('style',style_str); // this can accept '!important'
      else node.removeAttribute('style');
    },
//    color_tag_node : function(node, tag){
//      if (this.tags[tag]['in']) common_func.init_set_style(node,pref.liveTag.style_in_obj4);
//      else if (pref.liveTag.style) {
//        if (this.tags[tag].ur>2) common_func.init_set_style(node,pref.liveTag.style_urtm_obj4);
//        else if (this.tags[tag].ur>0) common_func.init_set_style(node,pref.liveTag.style_ur_obj4);
//        else common_func.init_set_style(node,null);
//      } else common_func.init_set_style(node,null);
//    },
    update_tag_string: function(tags, sep, func_click, tagname){
      var pn = document.createElement('span');
//      pn.setAttribute('class',pref.script_prefix+'_tag');
//      pn.setAttribute('name',pref.script_prefix+'_tag_parent');
      if (tags) for (var j=0;j<tags.length;j++) {
        if (j!=0 && sep) pn.appendChild(document.createTextNode(sep));
        var key = tags[j];
        var pn_1 = document.createElement(tagname? tagname : 'span');
        pn_1.setAttribute('class',pref.script_prefix+'_tag');
        pn_1.textContent = key;
        this.color_tag_node(pn_1,key);
        pn_1.onclick = func_click;
//        pn_1.onmouseover = this.tag_onmouseover;
        pn.appendChild(pn_1);
      }
      return pn;
    },
    tag_node_onclick: function(){
      var tag = this.textContent;
      liveTag.cbx_changed(tag, pref.liveTag.click_func);
    }

//    extract_tags_in_posts : function(th, tags, name){
//      tag[1] = this.update_tags_in_th(tags, tag[1][0], tag[0][1], pref.liveTag.max-tag[0][0].length, name);
//      this.update_pn_buf.delayed_do();
//    },
  };
//  liveTag.key_dirty = Object.create(liveTag.key_dirty_creation);
//  liveTag.cbx_onchange_entry = liveTag.cbx_onchange_entry(liveTag);
//  liveTag.update_pn_buf = new DelayBuffer(liveTag.update_pn.bind(liveTag), 500);
  liveTag.update_pn_buf = new DelayBuffer(liveTag.update_pn.bind(liveTag), pref.liveTag.disp_delay);
  liveTag.update_pn_1_lazy = new DelayBuffer(liveTag.update_pn_1.bind(liveTag, true), pref.liveTag.lazy_delay);
  liveTag.tags_ci = Object.getPrototypeOf(liveTag.tags);
  pref_func.site2_json(false,true,['liveTag']);
  thread_reader_init();

////  function LiveTag(tags, mems){ // I want to use 'Tag', but this brings difficulty into search...
////    this.tags = tags || Object.create(null); // tags : tags[TAG] = {key:, num;, mem:, pk:, in:, ex:};  // summary tree.
////    this.mems = mems || Object.create(null); // mems : mems[DOMAIN_BOARD][TAG] = {'THREAD':null, ...}; // member tree.
//////    Object.defineProperty(this, 'filter', {get: this.prep_filter_value, enumerable:true, configurable:true});
////    this.pn = document.createElement('div');
////    this.cbx_onchange_entry = (function(myself){function(){myself.cbx_onchange(this.name, this.checked);}})(this);
////    this.footer_onclick_entry = (function(myself){function(){myself.footer_onclick(this.name);}})(this);
////    this.active = null;
////  }
////  LiveTag.prototype = {
////    cbx_onchange : function(name,checked){
////      var name = this.name.split('.');
////      this.tags[name[0]][name[1]] = checked;
////      this.prep_search();
//////      this.prep_filter_val();
//////      Object.defineProperty(this, 'filter', {get: this.prep_filter_value, enumerable:true, configurable:true});
////    },
////    extract_tags_in_op : function(pn) {
////      var tags = pn[brwsr.innerText].match(tags_scan_regex);
////      var tags_uniq = Object.create(null);
////      for (var i=tags.length-1;i>=0;i--) if (tags[i] in tags_uniq) tags.splice(i,1); else tags_uniq[tags[i]] = null; // uniq in Case Sensitive
////      if (tags.length>pref.catalog.tag.max) return [];
////      if (tags.length>pref.catalog.tag.ignore) tags.splice(0,tags.length-pref.catalog.tag.ignore);
////      return tags;
////    },
////    update_tags : function(ths, partial){
////      var tags_in_board = Object.create(null);
////      for (var i=0;i<ths.length;i++) {
////        for (var j=0;j<ths[i].tags.length;j++) {
////          if (!tags_in_board[ths[i].tags[j]]) tags_in_board[ths[i].tags[j]] = Object.create(null);
////          tags_in_board[ths[i].tags[j]][ths[i].no] = null;
////        }
////      }
////      var db = ths[0].domain + ths[0].board;
////      if (!this.mems[db]) this.mems[db] = Object.create(null);
////      var mems_db = this.mems[db];
////      var tags = this.tags;
////      if (!partial) {
////        for (var i in mems_db) {
////          if (i in tags_in_board) {
////            tags[i].num += Object.keys(tags_in_board[i]).length - Object.keys(mems_db[i]).length;
////            mems_db[i] = tags_in_board[i];
////            tags_in_board[i] = null;
////          } else {
////            tags[i].num -= Object.keys(mems_db[i]).length;
////            delete tags[i].mem[db];
////            if (tags[i].num==0 && !tags[i].pk && !tags[i].in && !tags[i].ex) delete tags[i];
////            delete mems_db[i];
////          }
////        }
////      } else {
////        for (var i in tags_in_board) {
////          if (in in mems_db) {
////            old_len = Object.keys(mems_db[i]).length;
////            for (var j in tags_in_board[i]) mems_db[i][j] = tags_in_board[i][j];
////            tags[i].num += Object.keys(mems_db[i]).length - old_len;
////            tags_in_board[i] = null;
////          }
////        }
////      }
////      for (var i in tags_in_board) {
////        if (tags_in_board[i]!==null) { // i isn't in mems_db
////          if (!(i in tags)) tags[i] = {key:i, num;0, mem:Object.create(null), pk:false, in:false, ex:false};
////          tags[i].num += Object.keys(tags_in_board[i]).length;
////          tags[i].mem[db] = null;
////          mems_db[i] = tags_in_board[i];
////        }
////      }
////    },
////    update_pn : function(ci){
////      var tags = this.tags;
////      var tags_array = [];
////      for (var i in tags) tags_array[tags_array.length] = tags[i];
////      tags_array.sort(this.sort_func);
////      if (ci) {
////        var tags_ci = Object.create(null);
////        for (var i=0;i<tags_array.length;i++) {
////          var key = tags_array[i].key.toLowerCase();
////          if (!(key in tags_ci)) tags_ci[key] = i;
////          else {
////            tags_array[tags_ci[key]].num += tags_array[i].num; // CAUSE OVERESTIMATION, BUT EXECUTION SPEED HAS MORE PRIORITY, THEREFORE LEAVE THIS.
////            tags_array[tags_ci[key]].pk  |= tags_array[i].pk;
////            tags_array[tags_ci[key]].in  |= tags_array[i].in;
////            tags_array[tags_ci[key]].ex  |= tags_array[i].ex;
////            tags_array.splice(i,1);
////            i--;
////          }
////        }
////        tags_array.sort(this.sort_func);
////      }
////      this.pn.innerHTML = '';
////      for (var i=0;i<tags_array.length;i++) {
////        var item = document.createElement('span');
////        var str  = tags_array[i].num + ': ' + tags_array[i].key;
////        item.innerHTML = '<input type="checkbox" name="' + tags_array[i].key + '.pk" ' + ((tags_array[i].pk)? 'checked' : '') + '>' + 
////                         '<input type="checkbox" name="' + tags_array[i].key + '.in" ' + ((tags_array[i].in)? 'checked' : '') + '>' + 
////                         '<input type="checkbox" name="' + tags_array[i].key + '.ex" ' + ((tags_array[i].ex)? 'checked' : '') + '>' + str + '<br>';
////        item.childNodes[0].onchange = this.cbx_onchange_entry;
////        item.childNodes[1].onchange = this.cbx_onchange_entry;
////        item.childNodes[2].onchange = this.cbx_onchange_entry;
////        this.pn.appendChild(item);
////      }
////    },
////    prep_search : function(){
////      var active = {pk:false, in:false, ex:false};
////      var tags = this.tags;
////      for (var i in tags) if (tags[i].pk) {active.pk = true; break;}
////      for (var i in tags) if (tags[i].in) {active.in = true; break;}
////      for (var i in tags) if (tags[i].ex) {active.ex = true; break;}
////      this.active = active;
////    }
////    get_pick_up_mems : function(){
////      var retval = {};
////      if (this.active.pk) for (var i in tags) if (tags[i].pk) for (var j in tags[i].mem) retval[j] = null;
////      return retval;
////    },
//////    prep_filter_value : function(){
//////      var retval = {pk:Object.create(null), in:Object.create(null), ex:Object.create(null)};
//////      for (var i in this.tags) {
//////        if (this.tags[i].pk) retval.pk[i] = null;
//////        if (this.tags[i].in) retval.in[i] = null;
//////        if (this.tags[i].ex) retval.ex[i] = null;
//////      }
//////      Object.defineProperty(this, 'filter', {value: retval, writable:true, enumerable:true, configurable:true});
//////    },
////    prep_footer : function(tags){
////      var ft = document.createElement('span');
////      ft.setAttribute('style','cursor:pointer');
////      for (var i=tags.length-1;i>=0;i--) {
////        var tag_pn = document.createElement('span');
////        tag_pn.innerHTML = tags[i] + ' ';
////        tag_pn.onclick = this.footer_onclick_entry;
////        ft.appendChild(tag_pn);
////      }
////      return ft;
////    },
////    footer_onclick : function(name) {
////      var sel = pref.tag.footer_clicked;
////      this.tags[name][sel] = !this.tags[name][sel];
////      this.pn.getElementsByTagName('input')[name+'.'+sel] = this.tags[name][sel];
////    },

//  https://nolanlawson.com/2015/09/29/indexeddb-websql-localstorage-what-blocks-the-dom/    // IndexedDB IS TOO SLOW TO USE, Chrome47@2015.09.29
//  http://stackoverflow.com/questions/28693674/indexeddb-slow-retrieval-issue               // IndexedDB IS TOO SLOW TO USE @2015.02
//  http://stackoverflow.com/questions/10102571/indexeddb-very-slow-compared-to-websql-what-am-i-doing-wrong // IndexedDB IS TOO SLOW TO USE @2012.01.12
//  https://dev.mozilla.jp/2012/07/why-no-filesystem-api-in-firefox/
//  https://developer.mozilla.org/ja/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria#Storage_limits
//  https://developer.mozilla.org/en-US/docs/Web/API/File_System_API/Introduction
//  http://www.html5rocks.com/ja/tutorials/file/filesystem/
  var IDB = (function(){
    function IDBRequest_onerror(e){
      console.log('IDB: ERROR: ',e);
      indicator.report({err_str:'IDB_ERROR:'+e.target.error.name});
      for (var key of db_info.keys()) console.log(db_info.get(key));
      console.log('last_closed: ',last_closed);
    }
    function IDBRequest_onblocked(e){
      if (pref.debug_mode['21']) console.log('IDB: BLOCKED: '+e.oldVersion+' -> '+e.newVersion);
    }
    function IDBTransaction_onabort(e){
      console.log('IDBT: ABORT: '+e.target.error.name,e);
      indicator.report({err_str:'IDBT_ABORT:'+e.target.error.name});
      var tr = e.target;
      var db = tr.db;
//      if (tr.error.name==='TimeoutError') {
//        var info = tr_info.get(tr);
//        tr_info.delete(e.target);
//        console.log(info);
//        if (info && info.req) {
//          add_req(reqs_re, db.name, info.req); // retry
//          console.log('Requeued... '+db.name.replace(/^[^\/]*/,'')+req.no+' '+req.kind);
//        }
//      }
      // http://stackoverflow.com/questions/10477489/what-are-the-details-can-be-obtained-from-webkitstorageinfo-queryusageandquota
//      if (window.webkitStorageInfo) window.webkitStorageInfo.queryUsageAndQuota(webkitStorageInfo.TEMPORARY, console.log.bind(console));
      if (navigator.webkitTemporaryStorage) navigator.webkitTemporaryStorage.queryUsageAndQuota(console.log.bind(console));
      IDBT_rereq(db, tr, 'IDBT_abort:'+tr.error.name);
//      IDB_close(db, null, 'IDBT_abort:'+tr.error.name);
    }
    function IDBTransaction_onerror(e){
      console.log('IDBT: ERROR: '+e.target.error.name,e);
      indicator.report({err_str:'IDBT_ERROR:'+e.target.error.name});
      var tr = e.target.transaction;
      var db = e.target.db || e.target.transaction && e.target.transaction.db;
      IDBT_rereq(db, tr, 'IDBT_onerror:'+tr.error.name);
//      IDB_close(db, null, true);
    }
    function IDBRequest_onupgradeneeded(e){
      e.target.onsuccess = null; // prevent from being called twice.
      IDBRequest_onsuccess_open(e, true);
    }
    function IDBRequest_onsuccess_open(e, from_upgrade){
      var db = e.target.result;
      version[db.name] = db.version;
      delete waiting_open[db.name+((from_upgrade)? 'vc' : 'rw')];
//      var reqs = (from_upgrade)? reqs_vc[db.name] : reqs_rw[db.name];
      var reqs = from_upgrade && reqs_vc[db.name] || reqs_rw[db.name];
      if (pref.debug_mode['20']) {
        var count = 1;
        var debug_reqs = reqs && reqs.debug_query() || null;
//        var debug_coms = reqs && reqs.ary.slice(0,10).map(function(v){return v.kind;});
        console.log('IDB: opened: '+(db_info.size+1)+' '+db.name.replace(/^[^\/]*/,'')+' v'+db.version+', '+(debug_reqs && debug_reqs.length)+' req(s), '+e.type+', '+(debug_reqs && debug_reqs.coms));
      }
//      if (db_info.has(db)) console.log('IDB: ERROR: the same db was returned.', db_info.get(db));
      var info = {type:e.type, tr_count:1, reqs:reqs, pass:0, wdg:null, crawler:1, oss:{}, tr_info:new Map(), req_kinds:{}, coms:debug_reqs && debug_reqs.coms, done:0, done_put:0}; // tr_count.set(db, 1); // tr_count.set(db, (tr_count.get(db)||0)+1); // returns the same db sometimes.
      db_info.set(db, info);
      if (reqs) {
        for (var i=0;i<db.objectStoreNames.length;i++) info.oss[db.objectStoreNames[i]] = null;
        if (from_upgrade) {
          var tr = e.target.transaction;
          tr_inc(db);
          tr_set(tr, function(){IDBRequest_close({target:{db:db}});});
          if (db.version==1) { // patch for the first creation.
            delete waiting_open[db.name+'rw']; // entried by 'rw' always.
            pref4.archive.IDB_board_sel_options = null;
            db.createObjectStore('Meta'); // dummy write
            return req_end(db, from_upgrade);
          }
          var num_downgraded = 0;
          while (true) {
            indicator_update();
            var req = reqs.shift();
            info.pass++;
            if (!req) break;
            if (pref.debug_mode['20']) info.done++;
            if (pref.debug_mode['22'] && req.kind!=='put') console.log('req_upgrade: '+req.no+', '+req.kind+', '+req.key+', '+reqs.debug_query().length);
            info.req_kinds[req.kind] = null;
            var contains = info.oss[req.no]===null;
            if (req.kind==='put') {
              if (!contains) {
                make_1(db, req, IDBRequest_close);
                info.oss[req.no] = null;
                if (pref.debug_mode['22']) console.log('req_upgrade: '+req.no+', '+req.kind+', '+req.key+', '+reqs.debug_query().length);
              } else {
                add_req(reqs_rw, db.name, req); // downgrade
                if (pref.debug_mode['22']) num_downgraded++;
              }
//              else put_1(db,req, IDBRequest_close);
            } else if (req.kind==='delete_th') {
              if (contains) delete_th_1(db, req, tr); // returns void, not a transaction.
            }
          }
          if (pref.debug_mode['22'] && num_downgraded) console.log('req_upgrade: downgraded: '+num_downgraded);
          req_end(db, from_upgrade);
        } else {
          var loop_func = function complete_func(){req_1(db,reqs,from_upgrade,complete_func);}
          info.complete_func = loop_func;
          req_1(db, reqs, from_upgrade, loop_func);
//          while (info.crawler<pref.archive.IDB.nof_tr && !reqs.isEmpty) { // not sensitive when reqs are added after this.
//            info.crawler++;
//            req_1(db, reqs, from_upgrade, loop_func);
//          }
        }
      } else req_end(db, from_upgrade);
    }
    function req_1(db, reqs, from_upgrade, complete_func){ // multi transaction can be accepted, but not debugged.
      var info = db_info.get(db);
      if (!info) return; // closed by watchdog
      indicator_update();
      var req = (waiting_open[db.name+'vc']!==undefined)? null : reqs.shift();
      info.pass++;
      if (req) {
        if (pref.debug_mode['20']) info.done++;
        if (pref.debug_mode['22'] && req.kind!=='put_m') console.log(db.name.replace(/^[^\/]*/,'')+req.no+', '+req.kind+', '+req.key+', '+reqs.debug_query().length);
        var contains = info.oss[req.no]===null;
        if (req.kind==='get_all_m') {
          var reqs_current = [];
          var nos = {};
          for (var i=0;i<req.reqs.length;i++) if (info.oss[req.reqs[i].no]===null) {
            reqs_current[reqs_current.length] = req.reqs[i];
            nos[req.reqs[i].no] = null;
          }
          if (reqs_current.length!==0) get_all(db,{nos:Object.keys(nos), reqs:reqs_current}, complete_func);
          else complete_func();
//        } else if (req.kind==='get_all') {
//          if (contains) get_all(db,{nos:[req.no], reqs:[req]}, complete_func);
//          else complete_func();
        } else if (req.kind==='list_os') {
          req.obj(site.nickname, db.name.substr(pref.script_prefix.length+1), Array.prototype.slice.call(db.objectStoreNames).filter(function(v){return v!=='Meta';}));
          complete_func();
        } else if (req.kind==='put_m') {
          var reqs_current = [];
          var nos = {};
          for (var i=0;i<req.reqs.length;i++)
            if (info.oss[req.reqs[i].no]!==null) add_req(reqs_vc, db.name, req.reqs[i]); // upgrade
            else {
              reqs_current[reqs_current.length] = req.reqs[i];
              nos[req.reqs[i].no] = null;
            }
          if (pref.debug_mode['22']) console.log(db.name.replace(/^[^\/]*/,'')+(reqs_current[0] && reqs_current[0].no || 'skipped')+'('+Object.keys(nos).length+')'+', '+req.kind+'('+reqs_current.length+'), '+req.key+', '+reqs.debug_query().length);
          if (reqs_current.length>1) {
            req.reqs = reqs_current;
            req.nos = Object.keys(nos);
            put_1(db,req, complete_func);
          } else if (reqs_current.length==1) put_1(db,reqs_current[0], complete_func);
          else complete_func();
        } else if (req.kind==='put') {
          if (!contains) {add_req(reqs_vc, db.name, req);complete_func();} // upgrade
          else put_1(db,req, complete_func);
//        } else if (req.kind==='put_if') {
//          if (contains) put_1(db,req, complete_func);
//          else complete_func();
        } else if (req.kind==='delete') {
          if (contains) delete_1(db,req, complete_func);
          else complete_func();
        } else if (req.kind==='clean_up' || req.kind==='clean_m') {
          if (!times_pruned[db.name]) times_pruned[db.name] = {list:[], write:null};
          var list = times_pruned[db.name].list;
          var list_len_old = list.length;
          if (req.kind==='clean_up') {
            var nos = {Meta:null, __proto__:req.obj};
            for (var i=0;i<list.length;i++) nos[list[i].no] = null;
            var date = Date.now();
            var names = db.objectStoreNames;
            for (var i=0;i<names.length;i++) if (nos[names[i]]!==null) list[list.length] = {no:names[i], pruned_time:date};
          } else {
            for (var i=0;i<req.reqs.length;i++)
              if (info.oss[req.reqs[i].no]===null) list[list.length] = {no:req.reqs[i].no, pruned_time:req.reqs[i].obj};
          }
          if (times_pruned[db.name].write===null) {
            times_pruned[db.name].write = false;
            clean_up(db, req, complete_func);
          } else clean_up_end_proc(db, null, complete_func, list.length!==list_len_old);
//        } else if (req.kind==='check_clean') { // working code.
//          if (!times_pruned[db.name]) times_pruned[db.name] = [];
//          if (contains) times_pruned[db.name][times_pruned[db.name].length] = {no:req.no, pruned_time:req.obj};
//          clean_up_end_proc(db, null, complete_func, contains);

//          if (req.kind==='clean_up') { // working code.
//            var tgts = [];
//            for (var i=0;i<db.objectStoreNames.length;i++) if (req.obj[db.objectStoreNames[i]]!==null) tgts[tgts.length] = db.objectStoreNames[i];
//            clean_up(db, {tgts:tgts, prune:(req.kind==='clean_up'), __proto__:req}, complete_func); // call 'clean_up_end_proc' in 'clean_up'.
//          } else {
//            check_cleaned[db.name][check_cleaned[db.name].length] = {no:req.no, pruned_time:req.obj};
//            reqs[reqs.length] = {no:-1, key:'pruned_time', obj:check_cleaned[db.name], kind:'put'};
//            clean_up_end_proc(db, null, complete_func);
//          }
////        } else if (req.kind==='clean_up') { // working code.
////          check_cleaned[db.name] = Date.now();
////          var tgts = [];
////          for (var i=0;i<db.objectStoreNames.length;i++) if (req.obj[db.objectStoreNames[i]]!==null) tgts[tgts.length] = db.objectStoreNames[i];
////          clean_up(db, {tgts:tgts, prune:true, __proto__:req}, complete_func);
//////          for (var i=0;i<db.objectStoreNames.length;i++) if (req.obj[db.objectStoreNames[i]]!==null) clean_1(db, {no:db.objectStoreNames[i], prune:true, __proto__:req});
////        } else if (req.kind==='check_clean') {
////          var date = Date.now();
////          if (date - (check_cleaned[db.name] || 0 ) > pref.archive.IDB.check_every * ((pref.test_mode['75'])? 60000 : 3600000)) {
////            check_cleaned[db.name] = date;
////            clean_up(db, {tgts:Array.prototype.slice.call(db.objectStoreNames), __proto__:req}, complete_func);
////          } else complete_func();
//////          for (var i=0;i<db.objectStoreNames.length;i++) clean_1(db, {no:db.objectStoreNames[i], __proto__:req});
        } else complete_func();
        if (info.crawler<pref.archive.IDB.nof_tr && !reqs.isEmpty) {
          info.crawler++;
          req_1(db, reqs, from_upgrade, complete_func);
        }
      } else if (--info.crawler===0) req_end(db, from_upgrade);
    }
    function req_end(db, from_upgrade){
      IDBRequest_close({target:{db:db}});
      var req_parent = from_upgrade && reqs_vc[db.name] && reqs_vc || reqs_rw;
      if (req_parent[db.name] && req_parent[db.name].isEmpty) delete req_parent[db.name];
//      delete (from_upgrade && reqs_vc[db.name] && reqs_vc || reqs_rw)[db.name]; // BUG, might be remade.
      if (reqs_re[db.name]) reqs_re2rw(db.name);
//      if ((!from_upgrade)? reqs_vc[db.name] : reqs_rw[db.name]) open_db(db.name, (!from_upgrade)? db.version+1 : undefined);
//      if (req_parent===reqs_vc) {
      if (from_upgrade) {
        if (reqs_rw[db.name] && !reqs_rw[db.name].isEmpty) open_db(db.name);
      } else if (reqs_vc[db.name] && !reqs_vc[db.name].isEmpty) open_db(db.name, true);
      if (Object.keys(reqs_rw).length===0 && Object.keys(reqs_vc).length===0 && Object.keys(reqs_re).length===0) watchdog.stop();
    }
    function reqs_re2rw(db_name){
      if (reqs_rw[db_name]) reqs_rw[db_name].push_all(reqs_re[db_name]);
      else reqs_rw[db_name] = reqs_re[db_name];
      delete reqs_re[db_name];
    }

    function delete_th_1(db,req, tr){
//      tr_inc(db);
      db.deleteObjectStore(req.no);
//      tr_set(tr, (function(func_prev){
//        return function(e){
//          if (func_prev) func_prev(e);
//          IDBRequest_close({target:{db:db}}); // cause ERROR, probably bug in browser, oncomplete is fired too early at createObjectStore and deleteObjectStore.
//        }
//      })(tr.oncomplete));
if (pref.debug_mode['23']) console.log('IDB: delete_th: '+db.name+req.no+', '+db.objectStoreNames.length);
    }
    function make_1(db,req, complete_func){
      tr_inc(db);
      var tr = db.createObjectStore(req.no).transaction;
      tr_set(tr, (function(func_prev){ // tr belongs to db, transaction.oncomplete is called ONE TIME, so cascade oncomplete funcs.
        return function(e){
if (!pref.test_mode['66']) {
          put_1(db,req, complete_func);
} else {
          add_req(reqs_rw, db.name, req); // downgrade // DOESN'T WORK WHY???  // cause ERROR, probably bug in browser, oncomplete is fired too early at createObjectStore and deleteObjectStore.
          complete_func({target:{db:db}});
}
          if (func_prev) func_prev(e);
        }
      })(tr.oncomplete));
    }
    function put_1(db,reqs_in, complete_func){
      var reqs = reqs_in.reqs || [reqs_in];
      try {
        var IDBT = tr_set(db.transaction(reqs_in.nos || reqs_in.no, 'readwrite', reqs_in), complete_func, reqs_in, db);
        for (var i=0;i<reqs.length;i++) {
          var req = reqs[i];
          if (pref.test_mode['82'] && req.obj instanceof Blob) {
            if (pref.test_mode['83']) req.obj = null;
            else if (pref.test_mode['84']) {
              var str = '';
              while (str.length*2<req.obj.size) str += Math.random();
              req.obj = str;
            } else {
              var codes = [];
              for (var j=0;j*2<req.obj.size;j++) codes[j] = Math.floor(Math.random()*65536);
              req.obj = String.fromCharCode.apply(null,codes);
            }
          }
          if (pref.debug_mode['23']) console.log('put_'+((reqs_in.nos)?'m: ':'1: ')+db.name.replace(/^[^\/]*/,'')+req.no+', '+req.key+((req.key==='posts')? ':'+req.obj.length:'')+((reqs_in.nos)? ' '+(i+1)+'/'+reqs_in.nos.length+'/'+reqs_in.reqs.length:''));
          var IDBR = IDBT.objectStore(req.no).put((req.key!=='posts')? req.obj : JSON.stringify(req.obj, archiver.store_json_func),
                                                  (req.key!=='posts')? req.key : req.key+'_'+req.obj[0].no);
          IDBR.onerror   = IDBRequest_onerror;
//          IDBR.onsuccess = clear_wdg_get_db; // IDBRequest_onsuccess;
        }
        if (pref.debug_mode['20']) db_info.get(db).done_put += reqs.length;
      } catch (e){
//        if (pref.debug_mode['20'])
          console.log('IDB: fail to put: '+e.name+': ' + JSON.stringify(req,['no','key','kind']), e, db_info.get(db));
        if (e.name==='InvalidStateError') { // retry when latter requests catch up with a prior request which creates new objectStore.
          add_req(reqs_re, db.name, req); // retry
          if (pref.debug_mode['20']) console.log('IDB: re-scheduled:');
        }
        complete_func({target:{db:db}});
      }
    }
//    function IDBRequest_onsuccess(e){
//      var db = clear_wdg_get_db(e);
//      var info = db_info.get(db);
//      if (info) info = info.tr_info.get(e.target.transaction);
//      if (info && --info.nof_reqs===0) info.func(e);
//    }
    function delete_1(db,req, complete_func){
      tr_set(db.transaction(req.no,'readwrite'), complete_func).objectStore(req.no).delete(req.key); // .onsuccess = IDBRequest_close;
    }
    function tr_set(tr, complete_func, req, db){
      tr.oncomplete = (req)? IDBTransaction_oncomplete : complete_func;
      tr.onabort    = IDBTransaction_onabort;
      tr.onerror    = IDBTransaction_onerror;
      if (req) db_info.get(db).tr_info.set(tr,{req:req, func:complete_func}); //, nof_reqs:req.reqs && req.reqs.length || 1});
      return tr;
    }
    function IDBTransaction_oncomplete(e){
      var info = db_info.get(e.target.db);
      if (info) {
        var func = info.tr_info.get(e.target).func;
        info.tr_info.delete(e.target);
        if (func) func(e);
      }
    }
    function clean_up(db,req, complete_func){
      var contains = db.objectStoreNames.contains('Meta');
      if (contains) tr_set(db.transaction('Meta','readwrite'), complete_func).objectStore('Meta').get('pruned_time').onsuccess = clean_1_onsuccess;
      else {
        times_pruned[db.name].write = true;
        clean_up_end_proc(db,req, complete_func, true);
      }
    }
    function clean_1_onsuccess(e, prune){
      var db = e.target.transaction.db;
      var src = e.target.result;
      if (src) {
        var info = db_info.get(db);
        var oss = info && info.oss || {};
        src = src.filter(function(v){return oss[v.no]===null;});
        var src_obj = {};
        for (var i=0;i<src.length;i++) src_obj[src[i].no] = null;
        times_pruned[db.name].list = src.concat(times_pruned[db.name].list.filter(function(v,i,a){return src_obj[v.no]!==null;}));
      }
      times_pruned[db.name].write = true;
      clean_up_end_proc(db, null, null, true); // 'complete_func' will be called by transaction.oncomplete.
    }
//    function clean_up(db,req, complete_func){ // working code.
//      req.complete_func = function(e, tr){
//        if (tr) {
//          if (req.tgts.length===0) return;
//          tr.oncomplete = null;
//        }
//        clean_1(db,req, complete_func);
//      };
////      req.complete_func = function(){clean_1(db,req, complete_func);};
//      req.tr = pref.archive.IDB.nof_tr;
//      for (var i=0;i<req.tr;i++) clean_1(db,req, complete_func);
//    }
//    function clean_1(db,req, complete_func){
//      if (req.tgts.length===0) {
//        if (--req.tr===0) clean_up_end_proc(db,req, complete_func, true);
//        return;
//      }
//      if (db_info.get(db).wdg) delete db_info.get(db).wdg;
//      var no = req.tgts.shift();
//      if (pref.debug_mode['23']) console.log('clean_1: '+no+', '+req.tgts.length);
//      tr_set(db.transaction(no,'readwrite'), req.complete_func).objectStore(no).get('pruned_time').onsuccess = (req.prune)? clean_1_onsuccess_prune : clean_1_onsuccess;
//    }
////    function clean_1(db,req){ // CAUSE ERROR in Chrome, "Internal error: Too many transactions queued." Upper limit is about 400-500.
////      tr_inc(db);
////      var tr = db.transaction(req.no,'readwrite');
////      tr.objectStore(req.no).get('pruned_time').onsuccess = (req.prune)? clean_1_onsuccess_prune : clean_1_onsuccess;
////      tr.oncomplete = IDBRequest_close;
////      tr.onaboart = IDBTransaction_onabort;
////      tr.onerror = IDBTransaction_onerror;
////    }
//    function clean_1_onsuccess_prune(e){
//      clean_1_onsuccess(e, true);
//    }
//    function clean_1_onsuccess(e, prune){
//      var value = e.target.result;
//      if (!value && !prune) return;
//      var date = value || Date.now();
//      var db_name = e.target.transaction.db.name;
//      var board = db_name.replace(pref.script_prefix+'.','');
//      check_cleaned[db_name][check_cleaned[db_name].length] = {no:e.target.source.name, pruned_time:date};
//      if (!value && prune) e.target.source.put(date, 'pruned_time');
//      else if (pref.test_mode['76']) e.target.transaction.oncomplete(null, e.target.transaction);
//    }
//////    function clean_1_onsuccess(e, prune){ // working code.
//////      var value = e.target.result;
//////      var date = Date.now();
//////      if (!value && prune) e.target.source.put(date, 'pruned_time');
//////      else {
//////        if (value + pref.archive.IDB.prune * 3600000 < date) acc(site.nickname, e.target.transaction.db.name.replace(pref.script_prefix+'.',''),
//////                                                                 e.target.source.name, null, null, 'delete_th');
//////      }
//////    }
    function clean_up_end_proc(db,req, complete_func, put_to_IDB){
      var tgts = times_pruned[db.name].list;
//      if (sort) tgts.sort(function(a,b){return a.pruned_time - b.pruned_time;}); // sort is in-place
      var time_prune = Date.now() - pref.archive.IDB.prune * 3600000;
//      var board = db.name.replace(pref.script_prefix+'.','');
      var i=0;
      while (i<tgts.length && tgts[i].pruned_time < time_prune) {
        if (pref.archive.IDB.auto_restore_remove) liveTag.rm_404_1(site.nickname, db.name.replace(/^[^\/]*/,''), tgts[i].no, true);
        if (pref.archive.IDB.prune_flush) add_req(reqs_rw, db.name, {no:tgts[i++].no, key:null, obj:flush_and_prune, kind:'get_all'}, true);
        else add_req(reqs_vc, db.name, {no:tgts[i++].no, key:null, obj:null, kind:'delete_th'}, true);
      }
//      while (i<tgts.length && tgts[i].pruned_time < time_prune) add_req(reqs_vc, db.name, {no:tgts[i++].no, key:null, obj:null, kind:'delete_th'}, true); // acc(site.nickname, board, tgts[i++].no, null, null, 'delete_th');
      if (i>0) tgts.splice(0,i);
      if (times_pruned[db.name].write && (put_to_IDB || i!==0)) add_req(reqs_rw, db.name, {no:'Meta', key:'pruned_time', obj:tgts, kind:'put'});
      if (complete_func) complete_func();
    }
    function flush_and_prune(domain, board, no, result){
      var filename = 'CatChan_archive_pruned_'+domain+'-'+board.slice(1,-1)+'-'+no+'.tar';
      var file_id = 'pruned_'+domain+board+no+Date.now();
      archiver.event_funcs['export_thread'](domain, board, no, result, file_id, filename);
      acc(domain, board, no, null, null, 'delete_th');
    }
    function get_all(db,reqs_in, complete_func){
//      var req = tr_set(db.transaction(req.no,'readonly'), complete_func).objectStore(req.no).getAll(req.key).onsuccess = req.obj;
      var IDBT = tr_set(db.transaction(reqs_in.nos,'readonly'), complete_func);
      for (var i=0;i<reqs_in.reqs.length;i++) {
        var req = reqs_in.reqs[i];
        if (pref.debug_mode['23']) console.log('get_all: '+db.name.replace(/^[^\/]*/,'')+req.no+', '+req.key);
        var IDBR = IDBT.objectStore(req.no).openCursor((req.key==='posts')? IDBKeyRange.bound('posts', 'postt', false, true) : undefined);
        IDBR.onsuccess = get_all_onsuccess;
        req.result = {};
        req_dictionary.set(IDBR,req);
      }
    }
    var req_dictionary = new Map();
    function clear_wdg_get_db(e){
      var db = e.target.transaction.db;
      var info = db_info.get(db);
      if (info) info.pass++; // may be stopped by watchdog.
      return db;
    }
    function get_all_onsuccess(e){
      var db = clear_wdg_get_db(e);
      var IDBR = e.target;
      var req = req_dictionary.get(IDBR);
      var cursor = e.target.result;
      if (cursor) {
        req.result[cursor.key] = (cursor.key.indexOf && cursor.key.indexOf('posts')===0)? JSON.parse(cursor.value) :
//                                 (req.key==='posts')? null :
                                 (cursor.value instanceof ArrayBuffer)? common_func.arraybuffer2blob(cursor.key, cursor.value) : cursor.value;
        cursor.continue();
      } else {
        req_dictionary.delete(IDBR);
        var board = e.target.transaction.db.name.replace(pref.script_prefix+'.','');
        var no = e.target.source.name;
        setTimeout((function(req,board,no){return function(){req.obj(site.nickname, board, no, req.result);};})(req,board,no),0);
        if (pref.debug_mode['29']) {
          var sum = 0;
          for (var i in req.result) sum += (i.indexOf('posts')===0)? JSON.stringify(req.result[i]).length*2 : req.result[i] && req.result[i].size;
          console.log('IDB: '+board+no+': '+Object.keys(req.result).length+' files, '+sum.toLocaleString()+' bytes.');
        }
      }
    }
    function IDBRequest_close(e){
      var db = e.target.source && e.target.source.transaction.db || e.target.db || e.target.result;
      var info = db_info.get(db);
      if (!info) return; // closed by WATCHDOG.
      if (info.tr_count!==1) info.tr_count -= 1; //      if (tc===1) {db.close();tr_count.delete(db);}
      else IDB_close(db, info);
    }
    function IDBT_rereq(db, tr, message){
      var info = db_info.get(db);
      if (info && tr.mode!=='readonly') {
        var req = info.tr_info.get(tr).req;
        add_req((req.kind==='delete_th')? reqs_vc : reqs_re, db.name, req);
        console.log(message+': close and re-req, '+req.kind);
      }
    }
    function IDB_close(db, info, force){
      if (!info) info = db_info.get(db);
      if (force && info) for (var i of info.tr_info.keys()) IDBT_rereq(db, i, force);
      db_info.delete(db);
      var case_of_test_mode78 = !force && info.req_kinds['delete_th']!==undefined && Object.keys(info.req_kinds).length===1 || db.version==1;
      if (pref.debug_mode['26'] && case_of_test_mode78) console.log('Hit the case of test_mode[78]');
//      if (Object.keys(info.req_kinds).length===0 && db.version===1) console.log('test: v1');
//      else
      if (!case_of_test_mode78 || pref.test_mode['78']) db.close();
      else setTimeout(function(){db.close();},0);
      if (pref.debug_mode['20']) console.log('IDB: closed: '+db_info.size+' '+db.name.replace(/^[^\/]*/,'')+' v'+db.version+', '+((info)? info.type+', done:'+info.done+', done_put:'+info.done_put+', '+info.coms : ''));
      if (info) info.db = db;
      last_closed = info;
      indicator_update();
    }
    var last_closed = null; // for debug
    var db_info = new Map();
    function tr_inc(db){
      db_info.get(db).tr_count += 1;
    }
    var times_pruned = {};
    var version = {};
    var waiting_open = {}; // exclusive request,(closing a transaction without any acceess may cause an IDB ABORT ERROR)
    var reqs_vc = {};
    var reqs_rw = {};
    var reqs_re = {};
    var sub_callbacks = {};
    function acc(domain,board,no,key,obj, kind){
//      var db_name = pref.script_prefix+'.'+domain+board;
      if (domain===site.nickname) {
        var db_name = pref.script_prefix+'.'+board;
        var req_obj = {no:no, key:key, obj:obj, kind:kind};
        var reqs = (kind==='delete_th')? reqs_vc : reqs_rw;
        add_req(reqs, db_name, req_obj, true);
//      if (!reqs[db_name]) reqs[db_name] = [req_obj]; // not improved.
//      else reqs[db_name].push(req_obj);
//      open_db(db_name, ver);
      } else {
        if (typeof(obj)==='function') {
          sub_callbacks[domain+board+no] = obj;
          obj = 'sub_callback';
        }
//try {
        if (pref.test_mode['86'] && (obj instanceof ArrayBuffer)) send_message(domain,['IDB',['ACC',[domain,board,no,key,null, kind]]], null, [obj]); // https://bugs.chromium.org/p/chromium/issues/detail?id=334408
        else send_message(domain,['IDB',['ACC',[domain,board,no,key,obj, kind]]]);
//} catch (e) { // BUG. pn is attatched in some case.
//  console.log(e);
//}
      }
    }
    function open_db(db_name, ver, from_watchdog){
      var key = db_name+((ver)? 'vc' : 'rw');
      if (waiting_open[key]!==undefined && (!from_watchdog || ++waiting_open[key]<db_info.size)) {
        if (pref.debug_mode['27']) if (from_watchdog) console.log('IDB: WATCHDOG: '+key+', '+waiting_open[key]);
        return;
      }
      waiting_open[key] = 0;
      var req = window.indexedDB.open(db_name, ver && version[db_name]+1 || undefined); // version[db_name]+1 is NaN at initial.
      req.onerror = IDBRequest_onerror;
      req.onsuccess = IDBRequest_onsuccess_open;
      req.onupgradeneeded = IDBRequest_onupgradeneeded;
      req.onblocked = IDBRequest_onblocked;
    }
    function req_raw(domain,db_name,os_name,key,obj, kind){
      if (domain===site.nickname) {
        var req_obj = {no:os_name, key:key, obj:obj, kind:kind};
        var reqs = (kind==='delete_th')? reqs_vc : reqs_rw;
        add_req(reqs, db_name, req_obj, true);
      }
    }
    function add_req(reqs, db_name, req, call){
      indicator_req_count++;
      if (!indicator && indicator_parent) {
        indicator = indicator_parent.shift('limegreen', 'w', 'IDB', 0);
        indicator.report({start:Date.now(), prog_str:'Opening'});
      } else indicator_update();
      if (!reqs[db_name]) {
        reqs[db_name] = new ReqFifo(db_name, reqs!==reqs_vc, req);
        if (call) open_db(db_name, reqs===reqs_vc);
      } else {
        var spawn = reqs===reqs_rw && reqs[db_name].isEmpty;
        reqs[db_name].push(req);
        if (spawn) {
          for (var i of db_info.keys()) {
            var info = db_info.get(i);
            if (info.crawler<pref.archive.IDB.nof_tr && i.name===db_name && info.type==='success') {
              info.crawler++;
              setTimeout(info.complete_func, 100);
              break;
            }
          }
        }
      }
      watchdog.start(pref.archive.IDB.watchdog*1000);
    }
    var ReqFifo = function(db_name, allow_multi, init_val){
      this.ary = [];
      this.ary_ro = [];
//      this.count = 0;
      this.allow_multi = allow_multi;
      if (!this.reqs[db_name]) this.reqs[db_name] = {};
      this.reqs = this.reqs[db_name]; // shared
      this.cls = {}; // req clusters
      if (init_val) this.push(init_val);
      this.cl = null;
      this.cl_idx = 0;
    };
    ReqFifo.prototype = {
      shift: function(){
        var max = (this.allow_multi)? pref.archive.IDB.nof_cl_max : 1;
        var i=0;
        while (i<this.ary_ro.length && i<max && this.ary_ro[i].kind==='get_all') i++;
        if (i!=0) return {kind:'get_all_m', reqs:this.ary_ro.splice(0,i)};
        else if (this.ary_ro.length!==0) return this.ary_ro.shift();
//        if (this.ary_ro.length>0) return this.ary_ro.shift();
        if (this.ary.length===0 && !this.cl) return null;
if (!pref.test_mode['79']) {
        var retval = [];
  if (!pref.test_mode['81']) {
        var ref_no;
        while (retval.length<max) {
          var req = this.ary[i];
          if (!req || req.kind!=='put') break;
          if (ref_no!==undefined && (!req.no || ref_no!==req.no)) break;
          if (req.cl) {
            if (req.idx===undefined) {
              this.ary[i] = {kind:'put', cl:[req].concat(req.cl), idx:0, no:req.no};
              req.cl = null;
              req = this.ary[i];
              this.cls[req.no] = req;
            }
            if (req.idx>=req.cl.length-1) {
              this.cls[req.no] = null;
              i++;
            }
            req = req.cl[req.idx++]; // all reqs are 'put'.
          } else {
            this.cls[req.no] = null;
            i++;
          }
          retval[retval.length] = req;
          delete this.reqs[req.no + req.key]; // shared, so must use delete.
          if (retval.length===pref.archive.IDB.nof_cl-1) ref_no = req.no;
        }
        if (this.ary[i] && this.ary[i].cl && this.ary[i].idx<this.ary[i].cl.length) { // round robin
          var cl = this.ary.splice(i,1)[0];
          this.ary[this.ary.length] = cl;
        }
  } else {
        while (retval.length<max) { // working code.
          var req;
          if (this.cl===null) {
            req = this.ary[i];
            if (!req || req.kind!=='put') break;
            i++;
            if (req.cl) {
              this.cls[req.no] = null;
              this.cl = req.cl;
              this.cl_idx = 0;
              req.cl = null; // for retry.
            }
          } else {
            req = this.cl[this.cl_idx++]; // all reqs are 'put'.
            if (this.cl_idx>=this.cl.length) this.cl = null;
          }
          retval[retval.length] = req;
          delete this.reqs[req.no + req.key]; // shared, so must use delete.
        }
  }
        if (i>0) this.ary.splice(0,i);
        if (i===0 && this.ary[0] && this.ary[0].kind==='check_clean') this.cls['check_clean'] = null;
        return (retval.length>1)? {kind:'put_m', reqs:retval} : (retval.length>0)? retval[0] : this.ary.shift();
} else {
        while (i<max) { // working code // not debugged enough
          var req = this.ary[i];
          if (!req) break;
          if (req.cl) {
            this.ary = this.ary.slice(0,i+1).concat(req.cl,this.ary.slice(i+1));
            req.cl = null; // for retry.
          }
          if (req.kind==='put') {
            this.cls[req.no] = null;
            delete this.cls[req.no + req.key]; // shared, so must use delete.
            i++;
          } else break;
        }
////        while (i<max && this.ary[i] && this.ary[i].kind==='put') {delete this.cls[this.ary[i].no + this.ary[i].key]; i++;} // working code.
////        this.count += i;
        return (i>1)? {kind:'put_m', reqs:this.ary.splice(0,i)} :
                      this.ary.shift();
}
      },
      push: function(req){
        if (req.kind==='get_all' || req.kind==='list_os') {
          this.ary_ro[this.ary_ro.length] = req;
          return;
        }
        if (req.kind==='put') {
          var key = req.no + req.key;
          var req_old = this.reqs[key];
        }
        if (req_old) req_old.obj = (req.key==='posts')? req_old.obj.concat(req.obj) : req.obj;
        else if (key) {
          if (req.key==='posts' || req.key==='pruned_time' || req.key==='posts_deleted') this.reqs[key] = req;
//          var idx = this.reqs[req.no] - count; // maybe NaN // not debugged.
//          if (idx>1 && idx!==this.ary.length) {
//            this.ary.splice(idx,req);
//            this.reqs[req.no] = count + idx +1;
//          } else {
//            this.ary[this.ary.length] = req;
//            this.reqs[req.no] = count+this.ary.length;
          var req_cl = this.cls[req.no];
          if (req_cl) { // 'reqs' is used by 'put_m'.
            if (req_cl.cl) req_cl.cl[req_cl.cl.length] = req;
            else req_cl.cl = [req];
          } else {
            this.ary[this.ary.length] = req;
            this.cls[req.no] = req;
          }
        } else if (req.kind==='check_clean') {
          var key = null + req.key;
          var req_old = this.cls[key];
          if (req_old) req_old.reqs[req_old.reqs.length] = req;
          else {
            req = {kind:'clean_m', reqs:[req], no:null};
            this.cls[key] = req;
            this.ary[this.ary.length] = req;
          }
        } else this.ary[this.ary.length] = req;
      },
      push_all: function(reqs){
        while (!reqs.isEmpty) this.push(reqs.shift());
      },
//      get length(){return this.ary.length - this.idx;},
//      get length(){return this.ary.length + this.ary_ro.length;},
//      get length(){return this.ary.length + this.ary_ro.length + (this.cl && this.cl.length-this.cl || 0);}, // approx.
      get length(){return this.ary.length + this.ary_ro.length;},
      get length_whole(){
        var sum = 0;
        for (var i=0;i<this.ary.length;i++) sum += (this.ary[i].cl)? this.ary[i].cl.length-(this.ary[i].idx||0) : 1;
        return sum + this.ary_ro.length;
      },
      get isEmpty(){return this.ary.length===0 && !this.cl && this.ary_ro.length===0;},
      reqs: {},
      debug_query: function(){
        var whole_array = Array.prototype.concat.apply(this.ary_ro, this.ary.map(function(v){return (v.cl)? ((!pref.test_mode['81'])? v.cl.slice(v.idx || 0) : [v].concat(v.cl)) : v;}));
        var coms = [];
        var count = 1;
        var i=0;
        while (coms.length<20 && i++<whole_array.length) {
          if (whole_array[i] && whole_array[i-1].kind===whole_array[i].kind) count++;
          else {
            coms[coms.length] = whole_array[i-1].kind+((count!=1)? '*'+count:'');
            count = 1;
          }
        }
        if (i<whole_array.length) coms[coms.length-1] += '...';
//        var coms = whole_array.map((function(){ // working code.
//          var count = 1;
//          return function(v,i,a){
//            if (a[i+1] && v.kind===a[i+1].kind) {
//              count++;
//              return null;
//            } else {
//              var retval = v.kind+((count!=1)? '*'+count:'');
//              count = 1;
//              return retval;
//            }
//          }
//        })()).filter(function(v){return v;});
        return {coms:coms, length:this.ary_ro.length+'/'+this.ary.length+'/'+whole_array.length};
      }
    };
    var indicator_parent = null;
    var indicator = null;
    var indicator_req_count = 0;
    var indicator_update = function(){};
    var indicator_update = DelayBuffer.prototype.delayed_do.bind(new DelayBuffer(function(){
      if (!indicator) return;
      var stats = get_status();
      indicator.report({prog_str:stats.str});
      if (stats.total===0) {
        indicator.report({end:Date.now()});
        indicator = null;
        indicator_req_count = 0;
      }
    },100));
    function get_status(){
      var nof_crawlers = 0;
      for (var db of db_info.keys()) nof_crawlers += db_info.get(db).crawler;
      var sums = [0, 0, 0, 0, 0, 0, Object.keys(reqs_vc).length, Object.keys(reqs_rw).length, Object.keys(reqs_re).length, nof_crawlers, db_info.size, Object.keys(waiting_open).length];
      var tgts = [reqs_vc,reqs_rw,reqs_re];
      for (var i=0;i<3;i++) {
        if (sums[i+6]) for (var j in tgts[i]) {
          sums[i+3] += tgts[i][j].length;
          sums[i]   += tgts[i][j].length_whole;
        }
      }
      return {sums:sums, total:sums.reduce(function(a,b){return a+b;}), str:sums.join('/')+'/'+indicator_req_count};
    }
    var watchdog = new Watchdog(function (){
      var stats = get_status();
      if (pref.debug_mode['27']) console.log('IDB: '+stats.str);
      var inactivated = {};
      for (var db of db_info.keys()) {
        var info = db_info.get(db);
        if (pref.debug_mode['27']) console.log(info);
        if (info.wdg!==info.pass) {
          info.wdg = info.pass;
//        if (tgt.req && (!tgt.wdg || tgt.wdg!==tgt.req)) tgt.wdg = tgt.req;
//        if (!tgt.wdg || tgt.wdg!==tgt.req) tgt.wdg = tgt.req; // BUG. lock when tgt.req===unefined or tgt.req===null. // This was patched in 'req_1'
          inactivated[db.name] = null;
        } else {
          indicator_report();
          IDB_close(db, info, 'IDB: WDG');
        }
      }
      for (var i in reqs_vc) if (inactivated[i]!==null && !reqs_vc[i].isEmpty) open_db(i,true, true);
      for (var i in reqs_rw) if (inactivated[i]!==null && (!reqs_vc[i] || reqs_vc[i].isEmpty) && !reqs_rw[i].isEmpty) open_db(i, undefined, true);
      for (var i in reqs_re) if (inactivated[i]!==null && (!reqs_vc[i] || reqs_vc[i].isEmpty) && (!reqs_rw[i] || reqs_rw[i].isEmpty) && !reqs_re[i].isEmpty) {
        reqs_re2rw(i);
        open_db(i, undefined, true);
      }
      for (var db_name_key in waiting_open) {
        var db_name = db_name_key.replace(/(rw|vc)$/,'');
        if (inactivated[db_name]!==null && !reqs_vc[db_name] && !reqs_rw[db_name]) {
          indicator_report();
          open_db(db_name, db_name_key.search(/vc$/)!=-1, true);
        }
      }
      if (stats.total!==0) watchdog.start(pref.archive.IDB.watchdog*1000);
      function indicator_report(){
        if (stats.str) {
          indicator.report({err_str:'WDG: '+stats.str});
          stats.str = '';
        }
      }
    }, 60000);
    return {
      req: acc, // write: function(domain, board, no, key, data,     cmd)
                // read : function(domain, board, no, key, callback, cmd)
      req_raw: req_raw, // read : function(domain, db_name, os_name, key, callback, cmd)
      clean_up: function(domain, board, nos){
        if (version[pref.script_prefix+'.'+board]) {
          acc(domain,board,null,null,nos, 'clean_up');
          liveTag.mems[domain][board].IDB_synced = 1;
        }
      },
      set_indicator: function(indicator){
        if (!indicator_parent) indicator_parent = indicator;
//        indicator_parent.shift().set('Red','IDB:');
      },
      sub_funcs: function(args, list){
        if (args[0]==='ACC') {
          if (args[1][4]==='sub_callback') args[1][4] = IDB.sub_ack;
          else if (list.length>0) args[1][4] = list[0];
          acc.apply(this,args[1]);
        } else if (args[0]==='ACK') {
          var dbtk = args[1].slice(0,3).join('');
          if (sub_callbacks[dbtk]) sub_callbacks[dbtk].apply(this,args[1]);
          delete sub_callbacks[dbtk];
        }
      },
      sub_ack: function(domain, board, no, result){
        send_message('parent',['IDB',['ACK',[domain,board,no,result]]]);
      },
    };
  })();

  var archiver = (function(){
// http://www.redout.net/data/tar.html
// dollchan
// https://github.com/beatgammit/tar-js/blob/master/lib/tar.js
// https://gist.github.com/kig/417483
    var tar = (function(){
      function make_header(blob, lth, suffix){
        var header = new Uint8Array(512); // UInt8 for checksum.
        suffix = (suffix.substr(0,3)==='tn_')?  'thumbs/' + encode_filename(suffix.substr(3)) :
                 (suffix.substr(0,4)==='img_')? 'images/' + encode_filename(suffix.substr(4)) :
                 encode_filename(suffix);
        var name = lth.domain + '/' + encode_filename(lth.board.slice(1,-1)) + '/' + lth.no + '/' + suffix; // not to encode '/'
        set_header(header,   0, name, 100);  // name
        set_header(header, 100, '100777', 8);  // mode
        set_header(header, 108, '0', 8);       // uid
        set_header(header, 116, '0', 8);       // gid
        set_header(header, 124, (blob.byteLength||blob.size||0).toString(8), 12);  // fileSize, octal // blob may be arraybuffer.
        set_header(header, 136, Math.floor(Date.now()/1000).toString(8), 12);  // mtime, octal
        set_header(header, 148, '        ', 8);  // checksum 
        header[156] = 0x30;  // type 0 as a normal file.
        var checksum = 0;
        for(i=0;i<157;i++) checksum += header[i];
        set_header(header, 148, checksum.toString(8), 8); // checksum, octal
        return header;
      }
      function set_header(header, pos, numstr, len) {
        var j=0;
        while (j<numstr.length && j<len) header[pos++] = numstr.charCodeAt(j++) & 0xff;
        if (j<len) header[pos++] = 0x00;
      }
      function encode_filename(str){
        return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
          return '%' + c.charCodeAt(0).toString(16);});
      }
      var tars = {};
      var count = 0;
      return {
        add_blob: function(blob, lth, suffix, tarfile, ignore_limit){ // blob may be arraybuffer.
          if (!tars[tarfile]) tars[tarfile] = {files:[], size:0};
          var tfile = tars[tarfile];
          var size = blob.byteLength||blob.size;
          tfile.files[tfile.files.length] = make_header(blob, lth, suffix);
          tfile.size += 1;
          tfile.files[tfile.files.length] = blob;
          if (size%512!==0) tfile.files[tfile.files.length] = new Uint8Array(512-size%512);
          tfile.size += Math.floor((size+511)/512);
          if (!ignore_limit && (tfile.size>pref.archive.tarsize*2*1024 || pref.test_mode['71'])) this.flush(tarfile);
        },
        flush: function(tarfile, filename){
          if (!tarfile) {for (var i in tars) this.flush(i); return;}
          if (tars[tarfile]) { // called from both 'httpd.check_timestamp_and_flush' and 'archiver.flush_req', so the file might be flushed.
            tars[tarfile].files[tars[tarfile].files.length] = new Uint8Array(1024);
            download_url4(new Blob(tars[tarfile].files, {type:'application/x-tar'}), filename || 'CatChan_archive_updates_'+site.nickname+'_'+tarfile+'_'+(count++)+'.tar');
            delete tars[tarfile];
          }
        },
      };
    })();
    function store_posts(content, type, lth, suffix){
      if (!window.URL) return;
      if (!timestamp) set_timestamp();
      download_url3(new Blob([content], {type:type}), lth, suffix, timestamp);
    }
    function download_url3(blob, lth, suffix, timestamp){
      if (pref.archive.tar) tar.add_blob(blob, lth, suffix, timestamp);
      else download_url4(blob, 'CatChan_'+lth.key.replace(/\//g,'_') + '_' + suffix);
    }
    function download_url4(blob, filename){ // blob may be arraybuffer.
      if (blob instanceof ArrayBuffer) blob = common_func.arraybuffer2blob(filename, blob);
      if (brwsr.ff && !httpd.isLocal) {
        send_message('parent',['ARCHIVER', ['DOWNLOAD', [blob, filename]]]);
        return;
      }
      var url = window.URL.createObjectURL(blob);
      download_url(url, filename);
      window.URL.revokeObjectURL(url);
//      if (!brwsr.ff || httpd.isLocal) window.URL.revokeObjectURL(url);
    }
    function download_url(url, filename){ // this doesn't work if url is cross-origined, for example, i.4cdn.org from boards.4chan.org in 4chan.
      if (pref.test_mode['70']) return;
//      if (brwsr.ff && !httpd.isLocal) {
//        send_message('parent',['ARCHIVER', ['DOWNLOAD', [url, filename, site.nickname]]]); // doesn't work
//        return;
//      }
      var a_link = document.createElement('div');
      a_link.innerHTML = '<a href=' + url + ' download="' + filename + '">';
      if (brwsr.ff) site.script_body.appendChild(a_link);
      a_link.childNodes[0].click();
      if (brwsr.ff) site.script_body.removeChild(a_link);
    }
    var proto_archive = {initiator:'archive', get responseType(){return (pref.test_mode['85'])? 'blob' : 'arraybuffer';}, archive:true, callback_1:httpd.onload_archive, callback_1_fail:httpd.onload_archive_fail,
                         get max(){return this.tgts.length;},
                         get tgt(){return this.key + this.url.substr(this.url.lastIndexOf('/'));},
                        };
    var timestamp = null;
    var month = {Jan:'01', Feb:'02', Mar:'03', Apr:'04', May:'05', Jun:'06', Jul:'07', Aug:'08', Sep:'09', Oct:'10', Nov:'11', Dec:'12'};
    function set_timestamp(){
      var arr = new Date().toString().split(' ').slice(1,5);
      timestamp = [arr[2], month[arr[0]], arr[1], arr[3].replace(/:/g,'')].join('');
      httpd.req({tgts:[], timestamp:timestamp, __proto__:proto_archive},0);
    }
    var flush_req = DelayBuffer.prototype.delayed_do.bind(new DelayBuffer(function(){
//      if (reqs.length==0 && xhrs.size==0) tar.flush();
      httpd.check_timestamp_and_flush(timestamp);
    },5000));
    
    var xhrs = new Map();
    var reqs = [];
//    function download_url2(url, lth, kind, to_file, to_idb){ // for test
//      if (!timestamp) set_timestamp();
//      var req = {url:url, lth:lth, kind:kind, to_file:to_file, to_idb:to_idb, timestamp:timestamp};
    function download_url2(reqs_in){
      httpd.req_add({tgts:reqs_in, timestamp:timestamp, __proto__:proto_archive},0);
      return;
    }
////    function download_url2(reqs_in){ // working code.
////      for (var i=0;i<reqs_in.length;i++) {
////        if (xhrs.size>=10) reqs.push(reqs_in[i]);
////        else {
////          var xhr = new XMLHttpRequest();
////          xhr.responseType = 'blob';
////          xhr.onload  = download_url2_1_onload;
////          xhr.onerror = download_url2_1_onload;
////          xhr.onabort = download_url2_1_onload;
////          download_url2_1(xhr, reqs_in[i]);
////        }
////      }
////    }
////    function download_url2_1(xhr, req){ // for test
////      xhrs.set(xhr, req);
////      xhr.open('GET', req.url);
////      xhr.send();
////      return xhr;
////    }
////    function download_url2_1_onload(e){
////      var xhr = e.target;
////      var req = xhrs.get(xhr);
////      if (req.from) delete list_all_obj_downloading[req.from];
////      if(xhr.status === 200 && e.type==='load') {
////        var suffix = req.kind + '_'+ xhr.responseURL.replace(/.*\//g,'');
////        if (req.to_file) download_url3(xhr.response, req.lth, suffix, req.timestamp);
////        if (!pref.test_mode['65']) if (req.to_idb) IDB.req(req.lth.domain, req.lth.board, req.lth.no, suffix, xhr.response, 'put');
////      }
////      if (reqs.length>0) {
////        req = reqs.shift();
////        download_url2_1(e.target, req);
////      } else xhrs.delete(xhr);
////      if (xhrs.size===0) tar.flush();
////    }
    function img_dl(kind, th, lth, posts, img, img_idb, webm, webm_idb, reqs){
      for (var i=0;i<posts.length;i++) {
        var url = (kind==='tn')? site2[th.domain].catalog_json2html3_thumbnail(posts[i],th.board) : site2[th.domain].catalog_json2html3_src(posts[i],th.board);
        if (url) {
          if (!timestamp) set_timestamp();
//          var proto = {lth:lth, kind:kind, to_file:img||webm, to_idb:img_idb||webm_idb, timestamp:timestamp};
          var proto = {domain:th.domain, board:th.board, no:th.no, key:th.key, kind:kind, to_file:img||webm, to_idb:img_idb||webm_idb, timestamp:timestamp, __proto__:proto_archive};
          if (site2[th.domain].archive_patch_domain) site2[th.domain].archive_patch_domain(proto);
          if ((url.substr(-5,5)==='.webm')? webm || webm_idb : img || img_idb) reqs[reqs.length] = {url:url, __proto__:proto};
          if (posts[i].extra_files) for (var j=0;j<posts[i].extra_files.length;j++) {
            url = (kind==='tn')? site2[th.domain].catalog_json2html3_thumbnail(posts[i].extra_files[j],th.board) : site2[th.domain].catalog_json2html3_src(posts[i].extra_files[j],th.board);
            if ((url.substr(-5,5)==='.webm')? webm || webm_idb : img || img_idb) reqs[reqs.length] = {url:url, __proto__:proto};
          }}}
    }

    var url_funcs_wrapped = false;
    function url_funcs_wrap(){
      for (var d in site2) {
        if (site2[d].hasOwnProperty('catalog_json2html3_thumbnail')) site2[d].catalog_json2html3_thumbnail = wrap(site2[d].catalog_json2html3_thumbnail);
        if (site2[d].hasOwnProperty('catalog_json2html3_src'))       site2[d].catalog_json2html3_src       = wrap(site2[d].catalog_json2html3_src);
        if (site2[d].hasOwnProperty('parse_funcs')) {
          var tgts = ['catalog_html','page_html','thread_html','post_html'];
          for (var i=0;i<tgts.length;i++)
            if (site2[d].parse_funcs.hasOwnProperty(tgts[i]) && site2[d].parse_funcs[tgts[i]].hasOwnProperty('op_img_url'))
              site2[d].parse_funcs[tgts[i]].op_img_url = wrap(site2[d].parse_funcs[tgts[i]].op_img_url);
        }
      }
      function wrap(func){
        return function(th, board){
          var url = func.call(this, th, board);
          return (url && th.localArchive)? archiver.url2file(th.localArchive, url) : url;
        }
      }
    }
    var archive_no = 0;
    function restore(file, result, archive, IDB){
      if (!window.URL) return;
      var th_obj = (IDB)? result :
                   (file.type==='text/html')? new DOMParser().parseFromString(result, 'text/html') : JSON.parse(result);
      var dbt = (pref.archive.format==='auto')? common_func.name2domainboardthread(file.name.replace(/\.[^\.]*$/,'').split('_')[0].split('-').slice(0,3).join('/'),true) :
                                                [site0.domains[pref.archive.domain],
                                                 '/'+pref.archive.board.replace(/\//g,'')+'/'];
      if (pref.test_mode['80']) dbt[1] = dbt[1].slice(0,-1) + ((IDB)? '_IDB/' : '_File/');
      if (pref.archive.fix_inconsistency && dbt[0]!=='meguca') {
        if (th_obj.posts[0].no!=dbt[2]) { // lain/drg/4654
          th_obj.posts = [common_func.deep_copy(th_obj.posts[0])].concat(th_obj.posts);
          th_obj.posts[0].no = dbt[2];
          console.log('Archiver: Fixed: added dummy OP: '+dbt.join(''));
        }
        for (var i=0;i<th_obj.posts.length;i++) if (th_obj.posts[i].filename===false) {
          th_obj.posts[i].filename = 'LOST_AT_ARCHIVE';
          console.log('Archiver: Fixed: filename was lost: '+dbt.join('')+'#'+th_obj.posts[i].no);
        }
      }
      if (!url_funcs_wrapped) {
        url_funcs_wrap();
        url_funcs_wrapped = true;
      }
      var ths = cataLog.scan_boards_keyword_callback2(dbt[0]+','+dbt[1]+','+ (archive_no++)+',thread_' + ((file.type==='text/html')? 'html' : 'json'),
                                                      {date:Date.now(), status:200, response:th_obj},
                                                      ['archive_restore',{localArchive:archive, page:(IDB)?'IDB':'File',
                                                                          __proto__:cataLog.scan_boards_keyword_callback2_default_args}]);
      cataLog.threads[ths[0].key][16].archiveFile = (IDB)? 'IDB' : file;
      return ths[0];
    }
    function start_1(req, lth, footer, from_check_op){
      if (req==='ARC' || req==='ARC1') {
        lth.archived |= (req==='ARC')? 6 : 1;
//        lth.archived |= (req==='ARC')? 6 : 5;
        if (!from_check_op) scan.list_nup.add_scan(lth);
      } else if (req==='UARC') {
        lth.archived = 0;
        archiver.clean_list(lth.domain, lth.board, lth.no);
      }
      if (footer && pref.catalog.footer.archived) cataLog.Footer.update_force(lth.key);
    }
    var blist = {pn:null, time_bumped:null, time_created:null, time_posted:null, flag:null, footer:null, time_tu:null,
                 nof_posts:null, nof_files:null, tags:null, page:null,
                 parse_funcs:null, // THIS IS REDUNDANT, but this caused a bug, so this is for safe.
                 quotes:null, backlinks:null, reply_to_me:null, reply_of_mine:null, op_img_url:null}; // BUG. meguca has 'backlinks'.
    function store_json_func(key,value){
      return (blist[key]===null)? undefined : value;
    }

// https://www.w3.org/TR/html5/scripting-1.html#the-script-element
//   Note: When inserted using the document.write() method, script elements execute (typically synchronously), but when inserted using innerHTML and outerHTML attributes, they do not execute at all.
    var sanitize = (function(){
      var funcs = {
        html: (function(){
          var pn = document.createElement('div');
          var wlist = {'A':null, 'SPAN':null, 'DIV':null, 'BLOCKQUOTE':null, 'BR':null, 'WBR':null,
                       'U':null, 'S':null, 'STRIKE':null, 'B':null, 'I':null, 'BIG':null, 'SMALL':null, 'TT':null, 'SUB':null, 'SUP':null, 'EM':null, 'STRONG':null};
          return function (key,value,obj){
            pn.innerHTML = value;
            var tags = pn.getElementsByTagName('*');
            for (var i=0;i<tags.length;i++) if (wlist[tags[i].tagName]!==null) {obj[key] = '';return;}
          }
        })(),
        string: function (key,value,obj){
          if (value.search(/[<>"'&]/)!=-1) obj[key] = '';
        }
      };
      return function(ary){
        if (ary) for (var j=0;j<ary.length;j++) {
          var obj = ary[j];
          for (var i in obj)
            if (typeof(obj[i])==='string')
              if (i==='com') funcs.html(i, obj[i], obj);
              else funcs.string(i, obj[i], obj);
        }
        return ary;
      }
    })();
    var ls_key_archive = pref.script_prefix + '.archived';
    var list_all_obj = {};
    if (localStorage) load_list();
    if (pref.debug_mode['28']) console.log('list_all_obj: ',list_all_obj);
    var list_all_obj_downloading = {};
    function list_all(){
      if (pref.debug_mode['28']) console.log('list_all_obj_downloading: ',list_all_obj_downloading);
      for (var d in liveTag.mems) {
        var time_unit = site2[d].parse_funcs.post_json.time_unit;
        for (var b in liveTag.mems[d]) {
          var tgt     = list_all_obj[d] && list_all_obj[d][b];
          var tgt_tmp = tgt || {};
          for (var t in liveTag.mems[d][b]) {
            var lth = liveTag.mems[d][b][t];
            var time_checked = list_all_obj_downloading[lth.key] || lth.time_checked/time_unit;
            if (lth.ed_t) time_checked = (pref.archive.editing_timeout)? bug_patch_for_meguca_editing_timeout(lth) || time_checked : lth.ed_t[lth.ed_t.length-1].time - 1; // rewinds to oldest editing post and retry after reload.
            if (lth.archived) {
              if (list_all_obj_downloading[lth.key]) tgt_tmp[t] = list_all_obj_downloading[lth.key];
              else if (!tgt_tmp[t] || tgt_tmp[t]<time_checked) tgt_tmp[t] = time_checked;
            } else if (lth.posts_saved) tgt_tmp[t] = - time_checked; // 'lth.time_checked/time_unit;' can be used here.
//            if (lth.archived && !(lth.key in pref3.archive.list_obj2)) list_all_obj[lth.key] = lth.time_checked; // BUG. NOT implemented yet.
          }
          if (!tgt && Object.keys(tgt_tmp).length!==0) {
            if (!list_all_obj[d]) list_all_obj[d] = {};
            list_all_obj[d][b] = tgt_tmp;
          } else if (tgt && Object.keys(tgt).length===0) delete list_all_obj[d][b];
        }
        if (list_all_obj[d] && Object.keys(list_all_obj[d])===0) delete list_all_obj[d];
      }
    }
    function bug_patch_for_meguca_editing_timeout(lth){
      var time_now = Date.now()/1000;
      for (var i=lth.ed_t.length-1;i>=0;i--) if (typeof(lth.ed_t[i])!=='string') {
        var time = lth.ed_t[i].time;
        if (time_now-time<3600) return time;
      }
      return null;
    }
    function load_list(e){
      if (!e || e.key===ls_key_archive) list_all_obj = JSON.parse(e && e.newValue || localStorage[ls_key_archive] || '{}');
    }
    function save_list(){
      if (pref3.archive.working && localStorage) {
        list_all();
        if (Object.keys(list_all_obj).length===0) delete localStorage[ls_key_archive];
        else localStorage[ls_key_archive] = JSON.stringify(list_all_obj);
        if (pref.debug_mode['28']) console.log('list_all_obj: ',list_all_obj);
      }
    }
    window.addEventListener('storage', load_list, false);
    window.addEventListener('beforeunload', save_list, false);
    return {
      clean_list_all: function(domain, board, nos){
        if (list_all_obj[domain] && list_all_obj[domain][board]) {
          var list_all_obj_bd = list_all_obj[domain][board];
          for (var no in list_all_obj_bd) if (nos[no]===undefined) this.clean_list(domain,board,no);
        }
      },
      clean_list: function(domain,board,no){
        if (list_all_obj[domain] && list_all_obj[domain][board]) delete list_all_obj[domain][board][no]; // Since 4chan has 'delayed pruning', final archiving should be done here.
      },
      check_op: function(th,lth){
        var kwd = pref.archive.kwd;
        if (pref.archive.store_auto && kwd.str && (kwd.sub || kwd.name || kwd.com) &&
            cataLog.threads && cataLog.catalog_filter_query_keyword.kwd(pref.archive.kwd, th.posts, th.domain, th) ||
            this.check_archived_time(th.key, th.domain, th.board, th.no, th.parse_funcs.time_unit)!==false) start_1('ARC', lth, false, true);
      },
      check_archived_time: function(key, domain, board, no, time_unit){
        if (pref.archive.list) {
          var val = pref3.archive.list_obj2[key]; // find d/b/t@xxxx expression
          if (val && val.time) return val.time;
        }
        var val_inherited = list_all_obj[domain] && list_all_obj[domain][board] && list_all_obj[domain][board][no];
        if (pref.archive.list_inherit && val_inherited) return val_inherited;
        if (pref.archive.list) val = pref_func.merge_obj5(key,pref3.archive.list_obj2,null); // find all expresion
        return (val)? val.time/time_unit || val_inherited || 0 : false; // val may be undefined or null.
      },
      update_archived_time: function(name){
        pref3.archive.working = true;
        if (pref3.archive.list_obj2[name] && pref3.archive.list_obj2[name].time) {
          var key = new RegExp('(^|,)'+name.replace(/\+/,'\\+')+'([\\^@!][^,\n]*)*(,|\n|$)','mg');
//          var millisec = datetime%1000;
//          var time_str = '@' + new Date(datetime).toLocaleString() + ((datetime%1000==0)? '' : '.'+millisec);
//          str = str.value.replace(key,',') + ',' + name + time_str + '\n';
          pref.archive.list_str = pref.archive.list_str.value.replace(key,',') + ',' + name + '\n'; // remove time_str
          pref.archive.list_str = str.replace(/,,+/g,',').replace(/^,/g,'').replace(/\n,/g,'\n').replace(/\n\n+/g,'\n').replace(/^\n/,'');
          pref3.archive.list_obj2[name].time = null;
        }
      },
      store_entry: function(req, downloaded_files){
        if (cataLog.threads) {
          if (pref.archive.src==='shown') for (var name in cataLog.threads) if (cataLog.threads[name][9][0]===null) cataLog.threads[name][9] = cataLog.catalog_filter_query(name, true);
          for (var name in cataLog.threads) {
            var lth = liveTag.mems.getFromName(name);
            if (pref.archive.src==='stored' ||
               (pref.archive.src==='watched' && lth.watched) ||
               (pref.archive.src==='shown' && cataLog.threads[name][9][0])) start_1(req, lth, true);
          }
        }
      },
      start_1: start_1,
      restore_posts_from_IDB: function(value, th,  domain, board, no, result){
        var obj = this.event_funcs['consolidate_IDB_result'](result);
        if (obj.posts.length>1) {
          var lth = th.lth;
////          if (th.posts.length==1) {
////            lth.ta = {
////              posts: obj.posts,
////              nof_posts:obj.posts.length,
////              time_loaded:obj.posts[obj.posts.length-1].time,
////            };
//////          this.store(value, th, lth, null, null, true);
////          } else {
            obj.time_loaded = obj.posts[obj.posts.length-1].time;
            var deletedPosts = this.check_deleted_posts(value, th, lth, obj, true);
            if (lth.archived && deletedPosts && (lth.archived&0x02) && pref.archive.live.post) {
              var suffix_dbt = th.key.replace(/\//g,'-');
              store_posts(JSON.stringify(site2[th.domain].parse_funcs.thread_json.prep_to_archive(deletedPosts)), 'text/plain', lth, suffix_dbt+'_'+'deleted.json');
            }
////          }
        }
      },
      store_th_to_mem: function(value, th,lth, pf_store, editing_finished){ // for deleted posts detection, search, page mode (, archive).
        if (pf_store!=='no') {
          if (editing_finished && lth.ta.posts) {
            var ta_posts = lth.ta.posts;
            var j=ta_posts.length-1;
            for (var i=editing_finished.length-1;i>=0;i--) {
              while (j>=0 && ta_posts[j].no!=editing_finished[i].no) j--;
              if (j>=0) ta_posts[j] = editing_finished[i];
              else j=ta_posts.length-1;
            }
          }
          var pf_d = pref[cataLog.embed_mode].deleted_posts.detect;
          var posts = (th.posts && th.posts.length>1 && th.nof_posts>th.posts.length && lth.ta && pf_d!=='passive')?
              site2[th.domain].update_posts_replace_prep(th.posts, lth.ta.posts, typeof(pf_store)==='number'? pf_store : -1) :
              (th.parse_funcs.has_posts)? th.posts : lth.ta && lth.ta.posts || th.posts;
          if (!pref.test_mode['65'] && (lth.archived && pref.archive.live.post_idb || pf_d==='full_IDB')) {
            if (!lth.ta && pf_d==='full_IDB') IDB.req(th.domain, th.board, th.no, 'posts', this.restore_posts_from_IDB.bind(this, value, {posts:th.posts, __proto__:th}), 'get_all');
            var time_checked;
            if (lth.ta) time_checked = lth.ta.posts[lth.ta.posts.length-1].time;
            else {
              time_checked = list_all_obj[th.domain] && list_all_obj[th.domain][th.board] && list_all_obj[th.domain][th.board][th.no];
              if (time_checked<0) time_checked = - time_checked;
            }
            var posts_saved;
            if (time_checked && (!lth.ta || lth.ta.posts.length===lth.ta.nof_posts || th.posts.length < th.nof_posts)) {
              var i=th.posts.length;
              while (i>0 && th.posts[i-1].time>time_checked) i--;
              posts_saved = th.posts.slice(i);
            } else posts_saved = th.posts;
            if (editing_finished) posts_saved = editing_finished.concat(posts_saved);
            if (posts_saved.length>0) {
              if (th.type_data==='html') cataLog.format_html.prepare_html_extract_params(th);
              IDB.req(th.domain, th.board, th.no, 'posts', posts_saved, 'put');
              lth.posts_saved = 1;
            }
            if (pref.debug_mode['28'] && posts_saved.length>0) console.log('posts_saved: '+th.key+', '+time_checked+', '+posts_saved[posts_saved.length-1].time+' '+new Date(posts_saved[posts_saved.length-1].time*th.parse_funcs.time_unit).toLocaleString()+', LS:'+(list_all_obj[th.domain] && list_all_obj[th.domain][th.board] && list_all_obj[th.domain][th.board][th.no]));
          }
//          if (!pref.test_mode['65'] && pref.archive.oneshot.post_idb && (lth.archived&0x01)) IDB.req(th.domain, th.board, th.no, 'posts', posts, 'put');
          lth.ta = {
            posts: posts,
            nof_posts:th.nof_posts,
            time_loaded:th.time_loaded,
//            __proto__:th  // for debug.
          };
        } else if (lth.ta) delete lth.ta;
      },
      check_deleted_posts: function(value, th, lth, th_old, fill_IDB){
        if (pref[cataLog.embed_mode].deleted_posts.detect!=='no' && th_old && th_old.posts.length>1) {
          var thp = th.posts;
          var othp = th_old.posts;
          var flag = th.nof_posts === th.posts.length || th.type_source==='thread'; // 'thread' is for safe if inconsistent data is returned.
          var i=1;
          var j=1;
//          if (flag) {i=1;j=1;} // patch for 4chan's inconsistency between catalog_json and thread_json, thread_json returns old data and th_old.posts contains blank in it..
          if (flag) lth.rescan_dp = 0;
          else {
            i = th_old.nof_posts - othp.length +1 -(th.nof_posts - thp.length); // for short posts in 4chan catalog.
            j=1;
            if (i<1) {j+=1-i;i=1;}
          }
          var k=0;
          var m=0;
          var othpd = lth.pd || [];
          var post_deleted;
          var posts_offline = (fill_IDB)? [] : null;
          while (j<othp.length) {
            if (i<thp.length) {
              while (k<othpd.length && thp[i].no>othpd[k].no) k++;
              if (k<othpd.length && thp[i].no==othpd[k].no) {if (!th.native_prep) post_deleted = othpd.splice(k,1); else k++; continue;} // for inconsistent data between thread_json and catalog_json in 4chan.
//              if (j+1<othp.length && othp[j].no === othp[j+1].no) {j++;continue;} // BUG PATCH.
              if (thp[i].no === othp[j].no) {i++;j++;flag=true;continue;}
              if (thp[i].no <   othp[j].no) {if (flag && fill_IDB) posts_offline[posts_offline.length] = thp[i]; // console.log('fill: '+th.no+'#'+thp[i].no); 
                                             i++;              continue;}
            }
            while (m<othpd.length && othp[j].no>othpd[m].no) m++;
            if (m<othpd.length && othp[j].no === othpd[m].no) {j++;continue;}
            if (!flag) { // passive detection, deletion of some posts was detected, but I don't know which.
              if (pref[cataLog.embed_mode].deleted_posts.detect.indexOf('full')===0) {lth.rescan_dp=1; scan.list_nup.add_scan(lth);} // can't fild all of them.
              j++;
              continue;
            }

            post_deleted = othp[j++];
//            while (k<othpd.length && post_deleted.no>=othpd[k].no) k++; // BUG at serial posts are removed.
            if (!post_deleted.deleted_after) {
              post_deleted.deleted_after  = th_old.time_loaded;
              post_deleted.deleted_before = value && value.date || null;
//              post_deleted.deleted_debug  = th.type_parse + ', '+ th_old.type_parse + ', last' + (othp.length-j);
              var posts_wrapped = {posts:[th_old.posts[0]].concat(post_deleted), __proto__:th}; // BUG, post may NOT be derived from th.posts[0], html or json. time_unit may differ.
              site2[th.domain].wrap_to_parse.posts(posts_wrapped); // for merge
            }
            othpd.splice(m++,0,post_deleted);
          }
          lth.pd = (othpd.length>0)? othpd : null;
          if (post_deleted) {
            if (pref[cataLog.embed_mode].deleted_posts.store!=='no' && th.domain===site.nickname) {
              var storage = (pref[cataLog.embed_mode].deleted_posts.store==='LS')? localStorage : sessionStorage;
              if (storage) {
                var ls_key = site2[th.domain].ls_key_deletedPosts + th.board + th.no;
                if (othpd.length>0) storage[ls_key] = JSON.stringify(othpd, store_json_func);
                else delete storage[ls_key];
              }
            }
            if (!pref.test_mode['65'] && pref[cataLog.embed_mode].deleted_posts.detect==='full_IDB') this.store_deleted_posts_to_IDB(th, othpd);
//            if (!pref.test_mode['65'] && (lth.archived && pref.archive.live.post_idb || pref[cataLog.embed_mode].deleted_posts.detect==='full_IDB'))
//              IDB.req(th.domain, th.board, th.no, 'posts_deleted', JSON.stringify(othpd, store_json_func), (othpd.length>0)? 'put' : 'delete');
          }
          if (posts_offline && posts_offline.length>0) {
            if (th.domain!==site.nickname) posts_offline = JSON.parse(JSON.stringify(posts_offline, store_json_func)); // for structual clone, remove pn.
            IDB.req(th.domain, th.board, th.no, 'posts', posts_offline, 'put');
          }
          if (pref.debug_mode['19'] && post_deleted && lth.pd)
            for (var i=0;i<lth.pd.length-1;i++)
              if (lth.pd[i].no>=lth.pd[i+1].no)
                console.log('BUG: inorder of posts_deleted: '+th.key+', '+i+', '+lth.pd[i].no+', '+lth.pd[i+1].no);
        }
        return (post_deleted)? othpd : null; // return only if it's changed.
      },
      store_deleted_posts_to_IDB: function(th, othpd){
        IDB.req(th.domain, th.board, th.no, 'posts_deleted', JSON.stringify(othpd, store_json_func), (othpd.length>0)? 'put' : 'delete');
      },
      store_json_func: store_json_func, 
      store: function(value, th, lth, posts_new, time_check_old, pf_store, editing_finished){
        var deletedPosts = this.check_deleted_posts(value, th, lth, lth.ta);
        this.store_th_to_mem(value, th,lth, pf_store, editing_finished); // MUST BE AFTER 'check_deleted_posts', because it uses lth.ta for old version of posts and this revises them.
        if (lth.archived) {
          var time_unit = th.parse_funcs.time_unit;
          var time_checked = this.check_archived_time(th.key, th.domain, th.board, th.no, time_unit) || 0;
          time_check_old /= time_unit;
          if (time_checked<time_check_old) time_checked = time_check_old;
//          var time_checked = time_check_old/time_unit || this.check_archived_time(th.key, th.domain, th.board, th.no, time_unit) || 0; // BUG, because time_check_old brings pref.catalog.filter.time_str
          if (!(lth.archived&0x01) && (lth.archived&0x04)) if (th.posts[th.posts.length-1].time<=time_checked || th.time_posted<=time_checked*time_unit) if (!editing_finished) {
            lth.archived &= 0x02;
            return;
          }
//          if (!(lth.archived&0x01) && (lth.archived&0x04)) if (th.posts[th.posts.length-1].time*th.parse_funcs.time_unit<=time_checked || th.time_posted<=time_checked) if (!editing_finished) return;
          if (th.parse_funcs.posts_full) th.parse_funcs.posts_full(th);
          var live_active    = lth.archived&0x02;
          var oneshot_active = lth.archived&0x01;
          var post = live_active && pref.archive.live.post || oneshot_active && pref.archive.oneshot.post;
          var post_idb = live_active && pref.archive.live.post_idb || oneshot_active && pref.archive.oneshot.post_idb;
          var suffix_dbt = th.key.replace(/\//g,'-');
          if (deletedPosts) {
            if (post) store_posts(JSON.stringify(site2[th.domain].parse_funcs.thread_json.prep_to_archive(deletedPosts)), 'text/plain', lth, suffix_dbt+'_'+'deleted.json');
            if (post_idb && pref[cataLog.embed_mode].deleted_posts.detect!=='full_IDB') this.store_deleted_posts_to_IDB(th, deletedPosts);
          }
//          if (deletedPosts && post) store_posts(JSON.stringify(site2[th.domain].parse_funcs.thread_json.prep_to_archive(deletedPosts)), 'text/plain', lth, suffix_dbt+'_'+'deleted.json');
          var type = (th.type_data==='html')? 'text/html' : 'text/plain';
          var posts_all = (th.type_source==='thread' || th.posts.length===th.nof_posts)? th.posts : (lth.ta && lth.ta.posts.length===th.nof_posts)? lth.ta.posts : null;
          if (post) {
            var sub = (th.posts[0].sub || '').replace(/\..*/,'');
            var suffix = suffix_dbt + ((pref.archive.sub_in_filename && sub)? '_'+sub : '') + ((th.type_data==='html')? '.html' : '.json');
            if (posts_all) store_posts((th.type_source==='thread')? value.responseText :
                                                                    JSON.stringify(site2[th.domain].parse_funcs.thread_json.prep_to_archive(posts_all), store_json_func),
                                       type, lth, suffix);
            else {this.store_rescan(lth); return;}
          }
          if (posts_new || (lth.archived&0x05) || editing_finished) {
            var tn       = live_active && pref.archive.live.tn       || oneshot_active && pref.archive.oneshot.tn;
            var tn_idb   = live_active && pref.archive.live.tn_idb   || oneshot_active && pref.archive.oneshot.tn_idb;
            var img      = live_active && pref.archive.live.img      || oneshot_active && pref.archive.oneshot.img;
            var img_idb  = live_active && pref.archive.live.img_idb  || oneshot_active && pref.archive.oneshot.img_idb;
            var webm     = live_active && pref.archive.live.webm     || oneshot_active && pref.archive.oneshot.webm;
            var webm_idb = live_active && pref.archive.live.webm_idb || oneshot_active && pref.archive.oneshot.webm_idb;
            if (tn || tn_idb || img || img_idb || webm || webm_idb || post_idb) {
              if (lth.archived&0x05) {
                if (!posts_all && (oneshot_active || (!th.posts[1] || th.posts[1].time>time_checked) && (!lth.ta.posts[1] || lth.ta.posts[1].time>time_checked))) {this.store_rescan(lth); return;}
                if (oneshot_active) posts_new = posts_all;
                else {
                  var posts_src = (th.posts[1] && th.posts[1].time<=time_checked)? th.posts : lth.ta.posts;
                  var i = posts_src.length;
                  while (i>0 && posts_src[i-1].time>time_checked) i--;
                  posts_new = posts_src.slice(i); // posts_src contains posts_new always.
                }
              }
              if (editing_finished) posts_new = editing_finished.concat(posts_new || []);
              if (posts_new.length!=0) {
                if (pref.debug_mode['28']) console.log('archive: '+th.key+', '+posts_new.length+'/'+th.nof_posts);
                var reqs = [];
                if (tn || tn_idb)                       img_dl('tn',  th, lth, posts_new, tn,  tn_idb,  webm, webm_idb, reqs);
                if (img || img_idb || webm || webm_idb) img_dl('img', th, lth, posts_new, img, img_idb, webm, webm_idb, reqs);
                if (reqs.length!=0) {
                  reqs[reqs.length-1].from = th.key;
                  list_all_obj_downloading[th.key] = time_checked;
                  download_url2(reqs);
                }
                if (!pref.test_mode['65'] && post_idb && lth.archived&0x05) IDB.req(th.domain, th.board, th.no, 'posts', posts_new, 'put');
              }
            }
          }
          if (post && (deletedPosts || posts_all) && (!reqs || reqs.length===0 || th.domain!==site.nickname) && pref.archive.tar) flush_req();
          lth.archived &= 0x02;
          this.update_archived_time(th.key);
        }
      },
      store_rescan: function(lth){
        scan.list_nup.add_scan(lth);
        lth.archived |= 0x04;
      },
//      test_dl: function(url){
//        var xhr = download_url2(url, '4chan_test_xxxx_image_'+ url.replace(/.*\//g,''));
//        xhr.onprogress = function(e){console.log(e.target.responseURL+': '+e.loaded+'/'+e.total);};
//      },
      restore_entry: function(files, imgs, clear_func, posts_deleted){
        var archive = {};
        for (var i=0;i<imgs.length;i++) {
          if (archive[imgs[i].name]===undefined) archive[imgs[i].name] = {file:imgs[i]}; // force to remake url because of having different lifetimes. Old version was '= imgs[i];'
          else if (Array.isArray(archive[imgs[i].name])) archive[imgs[i].name].push({file:imgs[i]});
          else archive[imgs[i].name] = [archive[imgs[i].name], {file:imgs[i]}];
        }
//        for (var i=0;i<imgs.length;i++) archive[imgs[i].name] = {file:imgs[i]}; // force to remake url because of having different lifetimes. Old version was '= imgs[i];'
        var deleted = {};
        if (!pref.test_mode['64'] && pref[cataLog.embed_mode].deleted_posts.merge) for (var i=0;i<posts_deleted.length;i++) deleted[posts_deleted[i].name] = posts_deleted[i];
        var count = 0;
        if (pref.archive.clear_threads && cataLog.threads) cataLog.catalog_clear_threads(0);
        var fileReader = new FileReader();
        var name_deleted;
        fileReader.onerror = function (e){console.log('ERROR at loading json file, '+e);};
        fileReader.onload = function(e){
          if (!name_deleted) {
            restore(files[count-1], fileReader.result, archive);
            if (!pref.test_mode['64'] && pref[cataLog.embed_mode].deleted_posts.merge) {
              name_deleted = files[count-1].name.replace(/(_|\.).*/,'')+'_deleted.json';
              if (deleted[name_deleted]) {fileReader.readAsText(deleted[name_deleted]); return;}
            }
          } else {
            var name = name_deleted.slice(0,-13).replace(/\-/g,'/');
            if (pref.test_mode['80']) name = name.replace(/\/\d+$/,'_File$&');
            var lth = liveTag.mems.getFromName(name);
            archiver.prep_deleted_posts(lth.th, lth, fileReader.result);
          }
          name_deleted = null;
          if (files.length>count) fileReader.readAsText(files[count++]);
          else if (pref.archive.clear_files) clear_func();
        }
        fileReader.readAsText(files[count++]);
      },
      url2file: function(archive, url){
        var file = archive[url.replace(/[^\/]*\//g,'')];
        if (file) {
          if (Array.isArray(file)) file = (url.search(/thumb/)!=-1)? file[0] : file[file.length-1];
          if (!file.url) file.url = window.URL.createObjectURL(file.file);
          return file.url + ((file.file.type==='video/webm')? '" data-ext=".webm' : '');
        } else return url;
      },
//      url2file: function(archive, th){ // cause network access because post_json2html makes url begore this.
//        if (!window.URL) return;
//        var tgts = ['src','href'];
//        var all = th.pn.getElementsByTagName('*'); //'*[src],*[href]'
//        for (var i=0;i<all.length;i++)
//          for (var j=0;j<tgts.length;j++) {
//            var url = all[i].getAttribute(tgts[j]);
//            if (url) {
//              var file = archive[url.replace(/[^\/]*\//g,'')];
//              if (file) {
//                if (!file.url) file.url = window.URL.createObjectURL(file);
//                all[i].setAttribute(tgts[j], file.url);
//                if (file.type==='video/webm') all[i].setAttribute('data-ext','.webm');
//              }
//            }
//          }
//      },
      prep_deleted_posts: function(th,lth,src, src_obj){
        var posts_deleted = (src)? src_obj || JSON.parse(src) :
          (pref[cataLog.embed_mode].deleted_posts.store==='LS' && localStorage)? sanitize(JSON.parse(localStorage[site2[th.domain].ls_key_deletedPosts + th.board + th.no] || null)) :
          (pref[cataLog.embed_mode].deleted_posts.store==='SS' && sessionStorage)?      JSON.parse(sessionStorage[site2[th.domain].ls_key_deletedPosts + th.board + th.no] || null) : null;
        if (posts_deleted) {
//          for (var i=0;i<posts_deleted.length;i++) delete posts_deleted[i].pn;
          posts_deleted = site2[th.domain].parse_funcs.thread_json.rip_from_archive(posts_deleted);
          var th_deleted = {posts:[th.posts[0]].concat(posts_deleted),
                            parse_funcs: site2[th.domain].parse_funcs.thread_json,
////                            parse_funcs_html: site2[th.domain].parse_funcs.thread_html,
                            type_parse: 'thread_json',
                            type_source: 'thread',
                            type_data: 'json',
////                            type_html: 'thread_html',
////                            domain_html: th.domain,
//                            nof_posts:th.nof_posts - th.posts.length + posts_deleted.length+1,
                            __proto__:th};
          site2[th.domain].wrap_to_parse.posts(th_deleted, 1);
          if (src && lth.th) {  // NOT DESCRIBED ALL, UNDER IMPLEMENTATION....
            lth.pd = (lth.pd)? site2[th.domain].update_posts_merge_prep(th_deleted.posts, lth.pd, -1, true).slice(1) : posts_deleted;
            if ((cataLog.embed_mode==='page' || cataLog.embed_mode==='thread') && !pref.test_mode['64'] && pref[cataLog.embed_mode].deleted_posts.merge) {
              th.posts = site2[th.domain].update_posts_merge_prep(th.posts, lth.pd, -1, true);
//              cataLog.format_html.update_posts_in_page(th,th.key, null, true);
              cataLog.threads[th.key][16].th = th;
              cataLog.show_catalog(th.key);
            }
            cataLog.Footer.update_force(th.key);
            // CALL UPDATE_POSTS HERE.
          } else lth.pd = posts_deleted;
//          if (src) archiver.check_deleted_posts({date:date_load}, th, {archived:true}, th_deleted); // sourced from pipe.
//          else lth.pd = posts_deleted;
        }
      },
      refresh_start: function(){
        save_list(); // for browser's crash, but this make conflicts when multiple window is opened.
        timestamp=null;
      },
      list_all_obj_downloading: list_all_obj_downloading,
      download_url3: download_url3,
      download_url4: download_url4,
      tar: tar,
      sub_funcs: function(args){
        if (args[0]==='SUB_INIT') {
          cataLog.catalog_clear_threads(0);
          pref[cataLog.embed_mode].t2h_sel='All';
          if (args[1].IDB) IDB.req(args[1].domain, args[1].board, args[1].no, null, archiver.event_funcs['restore3'].bind(archiver.event_funcs), 'get_all');
          else {
            var tgt = args[1];
            var sel = parseInt(tgt.files_sel,10);
            var files = window.opener.document.getElementsByClassName(pref.script_prefix)[0].querySelectorAll('span[name="FILES_ARCHIVE'+sel+'"]')[0].querySelectorAll('input[type="file"]');
            for (var i=0;i<files.length;i++)
              for (var j=0;j<files[i].files.length;j++) {
                var src = files[i].files[j];
                if (src.name===tgt.name && src.size===tgt.size && src.lastModified===tgt.lastModified) {
                  archiver.event_funcs['restore2'](null, Array.prototype.slice.call(files[i+sel].files), [src]);
                  return;
                }
              }
          }
        } else if (args[0]==='DOWNLOAD') {
          download_url4(args[1][0], args[1][1]);
//          download_url(args[1][0], args[1][1]); // doesn't work
//          send_message(args[1][2],['ARCHIVER', ['REVOKE_URL', args[1][0]]]);
//        } else if (args[0]==='REVOKE_URL') window.URL.revokeObjectURL(args[1]);
        }
      },
      restore: restore,
      event_funcs:pref_func.settings.onchange_funcs.archive,
    };
  })();
 
  var recovery = (pref.features.recovery && localStorage)? (function(){
    var key;
    function init(){
      key = site2[site.nickname].ls_key_comment +site.board+site.no;
      var key_old = pref.script_prefix+'.comment.'+site.nickname+site.board+site.no; // patch for half year.
      if (pref.recovery.comment) {
        var comment = localStorage[key] || localStorage[key_old] || '';
        if (comment) {
          if (site.components.postform_comment ) site.components.postform_comment.value  = comment;
          if (site.components.postform_comment2) site.components.postform_comment2.value = comment;
        }
      }
    }
    init();
//    function clear(){if (localStorage) delete localStorage[key];}
    var src = null;
    var com = null;
    function com_changed(){
      src = this;
      delayed_check();
    }
    var delayed_check = new DelayBuffer(check_com,1000).get_binded_delayed_do();
    function check_com(){
      var com_new = src.value;
      if (!com || com.length<=com_new.length) com = com_new;
      src = null;
      delayed_save();
    }
    var delayed_save = new DelayBuffer(save, pref.recovery.interval*1000).get_binded_delayed_do();
    function save(){
      if (com) localStorage[key] = com;
      else delete localStorage[key];
      com = null;
    }
    function save_at_exit(){
      if (src) com = src.value;
      if (com!==null) save();
    }
    function setup(rec_inst,postform_comment,postform_submit){
      if (!rec_inst && pref.recovery.comment && postform_comment) {
        var func = com_changed.bind(postform_comment);
        postform_comment.addEventListener('change',func,false);
        postform_comment.addEventListener('keyup',func,false);
        postform_submit.addEventListener('click',func,false);
        rec_inst = [postform_comment, postform_submit, func];
      } else if (rec_inst && (!pref.recovery.comment || !postform_comment)) {
        rec_inst[0].removeEventListener('change',rec_inst[2],false);
        rec_inst[0].removeEventListener('keyup',rec_inst[2],false);
        rec_inst[1].removeEventListener('click',rec_inst[2],false);
        rec_inst = null;
      }
      return rec_inst;
    }
    var rec_inst = setup(null, site.components.postform_comment, site.components.postform_submit);
    var rec_inst2 = null;
    window.addEventListener('beforeunload', save_at_exit, false);
    return {
      setup: function(){
        rec_inst  = setup(rec_inst, site.components.postform_comment, site.components.postform_submit);
        rec_inst2 = setup(rec_inst2,site.components.postform_comment2,site.components.postform_submit2);
      },
      setup2: function(){rec_inst2 = setup(rec_inst2,site.components.postform_comment2, site.components.postform_submit2);},
//      clear: clear,
      reentry: function(){
        save_at_exit();
        init();
      },
    }
  })() : null;

  var scan = (function(){
////    list_nup_boards : Object.create(null), // list of next updates of boards.
////    list_nup : Object.create(null), // list of next updates.
    var list_nup = {
      // th.u: 0:ready, >0:requested, <0:blacklisted
      add: function(th, priority, force_thread){ // -1:locked, [1:0]:req, [2]:req_thread, [3]:force_json, [7:4]:priority,
        if (typeof(th)==='string') th = this.get_th(th);
        priority = (priority || 0) <<4;
        if (th.u===0) th.u = priority | ((force_thread)? 7 : 3);
        else if (th.u>0 && th.u<priority) th.u = priority | (th.u&0x0f);
      },
      add_scan: function(th){
        this.add(th);
        scan.scan_threads_delayed_do();
      },
      issued: function(th){
        if (typeof(th)==='string') th = this.get_th(th);
        if (th) th.u = (((th.u&0x03)===1)? 0xffffff00 : 0) | ((th.u===0)? 2 : th.u-1); // 'if (th)' for page(p0, p1...) // keep upper bits.
        return th && th.no && th.archived;
      },
      got_200: function(th){
        var lth = this.get_th(th.key);
        if (lth.u!==0 && (!(lth.u&0x04) || th.type_source==='thread')) lth.u = 0; // not create instances for future implementation.
      },
      got_404: function(th){
        if (typeof(th)==='string') th = this.get_th(th);
        if (th) th.u = -1;
      },
      get_th: function(key){
        var dbt = common_func.fullname2dbt(key);
        if (dbt[2].search(/(p|q)[0-9]+$/)!=-1) return null; // prevent board to be blacklisted when over page loading.
        if (dbt[2][0]==='t') dbt[2] = dbt[2].substr(1);
        else if (dbt[2].search(/^[0-9]/)==-1) dbt[2] = '';
        return liveTag.mems.init({domain:dbt[0], board:dbt[1], no:dbt[2]});
      },
      priority_th: [0, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0x100],
      get_list_thread: function(d, priority){
        var req_th = this.priority_th[priority || 0];
//        var req_th_u = this.priority_th[(priority || 0)+1];
        var count = 0;
        for (var b in liveTag.mems[d])
          for (var t in liveTag.mems[d][b])
           if (liveTag.mems[d][b][t].u>req_th) count++;            
//           if (liveTag.mems[d][b][t].u>req_th && liveTag.mems[d][b][t].u<req_th_u) count++;
        return (count===0)? null : [count, (function*(req_th){
          for (var b in liveTag.mems[d])
            for (var t in liveTag.mems[d][b])
              if (liveTag.mems[d][b][t].u>req_th) yield liveTag.mems[d][b][t]; // for getting robustness
//              if (liveTag.mems[d][b][t].u>req_th && liveTag.mems[d][b][t].u<req_th_u) yield liveTag.mems[d][b][t];
        })(req_th)];
      },
      get_list_thread2: function(d, priority){ // working code.
        var req_th = this.priority_th[priority || 0];
        var list = [];
//        for (var d in liveTag.mems)
        for (var b in liveTag.mems[d])
          for (var t in liveTag.mems[d][b])
            if (liveTag.mems[d][b][t].u>req_th) list[list.length] = liveTag.mems[d][b][t];
        return list;
      },
      get_list_board: function(d, priority){
        var req_th = this.priority_th[priority || 0];
//        var req_th_u = this.priority_th[(priority || 0)+1];
        var count = 0;
        for (var b in liveTag.mems[d])
          if (liveTag.mems[d][b].u>req_th) count++;
//          if (liveTag.mems[d][b].u>req_th && liveTag.mems[d][b].u<req_th_u) count++;
        return (count===0)? null : [count, (function*(req_th){
          for (var b in liveTag.mems[d])
            if (liveTag.mems[d][b].u>req_th) yield liveTag.mems[d][b];
//            if (liveTag.mems[d][b].u>req_th && liveTag.mems[d][b].u<req_th_u) yield liveTag.mems[d][b];
        })(req_th)];
      },
      get_list_board2: function(d, priority){
        var req_th = this.priority_th[priority || 0];
        var list = [];
        for (var b in liveTag.mems[d])
          if (liveTag.mems[d][b].u>req_th) list[list.length] = liveTag.mems[d][b];
        return list;
      },
//      add_domain: function(domain){liveTag.mems[domain].u = 1;},
      add_domain: function(domain, force_thread, boards){
        var max_boards = pref4.scan.max; // invoke getter
        if (!liveTag.active.pk){
          if (!boards) {
            for (var b in liveTag.mems[domain])
              if (liveTag.mems[domain][b].o!==null && liveTag.mems[domain][b].o < max_boards) this.add_board(domain+b, null, force_thread);
          } else for (var i=0;i<boards.length;i++) this.add_board(domain+boards[i], null, force_thread);
        } else {
          if (boards) {
            for (var b in liveTag.mems[domain]) { // working code for '>'
              if (liveTag.tags[liveTag.mems[domain][b].btag].pk) this.add_board(domain+b, null, force_thread);
              var btag2 = liveTag.mems[domain][b].btag2;
              if (btag2) {
                for (var i=0;i<btag2.length;i++)
                  if (liveTag.tags[btag2[i]].pk) this.add_board(domain+b, null, force_thread);
              }
            }
          } else {
            for (var i=0;i<max_boards;i++) if (liveTag.tags_array_old[i]) {
              for (var bt of liveTag.tags[liveTag.tags_array_old[i].key].mems.keys())
                if (!bt.no) this.add_board(bt, null, force_thread);
                else this.add(bt, null, force_thread);
            }
          }
        }
      },
      add_board: function(bd, priority, force_thread, use_boards_json, force_json){
        if (typeof(bd)==='string') bd = this.get_th(bd);
        if (force_thread===2) { // preparation read for search posts
          for (var t in bd) if (!bd[t].ta || bd[t].nof_posts!==bd[t].ta.posts.length) this.add(bd[t], priority, true);
          return;
        }
        if (!use_boards_json || bd.read_max<bd.max) {
          var upper_bits = ((priority || 0) <<4) | ((force_json)? 8 : 0) | ((force_thread)? 4 : 0);
          if (bd.u===0) bd.u = upper_bits | 3;
          else if (bd.u>0 && bd.u<priority) bd.u = upper_bits | (bd.u&0x0f);
        }
//        if (force_thread) for (var t in bd) this.add(bd[t], priority, force_thread); // BUG, bd had no members at initial, threads scan doesn't scheduled.
      },
////      add_board: function(bd, use_boards_json, force_thread, priority){ // working code.
////        if (typeof(bd)==='string') bd = this.get_th(bd);
//////        if (bd.u===0) bd.u = 3;
////        if (bd.u===0 && (!use_boards_json || bd.read_max<bd.max)) bd.u = 3;
//////        bd.u = 3;
//////        if (time) {
//////          if (bd.max) bd.read_max = bd.max;
//////          bd.read_time = time;
//////        }
////        if (force_thread) for (var t in bd) this.add(bd[t], force_thread);
////      },
      got_200_board: function(bd){
        if (typeof(bd)==='string') bd = this.get_th(bd);
        if (bd.u&0x04) for (var t in bd) this.add(bd[t], bd.u&0x00f0, true);
        if (bd.max) bd.read_max = bd.max;
        bd.u = 0;
      },
//      add_board: function(bd, time){ // working code.
//        if (typeof(bd)==='string') bd = this.get_th(bd);
////        if (bd.u===0) bd.u = 3;
//        bd.u = 3;
//        if (bd.max) bd.read_max = bd.max;
//        bd.read_time = time;
//      },
////      get_list_board: function(d){ // working code.
////        var list = [];
//////        var time_th = Date.now()-pref.liveTag.pickup_interval*1000;
//////        for (var d in liveTag.mems) {
////////          if (liveTag.mems[d].u) { // for 'add_domain' // working code.
////////            for (var b in liveTag.mems[d]) if (liveTag.mems[d][b].o!==null && liveTag.mems[d][b].o < pref.scan.max) this.add_board(d+b);
////////            liveTag.mems[d].u = 0;
////////          }
//////          if (domain && d!==domain) continue;
////        for (var b in liveTag.mems[d]) {
////          var tgt = liveTag.mems[d][b];
//////          if (tgt.u>0) if (tgt.read_time<time_th && (tgt.max===undefined || !pref.liveTag.utilize_boards_json || tgt.read_max<tgt.max)) list[list.length] = tgt;
//////          if (tgt.u>0) if (tgt.max===undefined || !pref.liveTag.utilize_boards_json || tgt.read_max<tgt.max) list[list.length] = tgt;
////          if (tgt.u>0) list[list.length] = tgt;
////        }
////        return (list.length!==0)? list : null;
////      },
//      query_list_board: function(domain){ // working code.
//        var d = liveTag.mems[domain];
//        if (d)
//          for (var b in d)
//            if (d[b].u>0) return true;
//        return false;
//      },
      scan_boards_enumerate: function(domain, func, ex_list){
        var thread_or_domain = pref.virtualBoard.scan_domains[domain]==='thread' || ex_list.has(liveTag.mems[domain]);
        var max_boards = pref4.scan.max; // invoke getter
        for (var b in liveTag.mems[domain])
          if (thread_or_domain || Object.keys(liveTag.mems[domain][b]).length!=0)
//            if (ex_list[liveTag.mems[domain][b].key]===undefined) // prevent multiple scan.
            if (!ex_list.has(liveTag.mems[domain][b])) // prevent multiple scan.
              if (liveTag.mems[domain][b].o!==null && liveTag.mems[domain][b].o < max_boards)
                if (!func || func(liveTag.mems[domain][b])) return true;
      },
    };
    var Scanner = function(type, domain, priority, key){ // type: 'b':boards, 't':threads
      this.type = type;
      this.domain = domain;
      this.key = key;
      this.priority = priority || 0;
      this.scanners[key] = this; // and also this.wdg, this.req
    };
    Scanner.prototype = {
      scanners: Object.create(null),
      func_entry: function(){
        var tgts;
if (!pref.test_mode['51']) { // 1-3 times faster than generator.
        tgts = (this.type==='b')? scan.list_nup.get_list_board2(this.domain, this.priority) : scan.list_nup.get_list_thread2(this.domain, this.priority);
        if (tgts.length!=0) this.func_scan(tgts,null);
        else this.exit();
} else {
        tgts = (this.type==='b')? scan.list_nup.get_list_board(this.domain, this.priority) : scan.list_nup.get_list_thread(this.domain, this.priority);
        if (tgts) this.func_scan(tgts,{tgts_iterator:tgts[1], max:tgts[0]});
        else this.exit();
}
      },
      func_scan: function(tgts,options, multi_entry){
        if (!this.wdg) this.wdg = new Watchdog(this.abort.bind(this),30000);
        cataLog.scan_init(this.key, tgts, {callback: this.func_cont.bind(this),
                                           watchdog: this.wdg.restart.bind(this.wdg),
                                           priority: this.priority,
                                           __proto__: options
                                          }, multi_entry);
      },
      func_cont: function() {
        if (this.req) {
          this.req = false;
          this.func_entry();
        } else this.exit();
      },
      exit: function(){
        if (this.wdg) this.wdg.stop();
        this.scanners[this.key] = null
        if (this.type==='b') {
          if (!this.aborted) scan.scan('t', this.domain, this.priority);
        } else if (this.type==='t' && cataLog.catalog_refresh_end) cataLog.catalog_refresh_end();
        if (this.callback) this.callback();
        var priority_next = get_highest_priority(this.type, this.domain);
        var key_next = get_key(this.type, this.domain, priority_next);
        if (this.scanners[key_next]===false) new Scanner(this.type, this.domain, priority_next, key_next).func_entry(); // do scheduled task, but this may not occur.
      },
      abort: function(){
        if (pref.debug_mode['7']) console.log('Scanner_abort: '+this.key);
        cataLog.scan_boards.scan_abort(this.key);
        if (this.aborted===undefined) {
          this.aborted = true;
          this.wdg.restart();
        } else this.exit();
      },
    };
    var ScannerUI = function(key, arg){ // arg is {tgts:, options:}
      this.key = key;
      this.arg = arg;
      this.scanners[key] = this;
      this.callback = this.arg.options && this.arg.options.callback;
    };
    ScannerUI.prototype = {
      scanners: Object.create(null),
      priority: 8,
      func_entry: function(){
        this.func_scan(this.arg.tgts, this.arg.options, true);
      },
      func_cont: function() {
        if (this.queue && this.queue.length>0) {
          this.arg = this.queue.shift();
          this.func_entry();
        } else this.exit();
      },
      __proto__: Scanner.prototype
    };
    function get_key(type, domain, priority){
      return ((type==='b')? 'scan' : 'scan_threads')+ '_' + domain + ':' + (priority || 0);
    }
    function get_highest_priority(type, domain){
      var key_pre = get_key(type, domain, 0).replace(/0$/,'');
      for (var p=8;p>=0;p--) {
        var scanner = Scanner.prototype.scanners[key_pre+p];
        if (scanner || scanner===false) return p;
      }
      return -1;
    }
    var scan_refresh_ex_list = new Set();
    return {
      scan_refresh: function(health_indicator, list, priority, list_domains){
        scan_refresh_ex_list.clear();
        for (var i=0;i<list.length;i++) {
          var dbt = common_func.name2domainboardthread(list[i],true);
          if (dbt[2].search(/^[cj]/)===0) scan_refresh_ex_list.add(liveTag.mems[dbt[0]][dbt[1]]);
          else if (dbt[2].search(/^t*[0-9]+/)===0) scan_refresh_ex_list.add(liveTag.mems[dbt[0]][dbt[1]][(dbt[2][0]==='t')? dbt[2].substr(1) : dbt[2]]); // redundant.
        }
        for (var i in list_domains) scan_refresh_ex_list.add(liveTag.mems[i]);
        scan.scan('t', null, priority);
        if (!pref.liveTag.use)
          for (var tag in liveTag.tags) // activate selected tags for NOT liveTag mode. In this case, tags are not many.
            if (liveTag.tags[tag].pk)
              for (var bt of liveTag.tags[tag].mems.keys())
                if (!scan_refresh_ex_list.has(bt))
                  if (bt.no) scan.list_nup.add(bt,2);
                  else scan.list_nup.add_board(bt,2);
        for (var d in liveTag.mems) {
          if (pref.liveTag.use) {
            if (site2[d].utilize_boards_json && pref.pref2[d].utilize_boards_json) {
              if (list_nup.scan_boards_enumerate(d, null, scan_refresh_ex_list))
                site2[d].get_boards_json('boards_'+d,(function(domain){return function(){scan.scan_refresh_1(domain, true);}})(d),true,health_indicator);
              else scan.scan('t', d);
            } else scan.scan_refresh_1(d, false);
          } else scan.scan('b', d);
        }
      },
      scan_refresh_1: function(domain, use_boards_json){
        list_nup.scan_boards_enumerate(domain, function(bd){scan.list_nup.add_board(bd, null, null, use_boards_json);}, scan_refresh_ex_list);
        scan.scan('b', domain);
      },
//      scan_refresh_move_req: function(list){ // working code.
//        for (var i=0;i<list.length;i++) {
//          var dbt = common_func.name2domainboardthread(list[i],true);
//          if (dbt[2].search(/^[cj]/)===0) {
//            scan.list_nup.add_board(dbt[0]+dbt[1]);
//            list.splice(i--,1);
//          } else if (dbt[2].search(/^t*[0-9]+/)===0) {
//            scan.list_nup.add(dbt[0]+dbt[1]+((dbt[2][0]==='t')? dbt[2].substr(1) : dbt[2]));
//            list.splice(i--,1);
//          }
//        }
//      },
      scan: function(type, domain, priority){
        if (!domain) for (var d in liveTag.mems) this.scan(type, d, priority);
        else {
          var key = get_key(type, domain, priority);
          var scanner = Scanner.prototype.scanners[key];
          if (scanner) scanner.req = true; // multi entry.
          else if (get_highest_priority(type, domain)>=priority) Scanner.prototype.scanners[key] = false; // schedule
          else if (type==='b' && (scanner = Scanner.prototype.scanners[get_key('t', domain, priority)]))
            scanner.callback = function(){scan.scan(type, domain, priority);}; // schedule
          else new Scanner(type, domain, priority, key).func_entry();
        }
      },
      abort: function(){
        for (var s in Scanner.prototype.scanners) {
          var scanner = Scanner.prototype.scanners[s];
          if (scanner) {
            if (scanner.wdg) scanner.wdg.stop();
            scanner.abort();
          }
        }
      },
      scan_ui: function(key, arg){
        new ScannerUI(key, arg).func_entry();
//        var scanner = ScannerUI.prototype.scanners[key];
//        if (scanner) {
//          if (!this.queue) this.queue = [];
//          this.queue[this.queue.length] = arg; // multi entry.
//        } else new ScannerUI(key, arg).func_entry();
      },
      scan_threads_delayed_do: DelayBuffer.prototype.delayed_do.bind(new DelayBuffer(function(){scan.scan('t');}, 200)),
      keyword_load: function(force, health_indicator){
        var flag = true;
        for (var domain in pref.virtualBoard.scan_domains) {
          if (pref.virtualBoard.scan_domains[domain]!=='none') {
            this.keyword_load_1(domain, force, null, health_indicator);
            flag = false;
          }
        }
        if (flag) this.keyword_load_1(site.nickname, force, null, health_indicator);
      },
      keyword_load_1: function(domain, force, boards, health_indicator){
//          if (!site3[domain].boards && (domain===site.nickname || pref.virtualBoard.scan_domains[domain]!=='none')) {
        if (!site3[domain].boards && ((!force && pref.virtualBoard.scan_domains[domain]!=='none') ||
                                       (force && liveTag.active.pk) || !boards)) {
          site2[domain].get_boards_json('kwd_load',function(){scan.keyword_load_1(domain, force, boards, health_indicator)},false,health_indicator);
          return;
        }
//          if (domain===site.nickname || pref.virtualBoard.scan_domains[domain]==='thread') {
//          if (pref.virtualBoard.scan_domains[domain]!=='none' || force) {
        if (pref.virtualBoard.scan_domains[domain]==='thread' || force) {
          scan.list_nup.add_domain(domain, pref.catalog.filter.kwd.post && force, boards);
          scan.scan('b',domain);
        }
      },
      list_nup: list_nup,
    };
  })();

  function make_catalog_obj(pn12_button){
    var catalog_func = null;
    function show_hide(){
      if (catalog_func===null) catalog_func = make_catalog(pn12_button);
      else catalog_func = catalog_func.destroy();
    }
    var embed_catalog;
    var embed_page;
    var embed_frame;
    var embed_mode;
    var embed_embed;
    function set_embed_xxxx(){
      embed_catalog = pref.catalog.embed && site.whereami==='catalog';
      embed_page    = pref.catalog.embed_page && site.whereami==='page';
      embed_frame   = pref.catalog.embed_frame && site.whereami==='frame';
      embed_mode = (pref.catalog.embed && site.whereami==='catalog')? 'catalog' :
                   (pref.catalog.embed_page && site.whereami==='page')? 'page' :
                   (pref.thread.embed && site.whereami==='thread')? 'thread' : 'float';
      embed_embed = embed_mode!=='float';
      cataLog.embed_mode = embed_mode; // this will be did in later, but do here also for meguca reentry.
    }
    cataLog.set_embed_xxxx = set_embed_xxxx;
    set_embed_xxxx();
    if (embed_embed) {
////      pref.catalog_board_list_sel = 0;
////      pref.catalog.filter.show = true;
////      pref.catalog_show_setting = true;
////      pref.catalog.design = 'catalog';
//      show_hide();  // moved after making software cache because of subscription.
//      if (brwsr.ff || site.settings) pn12_button.textContent = 'Frame'; // working code.
//      else pn12_button.getElementsByTagName('input')[0].value = 'Frame';
    } else {
////      pref.catalog.design = 'page';
      pn12_button.addEventListener('click', show_hide, false); // show_hide
    }
    styleSheet.init(embed_mode); // patch, but WHY???
    if (!pref.test_mode['98'] && embed_mode==='catalog') styleSheet.register('.backlink','display:inline;font-size:0.8em;');
//if (!(brwsr.ff && embed_mode==='catalog' && site.nickname==='4chan')) styleSheet.init(); // patch, but WHY???
////////if (!(brwsr.ff && embed_mode==='catalog' && site.nickname==='4chan')) { // patch, but WHY??? // working code.
//////////    var ss = document.styleSheets[document.styleSheets.length-1];
//////////    if (!ss) {
//////////      var ss = document.createElement('style');
//////////      document.head.appendChild(ss);
//////////      ss = ss.sheet;
//////////    }
////////    var ss = document.head.appendChild(document.createElement('style')).sheet;
////////    ss.insertRule('.catalog_triage_parent {pointer-events: none;}',0); 
////////    ss.insertRule('.catalog_triage_button {pointer-events: auto;}',1);
////////    pref_func.style_sheet = ss;
////////    pref_func.settings.onchange_funcs['catalog.click_area_add_rule'](); // rule 2.
////////    ss.insertRule('.'+pref.script_prefix+'_tag {cursor:pointer;}',3);
////////}

    function scan_tags_common(ths,html_str,tags_obj){
      var acc = true;
      if (tags_obj===undefined) {
        tags_obj = {cs:{}, ci:{}};
        acc = false;
      }
      for (var i in ths) {
        var tags_th = ths[i].tags;
        if (tags_th) {
          var dbt = cnst.name2domainboardthread(i,true);
          var tags_th_uniq = {};
          for (var j=tags_th.length-1;j>=0;j--)
            if (tags_th_uniq[tags_th[j]]===undefined) tags_th_uniq[tags_th[j]] = null; // BUG. #aaa and #AAA are counted as 2 in case insensitive mode.
            else tags_th.splice(j,1);
          if (tags_th.length<=pref.catalog.tag.max) {
            var end = (pref.catalog.tag.ignore<tags_th.length)? pref.catalog.tag.ignore : tags_th.length;
            for (var j=0;j<end;j++) {
              for (var k in tags_obj) {
                var tag_test = (k==='cs')? tags_th[j] : tags_th[j].toLowerCase();
                if (tags_obj[k][tag_test]===undefined) tags_obj[k][tag_test] = {num:1,mem:{}};
                else tags_obj[k][tag_test].num++;
                if (!tags_obj[k][tag_test].mem[dbt[0]+dbt[1]]) tags_obj[k][tag_test].mem[dbt[0]+dbt[1]] = 1;
                else tags_obj[k][tag_test].mem[dbt[0]+dbt[1]]++;
      }}}}}
      if (!acc) return scan_tags_common_b(tags_obj,html_str,{cs:[],ci:[]})[0];
    }
    function scan_tags_common_b(tags_obj, html_str, tags){ // CAN'T FIND 1->0 AT A BOARD.
      for (var i in tags_obj) {
        for (var j in tags_obj[i]) {
          var tag_ref = (i==='cs')? j : j.toLowerCase();
          for (var n=0;n<tags[i].length;n++) {
            var tag_test = (i==='cs')? tags[i][n].key : tags[i][n].key.toLowerCase();
            if (tag_ref===tag_test) {
              for (var k in tags_obj[i][j].mem) tags[i][n].mem[k] = tags_obj[i][j].mem[k]; // update.
//var old = tags[i][n].num;
              tags[i][n].num = 0;
              for (var k in tags[i][n].mem) tags[i][n].num += tags[i][n].mem[k];
//if (old!=tags[i][n].num) console.log(i+', '+j+', '+n+', '+tag_test+', '+old+', '+tags[i][n].num);
              delete tags_obj[i][j]; // works in Chrome and FF, BUT DANGEROUS?
              break;
            }
          }
        }
        for (var j in tags_obj[i]) tags[i].push({key:j, num:tags_obj[i][j].num, mem:tags_obj[i][j].mem});
//        tags[i].sort(function(a,b){return b.num - a.num;});
        tags[i].sort(function(a,b){return (b.num!=a.num)? b.num - a.num : (b.key > a.key)? -1:1;});
      }
      for (var i=0;i<tags.ci.length;i++) {
        var key = tags.ci[i].key.toLowerCase();
        for (var j=0;j<tags.cs.length;j++)
          if (key===tags.cs[j].key.toLowerCase()) {tags.ci[i].key=tags.cs[j].key; break;}
      }
      return scan_tags_common_c(tags, html_str);
    }
    function scan_tags_common_c(tags, html_str){
      var tags_tgt = (pref.catalog.filter.tag_ci)? tags.ci : tags.cs;
      var str2 = '';
      for (var i=0;i<tags_tgt.length;i++) {
        var item = tags_tgt[i].num + ': ' + tags_tgt[i].key;
        str2 = str2 + '<input type="checkbox"' + html_str + '> '+item + '<br>';
      }
      return [str2, tags];
    }
//    function scan_tags_common(ths,html_str,tags_obj){
//      var acc = true;
//      if (tags_obj===undefined) {
//        tags_obj = {cs:{}, ci:{}};
//        acc = false;
//      }
//      for (var i in ths) {
//        var tags_th = ths[i].tags;
//        if (tags_th) {
//          var dbt = cnst.name2domainboardthread(i,true);
//          var tags_th_uniq = {};
//          for (var j=tags_th.length-1;j>=0;j--)
//            if (tags_th_uniq[tags_th[j]]===undefined) tags_th_uniq[tags_th[j]] = null;
//            else tags_th.splice(j,1);
//          if (tags_th.length<=pref.catalog.tag.max) {
//            var end = (pref.catalog.tag.ignore<tags_th.length)? pref.catalog.tag.ignore : tags_th.length;
//            for (var j=0;j<end;j++) {
//              for (var k in tags_obj) {
//                var tag_test = (k==='cs')? tags_th[j] : tags_th[j].toLowerCase();
//                if (tags_obj[k][tag_test]===undefined) tags_obj[k][tag_test] = {num:0,mem:{}};
//                tags_obj[k][tag_test].num++;
//                tags_obj[k][tag_test].mem[dbt[0]+dbt[1]] = null;
//      }}}}}
//      if (!acc) return scan_tags_common_b(tags_obj,html_str)[0];
//    }
//    function scan_tags_common_b(tags_obj,html_str){
//      var tags = [];
//      for (var i in tags_obj.cs) tags.push({key:i, num:tags_obj.cs[i].num, mem:tags_obj.cs[i].mem});
//      tags.sort(function(a,b){return b.num - a.num;});
//      if (pref.catalog.filter.tag_ci) {
//        for (var i=0;i<tags.length-1;i++) {
//          var key = tags[i].key.toLowerCase();
//          tags[i].num = tags_obj.ci[key].num;
//          tags[i].mem = tags_obj.ci[key].mem;
//          for (var j=tags.length-1;j>i;j--) if (key===tags[j].key.toLowerCase()) tags.splice(j,1);
//        }
//        tags.sort(function(a,b){return b.num - a.num;});
//      }
//      var str2 = '';
//      for (var i=0;i<tags.length;i++) {
//        var item = tags[i].num + ': ' + tags[i].key;
//        str2 = str2 + '<input type="checkbox"' + html_str + '> '+item + '<br>';
//      }
//      return [str2, tags];
//    }
////    function scan_tags_common(ths,html_str,tags_obj,acc){
////      if (tags_obj===undefined) tags_obj = {};
//////      var tags_obj = {};
////      for (var i in ths) {
////        var tags_th = ths[i].tags;
////        if (tags_th) {
////          var tags_th_uniq = {};
////          for (var j=tags_th.length-1;j>=0;j--)
////            if (tags_th_uniq[tags_th[j]]===undefined) tags_th_uniq[tags_th[j]] = null;
////            else tags_th.splice(j,1);
////          if (tags_th.length<=pref.catalog.tag.max) {
////            var end = (pref.catalog.tag.ignore<tags_th.length)? pref.catalog.tag.ignore : tags_th.length;
////            for (var j=0;j<end;j++) {
////              if (tags_obj[tags_th[j]]===undefined) tags_obj[tags_th[j]] = [0,{}];
////              tags_obj[tags_th[j]][0]++;
////              tags_obj[tags_th[j]][1][i] = 0;
////            }
////          } 
////        }
////      }
////      if (!acc) return scan_tags_common_b(tags_obj,html_str);
////    }
////    function scan_tags_common_b(tags_obj,html_str){
////      var tags = [];
////      for (var i in tags_obj) tags.push({key:i, val:tags_obj[i][0], mem:tags_obj[i][1]});
////      tags.sort(function(a,b){return b.val - a.val;});
////      if (pref.catalog.filter.tag_ci) {
////        for (var i=0;i<tags.length-1;i++) {
////          var key = tags[i].key.toLowerCase();
////          for (var j=tags.length-1;j>i;j--) {
////            if (key===tags[j].key.toLowerCase()) {
//////console.log(tags[i].key+', '+tags[i].val +' + '+tags[j].key+', '+tags[j].val);
////              tags[i].val += tags[j].val;
////              for (var k in tags[j].mem) tags[i].mem[k] = 0;
////              tags.splice(j,1);
////            }
////          }
////        }
////        for (var i in tags) tags[i].val = Object.keys(tags[i].mem).length;
////        tags.sort(function(a,b){return b.val - a.val;});
////      }
////      var str2 = '';
////      for (var i=0;i<tags.length;i++) {
////        var item = tags[i].val + ': ' + tags[i].key;
////        str2 = str2 + '<input type="checkbox"' + html_str + '> '+item + '<br>';
////      }
////      return str2;
////    }
    function make_catalog(pn12_button){
      cataLog.embed_mode = embed_mode;
      if (pref[embed_mode].open_spoiler_text) styleSheet.open_spoiler_text();
      if (brwsr.sw_cache && pref.info_client) brwsr.sw_cache.subscribe(true);
//      var threads = []; // This makes non-associative array.
      var threads = {}; // This makes object.
      cataLog.threads = threads;
      var threads_idx = [];
      var pop_up_status = {};
////////      var boards = {};
//      var threads_last_deleted = {};
      var initialize_loop = true;

      var pn12_0_4 = document.createElement('div');
      var pn12 = cnst.init3({
        func_str:'left:0px:tile:get:bottom:resize:both:tb:width:'+pref.catalog.appearance.initial.width+'px:height:'+pref.catalog.appearance.initial.height+'px:resize:both:overflow:auto'+
          ((embed_embed)? ':display:none:embed':'') + ':Show'+(embed_embed?'':':bottom_top')+((embed_mode==='float')? ':tb_press:'+pref.catalog.appearance.initial.state:''),
        rolldown: function(){pn12_0_4.style.display='';},
        rollup: function(){pn12_0_4.style.display='none';},
        exit: show_hide,
        maximize: show_catalog_cont,
        get auto_roll(){return pref.catalog_auto_rollup_when_moving;}}).pn;
//      var pn12_whole = cnst.init('left:0px:tile:get:bottom:resize:both:Show:tb:width:'+pref.catalog.appearance.initial.width+'px:height:'+pref.catalog.appearance.initial.height+'px:resize:both:overflow:auto',
//        function(){pn12_0_4.style.display='';},function(){pn12_0_4.style.display='none';},show_hide,show_catalog_cont);
//      var pn12 = pn12_whole[0];
//      if (embed_embed) pn12.style.display = 'none';
//      var pn12_rollup_func = pn12_whole[1];

//// test for prototype base coding.
////      var pn12_whole = new Cnst2('left:0px:tile:get:bottom:resize:both:Show:tb:width:400px:height:400px:resize:both:overflow:auto',
////        {rolldowm:function(){pn12_0_4.style.display='';}, rollup:function(){pn12_0_4.style.display='none';}, exit:show_hide, maximize:show_catalog_cont});
////      var pn12 = pn12_whole.pn;
////      var pn12_rollup_func = pn12_whole.funcs.rollup;

//      cnst.bottom_top(pn12);
      var pn12_0 = pn12.childNodes[0];
      var pn12_1 = pn12.childNodes[1];
//      pn12_1.id = 'catalog_debug'; // working code.
//      var autorollup_state = false;
//      function auto_hide_catalog() {
//        if (pref.catalog_auto_rollup_when_moving) {
//          if (pn12_1.style.display!='none') {
//            pn12_rollup_func();
//            autorollup_state = true;
//          } else if (autorollup_state) {
//            pn12_rollup_func();
//            autorollup_state = false;
//          }
//        }
//      }
//      pn12.addEventListener('dragstart', auto_hide_catalog, false);
//      pn12.addEventListener('dragend'  , auto_hide_catalog, false);
      var pn12_0_2 = cnst.add_to_tb(pn12,
//        '<label name="filter"><input type="checkbox" name="catalog.filter.show"> Filter </label>' +
//        '<label name="settings"><input type="checkbox" name="catalog_show_setting"> Settings</label>'+
        '<button type="button" name="filter">'+ ((site2[site.nickname].CONTENT_SECURITY_POLICY_DATAURI)? 'F' : cnst.icons.img(cnst.icons.filter)) +'</button>' +
        '<button type="button" name="settings">'+ ((site2[site.nickname].CONTENT_SECURITY_POLICY_DATAURI)? 'S' : cnst.icons.img(cnst.icons.settings)) +'</button>'+
//        '<button name="refresh">Refresh</button>'+
//        '<button name="refresh">\u27f3</button>'+
        '<button type="button" name="refresh">'+ ((site2[site.nickname].CONTENT_SECURITY_POLICY_DATAURI)? 'R' : cnst.icons.img(cnst.icons.refresh)) +'</button>'+
        '<span name="num_of_pages">'+
          '<span name="hide_at_embed"> up to <input type="text" name="catalog_max_page" size="2" style="text-align: right;">pages in </span></span>'+
        '<span name="boards_selector"><select name="catalog_board_list_sel"></select></span>');
      var board_sel = pn12_0_2.getElementsByTagName('select')['catalog_board_list_sel'];
      cnst.auto_shrink_board_selector.setup(board_sel,pref.catalog_board_list_sel);
      pref_func.apply_prep(pn12_0_2,false);
      var pn12_0_2_childs = ['filter','settings','refresh','num_of_pages','boards_selector'];
      for (var i=0;i<pn12_0_2_childs.length;i++)
        if (!pref.catalog.appearance.titleBar[pn12_0_2_childs[i]]) pn12_0_2.getElementsByTagName('*')[pn12_0_2_childs[i]].style.display = 'none';
      pn12_1.style.width = pn12_0.offsetWidth + 'px';

      var healthIndicator = (function(){
        var his = [];
        var count = 0;
        var status = {};
        var HealthIndicator = function(){
          this.pn = document.createElement('span');
          this.pn.innerHTML = '<span style="color:limegreen"></span><span></span>';
          this.pn_countdown = this.pn.childNodes[0];
          this.pn_hi = this.pn.childNodes[1];
//          if (!(embed_catalog)) pn_hi.style['font-size'] = '24px';
          if (!pref.healthIndicator.show) this.pn.style.display = 'none';
          his.push(this);
          this.elems = [];
        }
        HealthIndicator.prototype = {
          shift: function(col,str,initiator,priority){
//            while (this.elems.length>=pref.healthIndicator.max) this.elems.shift().remove_from_parent();
            for (var i=this.elems.length-pref.healthIndicator.max;i>=0;i--) if (this.elems[i].remove_from_parent()) this.elems.splice(i,1);
            var elem = new HealthIndicatorElement(col,str,initiator,priority);
            this.pn_hi.insertBefore(elem.pn, this.pn_hi.firstChild);
            this.elems.push(elem);
            return elem;
          },
          destroy: function(){
            this.pn.parentNode.removeChild(this.pn);
            his.splice(his.indexOf(this),1);
          },
//          remove: function(tgt){this.elems.splice(this.elems.indexOf(tgt),1)[0].remove();},
//          set: function(col,str){this.elems[this.elems.length-1].set(col,str);}, // PATCH
        };
        var HealthIndicatorElement = function(col,str,initiator,priority){
          this.pn = document.createElement('span');
          this.name = 'healthIndicator.' + (count++);
          this.pn.setAttribute('name',this.name);
          this.set(col,str);
          this.pn.onmouseover = mouseover;
          this.pn.onmouseout  = mouseout;
          this.pn.onclick     = click;
          status[this.name] = {initiator:initiator, priority:priority};
          this.show_tooltip_delayed = new DelayBuffer(show_tooltip.bind(this), 100).get_binded_delayed_do();
//          this.status = status[this.name]; // patch for faster execution.
        }
        var src = null;
        HealthIndicatorElement.prototype = {
          set: function(col,str){
            if (str) this.pn.textContent = str;
            if (col) this.pn.setAttribute('style','color:'+col);
          },
          remove_from_parent: function(){ // must be called from parent to remove elems[this].
            if (pref.healthIndicator.dont_retire_running && !status[this.name].end) return false;
            delete status[this.name];
            this.pn.parentNode.removeChild(this.pn);
            if (this.pn===src) mouseout();
            return true;
          },
          remove: function(){
            if (this.remove_from_parent())
              for (var i=0;i<his.length;i++) {
                var idx = his[i].elems.indexOf(this);
                if (idx!=-1) {
                  his[i].elems.splice(idx,1);
                  return;
                }
              }
          },
          report: function(obj){
            var stat = status[this.name];
            if (!stat) return; // when indicator was pruned.
            var prog = stat.prog; // prepare for being overwritten.
            if (obj) for (var i in obj) {
              if (i==='err_str') {
                if (!stat.err_str) this.set('orange');
                stat[i] = ((stat[i])? stat[i]+', ':'') + obj[i];
              } else stat[i] = obj[i];
              if (i==='end') {
                if (prog) {
                  stat.prog_str = (stat.prog.IDX)? prog.IDX+'/'+prog.tgts.length :
                                                   prog.found_threads+'/'+prog.scanned+', '+prog.found_boards+'/'+prog.max;
                  stat.prog = null; // remove reference loop.
                }
                var result = (!stat.err_str || stat.initiator==='IDB')? '\u25cf' :
                             (prog && prog.SUC)? '\u25b2' : 'X';
//                             (prog && Object.keys(prog.error_obj).length<prog.max)? '\u25b2' : 'X';
                this.set((result==='X')?'red':null, result);
              }
            }
            if (src || pref.healthIndicator.expand_running) this.show_tooltip_delayed();
          },
        };
        function mouseover(e){
          if (!pref.tooltips['info'].show) return;
          src = this;
          pref_func.tooltips.req_show('info', e, show_tooltip);
//          show_tooltip.call(this,e);
        }
        function show_tooltip(e){
          var myself = e && e.target || this;
          var name = myself.name || myself.getAttribute('name');
          var stat = status[name];
          if (!stat) return; // retired already.
          if (stat.prog) stat.prog_str = (stat.prog.IDX)? stat.prog.IDX+'/'+stat.prog.tgts.length+', ' + stat.tgt :
                                                          stat.prog.found_threads+'/'+stat.prog.scanned+', '+stat.prog.found_boards+'/'+stat.prog.idx+'/'+stat.prog.max+', ' + stat.tgt;
          if (!e && pref.healthIndicator.expand_running && stat.start && !stat.end) myself.set(null,' :'+stat.prog_str);
          if (src && src.getAttribute('name')===name) {
            var cancel_button = !stat.end && !pref.healthIndicator.cancel;
            var html = 'Initiator: '+stat.initiator+'&emsp;'+
                       ((cancel_button)? '<button name="'+name+'">Cancel</button>' : '')+ '<br>' +
                       ((stat.start)? 'Start: '+ new Date(stat.start).toLocaleTimeString()+'<br>' : '')+
                       ((stat.prog_str)? 'Progress: '+ stat.prog_str+'<br>' : '')+
                      'Priority: '+ stat.priority+'<br>'+
                       ((stat.start && !stat.end && stat.prog)? 'Crawler: '+ stat.prog.crawler+'<br>' : '')+
                       ((stat.err_str)? '<span style="color:red">Errors: '+ stat.err_str+'</span><br>' : '')+
                       ((stat.abort_str)? '<span style="color:red">Abort: '+ stat.abort_str+'</span><br>' : '')+
                       ((stat.end)? 'End: '+ new Date(stat.end).toLocaleTimeString()+'<br>' : '');
            var retval = (!cancel_button)? html : {html:html, callback:tooltip_func}
            if (!e) pref_func.tooltips.show_2(null, retval); // push
            else return retval;
          }
        }
        function mouseout(e){
          src = null;
          if (pref.tooltips['info'].show) pref_func.tooltips.hide2();
        }
        function tooltip_func(pn){
          pn.getElementsByTagName('button')[0].onclick = cancel_scan;
        }
        function click(){
          if (pref.healthIndicator.cancel) cancel_scan.call(this);
        }
        function cancel_scan(){
          var name = this.getAttribute('name');
          if (status[name] && !status[name].end) cataLog.scan_boards.scan_abort(status[name].initiator);
        }
        function show(){
          var disp = (pref.healthIndicator.show)? '' : 'none';
          for (var i=0;i<his.length;i++) his[i].pn.childNodes[1].style.display = disp;
        }
        function shrink_running(){
          if (!pref.healthIndicator.expand_running)
            for (var i=0;i<his.length;i++) 
              for (var j=0;j<his[i].elems.length;j++) if (his[i].elems[j].pn.textContent.length>1) his[i].elems[j].set(null,'r');
        }
        return {
          HealthIndicator: HealthIndicator,
          show: show,
          shrink_running: shrink_running,
        }
      })();
      cataLog.healthIndicator = healthIndicator;
      var health_indicator = new healthIndicator.HealthIndicator();
      httpd.set_health_indicator(health_indicator);
      pn12_0.childNodes[3].appendChild(health_indicator.pn);
      var IDB_spacer = document.createElement('span');
      IDB_spacer.textContent = ' ';
      pn12_0.childNodes[3].appendChild(IDB_spacer);
      var IDB_indicator = new healthIndicator.HealthIndicator();
      IDB.set_indicator(IDB_indicator);
      pn12_0.childNodes[3].appendChild(IDB_indicator.pn);

////      var health_indicator = (function(){ // working code.
////        var pn_hi = document.createElement('span');
//////        if (!(embed_catalog)) pn_hi.style['font-size'] = '24px';
////        if (!pref.catalog.health_indicator.on) pn_hi.style.display = 'none';
////        pn12_0.childNodes[3].appendChild(pn_hi);
////        function insert_node(col,str){
////          var max = pref.catalog.health_indicator.max;
////          while (pn_hi.childNodes.length>=max) pn_hi.removeChild(pn_hi.lastChild);
////          var pn = document.createElement('span');
////          if (col) pn.setAttribute('style','color:'+col);
////          if (str) pn.innerHTML = str;
////          pn_hi.insertBefore(pn,pn_hi.firstChild);
////          return pn;
//////          while (pn_hi.childNodes.length>=max) pn_hi.removeChild(pn_hi.childNodes[pn_hi.childNodes.length-1]);
//////          pn_hi.innerHTML = '<span' + ((col)? ' style="color:'+col+'"' : '' ) + '>'+str+'</span>' + pn_hi.innerHTML;
////        }
////        pref_func.health_indicator = pn_hi;
////        return {
////          pn_hi : pn_hi,
////          set: function(pn,col,str){
//////            if (!pn) pn = pn_hi.childNodes[0];
////            if (str) pn.textContent = str;
////            if (col) pn.style.color = col;
////          },
////          shift: function(col,str){return insert_node(col,str);},
////          remove: function(pn){
////            pn.parentNode.removeChild(pn);
////          }
////        }
////      })();

      if (embed_mode==='float') pn12_0_4.setAttribute('class', pref.script_prefix+'_window');
      pn12_0_4.style = 'margin:0px 3px; clear:both';
      pn12_0.appendChild(pn12_0_4);
      pn12_0_4.innerHTML = pref_func.format_html_str(
        '<div style="float:right;display:none">'+
          '<div style="float:right">'+
            '<ICBX"' + embed_mode + '.auto_update"> Auto update<br>'+
            '1,<ITB3"' + embed_mode + '.auto_update_period"> min.<br>'+
//            '<input type="checkbox" name="catalog_snoop_refresh" checked> Snoop update<br>'+
//            '&emsp;<input type="checkbox" name="catalog_promiscuous"> Promiscuous<br>'+
            '<ICBX"catalog_refresh_clear"> Clear latter than<br>'+
            '1,<ITB4"catalog.max_threads_at_refresh">th at update<br>'+
            '<BTN"clear_threads,ClearAllThreads">'+
          '</div>'+
          '<div style="float:right">'+
            '<div name="hide_at_embed">'+
//              '<select name="catalog.indexing"><option>Last reply</option><option>Creation date</option><option>Reply count</option><option>Image count</option></select><br>'+
              '<select name="catalog.indexing"><option>Bump order</option><option>Creation date</option><option>Reply count</option><option>Image count</option><option>Last reply</option><option>Fast</option><option>/Bump order</option><option>/Creation date</option><option>/Reply count</option><option>/Image count</option><option>/Last reply</option><option>Slow</option></select><br>'+
              'size '+
              '<span name="catalog.text_mode.mode.graphic">'+
                '<input type="text" name="catalog_size_width" size="4" style="text-align: right;"> x '+
                '<input type="text" name="catalog_size_height" size="4" style="text-align: right;"></span>'+
              '<span name="catalog.text_mode.mode.text">'+
                '<input type="text" name="catalog_size_text_width" size="4" style="text-align: right;"> x '+
                '<input type="text" name="catalog_size_text_height" size="4" style="text-align: right;"></span>'+
            '</div>'+
            '<div>'+
//              '&emsp;Order<br>'+
              '<ICBX"catalog.order.reply_to_me"> New reply to me at first<br>'+
              '<ICBX"catalog.order.reply"> New reply at first<br>'+
//              '<input type="checkbox" name="catalog.order.watch"> Watch listed at first<br>'+
              pref_func.settings.html_funcs.rollup_radio('catalog.order.watch', ' :Watch listed', 1, '',
                ['first:at first','last:at last','dont_care:don\'t care'])+ '<br>'+
              pref_func.settings.html_funcs.rollup_radio('catalog.order.sticky', ' :Sticky', 1, '',
                ['first:at first','last:at last','dont_care:don\'t care'])+ '<br>'+
//              '&emsp;<input type="radio" name="catalog.order.sticky" value="hide"> hide<br>'+
            '</div>'+
          '</div>'+
//          '<div style="float:right">'+
//            '<div name="hide_at_embed">'+
//              '<input type="radio" name="catalog.text_mode.mode" value="graphic"> Graphical mode<br>'+
//              '<input type="radio" name="catalog.text_mode.mode" value="text"> Text mode<br>'+
//            '</div>'+
//          '</div>'+
        '</div>'+
        '<div align="left" style="float:left">'+
          '<div data-show3="kwd">'+
            '<a name="HIDE3" style="cursor:pointer">[-]</a>'+
            '<ICBX"catalog.filter.kwd.use"> Keyword :'+
//            '<textarea style="height:1em" cols="25" name="catalog.filter.kwd.str"></textarea>'+
            '<input type="text" name="catalog.filter.kwd.str" size="25">'+
            ' <ICBX"catalog.filter.kwd.ci">CI '+
            pref_func.settings.html_funcs.make_sel('catalog.filter.kwd.match', ['match all','match any','unmatch all','unmatch any'])+
            ' <ICBX"catalog.filter.kwd.sentence">Sentence'+
            ' <ICBX"catalog.filter.kwd.re">RE<br>'+
            '1,(<ICBX"catalog.filter.kwd.sub">Subject '+
            '<ICBX"catalog.filter.kwd.name">Name '+
//            '<input type="checkbox" name="catalog.filter.kwd.trip">Tripcode '+
            '<ICBX"catalog.filter.kwd.com">Comment '+
            '<ICBX"catalog.filter.kwd.file">Filename '+
            '<ICBX"catalog.filter.kwd.meta">No.)'+
            ' (<ICBX"catalog.filter.kwd.op">OP '+
            '<ICBX"catalog.filter.kwd.post">Posts)'+
            '<button name="scanBoard">></button>'+
            '<button name="scanSite">>></button>'+
          '</div>'+
//          '<div>'+
////            '<button name="scanSite">scanSite</button> '+
//////////            '<span name="scan_progress"></span><br>'+
////            '<button name="clear_threads">ClearAllThreads</button>'+
////            '<input type="checkbox" name="common.clear_at_manual_scan">Auto <br>'+
////            '<div style="float:left;overflow:auto;resize:both;" name="catalog.filter.tag_site_list"></div>'+
////            '<input type="checkbox" name="catalog.filter.tag_scansite">scan tags<br>'+
//          '</div>'+
          '<div style="clear:both" data-show3="time">'+
            '<a name="HIDE3" style="cursor:pointer">[-]</a>'+
            'Time: Posted/Created '+
            '<ICBX"catalog.filter.time">'+
            '<ICBX"catalog.filter.time_creation">Hide '+
//            '<input type="checkbox" name="catalog.filter.time_mark"> Mark: '+
            '<ICBX"catalog.filter.time_watch">'+
            '<ICBX"catalog.filter.time_watch_creation">Watch '+
//            '<textarea style="height:1em" cols="25" name="catalog.filter.time_str"></textarea>'+
            '<ITBL25"catalog.filter.time_str">'+
            '<select name="catalog.filter.time_quick_sel">'+
              '<option>quick select...</option>'+
              '<option>now</option>'+
              '<option>1 hour ago</option>'+
              '<option>2 hours ago</option>'+
              '<option>4 hours ago</option>'+
              '<option>12 hours ago</option>'+
              '<option>1 day ago</option>'+
              '<option>3 days ago</option>'+
              '<option>1 week ago</option>'+
            '</select>'+
//            '<span class="CatChan_hMenu">quick select...'+
//              '<div class="CatChan_hMCnt" style="z-index:1">'+
//                ['now','1 hour ago','2 hours ago','4 hours ago','12 hours ago','1 day ago','3 days ago','1 week ago'].map(function(v){return '<button type="button">'+v+'</button>';}).join('')+
//              '</div>'+
//            '</span>'+
            '<br>'+
          '</div>'+
          '<div style="clear:both;display:none" data-show3="tag">'+
            '<a name="HIDE3" style="cursor:pointer;float:left">[-]</a>'+
            '<span class="PLACEHOLDER" style="float:right"></span>'+ // tack
            liveTag.popup_filter.html+
////            '<div style="float:left">'+
////              '<input type="checkbox" name="catalog.filter.tag"> Tag :'+
////            '</div>'+
////            '<div style="float:left">'+
////              '<div>'+
////                ' Fetcn / In / Out / Threads / Tag '+
////                '<ITBL25"catalog.filter.tag_search.str" placeholder="Search tags...">'+
//////                ' <ICBX"catalog.filter.tag_search.ci">CI'+
////                ' <ICBX"catalog.filter.tag_search.re">RE'+
////              '</div>'+
////              '<div><span></span>'+pref_func.settings.html_funcs.rollup(
////                '<IC"catalog.filter.tag_search.show_nof_boards">Show number of boards<br>'+
////                '<BTN"tagB.shown_t_pk,T"><BTN"tagB.shown_t_in,T"><BTN"tagB.shown_t_ex,T"> Toggle checkboxes of shown tags<br>'+ // span for not being wrapped by label.
////                '<BTN"tagB.shown_c_pk,C"><BTN"tagB.shown_c_in,C"><BTN"tagB.shown_c_ex,C"> Clear checkboxes of shown tags<br>'+
////                '<BTN"tagB.all_c_pk,C"><BTN"tagB.all_c_in,C"><BTN"tagB.all_c_ex,C"> Clear checkboxes of all tags')+'<br></div>'+
////              '<div style="overflow:auto;resize:both;float:left" name="catalog.filter.tag_list"></div>'+
////              pref_func.settings.html_funcs.rollup('<div style="clear:both">'+
////                '<BTN"tag2bList,Add"> selected tags to the last of board group<br>'+
////                '1,Label: <ITBL20"catalog.filter.tag2bList.label" placeholder="default: topmost tag"><br>'+
////                '1,<IR"catalog.filter.tag2bList.by,tag">By tag<br>'+
////                '1,<IR"catalog.filter.tag2bList.by,board">By board<br>'+
////                '</div>')+
//////              '<a name="SHOW" style="cursor:pointer" data-str="[\u25b2]">[\u25bc]</a>'+
//////              '<div name="SUB" style="clear:both;display:none">TEST</div>'+
////            '</div>'+
////            '<div style="clear:both"></div>'+ // for floating
          '</div>'+
          '<div style="clear:both;display:none" data-show3="list">'+
            '<a name="HIDE3" style="cursor:pointer;float:left">[-]</a>'+
            '<div style="float:left">'+
              '<input type="checkbox" name="catalog.filter.list"> Exclusive list:<br>'+
  //            '<input type="checkbox" name="catalog.filter.list_mark_time"> Mark:<br>'+
  //            '<!-- &emsp;<input type="checkbox" name="catalog.filter.list_time_scroll"> Scroll to new post -->'+
  //            '<div style="clear:both">&emsp;<textarea style="height:1em" cols="20" name="catalog.filter.list_str"></textarea></div>'+
              '&emsp;<textarea style="height:1em" cols="20" name="catalog.filter.list_str"></textarea>'+
            '</div>'+
            '<div style="float:left">'+
  //            '<div style="float:left"><input type="checkbox" name="catalog.filter.attr_list"> Attribute list:<br></div>'+
              '<input type="checkbox" name="catalog.filter.attr_list"> Attribute list:<br>'+
              '&emsp;<textarea style="height:1em" cols="20" name="catalog.filter.attr_list_str"></textarea>'+
            '</div>'+
            '<div style="float:left">'+
              'Watch time list:<br>'+
  //            '<input type="checkbox" name="catalog.filter.watch_list_mark_time"> Mark:<br>'+
              '&emsp;<textarea style="height:1em" cols="20" name="catalog.filter.watch_list_str"></textarea>'+
            '</div>'+
            '<div style="float:left">'+
              '<input type="checkbox" name="catalog.filter.bookmark_list"> Bookmark list:<br>'+
              '&emsp;<textarea style="height:1em" cols="10" name="catalog.filter.bookmark_list_str"></textarea>'+
            '</div>'+
            '<div style="float:left">'+
              '<button name="load">load</button><input type="checkbox" name="catalog.auto_load_filter">Auto'+
              '&emsp;<button name="load_default">clear_filters</button><br>'+
              '<button name="save">save</button><input type="checkbox" name="catalog.auto_save_filter">Auto'+
              '&emsp;<input type="checkbox" name="catalog.auto_save_filter_at_refresh">Auto at refresh<br>'+
            '</div>'+
          '</div>'+
          '<div style="clear:both"></div>'+
          '<a name="SHOW3" style="cursor:pointer;float:left;display:none" data-show3="kwd">[+ keyword filter]</a>'+
          '<a name="SHOW3" style="cursor:pointer;float:left;display:none" data-show3="time">[+ Time filter]</a>'+
          '<a name="SHOW3" style="cursor:pointer;float:left" data-show3="tag">[+ Tag search]</a>'+
          '<a name="SHOW3" style="cursor:pointer;float:left" data-show3="list">[+ List filters]</a>'+
        '</div>'+
        '<div style="clear:both"></div>');
      function hide_prev_float(e){
        cnst.tack_float_nSblgs(e, true);
//        site.script_body.appendChild(e.currentTarget.nextSibling);
        e.currentTarget.previousSibling.style.display = 'none'; // must be AFTER float not to change offsetLeft.
      }
      function show_prev_dock(e){
        var tack = cnst.tack_dock_e2tack(e);
//        tack.parentNode.insertBefore(e.currentTarget.parentNode,tack);
        tack.previousSibling.style.display = null;
        cnst.tack_dock_nSblgs(e);
      }
      var pls = pn12_0_4.getElementsByClassName('PLACEHOLDER');
      pls[0].appendChild(site2[site.nickname].make_tack());
      cnst.set_tack_float(pls[0], hide_prev_float, show_prev_dock);
//      var btns = pn12_0_2.getElementsByTagName('button');
//      cnst.set_target_of_button(btns['settings'],pn12_0_4.childNodes[0]);
//      cnst.set_target_of_button(btns['filter'],pn12_0_4.childNodes[1]);

      cataLog.components = {
        catalog: {indexing:pn12_0_4.getElementsByTagName('select')['catalog.indexing']},
        pn12_0: pn12_0,
        pn12_0_4: pn12_0_4,
        pn_hi: null,
      };
//      if (!embed_embed) pn12_0_4.style.background = '#e5ecf9';
//      else if (embed_mode==='catalog') {
      if (embed_mode==='catalog' || embed_mode==='page' || embed_mode==='thread') {
        pn12_0_2.getElementsByTagName('span')['hide_at_embed'].style.display = 'none';
        pn12_0_4.getElementsByTagName('div')['hide_at_embed'].style.display = 'none';
        if (embed_mode==='catalog') site2[site.nickname].catalog_native_frame_prep(pn12,pn12_button);
      }
      var hide_target = (pref.catalog.text_mode.mode==='text')? 'catalog.text_mode.mode.graphic' : 'catalog.text_mode.mode.text';
      pn12_0_4.getElementsByTagName('span')[hide_target].style.display = 'none';
      filter_kwd_prep_init(null, pref.catalog.filter.kwd,true); // prep kwd.rexps

//      pref_func.tooltips.add_hier(pn12_0_4);
      pref_func.tooltips.add_root(pn12_0_4);
//      if (pref[embed_mode].auto_config_posts_search) auto_config_posts_search_deactivate();
      pref_func.apply_prep(pn12_0_4,false, null, null, true);
//      pref_func.apply_prep(pn12_0_4,true); // obj init.
      var pn12_0_4_selectors = pn12_0_4.getElementsByTagName('select');
      for (var i=0;i<pn12_0_4_selectors.length;i++) cnst.auto_shrink_selector(pn12_0_4_selectors[i]);
//      function catalog_setting_onchange_event(){
////console.log(this);
//        pref_func.apply_prep(this,true);
//        if (onchange_funcs[this.name]) onchange_funcs[this.name]();
//      }
      var pn_filter = pn12_0_4.childNodes[1];
      var catalog_board_list_sel_old;
      var oninput_funcs = {
        'catalog.filter.kwd.str': (function(){
          var pn_use = pn_filter.getElementsByTagName('*')['catalog.filter.kwd.use'];
          return function(e){
            if (pref.catalog.filter.kwd.use == !pref.catalog.filter.kwd.str) {
              pref.catalog.filter.kwd.use = !pref.catalog.filter.kwd.use;
              pref_func.apply_prep(pn_use,false);
            }
            if (e && e.target.name.substr(-4,4)==='.str') pref3.catalog.filter.kwd.str(e);
            filter_kwd_prep(e, pref.catalog.filter.kwd);
          }
        })(),
        'catalog.filter.list_str'  : function(){catalog_filter_changed();if (pref[embed_mode].mark_new_posts) format_html.time_filter_changed();},
        'catalog.filter.attr_list_str': function(){if (pref.catalog.filter.attr_list) catalog_attr_changed();},
        'catalog.filter.tag_search.str': liveTag.popup_filter.oninput_funcs['catalog.filter.tag_search.str'],
        __proto__: pref_func.settings.oninput_funcs.__proto__
      };
      var onchange_funcs = {
//        'catalog.filter.show' : function(){cnst.show_hide(pn_filter,pn12_1);},
//        'catalog_show_setting': function(){cnst.show_hide(pn_setting,pn12_1);},
        'filter' : function(){cnst.show_hide(pn_filter,pn12_1);cnst.toggleButton(this);}, // pn12_1 for maximize state
        'settings': function(){cnst.show_hide(pn_setting,pn12_1);cnst.toggleButton(this);},
//        'refresh'             : function(){catalog_refresh(true,null,false);},
        'refresh'             : function(){auto_update.timer_tgt(true);},
        'catalog_board_list_sel' : function(e, init){
          if (!init) {
            e.target.blur();
            if (pref.catalog.auto_save_filter) onchange_funcs.save(catalog_board_list_sel_old);
            if (pref.catalog.refresh.at_switch) catalog_clear_threads(0);
            prep_reserved_tags(false,catalog_board_list_sel_old);
          }
          threads_delayed_pruning = Object.create(null);
          if (pref.catalog.auto_load_filter) onchange_funcs.load();
          if (!init) catalog_refresh(pref.catalog.refresh.at_switch,null,false, true);
//          if (pref[embed_mode].auto_config_posts_search) {
//            pref.catalog.filter.kwd.post = false;
//            pref_func.apply_prep(pn12_0_4.getElementsByTagName('input')['catalog.filter.kwd.post'],true);
//          }
          catalog_board_list_sel_old = pref.catalog_board_list_sel;
        },
        'catalog_size_width'  : catalog_resized,
        'catalog_size_height' : catalog_resized,
        'catalog_size_text_width'  : catalog_resized,
        'catalog_size_text_height' : catalog_resized,
        'catalog.indexing'    : re_sort_thread,
//        'catalog.indexing'    : function(){
//          threads_idx=[];
//          for (var i in threads) insert_thread_idx(i);
//          show_catalog();
//        },
        '*.auto_update' : function(){auto_update.set()},
        '*.auto_update_period' : '*.auto_update',
        'clear_threads'       : function(){catalog_clear_threads(0);show_catalog();},
        'load'                : function(){
          if (localStorage) {
            pref_func.pref_overwrite(pref.catalog.filter,pref_default().catalog.filter);
            try { 
              pref_func.pref_overwrite(pref.catalog.filter,JSON.parse(localStorage.getItem(onchange_funcs.load_save_key(board_sel.selectedIndex))),true);
              pref_func.apply_prep(pn_filter,false, null, null, true); // also make obj.
//              pref_func.apply_prep(pn_filter,true); // make obj2.
              filter_kwd_prep_init(null, pref.catalog.filter.kwd, initialize_loop);
              liveTag.filter_onchange(pref.catalog.filter.tag_search, true);
              catalog_attr_changed();
            } catch (e){
              console.log(e);
            }
          }
        },
//        'save_onleave'        : function(){if (pref.catalog.auto_save_filter) onchange_funcs.save();window.removeEventListener('beforeunload', onchange_funcs.save_onleave, false);},
//        'save'                : function(){if (localStorage) localStorage.setItem(onchange_funcs.load_save_key(pref.catalog_board_list_sel),JSON.stringify(pref.catalog.filter));},
        'save'                : function(sel){
          if (localStorage) {
            if (sel===undefined) sel = pref.catalog_board_list_sel;
            var pf = pref.catalog.filter;
            var save_str = JSON.stringify(
              pref_func.obj_elim_the_same(pref_default(true).catalog.filter, pref.catalog.filter),
              (!pf.time && !pf.time_watch && !pf.time_watch_creation && !pf.time_creation)?
                function(key,value){return (key==='time_str')? undefined : value;} : undefined);
            var key = onchange_funcs.load_save_key(sel);
            if (!key) return;
            if (save_str==='{}') delete localStorage[key];
            else localStorage.setItem(key, save_str);
          }
        },
        'load_default'               : function(){
//          var pref_def = pref_default();
          pref_func.pref_overwrite(pref.catalog.filter,pref_default().catalog.filter);
//          pref.catalog.filter.time_str = new Date().toLocaleString();
          pref_func.apply_prep(pn12_0_4,false, null, null, true);
//          pref_func.apply_prep(pn12_0_4,true); // obj init.
          filter_kwd_prep(null, pref.catalog.filter.kwd);
          catalog_attr_changed();
        },
        'load_save_key'       : function(num){
          var row_obj = pref.catalog_board_list_obj[num];
          return (row_obj)? pref.script_prefix + '.catalog.filter.' + row_obj[0].key : null;},
        'catalog.filter.kwd.use'   : filter_kwd_active,
        'catalog.filter.kwd.match' : filter_kwd_prep,
        'catalog.filter.kwd.re'    : filter_kwd_prep,
        'catalog.filter.kwd.ci'    : filter_kwd_prep,
        'catalog.filter.kwd.sentence': filter_kwd_prep,
        'catalog.filter.kwd.op'    : filter_kwd_active,
        'catalog.filter.kwd.sub'   : filter_kwd_active,
        'catalog.filter.kwd.name'  : filter_kwd_active,
        'catalog.filter.kwd.file'  : filter_kwd_active,
        'catalog.filter.kwd.com'   : filter_kwd_active,
        'catalog.filter.kwd.trip'  : filter_kwd_active,
        'catalog.filter.kwd.meta'  : filter_kwd_active,
        'catalog.filter.kwd.post'  : function(e){
          filter_kwd_active(e);
          if (e.target.checked) {
            if (pref[cataLog.embed_mode].searchAs) onchange_funcs.scanBoard(e, true, true);
            if (pref[cataLog.embed_mode].searchAsA) onchange_funcs.scanSite(e, true, true);
          }
//          if (pref[embed_mode].auto_config_posts_search) {
//            if (e.target.checked) {
//              pref[embed_mode].t2h_sel = 'ALL_agg';
//              if (embed_mode==='catalog') pref[embed_mode].popup2 = 'sr';
//              onchange_funcs.scanBoard();
//            } else {
//              var pref_def = pref_default();
//              pref[embed_mode].t2h_sel = pref_def[embed_mode].t2h_sel;
//              if (embed_mode==='catalog') pref[embed_mode].popup2 = pref_def[embed_mode].popup2;
//            }
//            pref_func.apply_prep(pref_func.mirror_targets.pn13_1,false);
//          }
        },
        'catalog.filter.tag'       : catalog_filter_changed,
//        'catalog.filter.tag_list'  : catalog_filter_changed,
        'catalog.filter.time'      : oninput_funcs['catalog.filter.list_str'],
        'catalog.filter.time_creation' : 'catalog.filter.time',
        'catalog.filter.time_str'  : 'catalog.filter.time',
        'catalog.filter.list'      : 'catalog.filter.time',
        'catalog.filter.watch_list_str' : 'catalog.filter.time',
//        'catalog.filter.attr_list' : catalog_filter_changed,
//        'catalog.filter.attr_list_str' : catalog_filter_changed,
//        'catalog.filter.attr_list' : show_catalog, //catalog_attr_changed,
//        'catalog.filter.attr_list_str' : show_catalog, //catalog_attr_changed
        'catalog.filter.attr_list' : catalog_attr_changed,
//        'scan'                     : scan_tags,
        'scanBoardIf': function(e){onchange_funcs.scanBoard(e,false,true);},
        'scanSiteIf': function(e){onchange_funcs.scanSite(e,false,true);},
        'scanBoard' : function(e, from_auto, required_only){if (!from_auto && pref.common.clear_at_manual_scan) onchange_funcs.clear_threads();scan.keyword_load_1(site.nickname,required_only? 2:true,[site.board], health_indicator);},

        'scanSite' : function(e, from_auto, required_only){if (!from_auto && pref.common.clear_at_manual_scan) onchange_funcs.clear_threads();scan.keyword_load(required_only? 2:true, health_indicator);},
        'catalog.order.reply_to_me' : re_sort_thread,
        'catalog.order.reply'       : re_sort_thread,
        'catalog.order.watch'       : re_sort_thread,
        'catalog.order.sticky'      : re_sort_thread,
//        'catalog.filter.tag_ci'     : function(){scan_tags_init(scan_tags_common_c(site3[site.nickname].tags,'')[0], null);},
        'catalog.filter.time_quick_sel': function(){
          var time = [0,0,1,2,4,12,24,72,168][this.selectedIndex]*3600000;
          ago_clicked(null, time);
        },
        'catalog.filter.tag_search.re': 'catalog.filter.tag_search.str',
        'catalog.filter.tag_search.show_nof_boards': liveTag.popup_filter.onchange_funcs['catalog.filter.tag_search.show_nof_boards'],
        'tagB.*': liveTag.cbx_all_onchange,
        'tag2bList': liveTag.add_tags_to_boardlist,
        __proto__: oninput_funcs,
      };
////      onchange_funcs.entry_func = (function(myself){ // working code.
////        return function(e){
////          pref_func.apply_prep(this,true);
////          var this_name = this.getAttribute('name'); // for <span>
////          if (myself[this_name]) myself[this_name].call(this,e);
////          else if (this_name.indexOf('.')!=-1 && this_name.substr(0,this_name.indexOf('.'))===embed_mode) {
////            var name = this_name.substr(this_name.indexOf('.')+1);
////            if (myself[name]) myself[name].call(this,e);
////          }
////        }
////      })(onchange_funcs);
      window.addEventListener('beforeunload', window_beforeunload, false);
      oninput_funcs = pref_func.add_onchange_format(oninput_funcs);
      onchange_funcs = pref_func.add_onchange_format(onchange_funcs);
      pref_func.add_onchange(pn12_0_2,onchange_funcs, oninput_funcs); // causes 1 leak.
      cataLog.event_func = pref_func.add_onchange(pn12_0_4,onchange_funcs, oninput_funcs); // causes 1 leak.
//console.log('init_onchange');
      window.addEventListener('storage', site2[site.nickname].prep_own_posts_event, false);
//      site2[site.nickname].prep_own_posts();
      site2[site.nickname].check_reply.make_own_posts(); // prevent from calling twice.
      function window_beforeunload() {
        if (pref.catalog.auto_save_filter && embed_mode!=='thread') onchange_funcs.save();
        window.removeEventListener('beforeunload', window_beforeunload, false);
      }
      if (initialize_loop && pref.virtualBoard.scan && embed_mode!=='thread')
        setTimeout(function(){scan.keyword_load(false, health_indicator);}, pref.virtualBoard.scanDelay*1000);
      
      var pn_setting = pn12_0_4.childNodes[0];
      var triage_parent;
      triage_parent_set();
      function triage_parent_set(){
        triage_parent = (embed_embed)? site2[site.nickname].catalog_get_native_area() : pn12_1;
        cataLog.parent = triage_parent;
      }
      cataLog.triage_parent_set = triage_parent_set;
//      if (pref.catalog.auto_load_filter) onchange_funcs.load();
      onchange_funcs.catalog_board_list_sel(null,true);

      var tags_scan_regex = new RegExp('#[^#, \.:;\n]+(?=#|,| |\.|:|;|\n|$)','g'); // ATTENTION. REFER function prep_tag_str(); // AND ALSO IN scan_tag_obj.
      var scan_boards = (function(){
//        var scan_button   = pn12_0_4.getElementsByTagName('button')['scanSite'];
////////        var scan_boards   = {args:{}, crawler_timer:null, pool:null};
        var scan_boards   = {args:{}, pool:null};
////////        var scan_progress = (function(){
////////          var elem = pn12_0_4.getElementsByTagName('span')['scan_progress'];
////////          var timer = null;
////////          var str = '';
////////          function show(){elem.innerHTML=str; timer=null;}
////////          return function(s){str=s; if (timer===null) timer = setTimeout(show,100);};
////////        })();
////////        function keyword_load(key){ // working code.
////////          if (scan_boards_check_pre(key,true)) {
//////////            if (pref.common.clear_at_manual_scan && !keep) onchange_funcs.clear_threads();
////////            scan_button.innerHTML = 'Cancel';
////////            if (!site3[site.nickname].boards) {
////////              http_req.get(key,site.nickname,site2[site.nickname].url_boards_json(),scan_boards_keyword_callback,pref.scan.lifetime*60,true,key);
////////              scan_progress('Loading boards\' information');
////////            } else {
////////              var tgts = site2[site.nickname].enumerate_boards_to_scan(); // must remake to evaluate change of preference.
////////              scan_boards_init(key, tgts, {lifetime:pref.scan.lifetime*60, cache_write:true,
////////                                           callback:(pref.liveTag.use)? catalog_liveTag_scan_threads : null, callback_args:'scan'});
////////            }
////////          }
////////        }
        function scan_boards_check_pre(key){
          if (scan_boards.args[key]) {
            if (scan_boards.args[key].max != scan_boards.args[key].idx) {
              scan_boards.args[key].max = scan_boards.args[key].idx;
              if (scan_boards.args[key].indicator) scan_boards.args[key].indicator.report({abort_str:'canceled'});
            } else {
////////              if (scan_boards.args[key].crawler_watchdog) scan_boards.args[key].crawler_watchdog.stop();
////              crawler.watchdog.abort(key);
              if (scan_boards.args[key].indicator) scan_boards.args[key].indicator.report({abort_str:'aborted', end:Date.now()});
              delete scan_boards.args[key];
            }
            return false;
          } else return true;
        }
//        function scan_boards_keyword_init(key){
//          scan_boards_init(key, site3[site.nickname].boards,pref.catalog.filter.tag_scansite,pref.catalog.filter.tag_scansite,pref.scan.lifetime*60);
//          var obj = [];
//          obj.max_threads = pref.scan.max_threads;
//          var count = pref.scan.max;
//          for (var i in site3[site.nickname].boards) if (site3[site.nickname].boards[i].max) {
//            obj.push('/'+site3[site.nickname].boards[i].uri+'/');
//            if (--count==0) break;
//          }
//          scan_boards_init(key, obj, {lifetime:pref.scan.lifetime*60, cache_write:true});
//        }
        function scan_init(key,mem,args, multi_entry){
if (pref.debug_mode['5']) console.log('scan_init: '+key);
          if (!multi_entry && !scan_boards_check_pre(key,false)) return;
          if (!Array.isArray(mem)) mem = Object.keys(mem);
          if (mem.length==0) {
            if (args.callback) args.callback(args.callback_args);
            return;
          }
          scan_boards_init(key, mem, args);
        }
        scan_boards.args_proto = { // for httpd
          callback_1: function(req,value,REQ){
            scan_boards_keyword_callback2(req.key2||'',value,[null,REQ]); // req.key2||'' for over limit error.
          },
          get_tgt_func: function(req){
            if (req.IDX<req.max && (req.refresh || req.found_threads<req.max_threads)) {
              do {
                var tgt = scan_boards_keyword_make_tgt(req,req.IDX++);
              } while (req.IDX<req.max && (!tgt || (pref.catalog.board.ex_list && pref_func.merge_obj5(tgt,pref.catalog.board.ex_list_obj2,{hit:false}).hit)));  // 'if (tgt)' is for tgts_iterator
              if (req.IDX<=req.max) {
                var archived = scan.list_nup.issued(tgt);
                var dbt = common_func.name2dbt(tgt);
                var url = site2[dbt[0]].make_url4(dbt);
                var key2 = dbt.join(',');
                return {REQ:req, url:url[0], responseType:(archived)? 'text' : (url[1]==='html')? 'document' : url[1], tgt:tgt, key2:key2, data_type:url[1], domain:dbt[0]};
              }
            }
          },
          callback: function(req){
            if (req.found_threads>=req.max_threads) req.INDICATOR.report({err_str:'Aborted.(Reached upper limit)'});
            delete scan_boards.args[req.key];
            if (Object.keys(scan_boards.args).length==0) scan_boards.pool = null;
            if (req.callback2) req.callback2(req.callback_args);
          },
          init_func: function(req){
            Object.defineProperty(req,'idx',{get:function(){return this.IDX;}, configurable:true}); // for test.
            Object.defineProperty(req,'indicator',{get:function(){return this.INDICATOR;}, configurable:true}); // for test.
            Object.defineProperty(req,'tgts',{get:function(){return this.obj;}, configurable:true}); // for test.
            Object.defineProperty(req,'initiator',{get:function(){return this.key;}, configurable:true}); // for test.
            if (req.hasOwnProperty('callback')) {
              req.callback2 = req.callback;
              delete req.callback;
            }
          },
        };
        scan_boards.args_proto.callback_1_fail = scan_boards.args_proto.callback_1;
        function scan_boards_init(key, obj, args){
          if (!scan_boards.pool) scan_boards.pool = {
            div: document.createElement('div'), parser: new DOMParser(), doc: null, ths: null, dbt: null, tgts: null, tags:{cs:{}, ci:{}},
            name:null, sticky:null, type:null, wrapper_obj:null};
  //        var obj = site3[site.nickname].boards;
          scan_boards.args[key] = {
                key: key,
                idx: 0,
//                max: (obj.length>pref.scan.max)? pref.scan.max : obj.length,
                max: obj.length,
//                max_threads: (obj.length>pref.scan.max)? obj.length : pref.scan.max,
                max_threads: pref4.scan.max_threads,
                found_threads: 0,
                found_boards: 0,
                scanned: 0,
////////                error: '',
//                error_obj: {},
                crawler: 0,
////////                crawler_max : pref.scan.crawler,
                obj: obj,
//                scan_tag: pref.catalog.filter.tag_scansite,
//                store_tag: pref.catalog.filter.tag_scansite,
                lifetime: 0,
                cache_write: false,
                callback : null,
                callback_args : null,
                pool: scan_boards.pool,
                refresh: null,
                indicator: null,
                tgt_raw: false,
                watchdog: null,
////////                spawn_crawler: function(){scan_boards_spawn_crawler(key);},
////////                crawler_watchdog: null,
                from_auto: null,
                load_on_demand: null,
//                tag_only: null,
                senders_returned:[],
                priority: 0,
                tgts_iterator: null,
            __proto__: scan_boards.args_proto
          };
          for (var i in args) scan_boards.args[key][i] = args[i];
          var sb = scan_boards.args[key];

          if (sb.load_on_demand && !sb.tgts_iterator) {
////            sb.max = 1; // working code.
////            for (var i=obj.length-1;i>=1;i--) {
////              var name = 'ODL:'+ sb.obj[i];
////              var idx = threads_idx.indexOf(name);
////              if (idx!=-1) threads_idx.splice(idx,1);
////              threads_idx.unshift(name);
////            }
            for (var i=0;i<sb.obj.length;i++) {
              var tgt = scan_boards_keyword_make_tgt(sb,i);
              var dbt = common_func.name2domainboardthread(tgt,true);
              if (dbt[2].search(/[cjpq][1-9]/)===0) {
                threads_index.idx_insert_odl(tgt);
                sb.obj.splice(i--,1);
              }
            }
            if (sb.obj.length===0) {
              if (sb.indicator) sb.indicator.remove();
              if (sb.callback) {
                var func = sb.callback
                var args = sb.callback_args;
              }
              delete scan_boards.args[sb.key];
              return (func)? func(args) : undefined;
            } else {
              if (load_on_demand.get()) sb.callback = (sb.callback)? (function(func_old){return function(){load_on_demand.release();func_old();}})(sb.callback) : load_on_demand.release; // First access may not have mutex.
              sb.max = sb.obj.length;
              drawn_idx = 0;
            }
          }

          scan_boards.args_proto.init_func(sb);
          httpd.req(sb, (sb.priority<7)? sb.priority+1 : 1); // patch
          
////          if (!sb.indicator) sb.indicator = health_indicator.shift('limegreen','r',sb.key,sb.priority); // working code.
////          sb.indicator.report({start:Date.now(), prog:sb}); // make reference loop.
////          while (sb.crawler<pref.scan.crawler) {
////////////            scan_boards_spawn_crawler(key, true);
////            crawler.spawn(key, true);
////            if (pref.scan.crawler_adaptive) break;
////          }
        }
////        var crawler = { // working code.
////          key: null,
////          priority: 0,
////          num: 0, // dangerous, may hang up, all crawlers must be returned.
////          wdg_spawn: null,
////          spawn_req: function(sb){
////            this.clear_req(sb);
////            if (sb.priority>=this.priority) {
////              if (this.num<pref.scan.crawler || sb.priority>this.priority) {
////                this.wdg_spawn.start(pref.scan.crawler_idle_time_to_spawn);
////                this.key = sb.key;
////                this.priority = sb.priority;
////              }
////            }
////          },
////          spawn: function(key, init){
////            var sb = scan_boards.args[(key || this.key)]; // not to keep greping 'sb' object, 'key' and 'priority' are primitives.
////            if (sb && sb.idx<sb.max) {
////              var sender = (sb.senders_returned.length>0)? sb.senders_returned.shift() : sb.key+':'+sb.crawler;
////              sb.crawler++;
////              this.num++;
////              this.watchdog.add(sb, sender);
////              if (pref.debug_mode['5']) console.log('crawler_spawn: '+sender+'/'+sb.crawler);
////              scan_boards_keyword([sender,sb],200);
////              if (!init && !pref.scan.crawler_adaptive) this.spawn_req(sb);
////            }
////          },
////          clear_req: function(sb){
////            if (sb.priority>=this.priority) this.wdg_spawn.stop();
////          },
////          check_priority: function(sb, sender){
////            if (sb.priority>=this.priority || sb.crawler==1) return true;
////            else {
////              this.finish(sb, sender);
//////              sb.senders_returned.push(sender);  // THIS CAUSED A BUG,
////                                                   // crawler with status 1200(now changed to -200) call 'finish' immediately,
////                                                   // but this is respawned and causes multiple call of 'watchdog.add'.
////                                                   // For easy debug, this was moved to 'finish'.
////              return false;
////            }
////          },
////          finish: function(sb, sender){
////            this.clear_req(sb);
////            http_req.close(sender);
////            this.watchdog.end(sender);
////            sb.senders_returned.push(sender); // shold be here, but slightly redundant for end.
////            sb.crawler--;
////            this.num--;
////            if (pref.debug_mode['5']) console.log('crawler_finish: '+sender+'/'+sb.crawler);
////          },
////          finish_all: function(sb){
////            this.priority = 0;
////            if (Object.keys(scan_boards.args).length==0) this.reset(); // for safety.
////            else for (var key in scan_boards.args) if (scan_boards.args[key].senders_returned.length>0) this.spawn(key);
////          },
////          reset: function(){
////            this.num = 0;
////            this.watchdog.reset();
////          },
////          watchdog: {
////            list: [],
////            sbs: Object.create(null),
////            add: function(sb,sender){
////              this.list.push(sender);
////              this.sbs[sender] = sb;
////              if (this.list.length===1) this.wdg.start();
////            },
////            end: function(sender){
////              this.report_alive(sender);
////              delete this.sbs[sender];
////              this.list.splice(this.list.indexOf(sender),1);
////              if (this.list.length===0) this.wdg.stop();
//////              else this.wdg.restart(); // this is redundant because report_alive exists before
////            },
////            wdg: null,
////            report_alive: function(sender){
////              if (sender===this.list[0]) {
////                this.list.push(this.list.shift());
////                this.wdg.restart();
////              }
////            },
////            respawn: function(){
////              var sender = this.list[0];
////              var sb = this.sbs[sender];
////              if (pref.debug_mode['7']) console.log('crawler_respawn: '+sender+'/'+((sb)?sb.crawler:'undefined'));
////              scan_boards_keyword([sender,sb],200);
////              this.report_alive(sender);
////            },
////            reset: function(){
////              this.list = [];
////              this.sbs = Object.create(null);
////              this.wdg.stop();
////            },
////            abort: function(key){
////              for (var i=this.list.length-1;i>=0;i--) if (this.list[i].indexOf(key+':')===0) this.end(this.list[i]);
////            },
////          },
////          priority_up: null,
////          priority_release: null,
////          priority_wdg: null,
////          priority_count: 0,
////        };
////        crawler.wdg_spawn = new Watchdog(crawler.spawn.bind(crawler), 100);
////        crawler.watchdog.wdg = new Watchdog(crawler.watchdog.respawn.bind(crawler.watchdog), 30000);
////        crawler.priority_up = function(p){
////                                this.priority = p;
////                                this.priority_count++;
////                                this.priority_wdg.start();
////                              }.bind(crawler);
////        crawler.priority_release = function(){
////                                     if (--this.priority_count<=0) {
////                                       this.priority=0;
////                                       this.priority_wdg.stop();
////                                     } else this.priority_wdg.restart();
////                                   }.bind(crawler);
////        crawler.priority_wdg = new Watchdog(crawler.priority_release, 10000);

////////        function scan_boards_spawn_crawler_timer(sb){ // working code.
////////          scan_boards_crawler_timer_clear();
////////          if (sb.crawler<sb.crawler_max) scan_boards.crawler_timer = setTimeout(sb.spawn_crawler, pref.scan.crawler_idle_time_to_spawn);
////////        }
////////        function scan_boards_spawn_crawler(key, init){
////////          var sb = scan_boards.args[key];
////////          if (pref.debug_mode['5']) console.log('crawler_spawn: '+sb.key+', '+(sb.crawler+1));
////////          scan_boards_keyword([sb.key+sb.crawler++,sb],200);
////////          if (!init && sb.idx<sb.max) scan_boards_spawn_crawler_timer(sb);
////////        }
////////        function scan_boards_crawler_timer_clear(){
////////          if (scan_boards.crawler_timer!==null) {
////////            clearTimeout(scan_boards.crawler_timer);
////////            scan_boards.crawler_timer=null;
////////          }
////////        }
////////        var CrawlerWatchdog = function(sb){ // patch for 8chan's unstability.
////////          this.sb = sb;
////////          this.tgt = 0;
////////          this.db = new DelayBuffer(this.respawn.bind(this), 30000);
////////          this.db.delayed_do();
////////        }
////////        CrawlerWatchdog.prototype = {
////////          report_alive: function(kwd){
////////            if (!this.sb) return; // stopped already
////////            var me = kwd.substr(this.sb.key.length);
////////            if (this.tgt==me) {
////////              this.tgt = (this.tgt<this.sb.crawler-1)? this.tgt+1 : 0;
////////              this.db.cancel();
////////              this.db.delayed_do();
////////            }
////////          },
////////          respawn: function(){
////////            if (this.sb.idx<this.sb.max) {
////////              if (pref.debug_mode['7']) console.log('crawler_respawn: '+this.sb.key+this.tgt+'/'+this.sb.crawler);
////////              scan_boards_keyword([this.sb.key+this.tgt,this.sb],200);
////////              this.report_alive(this.sb.key+this.tgt);
////////            } else {
////////              if (pref.debug_mode['7']) console.log('crawler_respawn: '+this.sb.key+this.tgt+'/'+this.sb.crawler+', stopped.');
////////              this.stop();
////////            }
////////          },
////////          stop: function(){
////////            this.db.cancel();
////////            this.sb = null; // release pointer
////////          }
////////        }
        function scan_boards_keyword_make_tgt(sb,idx){
          var tgt = (sb.tgts_iterator)? sb.tgts_iterator.next().value : sb.obj[idx];
          if (tgt && typeof(tgt)!=='string') {
            var force_json = tgt.u&0x0080;
            tgt = tgt.key;
          }
          var dbt;
          if (tgt) dbt = cnst.name2domainboardthread(tgt,true);
          return (!tgt)? tgt:
                 (sb.tgt_raw)? tgt :
                 (dbt[2]==='')? tgt + ((pref.catalog.catalog_json | force_json)? 'j0' : 'c0') :
                 (pref.catalog.catalog_json && dbt[2][0].search(/[0-9]/)!=-1)? dbt[0]+dbt[1]+'t'+dbt[2] : tgt;
        }
////        function scan_boards_keyword(args,status){ // working code.
////          var sender = args[0];
////          var sb = args[1];
////          crawler.watchdog.report_alive(sender);
////          if (sb.watchdog) sb.watchdog();
////          if (pref.scan.crawler_adaptive) if (!crawler.check_priority(sb,sender)) return;
////////////          if (sb.crawler_watchdog) sb.crawler_watchdog.report_alive(sender);
//////if (pref.debug_mode['5']) console.log('request_entry: '+sb.idx+'/'+sb.max+', '+sb.found_threads+'/'+sb.max_threads+', '+status);
////if (pref.debug_mode['5'] && sb.idx!=0 && sb.idx%1000==0) console.log('request_progress: '+sb.key+', '+sb.idx+'/'+sb.max+', '+sb.found_threads+'/'+sb.max_threads+', '+status);
////          if (sb.idx<sb.max && (sb.refresh || sb.found_threads<sb.max_threads) && status<500) {
////            var tgt = scan_boards_keyword_make_tgt(sb,sb.idx);
////            sb.idx++;
////////////            scan_progress(sb.found_threads+'/'+sb.scanned+', '+sb.found_boards+'/'+sb.idx+'/'+sb.max+', ' + tgt);
////            if (tgt && (!pref.catalog.board.ex_list || !pref_func.merge_obj5(tgt,pref.catalog.board.ex_list_obj2,{hit:false}).hit)) { // 'if (tgt)' is for tgts_iterator
////              if (sb.indicator) sb.indicator.report({tgt:tgt});
////              http_req.get(sender,tgt,'',scan_boards_keyword_callback2,sb.lifetime,sb.cache_write,args, scan.list_nup.issued(tgt));
////////////              if (sb.idx<sb.max && pref.scan.crawler_adaptive) scan_boards_spawn_crawler_timer(sb);
////              if (pref.scan.crawler_adaptive) crawler.spawn_req(sb);
////            } else scan_boards_keyword(args,200);
////          } else {
////            crawler.finish(sb, sender);
////////////            http_req.close(sender);
////            if (sb.crawler===0) {
////////////              if (pref.scan.crawler_adaptive) scan_boards_crawler_timer_clear();
////////////              if (sb.crawler_watchdog) sb.crawler_watchdog.stop();
////////////              var prog_str = sb.found_threads+'/'+sb.scanned+', '+sb.found_boards+'/'+sb.max
////////////                            + '<span style="color:red">'
////////////                            +( (sb.error!=='')? ', Error at loading '+sb.error :
////////////                              ((!sb.refresh && sb.found_threads>=sb.max_threads)? ', Aborted.(Reached upper limit)' : ''))
////////////                            + '</span>';
////////////              scan_progress(prog_str);
//////              sb.max = sb.idx;
//////              if (sb.key==='scan') scan_button.innerHTML = 'scanSite';
////if (pref.test_mode['22']) {
////              if (sb.store_tag) {
////  //console.log(new Date());
////  //              scan_tags_init(sb.pool.tags);
////                var ret_obj = scan_tags_common_b(sb.pool.tags,'',site3[site.nickname].tags);
////                site3[site.nickname].tags = ret_obj[1];
////                scan_tags_init(ret_obj[0],true);
////  //              sb.pool.div.innerHTML = '';
////  //console.log(new Date());
////              }
////}
//////              sb = null;
////              if (sb.indicator) {
////////////                var keys = Object.keys(sb.error_obj);
////////////                if (keys.length==0) sb.indicator.set(null,'\u25cf');
////////////                else if (keys.length>=sb.max) sb.indicator.set('red','X');
////////////                else sb.indicator.set(null,'\u25b2');
////                if (sb.found_threads>=sb.max_threads) sb.indicator.report({err_str:'Aborted.(Reached upper limit)'});
////                sb.indicator.report({end:Date.now()});
////              }
////              delete scan_boards.args[sb.key];
////if (pref.debug_mode['5']) console.log('scan_boards_end: '+sb.key+', Running:'+Object.keys(scan_boards.args));
////              crawler.finish_all(sb);
////              if (Object.keys(scan_boards.args).length==0) scan_boards.pool = null;
////              if (sb.callback) sb.callback(sb.callback_args);
////            }
////          }
////        }

        cataLog.scan_boards_keyword_callback2_default_args = {refresh:true, found_threads:0, get max_threads(){return pref4.scan.max_threads;}, found_board:0, scanned:0};
        var threads_meguca = {};
        function scan_boards_keyword_callback2(key,value,args, insert_thread_from_native){ // requires snoop and on demand rendering for merge.
////////  if (pref.scan.crawler_adaptive) scan_boards_crawler_timer_clear();
          var sb = args[1];
          var dbt = key.split(',');
////          if (pref.scan.crawler_adaptive) crawler.clear_req(sb);
          if ((value.status==200 || value.status==304) && value.response && sb.found_threads<sb.max_threads) { // Checking 'value.response' is a patch for 8chan's inconsistency, 8chan sometimes return 200 with null. // checking 304 is a patch.
if (dbt[0]==='meguca1' && dbt[3]==='catalog_json') { // PATCH FOR MEGUCA
            for (var i=0;i<value.response.length;i++) {
//              threads_meguca[dbt[1]+value.response[i]] = {page:parseInt(i/10) +'.'+ i%10, refresh:sb.refresh};
              liveTag.mems.init({domain:dbt[0], board:dbt[1], no:value.response[i]});
              threads_meguca[dbt[1]+value.response[i]] = {page:parseInt(i/10) +'.'+ i%10, refresh:sb.refresh || threads_meguca[dbt[1]+value.response[i]] && threads_meguca[dbt[1]+value.response[i]].refresh}; // patch.
              scan.list_nup.add(dbt[0]+dbt[1]+value.response[i], sb.priority);
//              if (pref.liveTag.use) scan.list_nup.add_board(dbt[0]+dbt[1], value.date);
            }
            scan.list_nup.got_200_board(dbt[0]+dbt[1]);
} else {
            var tgts = {};
            var parse_options = (dbt[3]==='thread_html' || dbt[3]==='thread_json')? {thread:dbt[2]} : {page:dbt[2]};
            if (sb.localArchive) {
              parse_options.localArchive = sb.localArchive;
              parse_options.page = sb.page;
            }
            var ths = site2[dbt[0]].wrap_to_parse.get(value.response, dbt[0], dbt[1], dbt[3], parse_options);
            if (sb.localArchive) {
              for (var i=0;i<ths.length;i++) ths[i].key = ths[i].key.substr(0,ths[i].key.lastIndexOf('/')+1) + ths[i].posts[0].no;
              if (ths.length===1) dbt[2] = ths[0].posts[0].no;
            }
            if (sb.force_annotate) { // for reentry in meguca.
              for (var i=0;i<ths.length;i++) if (threads[ths[i].key] && ths[i].pn && threads[ths[i].key][0]!==ths[i].pn) {
                threads[ths[i].key][0] = ths[i].pn;
                threads[ths[i].key][1] = true;
                insert_thread_format_th_pn(threads[ths[i].key], true, true, true, ths[i]);
//                threads[ths[i].key][24] = prep_footer3(ths[i]);
                threads[ths[i].key][16].posts = ths[i].posts;
              }
            }
            sb.scanned += ths.length;
if (pref.test_mode['22']) {
            var tgt_pn = sb.pool.div;
            var from_catalog = dbt[3]==='catalog_json' || dbt[3]==='catalog_html';
            var filter_active = pref.catalog.filter.kwd.active || (pref.catalog.filter.tag && filter_tags.length!=0);
} else {
//            var filter_active = pref.catalog.filter.kwd.active || (pref.catalog.filter.tag && pref.liveTag.use && liveTag.active.in);
//            var filter_active = pref.catalog.filter.kwd.active || (pref.catalog.filter.tag && liveTag.active.in); // for passive but don't use.
            var filter_active_kwd = pref.catalog.filter.kwd.active;
            var filter_active_tag = pref.catalog.filter.tag && liveTag.active.in; // for passive
}
////            var from_json = dbt[3].indexOf('_json')!=-1;
            var refresh = sb.refresh;
            if (dbt[0]==='meguca1' && dbt[3]==='thread_json') { // PATCH FOR MEGUCA
              var tgt_th_meguca = threads_meguca[dbt[1]+dbt[2]];
              if (tgt_th_meguca!== undefined) {
                refresh = tgt_th_meguca.refresh;
                ths[0].page = tgt_th_meguca.page;
                delete threads_meguca[dbt[1]+dbt[2]];
              }
            }
            var post_updated_static = pref.liveTag.from==='post' || pref.stats.use || pref[embed_mode].deleted_posts.detect.indexOf('full')===0 ||
                pref[embed_mode].storePosts==='ALL_agg' || site2[dbt[0]].parse_funcs[dbt[3]].has_editing && (embed_mode==='page' || embed_mode==='thread');
//            var post_updated_static = pref.liveTag.from==='post' || pref.stats.use || pref[embed_mode].deleted_posts.detect==='full';
            var pf_store = (pref[embed_mode].storePosts==='ALL_agg' || pref[embed_mode].storePosts==='auto' && pref4.search_posts_active_once)? 'ALL' : pref[embed_mode].deleted_posts.detect;
            for (var i=0;i<ths.length;i++) {
              var th = ths[i];
              if (!th.no) continue; // PATCH for a bug in 4chan, 4chan returns invalid data.
              th.time_loaded = value.date;
              if (sb.native_prep) th.native_prep = true;
if (pref.test_mode['33'] && dbt[0]==='meguca1' && dbt[3]==='thread_json') {scan.list_nup.got_200(th);continue;}
if (pref.test_mode['22']) {
              if (sb.scan_tag && from_catalog) {
                if (th.type_data==='json') tgt_pn.innerHTML = th.name + '\n' + th.sub + '\n' + th.com;
                else tgt_pn = th.pn;
                th.tags = tgt_pn[brwsr.innerText].match(tags_scan_regex);
              }
} else {
//var tmp_len = Object.keys(scan.list_nup).length;
//if (tmp_len!=0 && tmp_len%100===0) console.log('len: '+tmp_len);
////////              if (pref.liveTag.use) {
//              var mems_exist = liveTag.mems.exist(th);
              var lth = liveTag.prep_tags(th); // extract tags in op. // editing tags are updated in this.
              th.tags = lth;
              var watch = lth[2];
              var tgt_th = threads[th.key];
              var tag_updated = (tgt_th)? undefined : th.tags; // force new thread to add tags
              var post_updated = (post_updated_static || (watch[0]&0x002c0000))? false : null; // archiving or watching
//              var post_updated = (post_updated_static || (watch[0]&0x000c0000))? false : null;

              if (lth.ed_t && th.parse_funcs.has_posts) { // lth.ed_t is created only when th.parse_funcs.has_editing is true. lth.ed_t is shared even if pref.liveTag.from!=='post'
                var ed_f = [];
                tag_updated = liveTag.update_tags_in_editing_posts(th, lth, ed_f) || tag_updated; // lth.ed_t is updated here. 
                if (ed_f.length===0) ed_f = null;
              }
//              if (th.parse_funcs.has_editing && th.parse_funcs.has_posts) {
//                var ed_p = lth.ed_p || lth.ed_t; // share lth.ed_t when pref.liveTag.from==='post'
//                if (ed_p) {
//                  var ed_f;
//                  var posts_obj = th.parse_funcs.posts_obj(th,ed_p[ed_p.length-1].no);
//                  for (var j=ed_p.length-1;j>=0;j--) {
//                    var post = posts_obj[ed_p[j]]; // post may be a tag.
//                    if (post && !post.editing) {
//                      if (ed_f) ed_f[ed_f.length] = post;
//                      else ed_f = [post];
//                      //// CODE FOR UPDATING ARCHIVES SHOULD BE HERE.
//                      //// CODE FOR UPDATING POSTS CAN BE HERE.
//                      if (lth.ed_p) {
//                        if (lth.ed_p.length!==1) lth.ed_p.splice(j,1);
//                        else lth.ed_p = null;
//                      }
//                    }
//                  }
//                  if (lth.ed_t) tag_updated = liveTag.update_tags_in_editing_posts(th, lth, posts_obj) || tag_updated; // lth.ed_t is updated here.
//                }
//              }

//              if (liveTag.mems[dbt[0]][dbt[1]] && liveTag.mems[dbt[0]][dbt[1]].f) scan.list_nup.add(th.key, sb.priority); // use dbt[0] instead of th.domain for /popular/
              if (lth.q && lth.q.waiting && th.parse_funcs.has_posts) site2[th.domain].popups_fetched(th, lth);
              var updated = null;
              var archive_store = (lth.archived || pf_store!=='no') && (!pref.test_mode['67'] && !sb.localArchive);
              var pf_store_th = tgt_th && tgt_th[16].get_t2h_num_of_posts() || 'no';
              var pf_store_1 = (pf_store==='ALL' || pref[embed_mode].storePosts==='ALL' && tgt_th)? -1
                  : (pf_store==='no' || pf_store==='passive' && pf_store_th!=='no')? pf_store_th : pf_store;
              if (post_updated!==null && (lth.nof_posts<th.nof_posts || (watch[0]&0x00060000))) { // watch req || retag req
//              if (post_updated!==null && (lth.nof_posts<th.nof_posts || watch[3]<0)) { // watch[3]<0 is a patch for retag.
//if (th.parse_funcs.has_posts && th.last_replies) console.log(th.key+', '+th.last_replies.length+', '+th.nof_posts+', '+lth.nof_posts);
//                if (pref.debug_mode.unread_count===th.key) console.log('uc: watch[0]='+lth.nof_posts+', nof_posts='+th.nof_posts);
                if (th.type_source==='thread' || 
//                    (th.parse_funcs.has_posts && th.last_replies && th.last_replies.length>=th.nof_posts-lth.nof_posts) ||
                    (th.parse_funcs.has_posts && th.posts.length>th.nof_posts-lth.nof_posts && (lth.ta || pref[embed_mode].deleted_posts.detect.indexOf('full')!==0)) ||
                    (th.nof_posts===1 && th.posts[0].time>=0 && !th.parse_funcs.dont_have_com)) {
                  post_updated = true;
                  updated = site2[th.domain].check_reply.check(th, watch, tgt_th, sb.ext_posts || []); // dive in at the first time if page_html contains all posts. sb.ext_posts for embed_mode==='thread'.
                  tag_updated = updated.tags || tag_updated;
                  scan.list_nup.got_200(th); // patch for 8chan. 8chan has an inconsistensy between catalog and threads,
                                             // some threads which are there in catalog sometimes returns 404 if it gets as a thread.
                                             // However, 8chan doesn't return 404, but fails at send(null), so system like watchdog is required.
//                  if (pref.debug_mode['3']) console.log('Check tags: '+th.key+', '+lth.nof_posts);
                  if (pref.threadStats.use && site2[th.domain].stats_ID && (refresh || tgt_th)) if (site2[th.domain].stats_ID(th, updated.posts, lth)) scan.list_nup.add(th.key, 0);
                  if (archive_store) archiver.store(value, th, lth, updated.posts, updated.time_check_old, pf_store_1, ed_f);
                } else { // if (!(th.parse_funcs.has_posts && !th.last_replies))
                  scan.list_nup.add(th.key, sb.priority);
//                  if (pref.debug_mode['3']) console.log('Schedule to check tags: '+th.key+', '+lth.nof_posts);
                  if (ed_f && archive_store) archiver.store(value, th, lth, undefined, undefined, pf_store_1, ed_f);
                }
              } else {
                if (!sb.localArchive) scan.list_nup.got_200(th);
                if (pref.threadStats.use && site2[th.domain].stats_ID && (refresh || tgt_th)) site2[th.domain].stats_ID(th, null, lth);
//                  if (lth.nof_posts==th.nof_posts || !pref.network.fetch_actively || // only active when count is changed,
//                      // 'th.parse_funcs.missing_info' doesn't have state if the thread is not stored(tgt_th===undefined),
//                      //and all members will be fetched forever.
//                    ((tgt_th)? !tgt_th[23] || th.type_source==='thread' : !th.parse_funcs.missing_info)) scan.list_nup.got_200(th); // for threads which doesn't have posts.
//                  else th.parse_funcs.missing_info_fetch(th);
////                if (th.parse_funcs.has_editing) updated = {posts:th.posts.slice(lth.nof_posts || 0)}; // BUG, REDUNDANT.
                if ((lth.rescan_dp || lth.force_ar || ed_f || lth.nof_posts!=th.nof_posts && th.parse_funcs.has_posts) && archive_store)
                  archiver.store(value, th, lth, undefined, undefined, pf_store_1, ed_f); // for initial if watched already // BUG!!! THIS DOESN'T WORK IF 304 IS RETURNED. // changed from 'lth.nof_posts<th.nof_posts'.
////                if (lth.nof_posts!=th.nof_posts)
////                  if(!th.parse_funcs.has_editing || th.parse_funcs.has_posts || embed_mode==='catalog') lth.nof_posts = th.nof_posts; // to get updated in next loop. // BUG, REDUNDANT.
                if (lth.nof_posts!=th.nof_posts) lth.nof_posts = th.nof_posts;
              }
////////              }
              if (th.parse_funcs.has_editing) {
                if (updated && pref.liveTag.from!=='post') { // share lth.ed_t always
                  var ed_p = undefined;
                  for (var j=0;j<updated.posts.length;j++) // update is reverse ordered.
                    if (updated.posts[j].editing && updated.posts[j].no!=th.no)
                      if (ed_p) ed_p[ed_p.length] = updated.posts[j];
                      else ed_p = [updated.posts[j]];
                  if (ed_p) {
                    lth.ed_t = (lth.ed_t)? ed_p.concat(lth.ed_t) : ed_p;
                    if (pref.debug_mode['24']) console.log(th.key+ ': lth.ed_t: '+ lth.ed_t.map(function(v){return (typeof(v)==='string')? v : v.no+'('+v.time+')';}));
                  }
                }
//                if (updated && pref.liveTag.from!=='post') { // share lth.ed_t when pref.liveTag.from==='post'
//                  var ed_p = undefined; // ed_p is used previously, so it must be cleared.
//                  for (var j=0;j<updated.posts.length;j++) // update is reverse ordered.
//                    if (updated.posts[j].editing)
//                      if (ed_p) ed_p[ed_p.length] = updated.posts[j];
//                      else ed_p = [updated.posts[j]];
//                  if (ed_p) lth.ed_p = (lth.ed_p)? ed_p.concat(lth.ed_p) : ed_p;
//                }
//                if (updated) for (var j=updated.posts.length-1;j>=0;j--) // update is reverse ordered.
//                  if (updated.posts[j].editing)
//                    if (lth.ed_p) lth.ed_p[lth.ed_p.length] = updated.posts[j].no;
//                    else lth.ed_p = [updated.posts[j].no];
                if (th.type_source==='catalog' && (lth.ed_p || lth.ed_t) && (lth.archived || pref[embed_mode].t2h_sel!=='no' && tgt_th) &&
                  lth.ed_u<th.replyTime) scan.list_nup.add(th.key, sb.priority);
//                if (th.type_source==='catalog' && embed_mode!=='catalog' && tgt_th &&
//                  (tgt_th[16].needs_update<th.replyTime || tgt_th[16].needs_update===null))) scan.list_nup.add(th.key, sb.priority);
//                if (th.type_source==='catalog' && embed_mode!=='catalog' && tgt_th && lth.ed_p) scan.list_nup.add(th.key, sb.priority);
              }
//              if (th.domain==='meguca' && th.type_source==='catalog' && embed_mode!=='catalog' && tgt_th && tgt_th[16].needs_update<th.logCtr) scan.list_nup.add(th.key, sb.priority);
}
if (pref.test_mode['32'] && dbt[0]==='meguca1' && dbt[3]==='thread_json') continue;
              if (lth.th) {
                if (!tgt_th) delete lth.th;
                else if (lth.th.parse_funcs.missing_info && (!th.parse_funcs.missing_info || th.parse_funcs.missing_info<lth.th.parse_funcs.missing_info)) {
                  if (lth.th.pn) th.pn = lth.th.pn;
                  lth.th = th;
                  // lth.th.posts SHOULD BE REDUCED HERE.
                }
              }
////              if (tgt_th) { // working code.
////                if (tgt_th[23]) {
////                  for (var p in tgt_th[23]) {
////                    if (p==='time_posted') {
////                      if (th.time_posted) {tgt_th[8][4] = th.time_posted; delete tgt_th[23][p];}
////                    } else if (p==='op_img_src_url') {
////                      if (th.parse_funcs.get_op_src) {tgt_th[16].op_img_src_url = th.parse_funcs.get_op_src(th); delete tgt_th[23][p];}
////                    }
////                  }
////                  if (Object.keys(tgt_th[23]).length===0) {
////                    tgt_th[23] = null;
//////                    if (missing_info[th.key]!==undefined) delete missing_info[th.key]
////                  }
////                }
////              }
              
              var pick_up_for_search = th.type_source==='thread' && pref[embed_mode].storePosts==='ALL_agg';
              var picked_up_by_kwd_filter = filter_active_kwd && catalog_filter_query_keyword.kwd(pref.catalog.filter.kwd, th.posts, th.domain, th);
              var picked_up_by_tag_filter = filter_active_tag && liveTag.search_by_tags(th.tags);
              var picked_up_by_filter = picked_up_by_kwd_filter || picked_up_by_tag_filter;
              var tgt_th_status = (tgt_th===undefined)? undefined : tgt_th[9][0];
//              var force_update = (tgt_th && (tgt_th[16].expand_posts || (th.type_source==='thread' && (tgt_th[16].needs_update===true || tgt_th[16].needs_update===1)))) || pick_up_for_search;
              var force_update = (tgt_th && (tgt_th[16].expand_posts || (th.type_source==='thread' && tgt_th[16].needs_update===true))) ||
                                 lth.ed_u<th.replyTime || pick_up_for_search;
//              var force_update = (tgt_th && (tgt_th[16].expand_posts || (th.type_source==='thread' &&
//                (tgt_th[16].needs_update===true || (tgt_th[16].needs_update<th.replyTime || tgt_th[16].needs_update===null))))) || pick_up_for_search;
//              if (refresh || (post_updated && tgt_th) || picked_up_by_filter || force_update) {
//              if (!sb.tag_only && (sb.refresh || (post_updated && tgt_th) || picked_up_by_filter)) {
//              if (!sb.tag_only && (sb.refresh || (filter_active && catalog_filter_query_scan(th.posts, th.tags)))) {
////////                if (insert_thread_with_test(th, dbt[3], value.date)) {// RUNS A REDUNDANT POST CHECK AT FIRST TIME....
              if (post_updated===null && tgt_th && (refresh || picked_up_by_filter)) {
//                if (post_updated===null && tgt_th) {
                var tgt_th8 = tgt_th[8];
                post_updated = !((((tgt_th8[0]>tgt_th8[4])? tgt_th8[0] : (tgt_th8[4] || tgt_th8[0])) >= ((th.time_bumped > th.time_posted)? th.time_bumped : (th.time_posted || th.time_bumped))) && // vichan has inconsistency in time between catalog.json and thread.json.
                                 tgt_th8[2]==th.nof_posts && tgt_th8[3]==th.nof_files) || th.type_source==='thread'; // pass thread to revise all of tgt_th[8]
              }
              if (post_updated || (refresh || picked_up_by_filter) && !tgt_th || force_update) {
//              if (post_updated || picked_up_by_filter || tgt_th_status===undefined || force_update) {
                if (!tgt_th) { // PATCH, WILL BE REMOVED BY CONSOLIDATING.
                  var pf_store_th_2 = tgt_th16_proto.get_t2h_num_of_posts.call({lth:lth}) || 'no';
                  if (pf_store!=='ALL' && (pf_store==='no' || pf_store==='passive' && pf_store_th_2!=='no'))
                    if (pf_store_1!==pf_store_th_2) archiver.store_th_to_mem(value, th,lth, pf_store_th_2, null);
                }
                if (pref[embed_mode].scroll_lock) show_catalog_scroll_lock.set();
                insert_thread(th, value.date, picked_up_by_kwd_filter, insert_thread_from_native && ths[i].pn); // '&& ths[i].pn' for reentry.
                tgts[th.key] = true;
                tgt_th = threads[th.key];
              } // else if (pref[embed_mode].load_on_demand) threads_index.idx_reorder(th.key); // place thread before ODL. // changed. // implementation is changed.
              sb.found_threads++;
              if (sb.from_auto && (!tgt_th_status && tgt_th[9][0])) notifier.appeared(th,tgt_th_status===undefined);
//              } // else if (pref[embed_mode].load_on_demand && tgt_th) threads_index.idx_reorder(th.key); // temporal, should be rewritten.  // place thread before ODL. // implementation is changed.
//              if (tgt_th_status!==undefined && tgt_th[16].expand_posts) insert_thread_format_html(th,th.key,false,false,th.type_data==='json'); // format_html.update_posts_in_page(th, th.key, true);
if (!pref.test_mode['31'])
              if (tgt_th) {
                if (th.page) tgt_th[14] = th.page;
                Footer.update(th.key, th.country && post_updated, (tgt_th_status!==undefined)? tag_updated : th.tags);
              }
//              if (tgt_th) insert_footer3(th.key,(post_updated)? th.flags:null, th.page, (tgt_th_status!==undefined)? tag_updated : th.tags, th);
//              if (pref.liveTag.use && i===0) scan.list_nup.add_board(th.domain+th.board, (th.type_source==='catalog')? value.date : null);
//              if (th.tags.q && th.parse_funcs.has_posts) site2[th.domain].popups_fetched(th); // stored AFTER modifying pn. // BUT, posts are deleted sometimes.
            }
if (pref.test_mode['22']) {
            if (sb.scan_tag && from_catalog) tag_scan_board(ths, sb);
}
            if (dbt[3]==='catalog_json' || dbt[3]==='catalog_html') {
////              if (pref.liveTag.use) scan.list_nup.add_board(dbt[0]+dbt[1], value.date);
              scan.list_nup.got_200_board(dbt[0]+dbt[1]);
              rm_items_404_check(dbt[0],dbt[1],ths);
////              if (liveTag.mems[dbt[0]][dbt[1]] && liveTag.mems[dbt[0]][dbt[1]].f) { // 'liveTag.mems[dbt[0]][dbt[1]]' is for /popular/
////                for (var i=0;i<ths.length;i++) scan.list_nup.add(ths[i].key);
////                liveTag.mems[dbt[0]][dbt[1]].f = false;
////              }
//              if (liveTag.mems[dbt[0]][dbt[1]] && liveTag.mems[dbt[0]][dbt[1]].f) liveTag.mems[dbt[0]][dbt[1]].f = false; // 'liveTag.mems[dbt[0]][dbt[1]]' is for /popular/
            }
            if (pref.catalog_max_page_auto && (dbt[3]==='page_html' || (dbt[3]==='catalog_json' && site2[dbt[0]].parse_funcs[dbt[3]].get_max_page))) {
              var max_page = site2[dbt[0]].parse_funcs[dbt[3]].get_max_page(value.response);
              if (max_page) liveTag.mems[dbt[0]][dbt[1]].pgs = max_page;
            }
            if (pref[embed_mode].load_on_demand) {
              var tgt = ths[ths.length-1];
              if (tgt && tgt.type_source==='page' && (!site2[tgt.domain].all_boards || site2[tgt.domain].all_boards.indexOf(site.board)!=-1)) threads_index.idx_raise_odl(tgt);
            }
            if (Object.keys(tgts).length!==0 && !sb.native_prep) {
              sb.found_boards++;
              show_catalog(tgts);
  //          if (pref.catalog.filter.tag_scan_auto) scan_tags();
            }
  
////////            if ((dbt[3]==='thread_html' || dbt[3]==='thread_json') && threads[ths[0].key]) update_thread(dbt[0]+dbt[1]+dbt[2], ths[0], threads[ths[0].key][19]); // patch  // working code.
//            if ((dbt[3]==='thread_html' || dbt[3]==='thread_json') && threads[ths[0].key] && threads[ths[0].key][23]) update_thread(dbt[0]+dbt[1]+dbt[2], ths[0], threads[ths[0].key][19]); // patch to delete threads[name][23]
////            if (dbt[3]==='thread_html') {
////              var name = dbt[0] + dbt[1] + dbt[2];
////              if (threads[name]) { // patch for parallel entry.
////                site2[dbt[0]].check_reply.do(value.response, dbt, threads[name][19], threads[name][8], dbt[3]); // SHOULD CONSOLIDATE TO CHECK_REPLY.CHECK().
////
//////                if (threads[name][20]!==sb.pool.sticky) { // working code.
//////                  site2[dbt[0]].add_sticky_info(threads[name][0],threads[name][18],sb.pool.sticky);
//////                  threads[name][20] = sb.pool.sticky;
//////                }
////                if (threads[name][23]) {
////                  threads[name][23] = false;
////                  threads[name][9] = catalog_filter_query(name);
////                }
//////                if (pref.catalog_footer_show_nof_rep) site2[dbt[0]].insert_footer2(threads[name][0],threads[name][18],threads[name][19],threads[name][8]);
////                if (pref.catalog_footer_show_nof_rep) insert_footer3(threads[name][24],threads[name][19],threads[name][8],name);
////                threads[name][21] = false;
////                if (threads[name][19][0]>=0) notifier.changed(name,threads);
////                threads[name][19][5] = false;
////                threads[name][19][4] = null; // for GC.
////                reorder_thread_idx(name);
//////var debug = '';
//////for (var d=0;d<10;d++) debug += threads_idx[d] + ', ';
//////console.log('ddd :'+debug);
//////              if (reorder_thread_idx(name)) {
//////                tgts = {};
//////                tgts[name] = true;
//////                show_catalog(tgts);
//////              }
////              }
////            }
//            if (sb.native_prep) return ths;
}
          } else { // DON'T USE TH.XXX BECAUSE MEGUCA DOESN'T HAVE.
            if (value.status==404 && (dbt[3]==='thread_json' || dbt[3]==='thread_html')) {
              if (pref.liveTag.rm_404_immediately) liveTag.rm_404_1(dbt[0],dbt[1],dbt[2]);
              scan.list_nup.got_404(dbt[0] + dbt[1] + dbt[2]);
            }
            if (sb.found_threads<sb.max_threads) {
////////              sb.error += ((sb.error==='')? '' : ', ') + key;
////////              sb.error_obj[key] = value.status;
              if (value.status==404) comment_out_bookmark(key);
////              if (sb.indicator) {
////                sb.indicator.report({err_str:key+'('+value.status+')'});
////                sb.indicator.set('orange');
////              }
            }
            if (value.response===null && value.status==200) { // patch for 8chan's inconsistency.
              if (pref.debug_mode['16']) console.log('ERROR!!! Inconsistency in server. Server returned null with status 200 for '+site2[dbt[0]].make_url4(dbt)[0]+' , '+key);
              value.status=-200;
            }
            if (value.status==404 && pref.catalog_max_page_auto && (dbt[3]==='page_json' || dbt[3]==='page_html')) {
              var max_page = parseInt(dbt[2].replace(/^[pq]/,''),10);
              if (!liveTag.mems[dbt[0]][dbt[1]].pgs || max_page<liveTag.mems[dbt[0]][dbt[1]].pgs) liveTag.mems[dbt[0]][dbt[1]].pgs = max_page;
            }
          }
////          scan_boards_keyword(args,value.status);
          if (sb.refresh && !pref.test_mode['65'] && pref.archive.IDB.auto_restore && (!threads_delayed_pruning[dbt[0]] || !threads_delayed_pruning[dbt[0]][dbt[1]]) &&
              (dbt[3]=='catalog_json' || dbt[3]==='catalog_html' || dbt[3]=='page_json' || dbt[3]==='page_html') && !window.opener) restore_bd_from_IDB(dbt[0], dbt[1]);
          return ths;
        }
        cataLog.scan_boards_keyword_callback2 = scan_boards_keyword_callback2;
////        function tag_scan_extract_1(pn) { // working code.
////          return pn[brwsr.innerText].match(tags_scan_regex);
////        }
        function tag_scan_board(ths, sb) { // patch
          var ths_tag = {};
          for (var i=0;i<ths.length;i++) ths_tag[ths[i].key] = ths[i];
          scan_tags_common(ths_tag,'',sb.pool.tags);
        }

////        function tag_scan_extract_1(key,pn,sb) {
////          pn.tags = pn[brwsr.innerText].match(tags_scan_regex);
////          var ths = {};
////          ths[key] = pn;
////          scan_tags_common(ths,'',sb.pool.tags);
////  //        scan_tags_common({key:pn},'',sb.pool.tags,true);
////  //        return pn.tags;
////        }

////////        function scan_boards_keyword_callback2(key,value,args){
////////          var sb = args[1];
////////          if (pref.scan.crawler_adaptive) scan_boards_crawler_timer_clear();
////////          sb.pool.dbt = cnst.name2domainboardthread(key,true);
////////          if (value.status==200 && sb.found_threads<sb.max_threads) {
////////            if (sb.pool.dbt[2]=='j0' || sb.pool.dbt[2]=='c0') {
////////              if (sb.pool.dbt[2]=='j0') {
////////                sb.pool.type = 'catalog_json';
////////                sb.pool.doc = ('response' in value)? value.response : JSON.parse(value.responseText);
////////                var obj = sb.pool.doc;
//////////                var obj = ('response' in value)? value.response : JSON.parse(value.responseText);
////////    //            if (sb.scan_tag) {
////////    //              for (var i=0;i<obj.length;i++) {
////////    //                for (var j=0;j<obj[i].threads.length;j++) {
////////    //                  sb.pool.div.innerHTML = obj[i].threads[j].com;
////////    //                  obj[i].threads[j].tags = tag_scan_extract_1(sb.pool.dbt[0]+sb.pool.dbt[1]+obj[i].threads[j].no,sb.pool.div,sb);
////////    //                }
////////    //            }}
////////                for (var i=0;i<obj.length;i++) {
////////                  if (obj[i].threads) {
////////                    sb.scanned += obj[i].threads.length;
////////                    for (var j=0;j<obj[i].threads.length;j++) {
////////                      sb.name = sb.pool.dbt[0]+sb.pool.dbt[1]+obj[i].threads[j].no;
//////////                      if (threads[sb.name] && threads[sb.name][20]!==obj[i].threads[j].sticky) { // working code.
//////////                        site2[sb.pool.dbt[0]].add_sticky_info(threads[sb.name][0],threads[sb.name][18],obj[i].threads[j].sticky);
//////////                        threads[sb.name][20] = obj[i].threads[j].sticky;
////////////                        reorder_thread_idx(sb.pool.dbt[0] + sb.pool.dbt[1] +sb.pool.dbt[2].substr(1)); doesn't prepared threads[];
//////////                      }
////////                      if (sb.scan_tag) {
////////                        sb.pool.div.innerHTML = obj[i].threads[j].com + '\n' + obj[i].threads[j].sub + '\n' + obj[i].threads[j].name;
////////                        tag_scan_extract_1(sb.pool.dbt[0]+sb.pool.dbt[1]+obj[i].threads[j].no,sb.pool.div,sb);
////////                      }
//////////                      var search_obj = [obj[i].threads[j].com, obj[i].threads[j].sub, obj[i].threads[j].name,'','','','',''];
//////////                      if (!catalog_filter_query_scan(search_obj,sb.pool.div.tags)) {obj[i].threads.splice(j,1);j--;}
////////                      if (!catalog_filter_query_scan(obj[i].threads[j],sb.pool.div.tags)) {obj[i].threads.splice(j,1);j--;}
////////                    }
////////                  }
////////                }
////////    //            for (var i=0;i<obj.length;i++) sb.scanned += obj[i].threads.length; // NOT SO FAST.
////////    //            var kwd = pref.catalog.filter.kwd.str;
////////    //            if (pref.catalog.filter.kwd && kwd!=='') {
////////    //              if (!pref.catalog.filter.kwd.re) kwd = kwd.replace(/\*/g,'.*');
////////    //              if (pref.catalog.filter.kwd.ci) kwd = new RegExp(kwd,'i');
////////    //              for (var i=0;i<obj.length;i++) {
////////    //                for (var j=obj[i].threads.length-1;j>=0;j--) {
////////    //                  var str = obj[i].threads[j].name + '\n' + obj[i].threads[j].sub + '\n' + obj[i].threads[j].com;
////////    //                  var result = (str.search(kwd)!=-1);
////////    //                  if (pref.catalog.filter.kwd.match==='unmatch') result = !result;
////////    //                  if (!result) obj[i].threads.splice(j,1);
////////    //                }
////////    //              }
////////    //            }
////////                if ((pref.catalog.filter.kwd.use && pref.catalog.filter.kwd.str!=='') || (pref.catalog.filter.tag && filter_tags.length!=0))
////////                  sb.pool.ths = site2[sb.pool.dbt[0]].catalog_from_json3(obj,sb.pool.dbt[1]); // heavy, and cause loading in chrome.
////////                else sb.pool.ths = [];
////////              } else {
////////                sb.pool.type = 'catalog_html';
////////                sb.pool.doc = ('response' in value)? value.response : sb.pool.parser.parseFromString(value.responseText, 'text/html');
////////                sb.pool.ths = site2[sb.pool.dbt[0]].catalog_from_native(value.date,sb.pool.doc,sb.pool.dbt[1],sb.pool.type);
////////    //            if (sb.scan_tag) for (var i=0;i<sb.pool.ths.length;i++) sb.pool.ths[i].tags = tag_scan_extract_1(sb.pool.dbt[0]+sb.pool.dbt[1]+sb.pool.ths[i].no,sb.pool.ths[i].pn,sb);
////////                sb.scanned += sb.pool.ths.length;
////////                for (var i=0;i<sb.pool.ths.length;i++) {
////////                  if (sb.scan_tag) tag_scan_extract_1(sb.pool.dbt[0]+sb.pool.dbt[1]+sb.pool.ths[i].no,sb.pool.ths[i].pn,sb);
////////                  if (!catalog_filter_query_scan(sb.pool.ths[i],sb.pool.ths[i].pn.tags)) {sb.pool.ths.splice(i,1);i--;}
////////                }
////////              }         
////////              if (sb.pool.ths.length!=0 && ((pref.catalog.filter.kwd.use && pref.catalog.filter.kwd.str!=='') || (pref.catalog.filter.tag && filter_tags.length!=0))) {
////////                sb.found_boards++;
////////                sb.found_threads += sb.pool.ths.length;
////////                sb.pool.tgts = {};
////////                for (var i=0;i<sb.pool.ths.length;i++) {
////////                  insert_thread_with_test(sb.pool.ths[i], sb.pool.type, value.date); // patch
//////////                  insert_thread_from_native(sb.pool.ths[i], sb.pool.dbt[0], sb.pool.dbt[1], false, value.date);
////////                  sb.pool.tgts[sb.pool.dbt[0]+sb.pool.dbt[1]+sb.pool.ths[i].no] = true;
////////                }
////////                show_catalog(sb.pool.tgts);
////////    //            if (pref.catalog.filter.tag_scan_auto) scan_tags();
////////              }
////////            } else {
////////              var name = sb.pool.dbt[0] + sb.pool.dbt[1] + ((sb.pool.dbt[2][0]==='t')? sb.pool.dbt[2].substr(1) : sb.pool.dbt[2]);
////////              if (threads[name]) { // patch for parallel entry.
////////                sb.pool.type = (sb.pool.dbt[2][0]!=='t')? 'thread_html' : 'thread_json';
////////                if (sb.pool.dbt[2][0]!=='t') sb.pool.doc = ('response' in value)? value.response : sb.pool.parser.parseFromString(value.responseText, 'text/html');
//////////                site2[sb.pool.dbt[0]].check_reply_to_me(name,sb.pool.dbt,threads[name][19],(sb.pool.dbt[2][0]!=='t')? sb.pool.doc : value);
//////////var time_0 = performance.now();
//////////                site2[sb.pool.dbt[0]].check_reply_to_me(name,sb.pool.dbt,threads[name][19],(sb.pool.dbt[2][0]!=='t')? sb.pool.doc : value,threads[name][8], sb.pool, sb.pool.type); // also checks sage.
//////////                site2[sb.pool.dbt[0]].check_reply_to_me(name,sb.pool.dbt,threads[name][19],(sb.pool.dbt[2][0]!=='t')? sb.pool.doc : value.response, threads[name][8], sb.pool, sb.pool.type); // also checks sage.
////////                site2[sb.pool.dbt[0]].check_reply.do((sb.pool.dbt[2][0]!=='t')? sb.pool.doc : value.response, sb.pool.dbt, threads[name][19], threads[name][8], sb.pool.type);
////////
//////////                if (threads[name][19][0]>threads[name][8][4]) threads[name][19][0] = -1; // 2015.05.01 removed, but I don't remember why I wrote this.
////////
//////////console.log('check_reply :'+name+', '+(performance.now()-time_0));
//////////                if (threads[name][20]!==sb.pool.sticky) { // working code.
//////////                  site2[sb.pool.dbt[0]].add_sticky_info(threads[name][0],threads[name][18],sb.pool.sticky);
//////////                  threads[name][20] = sb.pool.sticky;
//////////                }
////////                if (threads[name][23]) {
////////                  threads[name][23] = false;
////////                  threads[name][9] = catalog_filter_query(name);
////////                }
//////////                if (pref.catalog_footer_show_nof_rep) site2[sb.pool.dbt[0]].insert_footer2(threads[name][0],threads[name][18],threads[name][19],threads[name][8]);
////////                if (pref.catalog_footer_show_nof_rep) insert_footer3(threads[name][24],threads[name][19],threads[name][8],name);
////////                threads[name][21] = false;
////////                if (threads[name][19][0]>=0) notifier.changed(name,threads);
////////                threads[name][19][5] = false;
////////                threads[name][19][4] = null; // for GC.
////////                reorder_thread_idx(name);
//////////var debug = '';
//////////for (var d=0;d<10;d++) debug += threads_idx[d] + ', ';
//////////console.log('ddd :'+debug);
//////////              if (reorder_thread_idx(name)) {
//////////                sb.pool.tgts = {};
//////////                sb.pool.tgts[name] = true;
//////////                show_catalog(sb.pool.tgts);
//////////              }
////////              }
////////            }
////////          } else {
////////            if (value.status==404 && (sb.pool.dbt[2][0]=='t' || sb.pool.dbt[2].search(/^[0-9]/)!=-1)) {
////////              var name = sb.pool.dbt[0] + sb.pool.dbt[1] + ((sb.pool.dbt[2][0]==='t')? sb.pool.dbt[2].substr(1) : sb.pool.dbt[2]);
////////              remove_thread(name);
////////            }
////////            if (sb.found_threads<sb.max_threads) sb.error += ((sb.error==='')? '' : ', ') + key;
////////          }
////////          sb.pool.doc = null;
////////          scan_boards_keyword(args,value.status);
////////        }
////////  
////////        function tag_scan_extract_1(key,pn,sb) {
////////  //        sb.pool.tags[key] = {};
////////  //        var tags = pn[brwsr.innerText].match(tags_scan_regex);
////////  //        sb.pool.tags[key].tags = tags;
////////  ////        var tags = div[brwsr.innerText].match(tags_scan_regex);
////////  ////        if (tags) {
////////  ////          var tags_uniq = {};
////////  ////          for (var k=0;k<tags.length;k++) tags_uniq[tags[k]] = 1;
////////  ////          for (var k in tags_uniq) {
////////  ////            if (sb.pool.tags[k]===undefined) sb.pool.tags[k] = [];
////////  ////            sb.pool.tags[k].push(key);
////////  ////          }
////////  ////        }
////////  //        return tags;
////////          pn.tags = pn[brwsr.innerText].match(tags_scan_regex);
////////          var ths = {};
////////          ths[key] = pn;
////////          scan_tags_common(ths,'',sb.pool.tags);
////////  //        scan_tags_common({key:pn},'',sb.pool.tags,true);
////////  //        return pn.tags;
////////        }
        cataLog.scan_init = scan_init;
        return {
          scan_init: scan_init,
          scan_abort: function(key){scan_init(key, {}, {});},
          scan_boards_keyword_callback2: scan_boards_keyword_callback2,
//          update_thread: update_thread,
////          priority_up: crawler.priority_up,
////          priority_release: crawler.priority_release,
        }
      }());
      cataLog.scan_boards = scan_boards;

      function catalog_resized(myself) {
        var tgt;
        if ((pref.catalog.text_mode.mode==='graphic' && (myself.name==='catalog_size_text_width' || myself.name==='catalog_size_text_height')) ||
            (pref.catalog.text_mode.mode==='text'    && (myself.name==='catalog_size_width'      || myself.name==='catalog_size_height'))) return;
        else tgt = myself.name.substr(myself.name.lastIndexOf('_')+1);
        var val = (pref[myself.name]==0)? '' : pref[myself.name] + 'px';
        for (var i in threads) threads[i][0].style[tgt] = val;
//        for (var i in threads) {
//          threads[i][0].style.width  = (pref.catalog_size_width==0 )? '' : pref.catalog_size_width  + 'px';
//          threads[i][0].style.height = (pref.catalog_size_height==0)? '' : pref.catalog_size_height + 'px';
//        }
      }
      var auto_update = (function(){
        var timer = null;
        var time_remains = 0;
        var timer_tgt = function(from_refresh_button){
          timer=null;
          catalog_refresh(true,null,!from_refresh_button);
          auto_update.set();
        }
        function stop_if_running(){
          if (timer) {clearTimeout(timer); timer=null;}
          if (pref.catalog_auto_update_countdown) health_indicator.pn_countdown.textContent = '';
        }
        function countdown(){
          health_indicator.pn_countdown.textContent = time_remains--;
          if (time_remains<0) timer_tgt();
          else timer = setTimeout(countdown,1000);
        }
        return {
          set : function(){
            stop_if_running();
            if (pref[embed_mode].auto_update) {
              var period = pref[embed_mode].auto_update_period || 0.5;
              if (!pref.catalog_auto_update_countdown) timer = setTimeout(timer_tgt,period*60000);
              else {
                time_remains = period*60;
                countdown();
              }
            }
          },
          stop_if_running: stop_if_running,
          timer_tgt : function(){
            if (timer) {clearTimeout(timer); timer=null;}
            timer_tgt(true);
          }
        }
      })();
      auto_update.set();
//      var auto_update_timer = null; // working code.
//      function set_auto_update(){
//        if (auto_update_timer) {clearTimeout(auto_update_timer);auto_update_timer=null;}
//        if (pref.catalog_auto_update) {
//          var period = pref.catalog_auto_update_period;
//          auto_update_timer=setTimeout(function(){auto_update_timer=null;catalog_refresh(true,null,true);},period*60000);
//        }
//      }
//      set_auto_update();

////      pn_filter.getElementsByTagName('*')['catalog.filter.tag_search.str'].onkeyup = function(){ // working code.
////        pref_func.apply_prep(this,true);
////        liveTag.filter_onchange();
////      }
////      if (!pref.catalog.filter.show) pn_filter.style.display = 'none';
      pn_filter.style.display = 'none';
////      pn_filter.getElementsByTagName('*')['catalog.filter.kwd.str'].onkeyup = function(){ // working code.
////        pref_func.apply_prep(this,true,true);
////        if ((!pref.catalog.filter.kwd.use && this.value!=='') || (pref.catalog.filter.kwd.use && this.value==='')) {
////          pref.catalog.filter.kwd.use = !pref.catalog.filter.kwd.use;
////          var use = pn_filter.getElementsByTagName('*')['catalog.filter.kwd.use'];
////          pref_func.apply_prep(use,false,true);
////        }
////      }
      var filter_time_str = pn_filter.getElementsByTagName('*')['catalog.filter.time_str'];
//      pn_filter.getElementsByTagName('button')['now'].onclick = function(){set_time_str(Date.now());}
//      var filter_time_ago_str = pn_filter.getElementsByTagName('*')['catalog.filter.time_ago_str'];
//      filter_time_ago_str.onkeyup = ago_clicked;
//      pn_filter.getElementsByTagName('button')['ago'].onclick= ago_clicked;
      function ago_clicked(e, time_in){
//        if (time_in===undefined) {
//          var str = filter_time_ago_str.value;
//          var time_in = (parseInt(str.replace(/:.*/,''),10)*60+parseInt(str.replace(/[^:]*:/,''),10))*60000;
//        }
        var time = Date.now() - time_in;
        filter_time_str.value = new Date(time).toLocaleString();
        pref_func.apply_prep(filter_time_str,true,true);
      }
//      function ago_clicked(){
//        var str = filter_time_ago_str.value;
//        var time = Date.now() - (parseInt(str.replace(/:.*/,''),10)*60+parseInt(str.replace(/[^:]*:/,''),10))*60000;
//        set_time_str(time);
//      }
//      function set_time_str(time){
//        filter_time_str.value = new Date(time).toLocaleString();
//        pn_filter_changed();
//      };
//      pn_filter.getElementsByTagName('button')['copy'].onclick =
//        function(){
//          pn_filter.getElementsByTagName('textarea')['catalog.filter.time_mark_str'].value=filter_time_str.value;
//          pn_filter_changed();
//        }
      var watch_list = pn_filter.getElementsByTagName('textarea')['catalog.filter.watch_list_str'];
      var search_ex_list = pn_filter.getElementsByTagName('textarea')['catalog.filter.list_str'];
//      search_ex_list.onkeyup = pn_filter_changed;
      var attr_list = pn_filter.getElementsByTagName('textarea')['catalog.filter.attr_list_str'];
//      attr_list.onkeyup = function(){if (pref.catalog.filter.attr_list) catalog_attr_changed();};
//      pn_filter.onchange = pn_filter_changed;
      function pn_filter_changed(){
        pref_func.apply_prep(pn_filter,true);
        catalog_filter_changed();
      }

////      function scan_tags(){ // working code.
////        var ths = [];
////        var j=0;
////        for (var i in threads) {
////          ths[j] = {};
////          ths[j++].tags = threads[i][0][brwsr.innerText].match(tags_scan_regex); // ATTENTION. DESCRIPTION IS ALSO EXIST IN CATALOG_FILTER_QUERY().
////        }
////        var str2 = scan_tags_common(ths,'');
////        scan_tags_init(str2,false);
////      }
      function scan_tags_init(str2, reload){
if (pref.test_mode['22']) {
        var pn_tag_list = pn_filter.getElementsByTagName('div')['catalog.filter.tag_list'];
        if (reload!==null) pn_tag_list.onchange = function(){prep_tag_str(null, reload, true);};
        pn_tag_list.innerHTML = str2;
        if (pn_tag_list.style.height=='') pn_tag_list.style.height = '30px';
        if (pn_tag_list.style.width=='') pn_tag_list.style.width = '100px';
//        prep_tag_str(true,reload);
        prep_tag_str(true,false);
}
      }
      var filter_tags = [];
      function prep_tag_str(keep,reload, from_onchange){
        var pn_tag_list = pn_filter.getElementsByTagName('div')['catalog.filter.tag_list'];
        var cbxes = pn_tag_list.getElementsByTagName('input');
        if (keep===true) {
          for (var i=0;i<filter_tags.length;i++) filter_tags[i] = filter_tags[i].toString().replace(/^\//,'').replace(/\(.*\n*.*/,'');
          var tags = [];
          for (var i=0;i<cbxes.length;i++) tags[i] = cbxes[i].nextSibling.textContent.replace(/ [0-9]*: /,'');
          for (var i=0;i<filter_tags.length;i++)
            for (var j=0;j<cbxes.length;j++)
              if (tags[j]==filter_tags[i]) cbxes[j].checked = true;
        }
        filter_tags = [];
        var tgts = {};
        var flag = false;
        for (var i=0;i<cbxes.length;i++)
          if (cbxes[i].checked) {
            filter_tags.push(new RegExp(cbxes[i].nextSibling.textContent.replace(/ [0-9]*: /,'').replace(/$/,'(#|,| |\\.|:|;|\n|$)'),(pref.catalog.filter.tag_ci)? 'i' : '')); // ATTENTION. REFER tag_scan_regex.
            if (reload) {
              var tags_tgt = (pref.catalog.filter.tag_ci)? site3[site.nickname].tags.ci[i].mem : site3[site.nickname].tags.cs[i].mem;
              for (var j in tags_tgt) tgts[j] = null;
            }
            flag = true;
          }
        if (from_onchange && flag) {
          pref.catalog.filter.tag = true;
          pref_func.apply_prep(pn12_0_4.getElementsByTagName('input')['catalog.filter.tag'],false);
        }
        if (pref.catalog.filter.tag) catalog_filter_changed();
//        pn_filter_changed();
        if (reload) {
//          for (var i in tgts) console.log(i);

//          load_list.tag.tgts = []; // working code.
//          for (var i in tgts) load_list.tag.tgts.push(i+'c0');
////          load_list.tag.use_cache = !refresh;
//          load_list.tag.idx = 0;
//          load_list.tag.mutex = true;
//          load_list.tag.from_auto = false;
//          load_list.tag.tgts = trim_list(load_list.tag.tgts,false);
//          if (pref.catalog_refresh_clear) catalog_clear_threads(pref.catalog.max_threads_at_refresh);
//          if (load_list.tag.idx<load_list.tag.tgts.length) get_page(load_list.tag);
          scan_boards.scan_init('refresh_tag',tgts, {lifetime:pref.scan.lifetime*60, cache_write:true});
//          set_auto_update();
          filter_tags_refresh_mem = tgts;
        }
      }
//      function load_save_key(){
//        return pref.script_prefix + '.catalog.adv_str.' + pref.catalog_board_list_obj[board_sel.selectedIndex][0].key;
//      }
//      pn_filter.getElementsByTagName('button')['load_adv_str'].onclick = function(){
//        if (localStorage) {
//          var tmp = JSON.parse(localStorage.getItem(load_save_key()));
//          if (tmp) {
//            search_ex_list.value = tmp[0];
//            attr_list.value = tmp[1];
//          }
//        }
//      };
//      pn_filter.getElementsByTagName('button')['save_adv_str'].onclick = function(){if (localStorage) localStorage.setItem(load_save_key(),JSON.stringify([search_ex_list.value,attr_list.value]));};
      
//      pn_filter.childNodes[11].onclick= function(){
//        var str = pn_filter.childNodes[10].value;
//        var time = Date.now() - (parseInt(str.replace(/:.*/,''),10)*60+parseInt(str.replace(/[^:]*:/,''),10))*60000;
//        pn_filter.childNodes[8].value = new Date(time).toLocaleString();
//        pref_func.apply_prep(pn_filter,true);
//        catalog_filter_changed();
//      };
//      if (pn12_0_2.childNodes[0].checked) cnst.show_hide(pn_filter);
//      pn12_1.style.width  = '';
//      pn12_1.style.height = '';

      var scroll_event_src = (embed_embed)? ((site2[site.nickname].catalog_get_native_scroll_area)? site2[site.nickname].catalog_get_native_scroll_area() : window) :
                                            triage_parent;
//      var scroll_event_src = (embed_embed)? window : triage_parent;
      var pn12_triage;
      var triage_str;
      function remake_triage(finish){
        triage.off();
        pref_func.tooltips.remove_root(pn12_triage);
        if (!finish) make_triage_entry();
      }
      function make_triage_entry(){
        var pn12_triage_all = new common_func.Triage(pref.catalog_triage_str, {onclick:triage_event, wheelpatch:(!embed_embed)? triage_wheel : null, name:'pn_catalog_triage'});
        pn12_triage = pn12_triage_all.pn;
        triage_str = pn12_triage_all.str;
        pn12_triage.style.position = 'absolute';
        pref_func.tooltips.add_root(pn12_triage);
//        var pn12_triage_all = common_func.make_triage({onclick:triage_event, wheelpatch:(!embed_catalog)? triage_wheel : null});
//        pn12_triage = pn12_triage_all.pn;
//        triage_str = pn12_triage_all.str;
//        pn12_triage.style.position = 'absolute';
//        pn12_triage.name = 'pn_catalog_triage';
//        if (pref.tooltip.show) pref_func.tooltips.add(pn12_triage);
//        pn12_triage.addEventListener('mouseover', catalog_triage_out_clear, false);
//        pn12_triage.addEventListener('mouseout' , catalog_triage_out_delay, false);
        pn12_triage.onmouseover = triage.triage_in;
        pn12_triage.onmouseout  = triage.triage_out;
        if (!pref.triage.hide_toggle) pn12_triage_all.format_tgt = null;
        triage.set_trg(pn12_triage_all);
      }
//      function make_triage(args){
//        var triage_str = [];
//        var pn_triage = document.createElement('div');
////        pn_triage.style.position = 'absolute';
////        pn_triage.name = 'pn_catalog_triage';
//        pn_triage.className = 'catalog_triage_parent';
//        var triage_str_lines = pref.catalog_triage_str.replace(/\/\/.*/mg,'').split('\n');
//        for (var i=triage_str_lines.length-1;i>=0;i--) if (triage_str_lines[i]==='') triage_str_lines.splice(i,1);
//        var triage_style_replace_list = (!brwsr.ff)? ['background','background-color'] : [];
//        for (var i=0;i<triage_str_lines.length;i++)
//          triage_str[i] = triage_str_lines[i].split(',');
//        for (var i=0;i<triage_str.length;i++) {
//          for (var j=0;j<triage_str[i].length;j+=3) {
//            var triage_button = document.createElement('button');
//            triage_button.innerHTML = triage_str[i][j+1];
//            triage_button.name = i+','+j;
//            triage_button.className = 'catalog_triage_button';
//            var triage_styles = (triage_str[i][j+2])? triage_str[i][j+2].split(';') : [];
//            for (var k=0;k<triage_styles.length;k++) {
//              var style_str = triage_styles[k].replace(/:.*/,'');
//              for (var m=0;m<triage_style_replace_list.length;m+=2) style_str = style_str.replace(triage_style_replace_list[m],triage_style_replace_list[m+1]);
//              triage_button.style[style_str] = triage_styles[k].replace(/[^:]*:/,'');
//            }
////            triage_button.onclick = triage_factory(i,j);
//            triage_button.onclick = args.onclick;
//            pn_triage.appendChild(triage_button);
//            if (args.wheelpatch) triage_button.onmousewheel = triage_wheel;
//          }
//          pn_triage.appendChild(document.createElement('br'));
//        }
////        pn_triage.onclick = function(e){  // also works, but CSS is the better.
////          e.preventDefault();
////          var evt = document.createEvent('MouseEvents');
////          evt.initUIEvent('click', false, true, window, 1);
////          threads[pn12_triage_thread][0].dispatchEvent(evt);
//////console.log('aaa');
////        };
//        return {pn:pn_triage, str:triage_str};
//      }
      function triage_wheel(e){ // patch
        triage.off();
        pref_func.tooltips.hide();
        e.preventDefault();
//        triage_parent.dispatchEvent(e); // copy is required.
          var evt = document.createEvent('MouseEvents');
        evt.initMouseEvent(e.type, e.canBubble, e.cancelable, e.view,
                   e.detail, e.screenX, e.screenY, e.clientX, e.clientY,
                   e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
                   e.button, e.relatedTarget);
        triage_parent.dispatchEvent(evt); // seems not to work...
      };
//      pn12_triage.childNodes[0].onclick = function(){search_ex_list.value = search_ex_list.value + ',' + pn12_triage_thread + '\n';pref_func.apply_prep(pn_filter,true);catalog_filter_changed();catalog_triage_out();};
//      pn12_triage.childNodes[2].onclick = function(){
////        var key = /8chan\/meta\/18578(@[^,]*)*,/;
//        var key = new RegExp(pn12_triage_thread +'(@[^,]*)*(,|$)','g');
//        search_ex_list.value = search_ex_list.value.replace(/,,+/,',').replace(key,'') + ',' + pn12_triage_thread + '@' + new Date(threads[pn12_triage_thread][8] + pref.localtime_offset*3600000).toLocaleString()+'\n';
//        pref_func.apply_prep(pn_filter,true);
//        catalog_filter_changed();
//        catalog_triage_out();
//      };
      function triage_event(){
        var flds = this.name.split(',');
        var i = parseInt(flds[0].replace(/[^\(]*\(/,''),10);
        var j = parseInt(flds[1].replace(/\).*/,''),10);
//      function triage(i,j){
        var name = triage.get_triaged_thread_name();
//        triage_exe(name,triage_str[i][j],triage_str[i][j+2],true);
////        pref_func.apply_prep(search_ex_list,true);
////        pref_func.apply_prep(attr_list,true);
////        pref_func.apply_prep(watch_list,true);
//        if (triage_str[i][j]==='UNDO') catalog_attr_changed();
//        else catalog_attr_set(name,threads[name][0]);
//        if (triage_str[i][j]==='WATCH' || triage_str[i][j]==='UNWATCH') show_catalog(name);
//        else catalog_filter_changed();
////        catalog_triage_out();
        triage_exe_0(name,triage_str[i][j],triage_str[i][j+2],true);
      }
      function triage_exe_pipe(args){triage_exe_0(args[0],args[1],args[2],args[3],args[4]);}
      function triage_exe_0(name,tri_str_ex,tri_str_attr,hist,datetime){
        if (['ARC','ARC1','UARC'].indexOf(tri_str_ex)!=-1) {
          if (!pref.test_mode['67']) archiver.start_1(tri_str_ex,liveTag.mems.getFromName(name),true); // test patch
          return;
        }
        var changed = triage_exe(name,tri_str_ex,tri_str_attr,hist,datetime);
        name = changed.name;
        if (changed.attr) catalog_attr_set(name,threads[name][0]);
        if (changed.ex) threads[name][9] = catalog_filter_query(name);
        if (changed.watch) {
          threads_index.idx_reorder(name);
          if (pref[embed_mode].mark_new_posts) if (embed_mode!=='catalog') format_html.update(name);
        }
        if (changed.ex || changed.watch) show_catalog(name);
        if (triage.get_trg().format_tgt) triage.format_buttons(changed.name);
        pref_func.tooltips.hide();
      }
      function triage_exe(name,tri_str_ex,tri_str_attr,hist,datetime){ // KILL,TIME,UNDO,NONE,WATCH,UNWATCH,DELETE,GO
        if (tri_str_ex==='UNWATCH') common_func.modify_bookmark(name,false);
        var changed = {ex:false, attr:false, watch:false, name:name};
        if (tri_str_ex==='GO') {click_thread(name, 'force');return changed;}
        if (tri_str_ex!=='UNDO') {
          if (hist) {
            if (triage_history.length>=pref.catalog_triage_hist*4) triage_history.splice(0,4);
            triage_history.push(arguments);
            triage_history.push(search_ex_list.value);
            triage_history.push(attr_list.value);
            triage_history.push(watch_list.value);
          }
          var key = new RegExp('(^|,)'+name.replace(/\+/,'\\+')+'([\\^@!][^,\n]*)*(,|\n|$)','mg');
//          if (tri_str_ex.search(/KILL|TIME|WATCH/)!=-1) { // contains UNWATCH
          if (['KILL','TIME','WATCH','UNWATCH','DELETE','KILL_N','TIME_N'].indexOf(tri_str_ex)!=-1) {
//            var datetime = threads[name][8][0] + pref.localtime_offset*3600000; // NO BLOCK SCOPE
//            var datetime = ((threads[name][8][0]>threads[name][8][4])? threads[name][8][0] : threads[name][8][4]) + pref.localtime_offset*3600000; // NO BLOCK SCOPE
//            var datetime = (tri_str_ex!=='DELETE')? threads[name][8][4] + pref.localtime_offset*3600000 : 0; // NO BLOCK SCOPE
            if (!datetime) datetime = (tri_str_ex!=='DELETE')? (threads[name][8][4]||threads[name][8][0]) : 0; // NO BLOCK SCOPE
            var millisec = datetime%1000; // NO BLOCK SCOPE
            var time_str = '@' + new Date(datetime).toLocaleString() + ((datetime%1000==0)? '' : '.'+millisec); // NO BLOCK SCOPE
            var wat_str = watch_list.value;
            if (tri_str_ex==='UNWATCH' && wat_str.indexOf(key)==-1) var unwatch_explicitly = true;
            wat_str = wat_str.replace(key,',');
//            if (tri_str_ex.search(/KILL|UNWATCH/)==-1) {
            if (tri_str_ex!=='DELETE') {
//              if (['TIME','WATCH'].indexOf(tri_str_ex)!=-1) {
              if (tri_str_ex==='WATCH' || (tri_str_ex==='TIME' || tri_str_ex==='TIME_N') && pref.catalog.auto_watch) {
                wat_str += ',' + name + time_str + '\n'; // TIME or WATCH
                mark_read_thread(name, true);
              } else {
                if (unwatch_explicitly) wat_str += ',' + name + '@0\n';
                mark_read_thread(name, false);
              }
            }
            watch_list.value = wat_str.replace(/,,+/g,',').replace(/^,/g,'').replace(/\n,/g,'\n').replace(/\n\n+/g,'\n').replace(/^\n/,'');
            changed.watch = true;
          }
//          if (tri_str_ex.search(/KILL|TIME|NONE/)!=-1) {
          if (['KILL','TIME','NONE','DELETE','UNWATCH','KILL_N','TIME_N'].indexOf(tri_str_ex)!=-1) {
            var ex_str = search_ex_list.value.replace(key,',');
            if (['KILL','KILL_N','TIME','TIME_N'].indexOf(tri_str_ex)!=-1) ex_str = ex_str + ',' + name + ((tri_str_ex==='TIME' || tri_str_ex==='TIME_N')? time_str : '') +'\n';
            search_ex_list.value = ex_str.replace(/,,+/g,',').replace(/^,/g,'').replace(/\n,/g,'\n').replace(/\n\n+/g,'\n').replace(/^\n/,'');
            changed.ex = true;
          }
////          if (['KILL','TIME','NONE','DELETE'].indexOf(tri_str_ex)!=-1) {
////            var at_str = attr_list.value.replace(key,',') + ((tri_str_attr!=='')? ',' + name + '^' +tri_str_attr : '') +'\n';
////            attr_list.value = at_str.replace(/,,+/g,',').replace(/^,/g,'').replace(/\n,/g,'\n').replace(/\n\n+/g,'\n').replace(/^\n/,'');
////            changed.attr = true;
////          }
          if (['KILL','TIME','NONE','DELETE','ATTR','SHOW','UNSHOW','STICKY','UNSTICKY'].indexOf(tri_str_ex)!=-1) {
            var at_str;
            if (tri_str_ex==='DELETE') at_str = '';
            else {
              var at_str = attr_list.value.match(key);
              at_str = (at_str)? at_str[0] : name;
              var at_obj = {val_obj2:null, val_obj3:null};
              pref_func.str2obj2(at_obj,'val_obj2',at_str);
              if (tri_str_ex==='ATTR' && tri_str_attr) pref_func.str2obj2(at_obj,'val_obj2',name+'^'+tri_str_attr, true);
              at_obj = at_obj.val_obj2[name];
              if (!at_obj.style) at_obj.style = {};
              if (!at_obj.cmd) at_obj.cmd = {};
              if (tri_str_ex==='SHOW') at_obj.cmd['show'] = true;
              else if (tri_str_ex==='UNSHOW') delete at_obj.cmd['show'];
              else if (tri_str_ex==='STICKY') {
                if (threads[changed.name][16].systemSticky) delete at_obj.cmd['sticky'];
                else at_obj.cmd['sticky'] = true;
              } else if (tri_str_ex==='UNSTICKY')
                if (threads[changed.name][16].systemSticky) at_obj.cmd['sticky'] = false;
                else delete at_obj.cmd['sticky'];
              at_str = name;
              if (['KILL','TIME','NONE'].indexOf(tri_str_ex)!=-1) {
                if (tri_str_attr!=='') at_str += '^' +tri_str_attr;
              } else { // 'ATTR'
                var at_obj_keys = Object.keys(at_obj.style);
                if (at_obj_keys.length!=0) {
                  for (var i=0;i<at_obj_keys.length;i++) at_obj_keys[i] += ':' + at_obj.style[at_obj_keys[i]];
                  at_str += '^' + at_obj_keys.join(';');
                }
              }
              at_obj_keys = Object.keys(at_obj.cmd);
              if (at_obj_keys.length!=0) {
                for (var i=0;i<at_obj_keys.length;i++) if (at_obj.cmd[at_obj_keys[i]]===false) at_obj_keys[i] += ':false';
                at_str += '!' + at_obj_keys.join(';');
              }
              at_str = (at_str === name)? '' : at_str + '\n';
            }
            at_str = attr_list.value.replace(key,',') + at_str;
            attr_list.value = at_str.replace(/,,+/g,',').replace(/^,/g,'').replace(/\n,/g,'\n').replace(/\n\n+/g,'\n').replace(/^\n/,'');
            changed.attr = true;
          }
        } else {
          if (triage_history.length!=0) {
            changed.watch = (watch_list.value     !== triage_history[triage_history.length-1]);
            changed.attr  = (attr_list.value      !== triage_history[triage_history.length-2]);
            changed.ex    = (search_ex_list.value !== triage_history[triage_history.length-3]);
            watch_list.value = triage_history.pop();
            attr_list.value = triage_history.pop();
            search_ex_list.value = triage_history.pop();
            var undo_args = triage_history.pop(); // from arguments
            changed.name = undo_args[0];
          }
        }
        if (tri_str_ex==='DELETE') {
          if (tri_str_attr===null) return changed;
          else {
            while (tri_str_attr.length!=0) {
              var name_next = tri_str_attr.shift();
              var changed_next = triage_exe(name_next,tri_str_ex,null,hist,datetime);
              changed.watch |= changed_next.watch;
              changed.ex    |= changed_next.ex;
              changed.attr  |= changed_next.attr;
            }
          }
        }
//        if (tri_str_ex==='UNDO') re_sort_thread();
//        else if (['WATCH','UNWATCH'].indexOf(tri_str_ex)!=-1) reorder_thread_idx(name);
//        if (tri_str_ex!=='NONE') pref_func.apply_prep(watch_list,true);
//        if (['UNDO','KILL','TIME','NONE'].indexOf(tri_str_ex)!=-1) pref_func.apply_prep(search_ex_list,true);
//        if (['WATCH','UNWATCH'].indexOf(tri_str_ex)==-1) pref_func.apply_prep(attr_list,true);
        if (changed.watch) pref_func.apply_prep(watch_list,true);
        if (changed.ex)    pref_func.apply_prep(search_ex_list,true);
        if (changed.attr)  pref_func.apply_prep(attr_list,true);
        if (tri_str_ex==='UNDO' && (changed.watch || undo_args[1]==='KILL')) { // re-order, 'KILL' doesn't change watch-list.
//        if (tri_str_ex==='UNDO' && changed.watch) { // re-order
          if (threads[changed.name]) {
            site2['DEFAULT'].check_reply.set_watch_time(threads[changed.name][19], get_watch_time_of_a_thread(changed.name,threads[changed.name][8][1], null, true), changed.name);
//            threads[changed.name][19][0] |= 0x00010000;
            scan_boards.scan_init('triage_undo', [changed.name], {refresh:true, priority:8});
          }
        }
        return changed;
      }
      var triage_history = [];

      var triage = (function(){
        var trg = null;
        function format_buttons(name){
          var tgt = trg.format_tgt;
          var tgt_th = threads[name];
          var lth = liveTag.mems.getFromName(name);
          for (var i=0;i<tgt.length;i++) tgt[i][0].style.display = (format_funcs[tgt[i][1]](tgt_th,lth))? 'none' : '';
        }
        var format_funcs = { // YOU MUST ALSO CHANGE toggles in Triage.
          'WATCH': function(tgt_th){return (tgt_th[19][0]&0x000c0000) && tgt_th[19][1]===0;},
          'UNWATCH': function(tgt_th){return !(tgt_th[19][0]&0x000c0000);},
          'SHOW': function(tgt_th){return tgt_th[16].icon_show_always;},
          'UNSHOW': function(tgt_th){return !tgt_th[16].icon_show_always;},
          'STICKY': function(tgt_th){return tgt_th[16].icon_sticky;},
          'UNSTICKY': function(tgt_th){return !tgt_th[16].icon_sticky;},
          'ARC': function(tgt_th,lth){return lth.archived;},
          'ARC1': function(tgt_th,lth){return lth.archived;},
          'UARC': function(tgt_th,lth){return !lth.archived;},
        };
        var on_off = (function(){
          var triaged_name = null;
          var triaged_pn = null;
          var db_thread_out = new DelayBuffer(thread_out,100);
          var thread_out_delayed = DelayBuffer.prototype.delayed_do.bind(db_thread_out);
          var db_triage_off = new DelayBuffer(triage_off,pref.triage.popdown_delay);
          var mode = true; // add/remove or show/hide
          function change_mode(){
            triage_parent.appendChild(pn12_triage);
            mode = false;
          }
          function thread_in(e){
            if (pref.catalog_triage) { // working.
              var pn = e.currentTarget;
              db_thread_out.cancel();
              if (triaged_pn===pn) return; // for faster execution.
              if (!triaged_name) {
                if (mode) pn12_triage = triage_parent.appendChild(pn12_triage);
                else pn12_triage.style.display = '';
              }
              if (!pref.triage.show_always) {db_triage_off.cancel();db_triage_off.delayed_do();}
              if (triaged_pn) triaged_pn.removeEventListener('mouseout', thread_out_delayed, false);
              var left = pn.offsetLeft - triage_parent.scrollLeft;
              if (pref.catalog_triage_place==='topLeft' || pref.catalog_triage_place==='bottomLeft') {
                pn12_triage.style.left = left + 'px';
                pn12_triage.style.right = null;
              } else {
                pn12_triage.style.right = triage_parent.offsetWidth - left - pn.offsetWidth + 'px';
                pn12_triage.style.left = null;
              }
              var top = pn.offsetTop  - triage_parent.scrollTop;
              if (pref.catalog_triage_place==='topLeft' || pref.catalog_triage_place==='topRight') {
                if (top<triage_parent.offsetTop) top = triage_parent.offsetTop;
                pn12_triage.style.top   = top + 'px';
                pn12_triage.style.bottom = null;
              } else {
                pn12_triage.style.bottom = window.innerHeight - top - pn.offsetHeight + 'px';
                pn12_triage.style.top = null;
              }
              triaged_pn = e.currentTarget;
              triaged_name = triaged_pn.name;
              triaged_pn.addEventListener('mouseout', thread_out_delayed, false);
              if (trg.format_tgt) format_buttons(triaged_name);
            } else triage_off();
          }
          function thread_out(){
            if (triaged_pn) {
              triaged_pn.removeEventListener('mouseout', thread_out_delayed, false);
              triaged_pn = null;
            }
            triage_off();
          }
          function triage_off(){
            if (triaged_name) {
              if (mode) pn12_triage = pn12_triage.parentNode.removeChild(pn12_triage); // for reentry, triage_parent wasn't updated when !pref[embed_mode].embed, for example, catalog -> thread -> catalog wiil cause an error.
//              if (mode) pn12_triage = triage_parent.removeChild(pn12_triage);
              else pn12_triage.style.display = 'none';
              triaged_name = null;
            }
            pref_func.tooltips.hide_if(pn12_triage);
          }
          return {
            get_triaged_thread_name: function(){return triaged_name;},
            change_mode: change_mode,
            thread_in:  thread_in,
            off: triage_off,
            off_delay: function(){db_triage_off.delayed_do(500);},
            triage_in:  function(){                              db_triage_off.cancel();    db_thread_out.cancel();},
            triage_out: function(){if (!pref.triage.show_always) db_triage_off.delayed_do();db_thread_out.delayed_do();},
          }
        })();
        return {
          get_triaged_thread_name: on_off.get_triaged_thread_name,
          change_mode: on_off.change_mode,
          thread_in:  on_off.thread_in,
          off: on_off.off,
          off_delay: on_off.off_delay,
          triage_in:  on_off.triage_in,
          triage_out: on_off.triage_out,
          set_trg: function(trg_new){trg = trg_new;},
          get_trg: function(){return trg;},
          format_buttons: format_buttons,
        }
      })();
      make_triage_entry();
      cataLog.triage = triage;
                

//      function insert_thread_with_test_from_catalog_json(th, snoop, date_load){
//        if (threads[th.key] && threads[th.key][8][0]>=th.time_bumped && threads[th.key][8][2]==th.nof_posts && threads[th.key][8][3]==th.nof_files) return false;
//        site2[th.domain].parse_funcs['catalog_json'].entry(th,['key','pn']);
//
//        var date = [th.time_bumped, th.time_created, th.nof_posts, th.nof_files]; // temporal
//        th.search_obj = [ th.com, th.sub, th.name, '', '', '', '', '']; // temporal
//        var url = site2[th.domain].make_url3(th.board, th.no, '0'); // temporal
//        insert_thread(th.pn, th.domain, th.page, date_load, th.key, th.pn.innerHTML, date, th.search_obj, url, true, th);
//        return true;
//      }
//      function insert_thread_with_test_from_catalog_html(th, snoop, date_load){
//        if (threads[th.key] && threads[th.key][8][0]>=th.time_bumped && threads[th.key][8][2]==th.nof_posts && threads[th.key][8][3]==th.nof_files) return false;
////        var th2 = site2[th.domain].catalog_from_native_1(th.pn,th.board);
////        insert_thread_from_native(th2, th.domain, th.board, snoop, date_load);
//        site2[th.domain].parse_funcs['catalog_html'].entry(th,['sub','name','com','page']);
//        var date = [th.time_bumped, th.time_created, th.nof_posts, th.nof_files]; // temporal
//        th.search_obj = [ th.com, th.sub, th.name, '', '', '', '', '']; // temporal
//        var url = site2[th.domain].make_url3(th.board, th.no, '0'); // temporal
//        insert_thread(th.pn, th.domain, th.page, date_load, th.key, th.pn.innerHTML, date, th.search_obj, url, true, th);
//        return true;
//      }

      function insert_thread_with_test(th, type, date_load){
        var name = th.key;
        if (threads_candidates_of_deletion && threads_candidates_of_deletion[name]) delete threads_candidates_of_deletion[name];
        if (threads[name] &&
//            ((threads[name][8][4] || threads[name][8][0])>=(th.time_posted || th.time_bumped)) && // vichan has inconsistency in time between catalog.json and thread.json.
            (((threads[name][8][0]>threads[name][8][4])? threads[name][8][0] : (threads[name][8][4] || threads[name][8][0])) >= ((th.time_bumped > th.time_posted)? th.time_bumped : (th.time_posted || th.time_bumped))) && // vichan has inconsistency in time between catalog.json and thread.json.
            threads[name][8][2]==th.nof_posts && threads[name][8][3]==th.nof_files
          && (!threads[name][21] || (th.type_parse!=='thread_html' && th.type_parse!=='thread_json'))) {
//        if (threads[name] && threads[name][8][0]>=th.time_bumped && threads[name][8][2]==th.nof_posts && threads[name][8][3]>=th.nof_files) {
////////          if (threads[name] && pref.catalog_footer_show_page && threads[name][24] && threads[name][24][2]!=th.page) insert_footer3(name,null,th.page);
          return false;
        }
if (pref.test_mode['0']) {
        site2[th.domain].parse_funcs[type].entry(th,site2[th.domain].parse_funcs[type]['after_test']);
}
        insert_thread_passed_test(th, type, date_load);
        return true;
      }
      function insert_thread_passed_test(th, type, date_load){
//        var date = [th.time_bumped, th.time_created, th.nof_posts, th.nof_files]; // temporal
//        th.search_obj = [ (th.com)? th.com : '', (th.sub)? th.sub : '', (th.name)? th.name : '', '', '', '', '', '']; // temporal
        var url = null;
////        if (type==='thread_html' || type==='page_html') {
//////          if (site.nickname!==th.domain) site2[th.domain].absolute_link(th.pn, th.board); // patch for url. BUT BUG.
////          url = site2[th.domain].get_thread_link(th.pn,th.board,pref.catalog_click!='expand',th.key);
////          th.html_org = th.pn.innerHTML; // patch, must be before trim.
////if (!pref.test_mode['5']) {
////          trim_html(th.pn, th.domain, pref.catalog_format.show, th.key); // temporal
////}
////        }
//////        } else url = site2[th.domain].make_url3(th.board, th.no, '0'); // temporal
//////        site2[th.domain].parse_funcs[type]['finisher'](th);
//        insert_thread(null, th.domain, th.page, date_load, th.key, (th.html_org)? th.html_org : th.pn.innerHTML, date, th.search_obj, url, true, th, type);
        insert_thread(null, th.domain, th.page, date_load, th.key, null, th.search_obj, url, true, th, type);
      }

////////      function insert_thread_from_native(th, nickname, board, snoop, date_load){
////////        var name = nickname + board + th.no;
////////        var date = [th.time_bumped, th.time_created, th.nof_posts, th.nof_files];
////////        var url = site2[nickname].make_url3(board, th.no, '0');
//////////        if (threads[name] && threads[name][8][0]>=date[0]) return 0;
////////        if (threads[name] && threads[name][8][0]>=date[0] && threads[name][8][2]==th.nof_posts && threads[name][8][3]==th.nof_files) return 0;
//////////        if (threads[name] && threads[name][8][0]==date[0] && threads[name][8][2]!=th.nof_posts && nickname==='8chan' && pref.catalog.order.find_sage_in_8chan) threads[name][21] = true; // for 8chan.
////////        return insert_thread(th.pn, nickname, th.page_no, date_load, name, th.pn.innerHTML, date, th.search_obj, url, true, th);
////////      }

////////      function re_trim_html(){
////////        for (var name in threads) {
////////          var date = get_mark_time(name,pref.catalog.filter.time_mark,pref.catalog.filter.list_mark_time,pref.catalog.filter.watch_list_mark_time);
////////          if (date===0) date = Infinity;
////////          var dbt = cnst.name2domainboardthread(name,true);
////////          site2[dbt[0]].mark_newer_posts(threads[name][0],date);
////////        }
////////      }
      function trim_html(src,nickname,format, name){
if (!pref.test_mode['7']) { // memory leak debug.
  if (!pref.test_mode['8']) {
    if (!pref.test_mode['9']) {// safe
      if (!pref.test_mode['10']) { // safe 30 min.
if (!pref.test_mode['11']) {
        if (!format.fileinfo) site2[nickname].remove_files_info(src);
}
if (!pref.test_mode['12']) {
//        if (!format.posts)    site2[nickname].remove_posts(src,0);
        if (pref[embed_mode].t2h_num_of_posts>=0) site2[nickname].remove_posts(src,(!format.posts)? 0 : pref[embed_mode].t2h_num_of_posts);
}
if (!pref.test_mode['13']) {
        if (format.contents)  site2[nickname].format_thread_contents(src);
}
      }
        if (format.layout)    site2[nickname].format_thread_layout(src);
        if (format.style)     site2[nickname].format_thread_style(src);
                              site2[nickname].format_thread_always(src);
    }
        if (pref[embed_mode].localtime) site2[nickname].localtime(src);
    //        if (pref.catalog.filter.time_mark) site2[nickname].mark_newer_posts(src,date);
  }
}
      }
      function trim_html_mark_time(src,nickname,format, name){
        var date = get_mark_time(name, pref[embed_mode].mark_new_posts, pref[embed_mode].mark_new_posts, pref[embed_mode].mark_new_posts);
        if (date>0) site2[nickname].mark_newer_posts(src,date);
        if (pref[embed_mode].format.thumb.resize) site2[nickname].format_remove_tn_area_size(src);
      }
////////      function insert_thread_from_page(src, nickname, boardname, op_no, page_no, nof_posts, nof_files, snoop, date_load){
////////        var name = nickname + boardname + op_no;
////////        if (snoop && !pref.catalog_promiscuous && !threads[name]) {
////////          var hit = false;
////////          for (var i=0;i<load_list.refresh.tgts.length;i++)
////////            if (load_list.refresh.tgts[i][0].indexOf(nickname+boardname+'p'+page_no)!=-1 ||
////////                load_list.refresh.tgts[i][0].indexOf(nickname+boardname+op_no)!=-1) {hit=true;break;}
////////          if (!hit) return 0;
////////        }
////////        var date = site2[nickname].get_time_of_posts(src);
////////        if (threads[name] && threads[name][13]<date_load) update_page_in_footer(name,page_no,date_load);
////////        if (threads[name] && threads[name][8][0]>=date[0]) return 0;
//////////console.log('In :'+name);
////////        var url = site2[nickname].get_thread_link(src,boardname,pref.catalog_click!='expand',name);
//////////        var date_mark = Date.parse(pref.catalog.filter.time_str) - pref.localtime_offset*3600000;
//////////        console.log(name+', '+date);
//////////        var src1 = document.createElement('div');
//////////        src1.innerHTML = src.innerHTML;
////////        var html_org = src.innerHTML;
////////        var src2 = document.createElement('div');
////////        src2.innerHTML = src.innerHTML;
////////        var cross_domain = pref.catalog_board_list_obj[board_sel.selectedIndex][0]['domain']!=nickname;
////////        var cross_board  = pref.catalog_board_list_obj[board_sel.selectedIndex][0]['board']!=boardname;
////////        date = date.concat(site2[nickname].insert_footer(src,page_no,((cross_domain)? nickname : '')+((cross_board)? boardname : ''),pref.catalog_footer,date,nof_posts,nof_files));
//////////        trim_html(src,  nickname, pref.catalog_format.show, date_mark);
////////////        trim_html(src1, nickname, pref.catalog_format.hover, date_mark);
//////////        trim_html(src2, nickname, pref.catalog_format.search, date_mark);
////////        trim_html(src,  nickname, pref.catalog_format.show, name);
////////        trim_html(src2, nickname, pref.catalog_format.search, name);
////////        return insert_thread(src, nickname, page_no, date_load, name, html_org, date, src2, url, false, {board:boardname});
////////      }
      function image_resize1_onload() {
        this.removeEventListener('load',common_func.image_resize1_onload,false);
        common_func.image_resize(this, pref.catalog_size_tn1_width, pref.catalog_size_tn1_height);
      }
      function image_resize2_onload() {
        this.removeEventListener('load',common_func.image_resize2_onload,false);
        common_func.image_resize(this, pref.catalog_size_tn2_width, pref.catalog_size_tn2_height);
      }
//      function convert_html(name,th){
//        if (!embed_catalog && pref.catalog.text_mode.mode==='text') {
//          var text = document.createElement('span');
//          text.innerHTML = ((pref.catalog.text_mode.sub  && threads[name][4][1][0])? '&emsp;' + threads[name][4][1][0] : '') +
//                           ((pref.catalog.text_mode.name && threads[name][4][2][0])? '&emsp;' + threads[name][4][2][0] : '') +
//                           ((pref.catalog.text_mode.com  && threads[name][4][0][0])? '&emsp;' + threads[name][4][0][0] : '');
//          var footer_new = document.createElement('span');
//          footer_new.innerHTML = th.footer.innerHTML; // make footer on demand.
//          th.footer = footer_new;
//          th.pn.innerHTML = '';
//          th.pn.appendChild(th.footer);
//          th.pn.appendChild(text);
//          threads[name][18] = 'text';
//        } else {
//          th.pn.innerHTML = threads[name][25][1];
//          th.footer = threads[name][25][0];
//        }
//      }

////////
//////// safe758
////////              page                  catalog + thread
//////// adoptNode    works with errors     works with errors
//////// importNode   works with errors     works with errors
//////// None         works with no errors  works with no errors
////////
//////// Memory leak was found with None (document leaks when I read KC's one), but I'll go with None.
////////
//      function insert_thread(src, nickname, page_no, date_load, name, html_org, src2, url, from_native, th, type){
      function merge_deleted_posts(lth, posts, num, t2h){
        return site2[lth.domain].update_posts_merge_prep(posts, lth.pd, (num===false)? posts.length-1 : num + ((t2h==='unread' || t2h==='N_unread')? lth.pd.length : 0), true);
      }
      var tgt_th16_proto = {
        get no(){return this.dbt[2];},
        get board(){return this.dbt[1];},
        get domain(){return this.dbt[0];},
        get key(){return this.dbt.join('');},
        get nof_posts(){return liveTag.mems.getFromName(this.key).nof_posts;},
        get nof_files(){return threads[this.key][8][3];},
//        get time(){return this.posts[0].time || threads[name][8][1];},
////        get sub(){return threads[this.key][4].sub;}, // this.posts && this.posts[0].sub;}, // for reentry in meguca
////        get com(){return threads[this.key][4].com;}, // this.posts && this.posts[0].com;}, // for reentry in meguca
////        get txt(){return threads[this.key][4].txt;}, // this.posts && this.posts[0].txt;}, // for reentry in meguca
        get tags(){return liveTag.mems.getFromName(this.key);},
        recent_posts: function(num, posts_in, remake){
          if (num===undefined || num===null) num = this.get_t2h_num_of_posts();
          var posts = posts_in;
          if (num!==false && !remake) {
            if (this.th && this.th.posts) posts = site2[this.lth.domain].update_posts_replace_prep(posts || this.th.posts, this.th.posts, num); // merge, posts===this.th.posts occurs also.
//            var posts = this.th && this.th.posts;
            if (this.posts && (num!=-1 || this.posts!==posts)) posts = site2[this.lth.domain].update_posts_replace_prep(posts || this.posts, this.posts, num); // merge // MUST CHANGE ADDRESS OF th.posts, 'th.posts===th_old.posts' is used 'insert_thread_format_html'
          } 
          if (!posts_in) {
            if (posts && this.lth.pd) posts = posts.filter(function(v){return !v.deleted_after;}); // posts may contain >num deleted posts.
            if ((!posts || num<0 || posts.length<=num) && this.lth.ta) posts = site2[this.lth.domain].update_posts_replace_prep(posts || this.lth.ta.posts, this.lth.ta.posts, num);
            if (!posts) posts = [this.op];
          }
//          var posts = this.th && this.th.posts || this.lth.ta && this.lth.ta.posts && site2[this.lth.domain].update_posts_replace_prep(this.posts || this.lth.ta.posts, this.lth.ta.posts, num) || this.posts;
          return (!pref.test_mode['64'] && pref[embed_mode].deleted_posts.merge && this.lth.pd)? merge_deleted_posts(this.lth, posts, num, pref[embed_mode].t2h_sel) : posts;
        },
        get_t2h_num_of_posts: function(){
          var t2h_sel = this.t2h_sel || pref[embed_mode].t2h_sel;
          return (t2h_sel==='page')? this.t2h_page || pref[embed_mode].t2h_num_of_posts
            : (t2h_sel==='L')? pref[embed_mode].t2h_L
            : (t2h_sel==='M')? pref[embed_mode].t2h_M
            : (t2h_sel==='N')? pref[embed_mode].t2h_num_of_posts
            : (t2h_sel==='N_unread')? pref[embed_mode].t2h_num_of_posts + this.lth.nr
            : (t2h_sel==='unread')? (this.lth.watched? this.lth.nr : this.t2h_page || pref[embed_mode].t2h_num_of_posts)
            : (t2h_sel==='no')? 0 : -1; // 'ALL' // and 'ALL_agg'
        },
        expand_num: function(){
          var num = this.get_t2h_num_of_posts()+1;
          var nof_posts = this.nof_posts;
          return (num==0 || num>nof_posts)? nof_posts : num;
        },
        expand: function(idx){
          this.expand_posts = true;
          this.t2h_sel = format_html.get_t2h_from_index(idx);
          var num = this.expand_num();
          var posts = this.recent_posts();
          if (posts.length < num) scan.scan_ui('expand_page', {tgts:[this.key], options:{refresh:true}});
          else {
            var th = {posts:posts, __proto__:threads[this.key][7]};
            site2[posts[0].domain_html].page_json2html3_add_omitted_info(th, this.posts, th.posts);
            insert_thread_prepare_html_lazy(threads[this.key], false, false, null, th);
            cataLog.show_catalog();
          }
        },
      };
      function insert_thread(th, date_load, picked_up_by_kwd_filter, insert_thread_from_native){
        var date_load = date_load;
        var name = th.key;
if (!pref.test_mode['28']) {
        if (site2[th.domain].preprocess_doc && !insert_thread_from_native) site2[th.domain].preprocess_doc(th.pn);
}
//console.log('insert_thread: '+name+','+th.page+', '+th.nof_posts+', '+th.nof_files);
if (pref.test_mode['26']) {
//        if (!insert_thread_from_native && th.type_data==='html') document.adoptNode(th.pn);  // KC causes memory leak if I don't use adoptNode(). // causes error in page mixing.
        if (!insert_thread_from_native && th.type_data==='html') th.pn = document.adoptNode(th.pn);
}
if (pref.test_mode['27']) {
        if (!insert_thread_from_native && th.type_data==='html') th.pn = document.importNode(th.pn, true);
}
//        if (th.pn.parentNode) th.pn.parentNode.removeChild(th.pn); // redundant.
////        if (site.nickname!==th.domain && th.type_data==='html') site2[th.domain].absolute_link(th);
//////        if (site.nickname!==th.domain) site2[th.domain].absolute_link(th); // make th.pn implicitly.
        var init_new = false;
        var tgt_th = threads[name];
        var date = [th.time_bumped, th.time_created, th.nof_posts, th.nof_files, th.time_posted];
        if (tgt_th && tgt_th[16].needs_update) {
          if (tgt_th[16].needs_update===true) {
            if (tgt_th[7]) th.page = tgt_th[7].page;
            remove_thread(name);
            tgt_th = undefined;
          } else delete tgt_th[16].needs_update;
        }
        if (tgt_th==undefined) {
if (pref.test_mode['19']) { // stability test.
          if (th.parse_funcs_html.th_init) th.parse_funcs_html.th_init(th); // BUG, should be moved into show_catalog() because threads aren't shown all the time and cause memory leak.
}
          init_new = true;
          threads[name] = [(insert_thread_from_native)? th.pn : false, // lazy generation, null may be returned by DOM, so 'false' is used here.
                           insert_thread_from_native, (embed_mode==='page' || !pref.test_mode['110'])? [triage.thread_in, null] : [func_in, func_pop_up],
                           null,
//                           [html_org || th.pn.innerHTML, nickname], // PATCHED. THIS WILL BE REMOVED.
                           null, // not used // th.posts && th.posts.slice(0,1), // 4 // {sub:th.sub, com:th.com, name:th.name, trip:th.trip, filename:th.filename}
//                           click_thread, // 5, click function.
                           [], // 5, click source
                           null,
                           null, // (!pref.test_mode['49'])? th : undefined, // 7, th, // test
                           date,
                           [true,0,true,0], // filter result
//                           (from_native)? click_thread_native : click_thread, null, url, date, true,
                           null, // timestamp for posts search
                           null, null, date_load, th.page, 0,
//                           (from_native && brwsr.ff)? th.init_func : null, // 16
//                           null, // 16, NOT USED
                           { dbt: common_func.name2domainboardthread(name,true),
//                             th_destroy: th.parse_funcs_html.th_destroy,
                             parse_funcs: th.parse_funcs,
                             systemSticky: th.sticky,
                             type_html: th.type_html, // for insert_thread_from_native
                             domain_html: th.domain_html,
                             parse_funcs_html: th.parse_funcs_html,
                             icon_sticky: null,
                             icon_show_always: null,
                             show_always: null,
//                             op_img_src_url: null,
                             th: th,
//                             popups: null, posts:null,
                             lth: th.lth,
                             op: th.posts && th.posts[0], // required in recent_posts to produce search source if no posts are stored in catalog mode. 'th.posts &&' must be redundant, but I haven't checked consistency yet. 
                             __proto__: tgt_th16_proto
                           }, // 16, others
//                           ch[brwsr.innerText].match(tags_scan_regex), // 17, tag
                           null, // 17, tag
                           th.type_html, // 18, type of html
                           null, // 19, tracking info
//                           [0,0,0,0,null,false,-2, 0, true, [], 0], // debug
                             // 19, time_of_checked, num_of_unread_replies_TO_ME, num_of_unread_replies,
                             //     time_of_checked_time_internal, args_for_desktop_notification, init,
                             //     time_of_checked_old, num_of_unread_old, inital_loop // for faster execution.
                             //     tag_temp, num_of_checked_posts_so_far
                           th.sticky, // 20 sticky.
//                           (nickname==='8chan' && from_native && pref.catalog.order.find_sage_in_8chan), // 21, watch.
                           false, // 21, watch.
                           {}, // 22, attr info for rollback.
                           null, // 23, for missing info
                           null, // 24, footer.
                           null, // 25, text_mode [0]: footer, [1]: html_backup
//                           th.op_img_url, // 26 op_iamge_url
                           ];
          tgt_th = threads[name];
//          if (name in threads_last_deleted) tgt_th[8][4] = threads_last_deleted[name].last_post_time;
          tgt_th[17] = liveTag.prep_tags(th);
          tgt_th[19] = liveTag.mems[th.domain][th.board][th.no][2];
          if (!(embed_mode==='catalog' && th.domain===site.nickname) &&
              ((th.domain==='KC' && th.type_source==='catalog') // doesn't have time info
              || th.posts[0].editing // th.domain==='meguca' // doesn't have op. FIXED in v3.
              )) {
            tgt_th[16].needs_update = true;
            if (th.type_source==='catalog') scan.list_nup.add(th.key);
          }
////          if (th.parse_funcs.missing_info) { // working code.
////            tgt_th[23] = common_func.shallow_copy_1(th.parse_funcs.missing_info);
////            if (pref.network.fetch_actively) th.parse_funcs.missing_info_fetch(th);
////          }

////          if ((embed_mode==='page' || embed_mode==='thread') && th.nof_posts>1 && th.posts.length===1) {
//////            cataLog.scan_init('refresh_inserted', [th.key], {refresh:true}); // DOESN'T WORK BECAUSE OF SO MANY REQUEST STOP PREVIOUS REQUESTS.
////            catalog_liveTag_scan_ui('scan_ui', {tgts:[th.key], options:{refresh:true}});
////          }
//          if (!(tgt_th[19][0]&0x000c0000) && (tgt_th[19][0]&0x00010000) && tgt_th[19][2]===0) {
//            var time_watch;
//            if (date[4]||date[0]) time_watch = get_watch_time_of_a_thread(name,date[1],date[4]||date[0], true); // THIS MAY BE REDUNDANT, threads pass 'prep_tags' always.
//            if (time_watch===0 && embed_mode==='thread' && pref.catalog.auto_watch) time_watch = (th.posts[th.posts.length-1].time || th.time);
//            if (time_watch!==0) site2[th.domain].check_reply.set_watch_time(tgt_th[19], time_watch);
//          }
////          if (site2[site.nickname].historyAPI) { // for reentry
////            tgt_th[16].tn_w = th.tn_w;
////            tgt_th[16].tn_h = th.tn_h;
////            tgt_th[16].op_img_url = th.op_img_url;
////          }
        }
        if (th.parse_funcs.posts_full) th.parse_funcs.posts_full(th);
        if (!date[0]) date[0] = tgt_th[8][0];
        if (!date[4]) date[4] = (tgt_th[8][4]<date[0])? date[0] : (tgt_th[8][4])? tgt_th[8][4] : site2[th.domain].check_reply.get_checked_time(tgt_th[19]);
        tgt_th[8] = date;
        if ((tgt_th[19][0]&0x00840000)===0x00800000 && (date[1]>0||date[4]>0)) {
          set_watch_time_thread(name, embed_mode, date[1],date[4], th, tgt_th[19]); // for meguca or those don't have time at first.
//          if ((tgt_th[19][0]&0x00840000)!==0x00800000) scan.list_nup.add_scan(th.key); // patched by trim_list:'force_init'
//            if (th.type_source==='thread') scan.list_nup.add_scan(th.key);
//            else scan.list_nup.add_board(th.domain+th.board);
        }

////        if (tgt_th[16].posts && tgt_th[16].posts.length===1 && (tgt_th[16].parse_funcs.missing_info > (th.parse_funcs.missing_info || -1))) { // PATCH
////          th.posts[0].pn = tgt_th[16].posts[0].pn;
////          tgt_th[16].posts = th.posts; // this cause inconsistency between posts shown and posts stored.
////          tgt_th[16].parse_funcs = th.parse_funcs;
////          tgt_th[16].parse_funcs_html = th.parse_funcs_html;
////          format_html.prepare_html_prep_posts(th);
////        }
        
//        var flag_posts_stored = embed_mode==='catalog' && pref[embed_mode].t2h_sel==='no' && th.parse_funcs.has_posts && pref.catalog.filter.kwd.posts_active && 
//          th.posts && // patch for 4chan catalog.
//          (pref[embed_mode].popup2==='sr' || (pref[embed_mode].popup2==='srpv' && catalog_filter_query_keyword.kwd(pref.catalog.filter.kwd, th.posts, th.domain, th))); // for simple search with scan.
//        if (flag_posts_stored) {
//          th.posts = catalog_filter_query_keyword.kwd_make_result(th.posts, th.domain, th);
//          if (th.posts) {
//            th.posts[0].__proto__.search_result = th.posts[0].search_result; // patch. see 'catalog_filter_query_keyword.kwd_make_result'
//            th.posts[0] = th.posts[0].__proto__;
//          }
//        }

//        tgt_th[9] = (picked_up_by_kwd_filter)? [true] : catalog_filter_query(name); // moved to later to apply t2h_num_of_posts
//        if (insert_thread_from_native) threads[name][16].posts = th.posts; // for reentry // BUG, html update exist in embed_thread.
        if (init_new && tgt_th[0]) threads[name][16].posts = th.posts;
        if (th.type_source==='page' || th.domain==='4chan' && th.type_parse==='catalog_json') threads[name][16].t2h_page = th.posts.length-1;

        if (tgt_th[16].expand_posts && (tgt_th[16].expand_num<=th.nof_posts || th.type_source==='thread')) tgt_th[16].expand_posts = false; // prevent infinite loop caused by !tgt_th[1]
        var t2h_num_of_posts = (th.type_source!=='page' || (tgt_th[16].t2h_sel || pref[embed_mode].t2h_sel)!=='page')? tgt_th[16].get_t2h_num_of_posts() : false;
        if (t2h_num_of_posts!==false) {
          if (init_new && (t2h_num_of_posts<0 || t2h_num_of_posts+1>th.posts.length) && th.posts.length<th.nof_posts && embed_mode==='page') { // load to add
//          if (init_new && (t2h_num_of_posts<0 || t2h_num_of_posts+1>th.posts.length) && th.posts.length<th.nof_posts) { // doesn't work for short links(last 50 posts)
            tgt_th[16].expand_posts = true;
            scan.list_nup.add_scan(th.key);
//            catalog_liveTag_scan_ui('scan_ui', {tgts:[name], options:{refresh:true}});
          }
        }
        var lth = th.lth;
        if (th.parse_funcs.has_posts) th.posts = tgt_th[16].recent_posts(t2h_num_of_posts, th.posts);
//        if (th.parse_funcs.has_posts && (pref.test_mode['49'] || !flag_posts_stored)) th.posts = tgt_th[16].recent_posts(t2h_num_of_posts, th.posts);
////        if (th.parse_funcs.has_posts && (pref.test_mode['49'] || !flag_posts_stored)) { // working code
////          if (t2h_num_of_posts!==false) {
////            if (tgt_th[16].th) th.posts = site2[th.domain].update_posts_replace_prep(th.posts, tgt_th[16].th.posts, t2h_num_of_posts); // merge
////            if (tgt_th[16].posts) th.posts = site2[th.domain].update_posts_replace_prep(th.posts, tgt_th[16].posts, t2h_num_of_posts); // merge // MUST CHANGE ADDRESS OF th.posts, 'th.posts===th_old.posts' is used 'insert_thread_format_html'
//////            if (embed_mode==='catalog' && th.posts.length<((t2h_num_of_posts>0)? t2h_num_of_posts : th.nof_posts) && lth.ta && lth.ta.posts.length>th.posts.length) th.posts = site2[th.domain].update_posts_replace_prep(th.posts, lth.ta.posts, t2h_num_of_posts); // merge, ONLY FOR FLAGS, CAN BE REMOVED AFTER CHANGING TO INCREMENTAL FLAGS.
////            // CAUSE BUG??? may cayse mixing posts which should use different prototype, posts_html and posts_json.
////          }
////          if (!pref.test_mode['64'] && pref[embed_mode].deleted_posts.merge && lth.pd) th.posts = merge_deleted_posts(lth, th.posts, t2h_num_of_posts, pref[embed_mode].t2h_sel);
//////            th.posts = site2[th.domain].update_posts_merge_prep(th.posts, th.lth.pd, 
//////              (t2h_num_of_posts===false)? th.posts.length-1 : t2h_num_of_posts + ((t2h_num_of_posts==='unread' || t2h_num_of_posts==='N_unread')? th.lth.pd.length : 0), true);
////        }
        if (!th.page && tgt_th[16].th) th.page = tgt_th[16].th.page;
        if (!init_new && th.parse_funcs.has_posts) tgt_th[16].th = th;
        if ((!pref.test_mode['49'] && pref[embed_mode].t2h_sel!=='no' || site2[site.nickname].historyAPI) && (!tgt_th[7] || th.parse_funcs.has_posts)) tgt_th[7] = th; // patch for reentry
//        if (!pref.test_mode['49'] && pref[embed_mode].t2h_sel!=='no') tgt_th[7] = th;
        if (pref[embed_mode].t2h_sel==='no') th.posts = th.posts.slice(0,1); // don't change th.posts itself, some other catalog may grep that.
        lth.th = th;
//        if (!pref.test_mode['49'] && th.parse_funcs.has_posts && pref.catalog.filter.kwd.posts_active && !flag_posts_stored) tgt_th[7] = th; // BUG at catalog.
        tgt_th[9][2] = null;
//        tgt_th[9] = (pref.filter.disable_list_when_kwd_active && picked_up_by_kwd_filter)? [true] : catalog_filter_query(name);
        tgt_th[9] = catalog_filter_query(name, true); // slightly redundant.

        catalog_attr_set(th.key,tgt_th[0]); // for cmd '!show'.
        if (insert_thread_from_native || (tgt_th[16].expand_posts && tgt_th[1] && !pref.catalog.filter.kwd.posts_active) || pref.test_mode['36']) insert_thread_prepare_html_lazy(tgt_th, init_new, insert_thread_from_native, null, th);
////        else {
////          var th_old = tgt_th[16].th;
////          if (th_old.posts.length<=1 || th.posts.length>1 && th.posts[th.posts.length-1].no > th_old.posts[th_old.posts.length-1].no) tgt_th[16].th = th;
////          else if (th.page) th_old.page = th.page;
////          catalog_attr_set(th.key,tgt_th[0]); // for 'show'.
////        }

        if (th.domain==='meguca') {
//        if (th.domain==='meguca' && tgt_th[16].needs_update!==true) {
          if (lth.ed_t) {
            lth.ed_u = th.replyTime; // meguca don't update JSON while editing.
//          var ed_p = lth.ed_p || lth.ed_t; // share lth.ed_t when pref.liveTag.from==='post'
//          if (ed_p) {
//            var i=0;
//            while (i<ed_p.length && typeof(ed_p[i])==='string') i++;
//            lth.ed_u = (!th.posts[1] || th.posts[1].no<=ed_p[i])? -1 : th.replyTime; // -1 for force update when editing posts are in scope. // 0 can't be used, because lth.ed_u becomes falsy.
          } else if (lth.ed_u) lth.ed_u = undefined; // null can't be used because (null<123) is true.
//          if (ed_p || tgt_th[16].needs_update<th.replyTime || tgt_th[16].needs_update===null)
//            tgt_th[16].needs_update = (ed_p && !(th.posts[1] && th.posts[1].no<=ed_p[ed_p.length-1]))? null : th.replyTime; // null means 'in scope and force update'.
//        if (th.domain==='meguca' && tgt_th[16].needs_update!==true) tgt_th[16].needs_update = th.lastUpdated || ((th.lth.ed_p)? null : undefined); // lastUpdated may be undefined.
//        if (th.parse_funcs.has_editing && tgt_th[16].needs_update!==true) tgt_th[16].needs_update = (th.lth.ed_p)? 1 : null;
        }
        return threads_index.idx_reorder(name);
      }
      function set_watch_time_thread(name, embed_mode, time_created, time_posted, th, watch){
        var time_watch = get_watch_time_of_a_thread(name,time_created,time_posted, true);
        if (time_watch>0) site2['DEFAULT'].check_reply.set_watch_time(watch, time_watch, name);
        else if (time_watch===0 && embed_mode==='thread' && pref.catalog.auto_watch) site2['DEFAULT'].check_reply.set_watched_to_last(watch, time_posted || time_created, name);
        else site2['DEFAULT'].check_reply.set_unwatch(watch);
      }
//      function set_watch_time_thread(name, embed_mode, time_created, time_posted, th, tgt_th19){
//        var time_watch = get_watch_time_of_a_thread(name,time_created,time_posted, true);
//        if (time_watch===0 && embed_mode==='thread' && pref.catalog.auto_watch) time_watch = (th.posts[th.posts.length-1].time || th.time);
//        site2[th.domain].check_reply.set_watch_time(tgt_th19, time_watch);
//      }
      cataLog.set_watch_time_thread = set_watch_time_thread;

      function insert_thread_prepare_html_lazy(tgt_th, init_new, insert_thread_from_native, from_lazy, th){
        var th = tgt_th[16].th || th;
        format_html.prepare_html_prep_posts(th); // wrap always for popup2, including "embed_mode==='catalog'".
        if (init_new || (embed_mode==='page' || embed_mode==='thread')) format_html.prepare_html(th, init_new);

        if (init_new) insert_thread_format_th_pn(tgt_th, init_new, insert_thread_from_native, from_lazy, th);
//          convert_html(name,th);
//          threads[name][25] = [threads[name][24][0], threads[name][0].innerHTML, threads[name][18]];
////////          insert_footer3(name,th.flags,th.page,threads[name][17]);
        if (tgt_th[0]) insert_thread_format_html(th,th.key,init_new,insert_thread_from_native);
        if (embed_mode==='catalog' && th.parse_funcs.has_posts) {
          var lth = th.lth;
          if (lth.ta && lth.ta.posts.length<th.posts) tgt_th[16].posts = th.posts; // patch for 4chan.
          else if (tgt_th[16].posts) tgt_th[16].posts = null;
        }
        tgt_th[16].th = null;
      }
      function insert_thread_format_th_pn(tgt_th, init_new, insert_thread_from_native, from_lazy, th){
        if (init_new) {
//          tgt_th[16].op_img_src_url = (th.parse_funcs.get_op_src)? th.parse_funcs.get_op_src(th) : th.op_img_url;
          var ch = tgt_th[0];
          tgt_th[3] = [ch.innerHTML, th.domain]; // PATCHED. THIS WILL BE REMOVED.
          ch.name = th.key; // ch.setAttribute('name',name); // for native html
          if (embed_mode==='float' || (th.domain!==site.nickname && !pref.catalog.mimic_base_site)) {
            ch.style.width  = ((pref.catalog.text_mode.mode==='text')? pref.catalog_size_text_width  : pref.catalog_size_width ) + 'px';
            ch.style.height = ((pref.catalog.text_mode.mode==='text')? pref.catalog_size_text_height : pref.catalog_size_height) + 'px';
            ch.style.float = 'left';
            ch.style.overflow = 'hidden';
//            ch.style.background = '#e5ecf9';
          }
          if (!ch.style) ch['style'] = {};

          tgt_th[0].addEventListener('mouseover', tgt_th[2][0], false);

          common_func.dom_addEventListener(tgt_th[5], th.pn, 'click', click_thread_whole);
          common_func.dom_addAttribute(th.pn, 'class', pref.script_prefix+'_thread');
          var tn_as = th.parse_funcs_html.tn_as(th);
          if (embed_mode!=='page' && embed_mode!=='thread') for (var i=0;i<tn_as.length;i++) {
            tn_as[i].onclick = click_thread_tn; // preventDefault is in this event handler.
            common_func.dom_addAttribute(tn_as[i], 'class', pref.script_prefix+'_thumbnail');
          }
          var tn_imgs = th.parse_funcs_html.tn_imgs(th);
          if (pref[embed_mode].format.thumb.resize) // BUG, should be moved into show_catalog() because threads aren't shown all the time and cause memory leak.
            for (var i=0;i<tn_imgs.length;i++) tn_imgs[i].addEventListener('load',(i==0)?image_resize1_onload : image_resize2_onload, false);

          if (tgt_th[20]===true) tgt_th[16].icon_sticky = (insert_thread_from_native)? site2[th.domain_html].get_icon(tgt_th[0],th.type_html, 'sticky', tgt_th[16]) :
                                                                                       site2[th.domain_html].add_icon(tgt_th[0],th.type_html, 'sticky', tgt_th[16]); // first time only.
          catalog_attr_set(th.key,tgt_th[0]);
  
          if (embed_mode==='float' && pref.catalog.text_mode.mode==='text') { // place after th.op_img_url. // NEED TO MODIFY REMOVE_THREAD TO PREVENT MEMORY LEAK.
            var text = document.createElement('span');
            text.innerHTML = ((pref.catalog.text_mode.sub && th.sub)? '&emsp;' + th.sub : '') +
                             ((pref.catalog.text_mode.name && th.name)? '&emsp;' + th.name : '') +
                             ((pref.catalog.text_mode.com && th.com)? '&emsp;' + th.com : '');
            var footer = th.footer; // make footer on demand.
            var footer_new = document.createElement('span');
            footer_new.innerHTML = footer.innerHTML;
            th.footer = footer_new;
            th.pn.innerHTML = '';
            th.pn.appendChild(th.footer);
            th.pn.appendChild(text);
            tgt_th[18] = 'text';
          }
          tgt_th[24] = Footer.prep_footer3(th, tgt_th[24]); // for reentry in meguca.
//          if (from_lazy) insert_footer3(th.key, null, th.page, th.tags, th); // consolidated into show_catalog
        }
      }

      function insert_thread_format_html(th,name,init_new,insert_thread_from_native, force_prep_html){
//        if (force_prep_html) format_html.prepare_html(th); // for json
        site2['DEFAULT'].check_reply.set_own_posts(th);
        var posts_used;
//        if (th.type_source==='page') threads[name][16].t2h_page = th.posts.length-1;
        if (init_new || insert_thread_from_native && site.nickname==='meguca') { // for reentry // TEMPORAL PATCH!!!
//        if (init_new || insert_thread_from_native) { // for reentry // BUG, html update mode exist in embed_thread.
//        if (init_new) {
          if (th.type_html==='page' || th.type_html==='thread') {
            var links = th.parse_funcs_html.get_thread_links(th.pn? th : {pn:threads[name][0], __proto__:th}); // for reentry. // THIS MUST BE HERE BEFORE update_posts_in_page, OP is also removed from th.pn at merge mode.
//            var links = th.parse_funcs_html.get_thread_links(th); // THIS MUST BE HERE BEFORE update_posts_in_page, OP is also removed from th.pn at merge mode.
            if (links) for (var i=0;i<links.length;i++) links[i].onclick = click_link;
          }
// working code, but BUG. this makes 'threads[name][16].posts === th.posts' BEFORE merging th.posts which contains deleted posts in 'embed_mode==='thread', so no merge will occur.
// But I remember I had troubled here..., safe1309-1308.
          if (embed_mode==='page' || embed_mode=='thread') posts_used = format_html.update_posts_in_page(th,name, true); // threads[name][16].posts!==th.posts is moved into 'update_posts_in_page'
          else {
            threads[name][16].posts = th.posts;
            posts_used = th.posts;
          }
 ////          if (embed_mode==='page' || embed_mode==='thread') {
//          if (embed_mode==='page' && threads[name][16].posts && threads[name][16].posts!==th.posts) format_html.update_posts_in_page(th,name,null, true);
//          else threads[name][16].posts = th.posts;
//          if ((embed_mode==='page' || embed_mode==='thread') && !pref.test_mode['64'] && pref[embed_mode].deleted_posts.merge && th.lth.pd) format_html.update_posts_in_page(th,name,null, true);

////            var t2h_num_of_posts = format_html.get_t2h_num_of_posts(threads[name], th.type_source);
////            if (t2h_num_of_posts!==false)
////              if (t2h_num_of_posts+1>th.posts.length && th.posts.length<th.nof_posts) {
////                threads[name][16].expand_posts = true;
////                scan.list_nup.add_scan(th.key);
//////                catalog_liveTag_scan_ui('scan_ui', {tgts:[name], options:{refresh:true}});
////              } else if (t2h_num_of_posts+1<th.posts.length && (th.parse_funcs.has_posts || t2h_num_of_posts===0)) format_html.update_posts_in_page(th,name,null, true);
          if (insert_thread_from_native && embed_mode==='page' && pref[embed_mode].use_expander_always) site2[th.domain_html].page_json2html3_replace_expander(th.posts, format_html.get_t2h_index(threads[name]), name);
          if (th.type_html==='page' || th.type_html==='thread') {
//            var links = th.parse_funcs_html.get_thread_links(th);
//            if (links) for (var i=0;i<links.length;i++) links[i].onclick = click_link;
//            if (th.parse_funcs.time_unit!==1) { // BUG!!! REFER 'update_posts_1'
//              var tu = th.parse_funcs.time_unit;
//              for (var i=0;i<th.posts.length;i++) th.posts[i].time *= th.parse_funcs.time_unit;
//            }
////            if (pref[embed_mode].colorID && site2[th.domain_html].colorID && (!pref[embed_mode].env.colorID_native || !insert_thread_from_native))
////              for (var i=0;i<th.posts.length;i++) site2[th.domain_html].colorID(th.posts[i].pn);
////            if (pref[embed_mode].backlink && site2[th.domain_html].backlink && (!pref[embed_mode].backlink_native || !insert_thread_from_native))
////              for (var i=0;i<th.posts.length;i++) if (th.tags.q && th.tags.q[th.posts[i].no]) site2[th.domain_html].backlink(th.posts[i].pn, th.tags.q[th.posts[i].no]);
            var pref_env = (!insert_thread_from_native)? pref[embed_mode] :
                                                         {
                                                           colorID: pref[embed_mode].colorID && !pref[embed_mode].env.colorID_native,
                                                           backlink: pref[embed_mode].backlink && !pref[embed_mode].env.backlink_native, // do nothing because all posts don't have post.backlinks because this is before calling 'popups_add'.
                                                           localtime: pref[embed_mode].localtime && !pref[embed_mode].env.localtime_native,
                                                         };
            for (var i=0;i<th.posts.length;i++) format_html.prepare_html_post(th, th.posts[i], th.tags.q, pref_env);
//            for (var i=0;i<th.posts.length;i++) site2[th.domain_html].format_pn(th.posts[i].pn, th.tags.q && th.tags.q[th.posts[i].no], pref_env, th.posts[i]);
          }
        } else {
          if (th.domain==='KC' && embed_mode==='page' && pref[embed_mode].use_expander_always) site2[th.domain_html].page_json2html3_replace_expander(th.posts, format_html.get_t2h_index(threads[name]), name); // test patch for KC, I don't know why but other than KC generates ERROR.
          if ((embed_mode==='page' || embed_mode==='thread') && (pref.catalog_expand_at_initial_embed || pref.catalog_expand_at_initial))
            if (th.parse_funcs.has_posts) posts_used = format_html.update_posts_in_page(th,name);
////////          if (threads[name][19][0]===0) { // patch // working code.
////////            threads[name][19][0] = - get_mark_time(name,pref.catalog.filter.time_watch,false,true);
////////            if (threads[name][19][0]!==0) threads[name][19][2] = 0;
////////          }
//          for (var i=0;i<threads_idx.length;i++) if (threads_idx[i]==name) {threads_idx.splice(i,1);break;}
//          if (pref.notify.desktop.use && pref.notify.desktop.reply && threads[name][8][2]!=date[2]) desktop_notifier_obj.show('New Reples in '+name,name);
//          ch = threads[name][0];
////////          if (th.type_html==='page_html' || th.type_html==='thread_html') {
////////            ch.innerHTML = src.innerHTML; // faster, but can't revise footer, because this re-create DOM and th.footer is abondoned.
////////            threads[name][24] = prep_footer3(th.footer,th.board,th.domain,th.flags); // can't work 
////////          }
//          ch.innerHTML = src.innerHTML; // revise footer.
//          if (threads[name][20]===true) site2[nickname].add_sticky_info(threads[name][0],threads[name][18],threads[name][20]);
//          threads[name][19][8] = false;
          if (th.type_source!=='catalog' && embed_mode==='float') threads[name][3][0] = (th.pn)? th.pn.innerHTML : null; // PATCHED TEMPORARILY, this will be deleted.
        }
//        if (embed_mode==='page' && th.posts && th.posts[0].search_result!==undefined && threads[name][16].posts) site2[th.domain_html].update_posts0_class(threads[name][16].posts[0].pn, th.posts[0].search_result); // place here, because sometimes filter is given at initial, and that is 'init_new===true' // patch for 4chan catalog. moved to 'format_pn'
//        if (th.posts && th.posts[0].search_result!==undefined && threads[name][16].posts) site2[th.domain_html].update_posts0_class(threads[name][16].posts[0].pn, th.posts[0].search_result); // place here, because sometimes filter is given at initial, and that is 'init_new===true'
        
        var idx_new_post = (init_new)? 0 : 1;
        if (embed_mode=='page' && th.type_data==='json') { // TEMPORAL PATCH
          th.domain_html = site.nickname;
          th.parse_funcs_html = site2[th.domain_html].parse_funcs.page_html;
          for (var i=idx_new_post;i<th.posts.length;i++) if (!th.posts[i].pn) th.posts[i].pn = site2[th.domain_html].post_json2html(th.posts[i],th.board);
          for (var i=idx_new_post;i<th.posts.length;i++) th.posts[i].tn_imgs = th.parse_funcs_html.tn_imgs(th.posts[i]);
          posts_used = th.posts.slice(idx_new_post);
        }
//        if (embed_page && th.parse_funcs.has_posts) {
        if (posts_used && (embed_mode==='page' || embed_mode==='thread')) {
          var add_event = !pref[embed_mode].env.expand_thumbnail_inline_native || !insert_thread_from_native || (pref[embed_mode].expand_thumbnail_inline_all_after && pref[embed_mode].env.event_dynamic);
          var expand_now = pref[embed_mode].expand_thumbnail_initial;
          var expand_on_demand = pref[embed_mode].thumbnail.inline.ondemand;
          if (add_event || expand_now || pref.test_mode['104'])
            for (var j=0;j<posts_used.length;j++) {
              var tn_imgs = th.parse_funcs_html.tn_imgs(posts_used[j]);
              if (tn_imgs) for (var i=0;i<tn_imgs.length;i++) {
                if (!pref.test_mode['104']) tn_imgs[i].onclick = DIH.expand_thumbnail_inline;
                else if (!add_event && !(pref[embed_mode].env.event_dynamic && th.domain===site.nickname)) GEH.prototype.blacklist_click.add(tn_imgs[i]);
//                tn_imgs[i].onclick = (add_event)? expand_thumbnail_inline : expand_thumbnail_on_demand_set; // REDUNDANT???
                if (expand_now) {
                  if (expand_on_demand) {
                    DIH.expand_thumbnail_queue_add(tn_imgs[i]);
                    expand_now = false;
                  } else DIH.expand_thumbnail_inline.call(tn_imgs[i], null, true);
                }
              }
            }
        }
//        if (pref.test_mode['103']) if (posts_used && ((embed_mode==='catalog' && init_new) || (embed_mode==='page' || embed_mode==='thread')))  // working code, but static.
//          if (pref[embed_mode].image_prefetch || (pref[embed_mode].image_hover && (!pref[embed_mode].env.image_hover_native || !insert_thread_from_native)))
//            if (th.parse_funcs.has_posts && (embed_mode==='page' || embed_mode==='thread')) {
//              for (var j=0;j<posts_used.length;j++) {
//                var tn_imgs = th.parse_funcs_html.tn_imgs(posts_used[j]);
//                if (tn_imgs) for (var i=0;i<tn_imgs.length;i++) tn_imgs[i].onmouseover = image_hover_add;
//              }
//            } else if (init_new && !th.parse_funcs_html.dynamic_image_hover) {
//              var tn_imgs = th.parse_funcs_html.tn_imgs(th);
//              for (var i=0;i<tn_imgs.length;i++) tn_imgs[i].onmouseover = image_hover_add;
//            }
        if ((embed_mode==='page' || embed_mode==='thread') && pref[embed_mode].popup && th.type_html!=='catalog') site2[th.domain].popups_add(threads[name][16], th, insert_thread_from_native && pref[embed_mode].env.popup_native && !pref[embed_mode].env.event_dynamic);
//        if (pref.catalog.filter.kwd.post && th.posts) threads[name][4] = th.posts;
//        threads[name][9] = catalog_filter_query(name);
//if (pref.test_mode['5']) {
//        if (init_new && th.type_html!='catalog' && (type==='thread_html' || type==='page_html')) { // modify HTML at end because of DYNAMIC PARSE.
////          trim_html(threads[name][0], th.domain, pref[embed_mode].format.show, th.key);
//          if (pref[embed_mode].localtime) site2[nickname].localtime(th.pn); // PATCH
//        }
//}
        if (pref[embed_mode].hide_posts_without_images) format_html.hide_posts_without_images(th,name);
        if (embed_mode!=='catalog') format_html.update_draw(name, threads[name][0], threads[name][16]);
      }
      var format_html = {
        prepare_html_prep_posts: function(th){
          site2[th.domain].wrap_to_parse.posts(th);
//          if (th.parse_funcs.posts_full) th.parse_funcs.posts_full(th); // BUG, DOESN'T HIT FILTER BEFORE BEING SHOWN.
          if (th.type_data==='html') this.prepare_html_extract_params(th); // extraction function assumes that it has all of properties, this must be after 'posts_full'.
        },
        prepare_html_extract_params: function(th){
          if (!th.extracted) {
            if (th.parse_funcs.filename) {
              for (var i=0;i<th.posts.length;i++) if (th.posts[i].pn) th.posts[i].filename = th.parse_funcs.filename(th.posts[i]); // deleted posts may be merged.
//              for (var i=0;i<th.posts.length;i++) th.posts[i].filename = th.parse_funcs.filename(th.posts[i]);
              th.filename = th.parse_funcs.filename(th);
            }
            if (th.parse_funcs.prep_mimic) th.parse_funcs.prep_mimic(th);
            th.extracted = true;
          }
        },
        prepare_html: function(th, init_new){
          var tgt_th = threads[th.key];
//        if ((th.domain!==site.nickname || site.whereami+'_html'!=type) && pref.catalog.mimic_base_site && th.pn && site2[site.nickname].catalog_json2html3) { // for KC.
//        if ((th.domain!==site.nickname || site.whereami!='catalog') && pref.catalog.mimic_base_site && th.pn && site2[site.nickname].catalog_json2html3) { // cause document leak in KC
//          site2[th.domain].wrap_to_parse.posts(th);
//          if (th.parse_funcs.posts_full) th.parse_funcs.posts_full(th);
          var mimic = ((th.domain!==site.nickname || site.whereami+'_html'!==th.type_mimic) && pref.catalog.mimic_base_site);
          var mimic_tgt = ((embed_mode==='page' || embed_mode==='thread') && site2[site.nickname].page_json2html3)? 'page' : 'catalog'; // temporal, remove '&& site2[site.nickname].page_json2html3' later.
          if (pref.test_mode['92']) mimic_tgt = 'catalog'; // for 4chan-X catalog.
//          if (init_new || !mimic)
//            if (mimic_tgt==='page' && th.type_data==='html') this.prepare_html_extract_params(th); // for popup2, always wrapping is required.
          if (mimic) {
            if (init_new) {
              var tmp_pn = (mimic_tgt==='page')? site2[site.nickname].page_json2html3(th,th.board,th.op_img_url, true) : // FIXED, BUT WHY THIS WAS 'false'??? <- probably patch for type_data==='html'
                                                 site2[site.nickname].catalog_json2html3(th,th.board,th.op_img_url);
              Object.defineProperty(th, 'pn', {value: tmp_pn, writable:true, enumerable:true, configurable:true});
            }
            th.type_html = mimic_tgt;
            th.domain_html = site.nickname;
            th.parse_funcs_html = site2[site.nickname].parse_funcs[th.type_html+'_html']; // overwrite.
          } else if (th.type_data==='html') site2.common.remove_by_tagname(th.pn,'script');
          if (init_new) {
            if (tgt_th[0]===false) { // patch
              tgt_th[0] = th.pn;
              tgt_th[16].type_html = th.type_html;
              tgt_th[16].domain_html = th.domain_html;
              tgt_th[16].parse_funcs_html = th.parse_funcs_html;
            }
            Object.defineProperty(th, 'footer', {value: th.parse_funcs_html.footer(th), writable:true, enumerable:true, configurable:true});
            this.prep_anchor_links(th.pn, th); // Files in op are out of posts[0].pn sometimes, so these must be called with 'th'.
//            if (th.localArchive) if (!pref.test_mode['67']) archiver.url2file(th.localArchive, th); // merged to root html generator to prevent needless prefetch.
//            if (th.parse_funcs.has_editing) for (var i=0;i<th.posts.length;i++) if (th.posts[i].editing)
//              th.posts[i].pn.classList.add(pref.script_prefix+'_post_editing');
//              th.posts[i].pn.style.background = '#cec952';
          }
//          else {
//            var pfunc_pn = site2[th.domain_html].parse_funcs['post_json'].pn;
//            for (var i=1;i<th.posts.length;i++) {
//              if (!th.posts[i].pn) th.posts[i].pn = pfunc_pn(th.posts[i]);
//              site2[th.domain].toplevel_anchor(th.posts[i], th.no);
//              if (site.nickname!==th.domain) site2[th.domain].absolute_link(th.posts[i]);
//              if (th.localArchive) if (!pref.test_mode['67']) archiver.url2file(th.localArchive, th.posts[i]);
//              if (th.posts[i].editing) th.posts[i].pn.style.background = '#cec952';
//            }
//          }
        },
        prep_anchor_links: function(pn, th){
          if (pref.test_mode['109'] || th.no!=site.no || th.board!=site.board || th.domain!=site.nickname) site2[th.domain].toplevel_anchor(pn, th);
          if (site.nickname!==th.domain) site2[th.domain].absolute_link(pn);
        },
        prepare_html_post: function(th, post, thq, pref_env){
          if (!post.pn) {
            post.pn = site2[th.domain_html].parse_funcs['post_json'].pn(post);
            if (!thq) thq = th.lth.q; // for expand old posts, to add backlinks.
          }
          if (!pref_env) this.prep_anchor_links(post.pn, th);
//          if (th.localArchive) if (!pref.test_mode['67']) archiver.url2file(th.localArchive, post); // merged to root html generator to prevent needless prefetch.
          site2[th.domain_html].format_pn(post.pn, (thq)? thq[post.no] : null, pref_env, post, th);
          if (post.editing) post.pn.classList.add(pref.script_prefix+'_post_editing');
//          if (post.editing) post.pn.style.background = '#cec952';
        },
        get_t2h_from_index: function(idx){
          return ['page','L','M','N','N_unread','unread','all'][idx];
        },
        get_t2h_index: function(tgt_th){
          var t2h_sel = tgt_th[16].t2h_sel || pref[embed_mode].t2h_sel; 
          return (t2h_sel==='page')? 0 :
                 (t2h_sel==='L')? 1 :
                 (t2h_sel==='M')? 2 :
                 (t2h_sel==='N')? 3 :
                 (t2h_sel==='N_unread')? 4 :
                 (t2h_sel==='unread')? 5 : 6;
        },
//        get_t2h_num_of_posts: function(tgt_th, type_source){ // moved to tgt_th[16].prototype
//          var t2h_sel = tgt_th[16] && tgt_th[16].t2h_sel || pref[embed_mode].t2h_sel; 
//          if (t2h_sel!=='page' || type_source!=='page' || tgt_th[16].expand_posts) {
//            return (t2h_sel==='page')? tgt_th[16].t2h_page || pref[embed_mode].t2h_num_of_posts :
//                   (t2h_sel==='L')? pref[embed_mode].t2h_L :
//                   (t2h_sel==='M')? pref[embed_mode].t2h_M :
//                   (t2h_sel==='N')? pref[embed_mode].t2h_num_of_posts :
//                   (t2h_sel==='N_unread')? pref[embed_mode].t2h_num_of_posts + ((tgt_th[19][0]&0x000c0000)? (tgt_th[19][1]&0x0000ffff) : 0) :
//                   (t2h_sel==='unread')? ((tgt_th[19][0]&0x000c0000)? (tgt_th[19][1]&0x0000ffff) : tgt_th[16].t2h_page) :
//                   (t2h_sel==='no')? 0 : -1; // 'ALL' and 'ALL_agg'
//          } else return false;
//        },
        update_posts_in_page: function(th,name, init_new){
//        update_posts_in_page: function(th,name, force_prep_html, remove){
//          if (!th.parse_funcs.has_posts && !remove) return;
//          if (force_prep_html) this.prepare_html(th); // for json
          var tgt_th = threads[name];
          var posts_used = [];
////          var t2h_num_of_posts = this.get_t2h_num_of_posts(tgt_th, th.type_source);
////          if (t2h_num_of_posts!==false) {
//////            if (t2h_num_of_posts>=0 && th.posts.length > t2h_num_of_posts+1) th.posts.splice(1,th.posts.length - t2h_num_of_posts -1);
////            if (t2h_num_of_posts>=0 && th.posts.length > t2h_num_of_posts+1)
////              th.posts = th.posts.slice(0,1).concat(th.posts.slice(th.posts.length - t2h_num_of_posts)); // SLIGHTLY REDUNDANT, SHOULD BE CONSOLIDATED.
////            else site2[th.domain].update_posts_replace_prep(th,tgt_th[16], t2h_num_of_posts);
////            site2[th.domain].page_json2html3_add_omitted_info(th, th.posts, th.posts);
////          }
//          if (!pref.test_mode['64'] && pref[embed_mode].deleted_posts.merge && th.lth.pd) {
//            th.posts_alive = th.posts;
//            th.posts_full  = site2[th.domain].update_posts_merge_prep(th.posts, th.lth.pd, th.posts.length-1, true);
//            th.posts = th.posts_full;
////            tgt_th[16].posts = site2[th.domain].update_posts_merge_prep(tgt_th[16].posts, th.lth.pd, true);
//            site2[th.domain_html].update_posts_replace(th,tgt_th[16],(pref[embed_mode].merge)? site2['DEFAULT'].update_posts_merge_base : tgt_th[0], pref[embed_mode].merge, tgt_th[1]);
//          } else 
          var mb = site2['DEFAULT'].update_posts_merge_bases;
          var merge_base_tgts = (init_new && (tgt_th[1] || !mb.initialized))? mb.base_tgts(th.key) : null;
          var merge_base = (tgt_th[1] && merge_base_tgts)? mb.query((tgt_th[16].posts && tgt_th[16].posts!==th.posts)? {pn:tgt_th[0], __proto__:tgt_th[16]} : th, merge_base_tgts, true) : mb.bases[th.key]; // redundant but for saster execution, shall works correctly if this doesn't exist. (not debugged.)
          if (merge_base_tgts && !tgt_th[1] && !mb.initialized) mb.setup_hook();
//          var merge_base = (pref[embed_mode].merge && tgt_th[1])? site2['DEFAULT'].update_posts_merge_bases.query((tgt_th[16].posts && tgt_th[16].posts!==th.posts)? {pn:tgt_th[0], __proto__:tgt_th[16]} : th, 'ALL', true) : site2['DEFAULT'].update_posts_merge_bases.bases[th.key]; // redundant but for saster execution, shall works correctly if this doesn't exist. (not debugged.)
//          if (init_new && merge_base && merge_base.pn!==th.pn) site2[th.domain_html].update_posts_merge_init(th, merge_base);
          if (!init_new || tgt_th[16].posts && tgt_th[16].posts!==th.posts) {
            if (init_new) posts_used = th.posts.slice(); // patch for merging deleted posts at initial.
            site2[th.domain_html].update_posts_replace(th,tgt_th[16], tgt_th[0], merge_base, tgt_th[1], posts_used);
//          site2[th.domain_html].update_posts_replace(th,tgt_th[16],(pref[embed_mode].merge)? site2['DEFAULT'].update_posts_merge_base : tgt_th[0], pref[embed_mode].merge, tgt_th[1], posts_used);
//            if (tgt_th[16].expand_posts) tgt_th[16].expand_posts = null;
          } else {
            tgt_th[16].posts = th.posts;
            posts_used = th.posts;
          }
          return posts_used;
        },
        replace_posts_by_search: function(tgt_th){ // tgt_th[16].th may be set by updater.
          var th = tgt_th[7];
          if (pref.catalog.filter.kwd.posts_active) {
            if (tgt_th[10]!=pref.catalog.filter.kwd.timestamp || tgt_th[16].th) { // existence of tgt_th[16].th means thread is updated.
              tgt_th[10] = pref.catalog.filter.kwd.timestamp;
              var th_new = catalog_filter_query_keyword.kwd_make_result(tgt_th[16].recent_posts(pref[embed_mode].sourceOfSP==='auto'? -1 : null), th.domain, th);
//              var th_new = catalog_filter_query_keyword.kwd_make_result(th.posts, th.domain, th);
              if (!th_new) {
                tgt_th[9][0] = false;
                tgt_th[16].th = null;
              } else {
                var flag = (!tgt_th[16].posts || tgt_th[16].posts.length!==th_new.length);
                if (!flag) {
                  var i=th_new.length-1;
                  while (i>=0) {
                    if (tgt_th[16].posts[i].no!==th_new[i].no) {flag=true; break;} // for no OP
                    i--;
                  }
                  if (!flag && tgt_th[16].posts && tgt_th[16].posts[0] && tgt_th[16].posts[0].pn &&
                      (tgt_th[16].posts[0].pn.classList.contains('CatChan_search_miss')==th_new[0].search_result))
                    site2[th.domain_html].update_posts0_class(tgt_th[16].posts[0].pn,th_new[0].search_result);
                }
                if (flag) {    
                  format_html.prepare_html_prep_posts(th);
                  tgt_th[16].th = {posts:th_new, __proto__:th};
//                  tgt_th[10] = pref.catalog.filter.kwd.timestamp;
                } else if (tgt_th[16].th) tgt_th[16].th = null;
              }
            }
          } else if (tgt_th[10] || tgt_th[16].th){ // rollback
            if (!tgt_th[16].th) tgt_th[16].th = {posts:tgt_th[16].recent_posts(null,null,true), __proto__:th};
//            if (!tgt_th[16].th) tgt_th[16].th = scopy_th(th);
            tgt_th[10] = false;
          }
          if (tgt_th[16].th && tgt_th[7]) // updated by this or updater.
            if (tgt_th[16].posts===tgt_th[7].posts) tgt_th[7].posts = tgt_th[7].posts.slice(); // backup
        },
        posts_search_inactivated: function(){
          for (var name in threads) {
            var th = threads[name][7];
            var tgt_th16 = threads[name][16];
            if (tgt_th16.posts && tgt_th16.posts[0] && tgt_th16.posts[0].pn && tgt_th16.posts[0].pn.classList.contains('CatChan_search_miss')) {
              site2[th.domain_html].update_posts0_class(tgt_th16.posts[0].pn,true);
//              delete th.posts[0].search_result; // can't update omitted info in page mode.
            }
          }
          drawn_idx = 0; // lazy filter.
        },
        hide_posts_without_images: function(th,name){
          var posts = threads[name][16].posts;
          for (var i=0;i<posts.length;i++) {
            var tn_imgs = th.parse_funcs_html.tn_imgs(th.posts[i]); // for test
            if (tn_imgs.length===0) posts[i].pn.style.display = 'none';
          }
        },
        update_draw: function(name, pn, th){
          if (pref[embed_mode].mark_new_posts && (threads[name][19][0]&0x000c0000)) {// draw only
            var mark_time = get_mark_time(name,pref.catalog.filter.time_watch || pref.catalog.filter.time_watch_creation,true,true);
            if (mark_time===0 && embed_mode==='thread') mark_time = site2['DEFAULT'].check_reply.get_checked_time(threads[name][19]);
            if (mark_time>0) site2[threads[name][16].domain_html].mark_newer_posts(pn, mark_time, null, true, th);
          }
        },
        update: function(name){ // draw and ERASE.
          var date = (pref[embed_mode].mark_new_posts && (threads[name][19][0]&0x000c0000))? get_mark_time(name, true, true, true) : 0;
          if (date===0) date = Infinity; // to erase mark
          if (threads[name][0]) site2[threads[name][16].domain_html].mark_newer_posts(threads[name][0], date, null, false, threads[name][16]);
        },
        time_filter_changed: function(){ // draw and ERASE.
          if (embed_mode!=='catalog') for (var name in threads) this.update(name);
        },
      }
      cataLog.format_html = format_html;

      function get_watch_time_of_a_thread(name, time_created, time_posted, extra_format){
        var ret_time = get_mark_time(name,pref.catalog.filter.time_watch || pref.catalog.filter.time_watch_creation,true,true, extra_format);
        return (extra_format && ret_time<0)? -ret_time :
               (time_posted && ret_time>time_posted)? 0 :
               (!pref.catalog.filter.time_watch && pref.catalog.filter.time_watch_creation && ret_time>time_created)? 0 :
               ret_time;
      }
      cataLog.get_watch_time_of_a_thread = get_watch_time_of_a_thread;

      function func_in(e){pop_up_delay(e,this.name);triage.thread_in(e);}
      function func_pop_up(e){pop_up_delay(e,this.name);}

      var Footer = {
        mode: embed_mode,
        threads: threads,
        timestamp_trial: 16,
        timestamp: 16,
        timestamp_trial_prep: function(){this.timestamp_trial = this.timestamp + 16;},
        timestamp_inc: function(){this.timestamp = this.timestamp_trial;},
        update_all_force: function(){
          this.formatted_arr = null;
          for (var name in this.threads) this.update_force(name);
        },
        update_force: function(name,tags){
          this.update(name,null,tags, true);
        },
        update: function(name,flags,tags, force){
          var footer = this.threads[name][24];
          if (!footer) return;
          if (this.threads[name][1] && (footer[4]>=this.timestamp || force)) {
            this.insert_footer3(footer, name, flags, tags);
            footer[4] &= 0xfffffff0; // keep timestamp
          } else {
            footer[4] |= (flags? 0x01 : 0) | (tags? 0x04 : 0) | 0x08; // | (page? 0x02 : 0); // 0x08 is dirty mark
//            if (flags) footer[1] = flags;
//            if (page) footer[2] = page;
          }
        },
        draw: function(name){
          var footer = this.threads[name][24];
          if (!footer) return;
          if (footer[4] & 0x0f) this.insert_footer3(footer, name);
          footer[4] = this.timestamp_trial; // update always to keep track
        },
        factory: function(mode, threads){
          return {
            threads: threads,
            timestamp_trial: this.timestamp,
            timestamp: this.timestamp,
            mode: mode,
            __proto__: this
          };
        },

        pn: document.createElement('div'),
        prep_flag_dom: function(dom){
          if (dom.flag && (dom.flag instanceof Element)) return dom.flag; // for KC
          if (!site2[site.nickname].post_flag2html) return undefined;
          this.pn.innerHTML = site2[site.nickname].post_flag2html(dom); // site2[dom.domain_html].post_flag2html(dom); // patch, mimic always
          return this.pn.childNodes[0];
        },
//        prep_flag_dom: function(flags, idx){ // working code
//          var dom = flags[idx];
//          if (dom instanceof Element) return dom;
//          if (dom.flag && (dom.flag instanceof Element)) flags[idx] = dom.flag; // for KC
//          else {
//            this.pn.innerHTML = site2[site.nickname].post_flag2html(dom); // site2[dom.domain_html].post_flag2html(dom); // patch, mimic always
//            flags[idx] = this.pn.childNodes[0];
//          }
//          return flags[idx];
//        },
        remove_nullfy: function(footer,idx){
          footer[0].removeChild(footer[idx]);
          footer[idx] = null;
        },
        ts_refresh: 0,
        ts_refresh_rx: null,
        refresh_start(){
          this.ts_refresh = Date.now();
          this.ts_refresh_rx = null;
        },
        format_relative_time(time){
          var rt = time - this.ts_refresh;
          var sign = (rt<0)? '-' : '+';
          var at = Math.floor(Math.abs(rt)/1000);
          var s = at%60;
          var m = (at>=60)? Math.floor((at%3600)/60) : 0;
          var h = (at>=3600)? Math.floor((at%86400)/3600) : 0;
          var d = (at>=86400)? Math.floor(at/86400)+'d' : '';
          return sign + d + ((d && h<10)? '0':'') + ((at>=3600)? h+':':'') + ((at>=3600 && m<10)?'0':'') + ((at>=60)? m+':':'') + ((at>=60 && s<10)?'0':'') + s;
//          return (sat<60)? '0:00:'+at
//            : (at<3600)? '0:Math.floor(at/60)+'mins'
//            : Math.floor(at/3600)+':'+Math.floor((at%3600)/60);
        },
        format_time(time){
          if (!this.ts_refresh_rx) this.ts_refresh_rx = new RegExp(new Date(this.ts_refresh).toLocaleDateString(),'g');
          return new Date(time).toLocaleString().replace(this.ts_refresh_rx,'') + ' ';
        },
        formatted_arr: null,
        get_str: (function(){
          var myself = null;
          var tgt_th = null;
          var lth = null;
          var nums2 = null;
          var funcs = {
            pg: function(pf){return (pf.page)? function(){return tgt_th[14] || '?';} : null;},
            nm: function(pf){return (pf.nrtm)? function(){return lth.watched? lth.nrtm : '';} : null;},
            nr: function(pf){return (pf.nr)?   function(){return lth.watched? lth.nr : '';} : null;},
            rp: function(pf){return (pf.rp)? function(){return nums2[2];} : null;},
            r1: function(pf){return (pf.rp)? function(){return nums2[2]-1;} : null;},
            im: function(pf){return (pf.im)? function(){return nums2[3];} : null;},
            lp: function(pf){return (pf.nl)? function(){return (lth.ta && lth.ta.posts)? lth.ta.posts.length : '';} : null;},
            dp: function(pf){return (pf.nd)? function(){return lth.pd? lth.pd.length : '';} : null;},
            ar: function(pf){return (pf.archived)? function(){return lth.archived? 'A' : '';} : null;},
            nf: function(pf){return (pf.nf)?  function(){return lth.sID && lth.sID.nc || '';} : null;},
            ni: function(pf){return (pf.nid)? function(){return lth.sID && (lth.sID.nid || lth.sID.np) || '';} : null;},
            ct: function(pf){return (pf.ctime)?  function(){return myself.format_time(nums2[1]);} : null;},
            cT: function(pf){return (pf.rctime)? function(){return myself.format_relative_time(nums2[1]);} : null;},
            bt: function(pf){return (pf.btime)?  function(){return nums2[0]? myself.format_time(nums2[0]) : '';} : null;},
            bT: function(pf){return (pf.rbtime)? function(){return nums2[0]? myself.format_relative_time(nums2[0]) : '';} : null;},
            pt: function(pf){return (pf.ptime)?  function(){return nums2[4]? myself.format_time(nums2[4]) : '';} : null;},
            pT: function(pf){return (pf.rptime)? function(){return nums2[4]? myself.format_relative_time(nums2[4]) : '';} : null;},
            pr: function(pf){return (pf.prate)?  function(){return Math.floor(nums2[2]/((myself.ts_refresh - nums2[1])/86400000));} : null;},
            dn: function(pf){return (pf.domain)? function(){return lth.domain;} : null;},
            bd: function(pf){return (pf.board)?  function(){return lth.board;} : null;},
            no: function(pf){return (pf.no)?     function(){return lth.no;} : null;},
            wrap: function(p,func,l){
              var str = func();
              return str!==''? p+str+l : '';
            },
            concat: function(arr){
              var str = arr[1]();
              for (var i=2;i<arr.length-1;i+=2) {
                var tmp = arr[i+1]();
                if (tmp!=='') str += arr[i] + tmp;
              }
              return str!==''? arr[0] + str + arr[arr.length-1] : '';
            },
          };
          var fmts = {
            native:    '(ar )(U: nm/nr / )R: (lp/)(r1)(+dp) / I: (im)( / P: pg) (ni/nf )(ct )(cT )(bt )(bT )(pt )(pT )(pr )(dn)(bd)(no) ',
            condensed: '(ar )(nm/)(nr/)(lp/)(rp)(+dp)(/im)(/pg) (ni/nf )(ct )(cT )(bt )(bT )(pt )(pT )(pr )(dn)(bd)(no) ',
            meguca:    '(ar )(dn)(bd)(no) (nm/)(nr/)(lp/)(rp)(+dp)(/im)(/pg) (ni/nf )(ct )(cT )(bt )(bT )(pt )(pT )(pr ) ',
//            get custom_str(){return pref[myself.mode].footer.custom_str;}, // patch for minify. This line hits a bug in minifier.
          };
          function compile(myself_in){
            myself = myself_in;
            var pf = pref[myself.mode].footer;
            var elems = 'ar|n[mrfio]|pg|r[p1]|im|[ld]p|[cbp][tT]|pr|dn|bd'
            var arr = pf.custom_str.split(new RegExp('(\\(.*?(?:'+elems+').*?\\))')).filter(function(v){return v;}); // will be changed to fmts[pf[myself.mode]]
            var rx = new RegExp('('+elems+')');
            var obj = {};
            var len = 0;
            var proto = {enumerable:true, configurable:true};
            for (var i=0;i<arr.length;i++) {
              var tmp = arr[i].slice(1,-1).split(rx);
              if (tmp.length>=3) {
                for (var j=1;j<tmp.length;j+=2) tmp[j] = funcs[tmp[j]](pf);
                for (var j=tmp.length-3;j>=0;j-=2) if (!tmp[j+1]) tmp.splice(j,2); else if (j>0 && !tmp[j-1]) tmp[j]='';
                if (tmp[1]) Object.defineProperty(obj, len++, {get: (tmp.length>=5)?    funcs['concat'].bind(null, tmp)
                                                                  : (tmp[0] || tmp[2])? funcs['wrap'].bind(null, tmp[0], tmp[1], tmp[2])
                                                                  :                     tmp[1], __proto__:proto});
//              if (tmp.length>=5) { // working code, but has a bug.
//                for (var j=1;j<tmp.length;j+=2) tmp[j] = funcs[tmp[j]](pf);
//                for (var j=tmp.length-3;j>=0;j-=2) if (!tmp[j-1] && !tmp[j+1]) tmp.splice(j,2); // access tmp[-1], but ok.
//                if (tmp.length>=3) Object.defineProperty(obj, len++, {get: funcs['concat'].bind(null, tmp), __proto__:proto});
//              } else if (tmp.length>=3) {
//                var func = funcs[tmp[1]](pf);
//                if (func && (tmp[0] || tmp[2])) func = funcs['wrap'].bind(null, tmp[0], func, tmp[2]);
//                if (func) Object.defineProperty(obj, len++, {get: func, __proto__:proto});
              } else if (arr[i]) Object.defineProperty(obj, len++, {value: arr[i], __proto__:proto});
            }
            obj.length = len;
            return obj;
          }
          return function(tgt_th_in, lth_in){
            if (!this.formatted_arr) this.formatted_arr = compile(this);
            tgt_th = tgt_th_in;
            lth = lth_in;
            nums2 = tgt_th[8];
            return Array.prototype.join.call(this.formatted_arr,'');
          };
        })(),
        prep_footer3: function(th, footer_old){
          var footer = th.footer;
          footer.classList.add(pref.script_prefix+'_footer');
          th.parse_funcs_html.footer_clear(th);
          var str = footer.innerHTML.replace(/ *R:[0-9 \/]*I:[0-9 \/]*/,'');
          str = str.replace(/P:[0-9 \/]*/,'');
          str = str.replace(/ *\(sticky\) */,'');
          if (str!=='') {
            footer.innerHTML = '<span></span>' + str;
            footer = footer.childNodes[0];
          }
          if (pref[this.mode].footer.br) {
            var footer_style = footer.getAttribute('style');
            footer_style = ((footer_style)? footer_style + ';' : '') + 'clear:both';
            footer.setAttribute('style',footer_style);
          }
          return [footer, null, null, null, 0x06 | (th.country? 0x01 : 0), null, null];
//          return (footer_old)? [footer, th.country, footer_old[2], null,          0x07, null, null] // for reentry
//          return (footer_old)? [footer, th.country, footer_old[2], footer_old[3], 0x07, null, null] // for reentry
//                             : [footer, th.country, null,          null,          0x07, null, null];
        },
        insert_footer3: function(footer, name, flags, tags){
//          var footer = threads[name][24];
//          if (!footer || !footer[0]) return; // on demand drawing
          var tgt_th = this.threads[name];
          var lth = liveTag.mems.getFromName(name);
          var pf = pref[this.mode].footer;
          var str;
          if (pf.use) {
            flags = flags || (footer[4]&0x01);
            tags = tags || (footer[4]&0x04);
            if (pf.design==='custom') str = this.get_str(tgt_th, lth);
            else {
      //        var nums   = threads[name][19];
              var nums2  = tgt_th[8];
      //        if (page===undefined || page===null || (page==='?' && footer[2])) page = footer[2];
    //          if (page) footer[2] = page;
    //          else page = footer[2] || '?';
              var page = tgt_th[14] || '?';
              var str_nr = ((pf.nrtm)? lth.nrtm +'/' : '' ) + lth.nr;
              var str_nl = (pf.nl && lth.ta && lth.ta.posts)? lth.ta.posts.length+'/' : '';
              var str_nd = (pf.nd && lth.pd)? '+'+lth.pd.length : '';
              str     = ((pf.archived && lth.archived)? 'A ' : '') +
                        ((pf.design==='native')?
                          ((pf.nr)? ((lth.watched)? 'U: '+ str_nr + ' / ' : ''):'') + 'R: '+ str_nl+(nums2[2]-1)+str_nd +  ' / I: '+nums2[3] + ((pf.page)? ' / P: '+page : '')
                        : ((pf.nr)? ((lth.watched)? str_nr + '/' : ''):'') + str_nl+nums2[2]+str_nd + '/'+nums2[3]+ ((pf.page)? '/'+page : '')); // trial.
              if (str) str += ' ';
              if (pf.nf || pf.nid) {
                var str_nc = pf.nf && lth.sID && lth.sID.nc;
                var str_nid = pf.nid && lth.sID && (lth.sID.nid || lth.sID.np);
                str += (str_nid || '') + ((str_nid && str_nc)? '/' : '') + (str_nc || '') + ((str_nid || str_nc)? ' ' : '');
              }
  
              if (pf.ctime) str += this.format_time(nums2[1]) + ' ';
              if (pf.rctime) str += this.format_relative_time(nums2[1]) + ' ';
              if (pf.btime && nums2[0]) str += this.format_time(nums2[0]) + ' ';
              if (pf.rbtime && nums2[0]) str += this.format_relative_time(nums2[0]) + ' ';
              if (pf.ptime && nums2[4]) str += this.format_time(nums2[4]) + ' ';
              if (pf.rptime && nums2[4]) str += this.format_relative_time(nums2[4]) + ' ';
  
              if (pf.prate) str += Math.floor(nums2[2]/((this.ts_refresh - nums2[1])/86400000)) + ' ';
              if (pf.board || pf.no || pf.domain) {
                str += ((pf.domain)? lth.domain : '')+
                       ((pf.board)? lth.board : '')+
                       ((pf.no)? lth.no : '') + ' ';
              }
            }
          }
  
          if (str) {
            if (footer[5]) footer[5].textContent = str;
            else footer[5] = footer[0].insertBefore(document.createTextNode(str), footer[0].firstChild);
          } else if (footer[5]) Footer.remove_nullfy(footer,5);
  
          if (pf.tag && pf.use) {
            if (tags || !footer[3]) {
              var pn = liveTag.update_tag_string(lth.tags, ', ', liveTag.tag_node_onclick);
              if (footer[3]) footer[3].parentNode.removeChild(footer[3]);
              footer[3] = footer[0].insertBefore(pn, footer[6]);
            }
          } else if (footer[3]) Footer.remove_nullfy(footer,3);
//          if (pf.tag && pf.use) { // working code
//            tags = tags && lth;
//            if (!footer[3]) {
//              footer[3] = footer[0].insertBefore(document.createElement('span'), footer[6]);
//              tags = lth;
//            } else if (tags) footer[3].removeChild(footer[3].firstChild);
//            if (tags) footer[3].appendChild(liveTag.update_tag_string(lth.tags, ', ', liveTag.tag_node_onclick));
//          } else if (footer[3]) Footer.remove_nullfy(footer,3);
  
          if (pf.flag && pref[this.mode].t2h_num_of_posts>=0 && pf.use) {
            if (flags || !footer[6]) flags = tgt_th[16].recent_posts(); // .slice(); // EMBED_MODE IS USED IN THIS, MUST BE CHANGED.
            if (!footer[6]) {
              footer[6] = footer[0].appendChild(document.createElement('span'));
//              if (!flags) flags = footer[1];
            }
            if (flags && flags.length>0) {
              for (var i=footer[6].childNodes.length-1;i>=0;i--) footer[6].removeChild(footer[6].firstChild);
              for (var i=0;i<flags.length;i++) if (flags[i]) {
                var flag = Footer.prep_flag_dom(flags[i]);
                if (flag) {
                  if (flags[i].deleted_after) flag.classList.add('CatChan_search_miss');
                  footer[6].appendChild(flag);
                }
              }
//              var i = flags.length - pref[embed_mode].t2h_num_of_posts; // working code
//              if (i<1) i=1;
//              if (flags[0] && Footer.prep_flag_dom(flags,0)) footer[6].appendChild(flags[0]);
//              while (i<flags.length) {
//                if (flags[i] && Footer.prep_flag_dom(flags,i)) footer[6].appendChild(flags[i]);
//                i++;
//              }
//              footer[1] = flags;
            }
          } else {
            if (footer[6]) Footer.remove_nullfy(footer,6);
//            if (flags) footer[1] = flags;
          }
          if (pref.debug_mode['32'] && footer[6]) {
            var flags_debug = tgt_th[16].recent_posts(); // .slice();
            var pn = document.createElement('span');
            for (var i=0;i<flags_debug.length;i++) if (flags_debug[i]) {
              var flag = Footer.prep_flag_dom(flags_debug[i]);
              if (flag) {
                if (flags_debug[i].deleted_after) flag.classList.add('CatChan_search_miss');
                pn.appendChild(flag);
              }
            }
            var pns = [footer[6], pn].map(function(v){
              return Array.prototype.map.call(v.getElementsByClassName('flag'),function(v){return v.getAttribute('class').match(/flag\-(..)/)[1];}).toString();});
            if (pns[0]!=pns[1]) console.log('Error: Flags: '+lth.key+': '+'\n'+pns[0]+'\n'+pns[1]);
          }
  
  //        footer[0].innerHTML = (pref.catalog_footer)? str : ''; // working code
  //        
  //        if (pref.catalog_footer && pref.catalog_footer_show_tag) {
  //          if (!footer[3]) {
  //            footer[3] = document.createElement('span');
  //            footer[3].innerHTML = '<span></span><span></span>';
  //          }
  //          if (tags) {
  //            for (var i=0;i<2;i++) {
  //              var pn = liveTag.update_tag_string(tags[i], ', ', liveTag.tag_node_onclick);
  //              footer[3].removeChild(footer[3].childNodes[i]);
  //              footer[3].insertBefore(pn,footer[3].childNodes[i] || null);
  //            }
  //          }
  ////          if (tags) { // working code.
  ////            for (var i=0;i<2;i++) {
  ////              if (!tags[i][2] || force_update) {
  ////                var pn = liveTag.update_tag_string(tags[i][0], ', ', liveTag.tag_node_onclick);
  ////                tags[i][2] = true;
  ////                footer[3].removeChild(footer[3].childNodes[i]);
  ////                footer[3].insertBefore(pn,footer[3].childNodes[i] || null);
  ////              }
  ////            }
  ////          }
  //          if (footer[3].parentNode!==footer[0]) footer[0].appendChild(footer[3]);
  //        }
  //
  //        if (pref.catalog_footer_show_flag && (flags || footer[1]) && pref.catalog_footer && pref[embed_mode].t2h_num_of_posts>=0) {
  //          if (flags) footer[1] = flags;
  //          else flags = footer[1];
  //          var i = flags.length - pref[embed_mode].t2h_num_of_posts;
  //          if (i<1) i=1;
  //          if (flags[0] && Footer.prep_flag_dom(flags,0)) footer[0].appendChild(flags[0]);
  //          while (i<flags.length) {
  //            if (flags[i] && Footer.prep_flag_dom(flags,i)) footer[0].appendChild(flags[i]);
  //            i++;
  //          }
  //////////          if (th && site.nickname!==th.domain) site2[th.domain].absolute_link(footer[0], th.board); // patch
  //        }
//            footer[4] = Footer.timestamp;
        }
      };
      Footer.refresh_start();
      cataLog.Footer = Footer;
//      cataLog.insert_footer3 = insert_footer3;

      function re_sort_thread(){
        threads_index.idx_re_sort();
      }
      var threads_index = (function(){ // threads_idx, threads_odl and drawn_idx must be separated.
        function re_sort(){
          var odl = [];
          for (var i=0;i<threads_idx.length;i++) if (threads_idx[i].substr(0,4)==='ODL:') odl[odl.length] = threads_idx[i];
          threads_idx=[];
          for (var i in threads) insert(i);
          for (var i=0;i<odl.length;i++) threads_idx[threads_idx.length] = odl[i];
          drawn_idx = 0;
          show_catalog();
        }
//      function reorder_threads_idx(names){
//        for (var i in names) reorder_thread_idx(i);
//      }
////      function reorder_thread_idx(name, skip_check){ // working code.
//////        for (var i=0;i<threads_idx.length;i++) if (threads_idx[i]==name) {threads_idx.splice(i,1);break;}
//////        insert_thread_idx(name);
////        var i;
////        if (!skip_check) {
////          i = 0;
////          while (i<threads_idx.length && threads_idx[i]!==name) i++;
////          if (i<threads_idx.length) threads_idx.splice(i,1);
////        } else i = -1;
////        return (i!=insert_thread_idx(name) || (threads[name] && threads[name][9][0]!=threads[name][1])); // returns need to redraw.
////      }

////      function raise_threads_idx_odl(db,key){ // works, but blocked by stikies.
////        var idx = threads_idx.indexOf(key);
////        if (idx!=-1) {
////          var kwd_odldb = 'ODL:'+db;
////          for (var i=idx+1;i<threads_idx.length;i++)
////            if (threads_idx[i].indexOf(kwd_odldb)===0) {
////              if (i!=idx+1) threads_idx.splice(idx+1,0,threads_idx.splice(i,1)[0]);
////              break;
////            }
////        }
////      }
////      function raise_threads_idx_odl(db){ // working, but blinks when there are 'watched and first' threads. (stickies can't be sticky)
////        for (var i=threads_idx.length-1;i>=0;i--)
////          if (threads_idx[i].indexOf(db)===0) {
////            if (i<threads_idx.length-2) {
////              var kwd_odldb = 'ODL:'+db;
////              for (var j=i+1;j<threads_idx.length;j++)
////                if (threads_idx[j].indexOf(kwd_odldb)===0) {
////                  if (j!=i+1) threads_idx.splice(i+1,0,threads_idx.splice(j,1)[0]);
////                  break;
////                }
////            }
////            break;
////          }
////      }
        function reorder(name){
          var idx_old = threads_idx.indexOf(name);
          if (idx_old!=-1) threads_idx.splice(idx_old,1);
          var idx_new = insert(name);
          if ((idx_new !== idx_old || embed_mode==='page') && (idx_new < drawn_idx || idx_old < drawn_idx)) drawn_idx = 0;
          else if (embed_mode==='page' && drawn_idx===true) drawn_idx = 0;
//          else if (embed_mode==='page' && drawn_idx===true) drawn_idx = idx_new; // BUG??? this doesn't track drawn_y and ref_count.
//          if (idx_new !== idx_old && (idx_new < drawn_idx || idx_old < drawn_idx)) drawn_idx = 0; // BUG. doesn't redraw if its size is changed.
          return (idx_new !==idx_old || (threads[name] && threads[name][9][0]!=threads[name][1])); // returns need to redraw.
        }
        var threads_odl = {};
//        var threads_odl_default = { '8': [0, undefined, undefined, undefined, undefined], // disable 'on demand mode' at indexing of 1,2,3
        var threads_odl_default = { '8': [0, 0, 0, 0, 0],
                                   '19': [0,0,0]};
        function get_threads_odl_default(str){
          var page = parseInt(str.substr(str.lastIndexOf('/')+2),10);
          return (page===0)? {'8': [undefined, undefined, undefined, undefined, undefined], __proto__: threads_odl_default} : // force to top
                             {'8': [-page, -page, -page, -page, -page], __proto__: threads_odl_default};  // force to last
        }
        var start,end;
        var kwd_odl = 'ODL:';
        var check_funcs = {
          reply_to_me: function(tgt_th){return (tgt_th[19][0]&0x000c0000) && (tgt_th[19][1]>>16)!=0;},
          reply: function(tgt_th){return (tgt_th[19][0]&0x000c0000) && tgt_th[19][1]!=0;},
          watch_first: function(tgt_th){return tgt_th[19][0]&0x000c0000;},
          watch_last: function(tgt_th){return !(tgt_th[19][0]&0x000c0000);},
          sticky_first: function(tgt_th){return tgt_th[20];},
          sticky_last: function(tgt_th){return !tgt_th[20];},
        }
        function get_tgt_th(str){
          return (str.indexOf(kwd_odl)===0)? (threads_odl[str] || get_threads_odl_default(str)) :
                                             threads[str];
        }
        function check_sub(myself, check_func){
          var ref = start;
          while (ref<end && check_func(get_tgt_th(threads_idx[ref]))) ref++;
          if (check_func(myself)) end = ref;
          else start = ref;
        }
        var funcs_get_date = {
          0: function(tgt_th8){return tgt_th8[0] || tgt_th8[4];},
          4: function(tgt_th8){return tgt_th8[4] || tgt_th8[0];},
          get 5(){var now = Date.now(); return function(tgt_th8){return (now - tgt_th8[1])/tgt_th8[2];}},
          1: function(tgt_th8){return tgt_th8[1];},
          2: function(tgt_th8){return tgt_th8[2];},
          3: function(tgt_th8){return tgt_th8[3];},
        }
        function insert(name){
          start = 0;
          end = threads_idx.length;
          var myself = get_tgt_th(name);
          if (pref.catalog.order.reply_to_me) check_sub(myself, check_funcs.reply_to_me);
          if (pref.catalog.order.reply) check_sub(myself, check_funcs.reply);
          if (pref.catalog.order.watch!=='dont_care') check_sub(myself, (pref.catalog.order.watch==='last')? check_funcs.watch_last : check_funcs.watch_first);
          if (pref.catalog.order.sticky!=='dont_care') check_sub(myself, (pref.catalog.order.sticky==='last')? check_funcs.sticky_last : check_funcs.sticky_first);
          var get_date = funcs_get_date[pref.catalog.indexing%6];
//          var indexing  = pref.catalog.indexing%6;
//          var indexing2 = pref.catalog.indexing;
//          var get_date = (indexing===0 || indexing===4)? function(tgt_th){return tgt_th[8][indexing] || tgt_th[8][(indexing===0)?4:0];} :
//                         (indexing===5)?                 (function(){var now = Date.now(); return function(tgt_th){return (now - tgt_th[8][1])/tgt_th[8][2];}})() :
//                                                         function(tgt_th){return tgt_th[8][indexing];};
          var date = get_date(myself[8]);
          var check_func = (pref.catalog.indexing>=5 && pref.catalog.indexing<11)? function(tgt_th){return date>=get_date(tgt_th[8]);} :
                                                                                   function(tgt_th){return date<=get_date(tgt_th[8]);};
          var ref = start;
          while (ref<end && check_func(get_tgt_th(threads_idx[ref]))) ref++;
  
          if (ref==threads_idx.length) threads_idx[threads_idx.length] = name;
          else threads_idx.splice(ref,0,name);
  //        if (ref<=drawn_idx) drawn_idx = 0; // can't track by 'drawn_idx = ref; drawn_y = 0;'. drawn_xxx must be synchronized.
          return ref;
        }
        function raise_odl(th){
          var i = threads_idx.indexOf(th.key);
          if (i!=-1) {
            var kwd_odldb = 'ODL:'+ th.domain + th.board;
            while (++i<threads_idx.length) {
              if (threads_idx[i].indexOf(kwd_odldb)===0) {
                threads_odl[threads_idx[i]] = {'8':[ (th.time_posted || th.time_bumped), th.time_created, th.nof_posts, th.nof_files, (th.time_bumped || th.time_posted) ],
                                               __proto__:threads_odl_default};
                insert(threads_idx.splice(i,1)[0]);
                break;
          }}}
        }
        function delete_odl(keys){
          for (var i=0;i<keys.length;i++) delete threads_odl[kwd_odl+keys[i]];
        } 
        function insert_odl(name){
          delete threads_odl[kwd_odl+name];
          reorder(kwd_odl+name);
        }
        return {
          idx_insert: insert,
          idx_raise_odl: raise_odl,
          idx_delete_odl: delete_odl,
          idx_insert_odl: insert_odl,
//          clear: clear, // NEED TO BE IMPLEMENTED to clear 'threads_odl' to prevent memory from leaking.
          idx_reorder: reorder,
          idx_re_sort: re_sort,
        }
      })();
////////      function insert_thread_idx(name){ // working code.
////////        var indexing = pref.catalog.indexing;
////////        var ref=0;
////////        var end = threads_idx.length;
////////        var dbt = common_func.fullname2dbt(name);
////////        var kwd_odl   = 'ODL:';
////////        var kwd_odldb = kwd_odl+dbt[0]+dbt[1];
////////        var check_func;
////////        function skip_odl_th(ref){
////////          var str = threads_idx[ref];
////////          if (str.indexOf(kwd_odl)===0) return str.indexOf(kwd_odldb)!==0;
////////          else return check_func(threads[str]);
////////        }
//////////console.log(name+', S: '+threads[name][19][1]+'/'+(threads[name][8][2]-threads[name][19][2])+', '+threads[name][8][2]+', '+threads[name][8][3]);
////////        if (pref.catalog.order.reply_to_me) {
////////          check_func = function(tgt_th){return tgt_th[19][0]!==0 && tgt_th[19][1]!=0;};
////////          while (ref<end && skip_odl_th(ref)) ref++;
////////          if (threads[name][19][0]!==0 && threads[name][19][1]!=0) {end=ref;ref=0;}
//////////console.log(name+', M: '+ref+'/'+end+', '+threads[name][19][1]);
////////        }
////////        if (pref.catalog.order.reply) {
////////          var ref2 = ref;
//////////          while (ref2<end && threads_idx[ref2].substr(0,4)!=='ODL:' && threads[threads_idx[ref2]][19][2]!=threads[threads_idx[ref2]][8][2]) ref2++;
//////////          while (ref2<end && threads_idx[ref2].substr(0,4)!=='ODL:' && threads[threads_idx[ref2]][19][2]!=0 && threads[threads_idx[ref2]][19][2]!=threads[threads_idx[ref2]][8][2]) ref2++;
//////////          if (threads[name][19][2]!=0 && threads[name][19][2]!=threads[name][8][2]) end = ref2;
////////          check_func = function(tgt_th){return tgt_th[19][0]!==0 && tgt_th[19][2]>0;};
////////          while (ref2<end && skip_odl_th(ref2)) ref2++;
////////          if (threads[name][19][0]!==0 && threads[name][19][2]>0) end = ref2;
////////          else ref = ref2;
//////////console.log(name+', N: '+ref+'/'+end+', '+(threads[name][8][2]-threads[name][19][2]));
////////        }
//////////        if (pref.catalog.order.watch) { // working code.
//////////          var ref2 = ref;
//////////          while (ref2<end && threads_idx[ref2].substr(0,4)!=='ODL:' && threads[threads_idx[ref2]][19][0]!==0) ref2++;
//////////          if (threads[name][19][0]!==0) end = ref2;
////////////          while (ref2<end && threads_idx[ref2].substr(0,4)!=='ODL:' && threads[threads_idx[ref2]][19][2]!=0) ref2++;
////////////          if (threads[name][19][2]!=0) end = ref2;
//////////          else ref = ref2;
////////////console.log(name+', R: '+ref+'/'+end);
//////////        }
////////        if (pref.catalog.order.watch!=='dont_care') { // working code.
////////          var polarity = (pref.catalog.order.watch==='last');
////////          var ref2 = ref;
////////          check_func = function(tgt_th){return polarity ^ tgt_th[19][0]!==0;};
////////          while (ref2<end && skip_odl_th(ref2)) ref2++;
////////          if (polarity ^ threads[name][19][0]!==0) end = ref2;
////////          else ref = ref2;
//////////console.log(name+', R: '+ref+'/'+end);
////////        }
////////        if (pref.catalog.order.sticky!=='dont_care') {
////////          var polarity = (pref.catalog.order.sticky==='last');
////////          var ref2 = ref;
////////          check_func = function(tgt_th){return polarity ^ tgt_th[20];};
////////          while (ref2<end && skip_odl_th(ref2)) ref2++;
////////          if (polarity ^ threads[name][20]) end = ref2;
////////          else ref = ref2;
//////////console.log(name+', T: '+ref+'/'+end);
////////        }
////////        var date = threads[name][8][indexing] || threads[name][8][(indexing===0)?4:0];
////////        check_func = function(tgt_th){return date<=(tgt_th[8][indexing] || tgt_th[8][(indexing===0)?4:0]);};
////////        while (ref<end && skip_odl_th(ref)) ref++;
////////        if (ref==threads_idx.length) threads_idx[threads_idx.length] = name;
////////        else threads_idx.splice(ref,0,name);
//////////console.log(name+', F: '+ref+'/'+end+', '+threads_idx.length);
//////////        if (ref<=drawn_idx) drawn_idx = 0; // can't track by 'drawn_idx = ref; drawn_y = 0;'. drawn_xxx must be synchronized.
////////        return ref;
////////      }

      function expand_shrink_thread(name){
        if (threads[name][0].style.width=='') {
          if (pref.catalog_expand_with_hr && embed_mode!=='catalog') show_catalog_hr(name,'shrink');
          threads[name][0].style.width = pref.catalog_size_width + 'px';
          threads[name][0].style.height = pref.catalog_size_height + 'px';
        } else {
          threads[name][0].style.width = '';
          threads[name][0].style.height = '';
          if (pref.catalog_expand_with_hr && embed_mode!=='catalog') show_catalog_hr(name,'add');
        }
      }

      var DIH = (function(){ // Dynamic Image Handler
        var hover_tn = null;
        var hover_ex = null;
        var hover_pf = null;
        var image_expand_on_demand_instance = null;
        var image_expanding = [];
        var zoom = null;
        function image_hover_prep(img,src, mode){
          var img_ex = clone_img(img, src, mode, 'hover');
          if (!img_ex) return;
          img_ex.style.position = 'fixed';
          img_ex.style.top = '0px';
          img_ex.style.right = '0px';
          img_ex.style.pointerEvents = 'none';
  //        if (pref.test_mode['69']) archiver.test_dl(img_ex.src);
          return img_ex;
        }
        function get_mode(e){
          return e.currentTarget===site.popup_body? 'page' : embed_mode;
        }
        function image_hover_add(e,src){
          var mode = get_mode(e);
          var img_tn = e.target; //  : this; // e.currentTarget;
          if (pref[embed_mode].image_hover) {
            var divert = hover_pf && hover_pf[1]===img_tn;
            var img_ex;
            if (divert) {
              img_ex = hover_pf[0];
              img_ex.style.display = '';
              hover_pf = null;
            } else {
              img_ex = image_hover_prep(img_tn,src, mode);
              if (!img_ex) return;
            }
            img_ex.style.zIndex = pref[embed_mode].thumbnail.hover.popup_zIndex;
//            img_tn.addEventListener('mouseout', image_hover_remove_tn, false);
            if (!divert) site.script_body.appendChild(img_ex);
            e.preventDefault();
            httpd.pause_req();
            img_ex.onload  = image_hover_onload;
            img_ex.onerror = httpd.pause_cancel;
            if (hover_ex) image_hover_remove(); // placed after show to reduce redraw.
            hover_tn = img_tn;
            hover_ex = img_ex;
          }

          if (hover_pf) {
            hover_pf[0].parentNode.removeChild(hover_pf[0]);
            hover_pf = null;
          }
          if (pref[embed_mode].image_prefetch) {
            var name = get_name_recursive(img_tn);
            var img_next = site2[site.nickname].get_next_image(img_tn);
            if (img_next) {
              var img_pf = image_hover_prep(img_next, null, mode);
              img_pf.style.display = 'none';
              site.script_body.appendChild(img_pf);
              hover_pf = [img_pf,img_next];
            }
          }
        }
//        function image_hover_remove_tn(e){
//          hover_tn.removeEventListener('mouseout', image_hover_remove_tn, false);
//          image_hover_remove();
//        }
        function image_hover_remove(){
          if (hover_ex) site.script_body.removeChild(hover_ex);
          hover_ex = null;
        }
        function image_hover_snatch(){
          if (!hover_ex) return;
//          hover_tn.removeEventListener('mouseout', image_hover_remove_tn, false);
          if (zoom_required(hover_ex)) {
            hover_ex.style.cursor = 'zoom-in';
            hover_ex.onclick = image_hover_zoom_in;
          }
          return hover_ex;
        }
        function image_hover_snatch_end(){
          var s = hover_ex.style;
          s.position = null;
          s.pointerEvents = null;
          s.zIndex = null;
          s.top = null;
          s.right = null;
          if (hover_ex.tagName==='VIDEO') hover_ex.play();
          hover_ex = null;
        }
        function image_hover_onload(e){
          httpd.pause_cancel();
          var pf = pref[embed_mode].thumbnail['hover'];
          if (!pf.zoom) return;
          var img = e.target;
          if (zoom_required(img, true)) {
            hover_tn.addEventListener('mouseout', image_hover_zoom_end, false);
            hover_tn.addEventListener('mousemove', image_hover_zoom_prep, false);
            hover_tn.addEventListener('click', image_hover_zoom_start, false);
            zoom = {x:document.documentElement.clientWidth - img.clientWidth, y:img.clientHeight, state:null};
//            zoom = {x:document.documentElement.clientWidth - parseInt(s.maxWidth,10), y:parseInt(s.maxHeight,10), state:null};
          }
        }
        function zoom_required(img, check){
          var pf = pref[embed_mode].thumbnail['hover'];
          if (check && !pf.zoom) return false;
          var s = img.style;
          return pf.limit_width && (img.naturalWidth > parseInt(s.maxWidth,10)) || pf.limit_height && (img.naturalHeight > parseInt(s.maxHeight,10));
        }
        function zoom_included(e){
          return e.clientX>zoom.x && e.clientY<zoom.y;
        }
        function image_hover_zoom_prep(e){
          if (zoom_included(e)) {
            if (!zoom.state) {
              e.target.style.cursor = 'zoom-in';
              zoom.state = true;
            }
          } else if (zoom.state) {
            e.target.style.cursor = 'auto';
            zoom.state = false;
          }
        }
        function image_hover_zoom_end(e){
          var tn = e.currentTarget;
          tn.removeEventListener('mouseout', image_hover_zoom_end, false);
          tn.removeEventListener('mousemove', image_hover_zoom_prep, false);
          tn.removeEventListener('click', image_hover_zoom_start, false);
          tn.style.cursor = null;
        }
        function image_hover_zoom_start(e){
          if (zoom_included(e)) {
            e.stopPropagation();
            e.preventDefault();
            image_hover_zoom_end(e);
//            e.currentTarget.removeEventListener('mouseout', image_hover_remove_tn, false);
            hover_ex.onmouseout = image_hover_remove;
            image_hover_zoom_in({target:hover_ex, clientX:e.clientX, clientY:e.clientY});
            image_hover_draggable(hover_ex);
          }
        }
        function image_hover_draggable(pn){
          pn.style.pointerEvents = 'auto';
          pn.draggable = true;
          pn.ondragstart = cnst.div_dragstart;
          pn['on'+brwsr.mousewheel] = cnst.div_scroll;
        }
        function maxWidth(inline_or_hover){
          return document.documentElement.clientWidth  - pref[embed_mode].thumbnail[inline_or_hover].margin_width;
        }
        function maxHeight(inline_or_hover){
          return document.documentElement.clientHeight - pref[embed_mode].thumbnail[inline_or_hover].margin_height;
        }
        function zoom_factor(img){
          var fx = img.naturalWidth/(parseInt(img.style.maxWidth,10) || maxWidth('hover'));
          var fy = img.naturalHeight/(parseInt(img.style.maxHeight,10) || maxHeight('hover'));
          return (fx>fy)? fx : fy;
        }
        function zoom_in_place(e, s, f){
          if (!s.top) {
            s = e.target.parentNode.parentNode.style;
            var oT = e.target.offsetTop;
            var oR = e.target.offsetLeft; // e.target.parentNode.parentNode.offsetWidth - e.target.offsetWidth - e.target.offsetLeft; // PATCH
          }
          s.top = parseInt(s.top,10)*f + ((oT||0)-e.clientY)*(f-1) + 'px';
          s.right = parseInt(s.right,10)*f - (document.documentElement.clientWidth - (oR||0) - e.clientX) * (f-1) + 'px';
        }
        function image_hover_zoom_in(e){
          var et = e.target;
          var s = et.style;
          zoom_in_place(e, s, zoom_factor(et));
          s.maxWidth  = 'none';
          s.maxHeight = 'none';
          s.cursor  = 'zoom-out';
          et.onclick = image_hover_zoom_out;
        }
        function image_hover_zoom_out(e){
          var et = e.target;
          var s = et.style;
          zoom_in_place(e, s, 1/zoom_factor(et));
          s.maxWidth  = maxWidth('hover')+'px';
          s.maxHeight = maxHeight('hover')+'px';
          s.cursor = 'zoom-in';
          et.onclick = image_hover_zoom_in;
        }

        function clone_img_make_src(img, mode, inline_or_hover, from_initial){
          var name = get_name_recursive(img);
          if (!from_initial && pref[embed_mode].env.event_dynamic && inline_or_hover!==undefined &&
            ((inline_or_hover==='inline')? pref[embed_mode].env.expand_thumbnail_inline_native : pref[embed_mode].env.image_hover_native)) return;
  //        &&  common_func.fullname2dbt(name)[0]===site.nickname) return;
          if (!name && pref.test_mode['106'] && pref.test_mode['107']) return img.src; // patch for expand all at initial in 4chan, BUT I DON'T KNOW WHY...
          var tgt_domain_html = (pref.catalog.mimic_base_site)? site.nickname : threads[name][16].domain_html;
  //        var tgt_th16 = threads[name][16];
  ////      var src = ((tgt_th16.type_html==='catalog')? tgt_th16.op_img_src_url : img.parentNode.href) || pn.src;
  //        return ((tgt_th16.type_html==='catalog')? // working code
  //          site2[tgt_th16.domain_html].parse_funcs.catalog_html.img2src && site2[tgt_th16.domain_html].parse_funcs.catalog_html.img2src(img) :
  //          site2[tgt_th16.domain_html].parse_funcs.post_html.img2src(img)) || img.src;
          mode = site2[tgt_domain_html].general_event_handler[site.whereami].image_hover_check_mode(img);
          if (mode!=='catalog') return site2[tgt_domain_html].parse_funcs.post_html.img2src(img) || img.src; // working code, but cause an error at merging when the base is lost.
  //        if (embed_mode!=='catalog') return site2[tgt_th16.domain_html].parse_funcs.post_html.img2src(img) || img.src; // working code, but cause an error at merging when the base is lost.
          else {
            var lth = liveTag.mems.getFromName(name);
            return site2[lth.domain].parse_funcs[lth.th.type_parse].get_op_src(lth.th, img);
          }
        }
        function clone_img(img, src, mode, inline_or_hover, from_initial){
          var pn = img.cloneNode();
  //        pn.src = (embed_mode==='page')? img.parentNode.href : pn.src; // TEMPORARILY!!!
          if (!src) src = clone_img_make_src(img, mode, inline_or_hover, from_initial);
          if (!src) return; // return when native dynamic function works.
          var ext = (src.search(/^blob/)===0)? site2['DEFAULT'].parse_funcs.post_html.img2ext(img) : '';
          if (src.indexOf('data-ext')!=-1) { // PATCH for archive
            ext = src.slice(src.indexOf('data-ext')+10).replace(/".*/,'');
            src = src.replace(/".*/,'');
          }
          if (src.substr(-5,5)==='.webm' || ext==='.webm' || img.getAttribute('data-ext')==='.webm') {
            if (pref[embed_mode].thumbnail[inline_or_hover].webm && !from_initial) {
              if (hover_ex && hover_ex.src===src) {
                pn = hover_ex;
                hover_ex = null;
                pn.style.position = null;
                pn.style.top = null;
                pn.style.right = null;
                pn.style.pointerEvents = null;
    //            pn.play();
              } else {
                var pn = document.createElement('video');
                pn.controls = true;
                pn.autoplay = true;
                //  <video controls="" loop="" autoplay="" class="expandedWebm" src="xxx.webm" style="max-width: 957px; max-height: 587px;"></video> // 4chan
              }
  if (!pref.test_mode['63']) {
              pn.loop  = pref[embed_mode].thumbnail[inline_or_hover].webm_loop;
              pn.muted = pref[embed_mode].thumbnail[inline_or_hover].webm_mute;
  }
            } else return null;
          }
          pn.src = src;
          pn.style.width = 'auto';
          pn.style.height = 'auto';
          if (pref[embed_mode].thumbnail[inline_or_hover].limit_width)  pn.style.maxWidth  = (document.documentElement.clientWidth  - pref[embed_mode].thumbnail[inline_or_hover].margin_width)  + 'px';
          if (pref[embed_mode].thumbnail[inline_or_hover].limit_height) pn.style.maxHeight = (document.documentElement.clientHeight - pref[embed_mode].thumbnail[inline_or_hover].margin_height) + 'px';
          return pn;
        }
        function expand_thumbnail_inline(e, from_initial){
          var mode = get_mode(e || {currentTarget:this});
          if (pref[embed_mode].expand_thumbnail_inline && image_expanding.indexOf(this)==-1) {
            var img_ex = clone_img(this, null, mode, 'inline', from_initial);
            if (!img_ex) {expand_thumbnail_on_demand_set.call(this);return;}
  //          if (!img_ex) return;
            if (img_ex.tagName!=='VIDEO') {
              img_ex.style.display = 'none';
              img_ex.addEventListener('load',expand_thumbnail_inline_load, false);
              this.style.opacity = 0.5;
            }
            this.parentNode.insertBefore(img_ex,this.nextSibling);
  //          this.onclick = null; // can't track event accurately because 'on demand expand' mode adds click event to images which have a native expansion event.
            image_expanding.push(img_ex);
            
            if (e) e.preventDefault();
            if (img_ex.tagName==='VIDEO') {
              expand_thumbnail_inline_load.call(img_ex);
              img_ex.play(); // may be diverted from image_hover
            }
          }
        }
        function expand_thumbnail_inline_load(){
          this.previousSibling.style.display = 'none';
          this.style.display = '';
          this.previousSibling.style.opacity = '';
          this.removeEventListener('load',expand_thumbnail_inline_load, false);
          this.onclick = shrink_thumbnail_inline;
          if (site2[site.nickname].format_expanded_thumbnail) site2[site.nickname].format_expanded_thumbnail(this);
          var idx = image_expanding.indexOf(this);
          if (idx>=0) image_expanding.splice(idx,1);
  
          if (site.patch.expand_thumbnail_inline_load) site.patch.expand_thumbnail_inline_load.call(this);
          expand_thumbnail_on_demand_set.call(this);
        }
        function expand_thumbnail_on_demand_set(){
          if (pref[embed_mode].expand_thumbnail_inline && (pref[embed_mode].expand_thumbnail_initial || pref[embed_mode].expand_thumbnail_inline_all_after)) {
            var img_next = site2[site.nickname].get_next_image(this,get_now_height()); // now_height for jump scroll
            if (img_next && img_next.style.display!=='none') expand_thumbnail_on_demand(img_next);
          }
        }
        function expand_thumbnail_on_demand(img){
          var ref_height = get_ref_height(pref[embed_mode].thumbnail.inline.ref_height/100);
          var offsetTop;
          if (Array.isArray(img)) {
            var tgt;
            var nowHeight = get_now_height();
            for (var i=0;i<img.length;i++) {
              var ot = img[i].offsetTop;
              if (ot>=nowHeight && ot<offsetTop || i===0) {
                tgt = img[i];
                offsetTop = ot;
              }
            }
            img = tgt;
          } else offsetTop = img.offsetTop;
          if (offsetTop<ref_height || !pref[embed_mode].thumbnail.inline.ondemand) {
            image_expand_on_demand_instance = null;
            expand_thumbnail_inline.call(img, null, true);
          } else image_expand_on_demand_instance = img;
        }
        function expand_thumbnail_queue_add(img){
          if (!image_expand_on_demand_instance) image_expand_on_demand_instance = img;
          else if (Array.isArray(image_expand_on_demand_instance)) image_expand_on_demand_instance[image_expand_on_demand_instance.length] = img;
          else image_expand_on_demand_instance = [image_expand_on_demand_instance, img];
          show_catalog_cont(); // patch, delayed 200ms
        }
        function shrink_thumbnail_inline(e){
  //        this.previousSibling.onclick = expand_thumbnail_inline;
          this.previousSibling.style.display = '';
          e.preventDefault();
          
          if (this.getAttribute('data-originalWidth')) {
            var pnode = this.parentNode.parentNode;
            pnode.style.width = this.getAttribute('data-originalWidth');
          }
          this.parentNode.removeChild(this);
        }
        return {
//          get_mode: function(e){return e.currentTarget===site.popup_body? 'page' : embed_mode;},
          image_hover_add: image_hover_add,
          image_hover_remove: image_hover_remove,
          image_hover_reentry: function(img, mode){
            if (!mode) mode = embed_mode; // TEMPORAL PATCH. all reentry func in GIH must be revised.
            if (hover_ex && hover_ex.src===img.src) hover_ex.src = clone_img_make_src(img, mode);
          },
          image_hover_snatch: image_hover_snatch,
          image_hover_snatch_end: image_hover_snatch_end,
          get hover_ex(){return hover_ex;},
          expand_thumbnail_inline: expand_thumbnail_inline,
          expand_thumbnail_on_demand: function(){
            if (image_expand_on_demand_instance) expand_thumbnail_on_demand(image_expand_on_demand_instance);
          },
          expand_thumbnail_queue_add: expand_thumbnail_queue_add,
        };
      })();
//      function image_hover_add(e,src){
//        DIH.image_hover_add.call(this,e,src);
//      }
      cataLog.DIH = DIH;
//      cataLog.image_hover_add = image_hover_add;
      cataLog.image_hover_reentry = DIH.image_hover_reentry;

      function get_name_recursive(pn){
        while (pn && !pn.name) pn = pn.parentNode;
        return pn && pn.name;
      }
      function click_thread_tn(e){
        if (pref[embed_mode].click==='none') return;
        e.preventDefault();
        if (pref[embed_mode].click_area==='entire') return;
        click_thread(get_name_recursive(this), (this.classList.contains(pref.script_prefix+'_link'))? this.getAttribute('href') : null);
      }
      function click_thread_whole(){
        if (pref[embed_mode].click_area==='entire') click_thread(this.name);
      }
      function click_thread(name, url){
        if (url) open_new_thread((url==='force')? null : url, name);
        else if (pref[embed_mode].click==='open') open_new_thread(null, name);
        else if (threads[name][18]!=='catalog' && pref[embed_mode].click==='expand') expand_shrink_thread(name);
      }
      function click_link(e){
        e.preventDefault();
        if (this.href) open_new_thread(this.href, get_name_recursive(this));
      }
//      function click_thread(name){
//        if (typeof(name)==='object') name= this.name;
//        var name = this.name;
//        if (pref.click=='expand') expand_shrink_thread(name);
//        else open_new_thread(threads[name][7], name);
//      }

      function add_open_new_thread_event(name,args){
        for (var i=0;i<args.length;i++) {
          var elem = args[i][0];
          var url  = args[i][1];
          var func = function(){open_new_thread(url, name);if (pref[embed_mode].click==='expand') expand_shrink_thread(name);};
          elem.addEventListener('click', func, false);
          args[i][1] = func;
        }
        return args;
      }
      function remove_open_new_thread_event(args){
        for (var i=0;i<args.length;i++) args[i][0].removeEventListener('click', args[i][1], false);
        return null;
      }
      function get_mark_time(name,time,list,watch, extra_format){
        if (watch) {
          var date_mark = pref_func.merge_obj5(name,pref.catalog.filter.watch_list_obj2,{hit:false});
          if ('time' in date_mark) return (extra_format)? -date_mark.time : date_mark.time;
        }
        if (list) {
          date_mark = pref_func.merge_obj5(name,pref.catalog.filter.list_obj2,{hit:false});
          if ('time' in date_mark) return date_mark.time;
          else if (date_mark.hit) return 0;
        }
        if (time && pref.catalog.filter.time_str!=='') return Date.parse(pref.catalog.filter.time_str);
        else return 0;
      }
//      function get_mark_time(name){
//        var date_mark = -1;
////        if (pref.catalog.filter.time_mark) date_mark = Date.parse(pref.catalog.filter.time_mark_str) - pref.localtime_offset*3600000;
//        if (pref.catalog.filter.time_mark) date_mark = Date.parse(pref.catalog.filter.time_str) - pref.localtime_offset*3600000;
//        if (pref.catalog.filter.list_mark_time) {
//          var time_list = catalog_filter_query_time_list(name)[1];
//          if (time_list) date_mark = time_list;
//        }
//        return date_mark;
//      }
      function open_new_thread(url, name){
        var dbt = common_func.fullname2dbt(name);
        if (threads[name][16].archiveFile) url = site2[(pref.archive.open_local)? site.nickname : dbt[0]].make_url4([site.nickname, site.board, '0','page_html'])[0];
//        if (threads[name][16].archiveFile) url = site2[dbt[0]].make_url4(common_func.name2dbt(name).slice(0,2).concat(['0','page_html']))[0];
        else {
          if (url===null) {
            url = site2[dbt[0]].make_url4(common_func.name2dbt(name))[0]; // temporal
            if (pref.catalog_open_last50!=='no') {
              var short_link = document.createElement('div');
              short_link.innerHTML = site2[dbt[0]].short_link(name, threads[name][8][2], null, '', '');
              var as = short_link.getElementsByTagName('a');
              for (var i=0;i<as.length;i++) {
                if (pref.catalog_open_last50==='exist' || !(threads[name][19][0]&0x000c0000) || (parseInt(as[i].textContent,10)>(threads[name][19][1]&0x0000ffff))) {
                  url = as[i].getAttribute('href');
                  break;
          }}}}
        }
//////////        if (url===null) url = site2[threads[name][16].dbt[0]].make_url3(threads[name][16].dbt[1], threads[name][16].dbt[2], '0'); // temporal // working code.
////////        if (url===null) url = site2[threads[name][16].dbt[0]].make_url4(common_func.name2dbt(name))[0]; // temporal
////////        if (typeof(url)==='string') url = [url];
////////        var idx = 0;
////////        var unread50 = (threads[name][19][0]!==0 && threads[name][19][2]<=50);
////////        if      (pref.catalog_open_last50==='no')    idx = 0;
////////        else if (pref.catalog_open_last50==='exist') idx = url.length-1;
////////        else if (pref.catalog_open_last50==='exist_watch') idx = (unread50)? url.length-1 : 0;
////////        else {
////////          var dbt = common_func.fullname2dbt(name); // patch
////////if (dbt[0]==='8chan' || dbt[0]==='lain') { // patch.
////////          if (url.length==1 && threads[name][8][2]>100) url[1] = url[0].replace(/.html/,'+50.html');
////////          if (pref.catalog_open_last50==='speculative') idx = (threads[name][8][2]>100)? url.length-1 : 0;
////////          else if (pref.catalog_open_last50==='spec_watch') idx = (unread50)? url.length-1 : 0;
////////}
////////        }
////////        url = url[idx];

//console.log(url);
//        var cw = window.open(url,(pref.catalog_open_in_new_tab)? '_blank' : '_self');
        var window_name = (site.embed_frame_win)? site.embed_frame
                        : (pref.catalog_open_where==='named')? name + ((threads[name][16].archiveFile)? 'A' : '')
                        : (pref.catalog_open_where==='_blank')? name + '_' + Date.now() : pref.catalog_open_where;
//                        : (pref.catalog_open_in_new_tab)? ((pref.catalog_use_named_window)? name : '_blank') : '_self';
        var time_marked = (pref[embed_mode].mark_new_posts)? get_watch_time_of_a_thread(name,threads[name][8][1], null, true) : 0;
        var message = ['MARK',time_marked];
        if (!site2[site.nickname].historyAPI || !site2[dbt[0]].historyAPI || !pref.pref2.meguca.historyAPI) {
          var cw = window.open(url,window_name);
          send_message(window_name, message,cw);
          if (pref.uip_tracker.on && pref.uip_tracker.annotate) {
            var lth = liveTag.mems.getFromName(name);
            if (lth.sID && lth.sID.h) send_message(window_name, ['UIP',lth.sID.h]);
          }
          if (threads[name][16].archiveFile) {
            var file = threads[name][16].archiveFile;
            send_message(window_name, ['ARCHIVER',['SUB_INIT',(file==='IDB')? {IDB:true, domain:dbt[0], board:(pref.test_mode['80'])? dbt[1].slice(0,-5)+'/' : dbt[1], no:dbt[2]} : // cut '_IDB'
                                                                              {name:file.name, size:file.size, lastModified:file.lastModified, files_sel:pref.archive.files_sel} ]]);
          }
        } else {
          if (site2[site.nickname].historyAPI_blocking) return; // patch for meguca, killing click, but this is dangerous.
          send_message_emu.push(message);
        }
        if (pref.catalog.auto_watch) triage_exe_0(name,'WATCH','',true);
      }
      function mark_read_thread(name,read){
        if (read) site2['DEFAULT'].check_reply.set_watched_to_last(threads[name][19], (threads[name][8][4]||threads[name][8][0]), name);
        else site2['DEFAULT'].check_reply.set_unwatch(threads[name][19]);
        if (pref.liveTag.style) liveTag.update_ur(name,0,true);
//        site2[cnst.name2domainboardthread(name,true)[0]].insert_footer2(threads[name][0],threads[name][18],threads[name][19],threads[name][8]);
        Footer.update_force(name);
//        if (reorder_thread_idx(name)) show_catalog(name); // called in triage_exe
        if (pref.notify.favicon) notifier.favicon.set(threads);
      }

      var show_catalog_init_funcs;
      var show_catalog_scroll_lock = (function(){
        var marks = null;
//        var set = Watchdog.prototype.restart.bind(new Watchdog(scroll_back, 5));
        var wdg  = new Watchdog(scroll_back, 5);
        var wdg2 = new Watchdog(tgt_lock_calcel, 100); // 500ms scroll lock and watchdog for oscillation.
        var set = Watchdog.prototype.restart.bind(wdg);
//        var last_viewed = null;
        function tgt_lock_calcel(){
          wdg.cancel();
          marks = null;
        }
        function scroll_back(){
          var mark_top = marks[0].offsetTop || 0;
          var abs_top = mark_top - marks[1] + marks[2];
          if (abs_top<0) abs_top = 0;
          if (!mark_top || get_now_height()===abs_top) { // may cause oscillation
//            marks = null;
//             wdg2.stop(); // scroll lock
            return;
          }
          window.scrollTo(0, abs_top);
          set();
        }
        var last_viewed = null;
        function start(pn){
          if (marks===null || pn) {
//            if (marks && pn) scroll_back();
            if (!pn) {
              pn = (wdg2.id)? last_viewed : // scroll locked
                              cataLog.general_event_handler.get_last_viewed() || last_viewed; // return null when initial or deleted
              if (!pn) return;
            }
            marks = [pn, pn.offsetTop, get_now_height()];
            last_viewed = pn;
////            if (last_viewed) { // working code.
////              marks = [last_viewed, last_viewed.offsetTop, get_now_height()];
////              set();
////            }
//            var now_height = get_now_height();
//            var last_top; // working code.
//            if (last_viewed) last_top = last_viewed.offsetTop;
//            if (last_viewed && last_top >= now_height && last_top <= now_height + window.innerHeight) marks = [last_viewed, last_top, now_height];
//            else { // scrolled
//              var posts = (embed_mode==='thread')? site2[site.nickname].wrap_to_parse.get(document, site.nickname, site.board, 'thread_html', {thread:site.no})[0].posts :
//                                                   site2[site.nickname].wrap_to_parse.get(document, site.nickname, site.board, 'page_html', {page:0})[0].posts;
//              var step = posts.length >> 1;
//              var i = 0;
//              while (step>0) {
//                if (posts[i+step].pn.offsetTop<now_height) i += step;
//                step >>= 1;
//              }
//              while (i<posts.length-1 && posts[i].pn.offsetTop<now_height) i++;
//              marks = [posts[i].pn, posts[i].pn.offsetTop, now_height];
//            }
          }
          wdg2.restart();
          set();
        }
        return {
          modified: function(tgt){
//            start((tgt.pn && marks[0]===tgt.pn)? site2[site.nickname].general_event_handler[site.whereami].get_prev_mark(tgt.pn) : null); // fail if get_prev_mark returns undefined;
            if (tgt.pn && marks && marks[0]===tgt.pn) {
              scroll_back();
              marks = null; // get_prev_mark may return undefined
//              start(site2[site.nickname].general_event_handler[site.whereami].get_prev_mark(tgt.pn));
              start(site2[site.nickname].general_event_handler[site.whereami].get_mark_from_height(tgt.pn.offsetTop));
              cataLog.general_event_handler.clear_last_viewed();
            } else start();
          },
          set: start,
//          viewed: function(tgt){if (!marks) last_viewed = tgt;},
//          viewed: function(tgt){
//            if (!wdg2.id)
//              last_viewed = tgt;}, // scroll lock
        }
      })();
      cataLog.show_catalog_scroll_lock = show_catalog_scroll_lock;
      var drawn_idx = 0;
      var show_catalog_cont = new DelayBuffer(show_catalog_delayed, 200).get_binded_delayed_do();
      cataLog.show_catalog_cont = show_catalog_cont;
      function show_catalog_delayed(){
        ref_heights = null;
        if (drawn_idx!==true) show_catalog();
        else if (cataLog.catalog_obj2.lazy_draw) cataLog.catalog_obj2.lazy_draw();
        cataLog.DIH.expand_thumbnail_on_demand();
      }
      var ref_heights = null;
      function get_ref_height(threshold){
        if (!threshold) threshold = 1.5;
//        return (embed_embed)? brwsr.document_body.scrollTop + window.innerHeight * threshold // slow.
//                            : triage_parent.scrollTop + triage_parent.clientHeight * threshold;
        if (!ref_heights) ref_heights = {scrollTop: (scroll_event_src===window)? brwsr.document_body.scrollTop : scroll_event_src.scrollTop,
                                         innerHeight: (scroll_event_src===window)? window.innerHeight : scroll_event_src.clientHeight}; // BUG, NEED TO ADD EVENTLISTENER TO TRIAGE_PARENT.'resize'.
        return ref_heights.scrollTop + ref_heights.innerHeight * threshold;
      }
      cataLog.get_ref_height = get_ref_height;
      function get_now_height(){
        return (embed_embed)? brwsr.document_body.scrollTop : triage_parent.scrollTop;
      }
      function scopy_th(th){
         var dst = {posts:[], __proto__:th};
         for (var i=0;i<th.posts.length;i++) dst.posts[i] = {__proto__:th.posts[i]};
         return dst;
      }
var debug_str2;
//      function show_catalog(tgts_in,sound){
    var catalog_obj2_proto = {
      show_catalog: function(tgts_in,sound){
//        if (this.masked) {this.updated_but_masked = true; return;} // test patch for meguca.
if (pref.debug_mode['11']) {
  var debug_str = threads_idx_debug(drawn_idx, this.drawn_y, this.ref_count, threads_idx);
}
if (pref.test_mode['23']) drawn_idx = 0;
        var draw_on_demand = pref[embed_mode].draw_on_demand && this.permit_draw_on_demand;
        var draw_adaptive = draw_on_demand && pref.network.adaptive;
        var draw_count = 0;
        if (draw_on_demand) {
          var ref_height = get_ref_height((pref[cataLog.embed_mode].merge)? 4 : (draw_adaptive)? ((show_catalog_db_th20.id!==null)? 0.2 : 1) : 1.5);
          if (drawn_idx!==0 && this.drawn_y>=ref_height)
            if (triage_parent.offsetHeight<this.drawn_y) drawn_idx = 0; // for expanding posts or images.
            else return;
//          if (drawn_idx!==0 && this.drawn_y>=ref_height) return;
        }
        if (pref[embed_mode].scroll_lock) show_catalog_scroll_lock.set();
        var tgts;
        if (typeof(tgts_in)==='string') {
          tgts = {};
          tgts[tgts_in] = null;
//        } else if (Array.isArray(tgts_in)) {
//          tgts = {};
//          for (var i=0;i<tgts_in.length;i++) tgts[tgts_in[i]] = null;
        } else tgts = tgts_in;
//        if (embed_catalog) {show_catalog_native();return;}
//        if (tgts) for (var name in tgts) if (threads[name] && threads[name][0].parentNode) threads[name][0].parentNode.removeChild(threads[name][0]); // this is required when the thread is moved to later. // THIS CAUSES A BLINK.
////////        catalog_triage_out();
        var triage_thread = triage.get_triaged_thread_name();
//        pref_func.tooltips.hide();
        var catalog_expand_with_hr = (embed_mode==='float' && pref.catalog_expand_with_hr) || pref[embed_mode].env.disp_filler;
        if (tgts!==undefined) for (var i=0;i<drawn_idx;i++) if (threads_idx[i] in tgts) {drawn_idx = i;break;}
        this.ref_count_init = pref[embed_mode].env.disp_offset;
        if (catalog_expand_with_hr) this.ref_count_init = show_catalog_skip_hs(this.ref_count_init);
        if (!draw_on_demand || drawn_idx===0 || drawn_idx===true) {
          this.func_track_reset(); // called with drawn_idx===true from 'release_draw'.
//          if (tgts===undefined) cataLog.Footer.timestamp_inc();
          cataLog.Footer.timestamp_trial_prep();
        }
        var load_tgt = '';
//        this.drawn_idx_mb = -1;
//        var appeared = [];
//var debug = '';
//for (var d=0;d<threads_idx.length;d++) if (threads_idx[d]!=='ODL:' && threads[threads_idx[d]][9][0]) debug += threads_idx[d] + ', ';
//console.log(debug);
        var i=0;
        var i_start = drawn_idx;
        var mode_merge_tails = (pref[cataLog.embed_mode].merge_list && pref.proto.merge_first && !pref[cataLog.embed_mode].merge)? null : false;
        var lazy_step = pref[cataLog.embed_mode].lazyDraw.step;
        var lazy_check = false;
//        var i_start = (draw_on_demand && drawn_idx!==true)? drawn_idx : 0;
        while (i<threads_idx.length) {
//console.log(this.drawn_y+', '+triage_parent.scrollTop+', '+triage_parent.clientHeight*1.5+', '+ref_height);
          var name = threads_idx[i];
          if (name.substr(0,4)==='ODL:') {
            if (load_tgt==='') {
              load_tgt = name;
              if (load_on_demand.call([load_tgt.substr(4)])) threads_idx.splice(i,1);
              break;
            }
          } else {
            if (draw_on_demand && this.drawn_y>=ref_height) {
              if (!this.lazy_draw || mode_merge_tails===false) {cataLog.Footer.timestamp_inc(); break;}
              if (mode_merge_tails===null) mode_merge_tails = i + 1; // be true
              if (!site2['DEFAULT'].update_posts_merge_bases.isShownForTails(name)) {i++;continue;}
            }
            if (tgts==='END' && mode_merge_tails===false) break;
            if (i>=i_start) {
              if (i%lazy_step===0) lazy_check = true;
              if (draw_on_demand || tgts===undefined || name in tgts) {
                if (threads[name][9][0]===null) threads[name][9] = catalog_filter_query(name, true);
                if (threads[name][9][0] && embed_mode==='page' && !pref.test_mode['52']) format_html.replace_posts_by_search(threads[name]); // may change threads[name][9][0]
                if (threads[name][9][0]) {
                  if (!threads[name][0] || threads[name][16].th) {
                    insert_thread_prepare_html_lazy(threads[name], !threads[name][0], false, true);
                    if (draw_adaptive) {
                      if (++draw_count==pref.network.th100) {
                        ref_height = get_ref_height(1);
                        show_catalog_db_th100.delayed_do();
                      } else if (draw_count===pref.network.th20) {
                        ref_height = get_ref_height(0.2);
                        show_catalog_db_th100.cancel();
                        show_catalog_db_th20.delayed_do();
                        draw_adaptive = false; // close
                      }
                    }
                  }
                  cataLog.Footer.draw(name);
                  if (mode_merge_tails) {
                    if (!threads[name][1]) if (this.func_show(name,null,catalog_expand_with_hr)) threads[name][1] = true;
                    i++;
                    continue;
                  }
////                  if (tgts!==undefined) { // working code.
////                    ref_count = 0;
////                    for (var j=0;j<i;j++) if (threads_idx[j].substr(0,4)!=='ODL:' && threads[threads_idx[j]][1]) ref_count++;
////                  }
////                  if (catalog_expand_with_hr) {
////                    var j = 0;
////                    var j_max = triage_parent.childNodes.length;
////                    while (j<=ref_count && j<j_max) if (triage_parent.childNodes[j++].tagName!=='DIV') ref_count++;
////                  }
                  var ref;
                  if (tgts!==undefined) {
                    var j=i-1;
                    while (j>=0 && (threads_idx[j].substr(0,4)==='ODL:' || !threads[threads_idx[j]][1] || (this.func_search_ref && this.func_serach_ref(threads_idx[j])))) j--;
                    if (j>=0) {
                      ref = threads[threads_idx[j]][0].nextSibling;
                      if (catalog_expand_with_hr && ref) ref = ref.nextSibling;
                    } else ref = triage_parent.childNodes[this.ref_count_init];
//                    delete tgts[name];
//                    if (Object.keys(tgts).length===0) tgts='END';
                  } else ref = triage_parent.childNodes[this.ref_count];
                  if (ref!==threads[name][0] || !threads[name][1]) {
                    if (this.func_show(name,ref,catalog_expand_with_hr)) threads[name][1] = true;
                    if (triage_thread) {triage.off_delay();triage_thread=null;}
                  }
//                  if (this.lazy_draw) this.lazy_draw(name);
//                  if (this.lazy_draw) if (this.lazy_draw(name, get_ref_height(4)) this.backup_mb_state(i);
                  if (threads[name][1]) {this.func_track_shown(name, draw_on_demand && lazy_check); lazy_check = false;}
//                  if (threads[name][1]) { // working code.
//                    if (draw_on_demand) drawn_y = threads[name][0].offsetTop; // for faster execution. DOM function is too heavy.
//                    ref_count += this.ref_step;
//                    if (catalog_expand_with_hr) ref_count = show_catalog_skip_hs(ref_count);
//                  }
                } else if (threads[name][1]) {
                  if (pop_up_status[name]) pop_down_event(name);
//                  threads[name][11] = remove_open_new_thread_event(threads[name][11]);
                  if (this.func_hide(name,catalog_expand_with_hr)) threads[name][1] = false;
                  if (triage_thread) {triage.off_delay();triage_thread=null;}
                }
// BUG
//              } else {
////                var ref = triage_parent.childNodes[ref_count];
////                for (var name in tgts) if (threads[name] && ref===threads[name][0]) {ref.parentNode.removeChild(ref);break;} // this is required when the thread is moved to later. // threads[name] may not exist when it is snoop, that contains redundant threads.
//                while (1) {
//                  var flag = true;
//                  var ref2 = triage_parent.childNodes[ref_count];
//                  for (var name2 in tgts) if (threads[name2] && ref2===threads[name2][0]) {
//                    ref2.parentNode.removeChild(ref2);
//                    flag=false;
//                    break;
//                  } // this is required when the thread is moved to later. // threads[name] may not exist when it is snoop, that contains redundant threads.
//                  if (flag) break;
//                }
//                if (threads[name][9][0]) ref_count++; // name must proceed by the count of eliminated in above.  THIS IS A BUG.
// BUG
                if (tgts!==undefined) if (delete tgts[name] && Object.keys(tgts).length===0) tgts='END';
              }
            }
            i++;
          }
          if (triage_thread===name) triage_thread = null;
        }
        if (mode_merge_tails) i = mode_merge_tails -1;
        drawn_idx = (!draw_on_demand || i==threads_idx.length)? true : (i<i_start)? i_start : i;
        if (this.lazy_draw) this.lazy_draw();
//        if (this.drawn_idx_mb!=-1) this.restore_mb_state();
//        if (appeared.length!=0 && sound) notifier.appeared(appeared,threads);
//var str_debug = '';
//for (var d=0;d<threads_idx.length;d++) if (threads[threads_idx[d]][1] && threads[threads_idx[d]][9][0]) str_debug += threads_idx[d] + threads[threads_idx[d]][8][pref.catalog.indexing] + ',';
//console.log(str_debug);
////        if (catalog_expand_with_hr)
////          for (var i=triage_parent.childNodes.length-2;i>=0;i--)
////            if (triage_parent.childNodes[i].tagName==='HR' && triage_parent.childNodes[i+1].tagName==='HR') triage_parent.removeChild(triage_parent.childNodes[i+1]);
if (pref.debug_mode['11'] && embed_mode!=='thread' && !pref[embed_mode].merge) {
        var flag = -1;
        var d_count = 0;
        for (var d=0;d<i;d++) {
          if (threads_idx[d][0]!=='O' && threads[threads_idx[d]][1]) {
            var dbt = common_func.fullname2dbt(threads_idx[d]);
            var tgt,tgt_bt;
            if (embed_mode==='page' && site.nickname==='4chan') {
              tgt = triage_parent.getElementsByClassName('CatChan_thread')[d_count++];
              tgt_bt = site.board + tgt.id.substr(1);
            } else if (embed_mode==='page' && site.nickname==='8chan') {
              tgt = triage_parent.getElementsByClassName('CatChan_thread')[d_count++];
              tgt_bt = '/' + tgt.getAttribute('data-board') + '/' + tgt.id.substr(7);
            } else {
              tgt = triage_parent.childNodes[pref[embed_mode].env.disp_offset + d_count++];
              tgt_bt = (embed_mode==='page')? '/' + tgt.getAttribute('data-board') + '/' + tgt.id.substr(7) :
                                              tgt.getElementsByTagName('a')[0].getAttribute('href').replace('res/','').replace('.html','').replace(/.*lainchan.org/,'').replace(/.*8ch.net/,'').replace('thread/','').replace(/.*4chan.org/,'').replace(/.*meguca.org/,'').replace(/.*krautchan.net/,'').replace(/thread\-/,'');
              if (dbt[0]==='4chan' && embed_mode==='catalog') tgt_bt = tgt_bt.substr(0,tgt_bt.lastIndexOf('/'));
            }
            if (dbt[1]+dbt[2]!==tgt_bt) {
              var debug_str4='';
              for (var j=d+1;j<d+5;j++) debug_str4 += threads_idx[j]+', ';
              console.log('ERROR: '+d+', '+tgt_bt+', '+threads_idx[d]+': '+i+', '+debug_str4);
              flag = i;
            }
          }
        }
        var debug_str3 = threads_idx_debug(drawn_idx, this.drawn_y, this.ref_count, threads_idx);
        if (flag!=-1) {
          console.log('PREV: '+debug_str2);
          console.log('IN:   '+debug_str);
          for (var i=0;i<flag+5;i++) if (triage_parent.childNodes[i]) console.log(triage_parent.childNodes[i]);
          console.log('OUT:  '+debug_str3);
//          console.trace();
        } else {
//          console.log('OK: '+debug_str);
        }
        debug_str2 = debug_str3;
}
      },
      func_show: function(name,ref){
        triage_parent.insertBefore(threads[name][0],(ref && ref.parentNode===triage_parent)? ref : null); // if many threads are removed, ref refers horizontal splitter.
        return true;
      },
      func_hide: function(name){
        triage_parent.removeChild(threads[name][0]);
        return true;
      },
      func_track_shown: function(name, update_drawn_y){
        if (update_drawn_y) this.drawn_y = threads[name][0].offsetTop; // for faster execution. DOM function is too heavy.
        this.ref_count += this.ref_step;
      },
      func_track_reset: function(){
        this.ref_count = this.ref_count_init;
        this.drawn_y = 0;
        drawn_idx= 0; // temporal patch, should be this.drawn_idx
//        cataLog.Footer.timestamp_inc();
      },
//      backup_mb_state: function(idx){
//        if (this.drawn_idx_mb==-1) {
//          this.drawn_idx_mb = idx;
//          this.ref_count_mb = this.ref_count;
//        }
//      },
//      restore_mb_state: function(){
//        drawn_idx = this.drawn_idx_mb;
//        this.ref_count = this.ref_count_mb;
//      },
      permit_draw_on_demand: true,
      ref_step: 1,
      drawn_y: 0,
      ref_count: 0,
      ref_count_init: 0,
//      drawn_idx_mb: -1,
//      ref_count_mb: 0,
    };
      if (pref.test_mode['96'] && embed_mode==='catalog') { // test for faster execution, removes redundant queries of offsetTop
        catalog_obj2_proto = {
          func_track_shown: (function(func_org){
            return function(name, update_drawn_y){
             var y_old = this.drawn_y;
              var check_y = this.od_count%this.od_width==0;
              func_org.call(this, name, update_drawn_y && check_y);
              if (check_y && y_old==this.drawn_y) this.od_width++;
              this.od_count++;
            }
          })(catalog_obj2_proto.func_track_shown),
          func_track_reset: (function(func_org){
            return function(){
              func_org.call(this);
              this.od_count = 0;
            };
          })(catalog_obj2_proto.func_track_reset),
          func_od_reset: function(){
            this.od_width = 1;
            show_catalog_cont();
          },
          od_width: 1, // on_demand_mode
          od_count: 0,
          __proto__: catalog_obj2_proto
        };
      }
      scroll_event_src.addEventListener('scroll', show_catalog_cont, false);
      window.addEventListener('resize', (pref.test_mode['96'] && embed_mode==='catalog')? catalog_obj2_proto.func_od_reset.bind(catalog_obj2_proto) : show_catalog_cont, false);
      var catalog_obj2 = catalog_obj2_proto;
      if (embed_mode==='page' && site2[site.nickname].all_boards && site2[site.nickname].all_boards.indexOf(site.board)!=-1) { // PATCH
        catalog_obj2 = {
          func_show: function(name){
            var ch = threads[name][0];
            if (ch.previousSibling && ch.previousSibling.tagName==='H2') {
              ch.previousSibling.style.display = '';
              ch.style.display = '';
              return true;
            } else return false;
          },
          func_hide: function(name){
            var ch = threads[name][0];
            if (ch.previousSibling && ch.previousSibling.tagName==='H2') {
              ch.previousSibling.style.display = 'none';
              ch.style.display = 'none';
              return true;
            } else return false;
          },
          permit_draw_on_demand: false,
          __proto__: catalog_obj2_proto
        }
////////      } else if (pref[embed_mode].merge) { // TEST // working code, but very slow because of basesd on HTML.
////////        var base_name = site.nickname + site.board + site.no;
////////        catalog_obj2 = {
////////          func_show_hide: function(name, show_or_hide){
////////            if (embed_mode==='thread' && base_name===name) return true;
////////            var myself = site2[site.nickname].update_posts_prep_merge();
////////            var dst = myself.posts;
////////            var pnode = myself.pn;
////////            var dbt = name.split('/');
////////            var posts = threads[name][16].posts;
////////            var src = {domain:dbt[0], board:dbt[1], no:dbt[2], posts:posts};
////////            if (show_or_hide) {
//////////////////              var j = dst.posts.length-1;
//////////////////              var i = posts.length-1;
//////////////////              while (i>=0) {
//////////////////                while (j>0 && dst.posts[j].time>posts[i].time) j--;
//////////////////                if (dst.posts[j].com===posts[i].com) break;
//////////////////                else i--;
//////////////////              }
//////////////////              while (++i<posts.length) {
//////////////////                while (j<dst.posts.length && dst.posts[j].time<posts[i].time) j++;
//////////////////                site2[site.nickname].update_posts_insert(src, dst, i, j, pnode);
//////////////////              }
////////////              var time_merged = threads[name][16].time_merged || 0; // working code.
////////////              var i = 0;
////////////              var j = 0;
//////////////              var scroll_add = 0;
//////////////              var now_height = (pref[embed_mode].scroll_lock && !init)? get_now_height() : 0;
//////////////              var now_height_tmp = now_height;
////////////              if (time_merged!==0) {
////////////                i = posts.length;
////////////                while (i>0 && posts[i-1].time>time_merged) i--;
////////////                j = dst.posts.length;
////////////                while (j>0 && dst.posts[j-1].time>time_merged) j--;
////////////              }
////////////              while (i<posts.length) {
////////////                while (j<dst.posts.length && (dst.posts[j].time<posts[i].time || dst.posts[j].time==posts[i].time && dst.posts[j].no<=posts[i].no)) j++;
////////////                site2[site.nickname].update_posts_insert(src, dst, i++, j, pnode);
//////////////                var add_val = site2[site.nickname].update_posts_insert(src, dst, i++, j, pnode, now_height_tmp); // slow
//////////////                if (add_val!==null) scroll_add += add_val;
//////////////                else now_height_tmp = 0;
////////////                if (pref[embed_mode].scroll_lock) show_catalog_scroll_lock.modified(src.posts[i-1]);
////////////              }
////////////              threads[name][16].time_merged = posts[posts.length-1].time;
//////////////              if (scroll_add) window.scrollTo(0,now_height + scroll_add);
////////              site2[site.nickname].update_posts_insert_merge(src.posts,0);
////////            } else {
//////////              var back = 0;
//////////              var now_height;
//////////              if (pref[embed_mode].scroll_lock) now_height = get_now_height();
////////              for (var i=posts.length-1;i>=0;i--) {
//////////                if (pref[embed_mode].scroll_lock) if (src.posts[i].offsetTop<now_height) back += src.posts[i].offsetHeight; // TEST, SHOULD INCLUDE container.
////////                if (src.posts[i].pn) site2[site.nickname].update_posts_remove(src, i, pnode, true);
////////              }
//////////              if (back) window.scrollTo(0,now_height-back);
////////              threads[name][16].time_merged = 0;
////////            }
////////            return true;
////////          },
////////          func_show: function(name){if (!threads[name][1]) this.func_show_hide(name, true); return true;},
////////          func_hide: function(name){if ( threads[name][1]) this.func_show_hide(name, false);return true;},
////////          permit_draw_on_demand: false,
////////          __proto__: catalog_obj2_proto
////////        }
////////        if (embed_mode==='page') {
////////          var top = site2[site.nickname].wrap_to_parse.get(document, site.nickname, site.board, 'page_html', {page:0})[0];
////////          catalog_obj2.base_name = site.nickname + site.board + top.no;
////////          site2['DEFAULT'].update_posts_merge_base = top.pn;
////////        }
//////////        if (pref[embed_mode].scroll_lock && site2[site.nickname].update_posts_remove_lock) {// TEST // TOO SLOW
//////////          site2[site.nickname].update_posts_remove = site2[site.nickname].update_posts_remove_lock;
//////////          site2[site.nickname].update_posts_insert = site2[site.nickname].update_posts_insert_lock;
//////////        }
////////        show_catalog_init_funcs = (embed_mode==='page')? function(){
////////          for (var name in threads)
////////          if (threads[name][0]!==site2['DEFAULT'].update_posts_merge_base && threads[name][0].parentNode===triage_parent) {
////////            if (threads[name][0].nextSibling.tagName==='HR') triage_parent.removeChild(threads[name][0].nextSibling);
////////            triage_parent.removeChild(threads[name][0]);
////////            catalog_obj2.func_show_hide(name, true);
////////          }
////////        } : null;
      } else if (pref[embed_mode].env.disp_filler) {
        catalog_obj2 = catalog_obj2_factory_filler((pref[embed_mode].env.disp_filler[0]==='<')? document.createElement('hr') : document.createTextNode(pref[embed_mode].env.disp_filler));
      } else if (embed_mode==='float' && pref.catalog_expand_with_hr) {
        catalog_obj2 = {
          func_show: function(name,ref){
            if (threads[name][1]) show_catalog_hr(name,'remove');
            triage_parent.insertBefore(threads[name][0],(ref && ref.parentNode===triage_parent)? ref : null); // if many threads are removed, ref refers horizontal splitter.
            show_catalog_hr(name,'add');
            return true;
          },
          func_hide: function(name){
            show_catalog_hr(name,'remove');
            triage_parent.removeChild(threads[name][0]);
            return true;
          },
          func_track_shown: function(name, update_drawn_y){
            this.__proto__.func_track_shown.call(this, name, update_drawn_y);
            this.ref_count = show_catalog_skip_hs(this.ref_count);
          },
          __proto__: catalog_obj2_proto
        }
//        var pctrls = triage_parent;
//        for (var i=pctrls.childNodes.length-1;i>=0;i--) if (pctrls.childNodes[i].tagName==='HR') pctrls.removeChild(pctrls.childNodes[i]);
//        pctrls.parentNode.insertBefore(document.createElement('hr'),pctrls.nextSibling);
      }
      function catalog_obj2_factory_filler(filler){
        return {
          func_show: function(name,ref){
            var hr = threads[name][1] && threads[name][0].nextSibling || this.filler.cloneNode(false); // for 4chan, lastChild.nextSibling === null.
//            var hr = (threads[name][1])? threads[name][0].nextSibling : this.filler.cloneNode(false);
            triage_parent.insertBefore(threads[name][0],ref);
            triage_parent.insertBefore(hr,ref);
            return true;
          },
          func_hide: function(name){
            triage_parent.removeChild(threads[name][0].nextSibling);
            triage_parent.removeChild(threads[name][0]);
            return true;
          },
          ref_step: 2,
          filler: filler,
          __proto__: catalog_obj2_proto
        };
      }
      var show_catalog = (catalog_obj2)? catalog_obj2.show_catalog.bind(catalog_obj2) :
                                         catalog_obj2_proto.show_catalog.bind(catalog_obj2_proto);
      cataLog.show_catalog = show_catalog;
      cataLog.catalog_obj2 = catalog_obj2;
      var show_catalog_db_th100 = new DelayBuffer(show_catalog, pref.network.th100_delay);
      var show_catalog_db_th20 = new DelayBuffer(show_catalog, pref.network.th20_delay);
      
function threads_idx_debug(idx,y,count, threads_idx){
  var str = 'drawn_idx:'+idx+', drawn_y:'+y+', ref_count:'+count+' ';
  for (var i=0;i<threads_idx.length;i++) if (!threads[threads_idx[i]] || threads[threads_idx[i]][1]) str += threads_idx[i]+', ';
  str += '::: '+JSON.stringify(threads_idx);
  return str;
}
      var load_on_demand = (function(){
        var mutex = true;
        var timer = null;
        function release(){
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          mutex = true;
        }
        return {
          call: function(tgts){
            if (this.get()) {
              threads_index.idx_delete_odl(tgts);
              scan_boards.scan_init('on_demand_load', tgts, {refresh:true, crawler_max:1, callback:load_on_demand.release_draw});
              return true;
            } else return false;
          },
          release: release,
          release_draw: function(){release();show_catalog();},
          get: function(){
            var retval = mutex;
            if (retval) timer = setTimeout(release, pref.catalog_load_on_demand_timeout*1000);
            mutex = false;
            return retval;
          }
        }
      })();

      function show_catalog_skip_hs(ref_count){
        var c_len = triage_parent.childNodes.length;
        var class_hs = pref.script_prefix+'_hs';
//        while (ref_count<c_len && triage_parent.childNodes[ref_count].className===class_hs) ref_count++;
        if (ref_count<c_len && triage_parent.childNodes[ref_count].className===class_hs) ref_count++;
        return ref_count;
      }
      function show_catalog_hr(name,func){
        if (embed_mode==='catalog') return;
        var pn = threads[name][0];
        var class_hs = pref.script_prefix+'_hs';
        if (func==='add' && pn.style.width==='' && pn.style.height==='') {
          if (pn.previousSibling && pn.previousSibling.className!==class_hs) pn.parentNode.insertBefore(site2[site.nickname].horizontal_separator_in_index(),pn);
          if (pn.nextSibling && pn.nextSibling.className!==class_hs) pn.parentNode.insertBefore(site2[site.nickname].horizontal_separator_in_index(),pn.nextSibling);
        }
        if (func==='shrink' || func==='remove' && pn.style.width==='' && pn.style.height==='' || func==='add' && (pn.style.width!=='' || pn.style.height!=='')) {
          var pn_test = (pn.previousSibling && pn.previousSibling.className===class_hs)? pn.previousSibling.previousSibling : null;
          if (pn_test && (pn_test.style.width!=='' || pn_test.style.height!=='')) pn.parentNode.removeChild(pn.previousSibling);
          var pn_test = (pn.nextSibling && pn.nextSibling.className===class_hs)? pn.nextSibling.nextSibling : null;
          if (pn_test && (pn_test.style.width!=='' || pn_test.style.height!=='')) pn.parentNode.removeChild(pn.nextSibling);
        }
        if (func==='remove') {
//          if (pn.previousSibling && pn.previousSibling.className===class_hs && pn.nextSibling && pn.nextSibling.className===class_hs) pn.parentNode.removeChild(pn.previousSibling); // BUG IN 8ch page mode, remoev first br and 'ref' becomes null.
          if (pn.previousSibling && pn.previousSibling.className===class_hs && pn.nextSibling && pn.nextSibling.className===class_hs) pn.parentNode.removeChild(pn.nextSibling);
//          if (pn.nextSibling && pn.nextSibling.className===class_hs && pn.nextSibling.nextSibling && pn.nextSibling.nextSibling.className===class_hs) pn.parentNode.removeChild(pn.nextSibling);
        }
      }

////      function show_catalog_hr(name,func){ // working code.
////        var pn = threads[name][0];
//////        var sibls = ['previousSibling', 'nextSibling'];
//////        if (pn.style.width==='' && pn.style.height==='') {
//////          for (var i=0;i<sibls.length;i++)
//////            while (pn[sibls[i]] && pn[sibls[i]].tagName==='HR' && pn[sibls[i]][sibls[i]].tagName==='HR') pn.parentNode.removeChild(pn[sibls[i]]);
////        if (func==='add' && pn.style.width==='' && pn.style.height==='') {
////          if (pn.previousSibling && pn.previousSibling.tagName!=='HR') pn.parentNode.insertBefore(document.createElement('hr'),pn);
////          if (pn.nextSibling && pn.nextSibling.tagName!=='HR') pn.parentNode.insertBefore(document.createElement('hr'),pn.nextSibling);
////        }
////        if (func==='shrink' || func==='remove' && pn.style.width==='' && pn.style.height==='' || func==='add' && (pn.style.width!=='' || pn.style.height!=='')) {
////          var pn_test = (pn.previousSibling && pn.previousSibling.tagName==='HR')? pn.previousSibling.previousSibling : null;
////          if (pn_test && (pn_test.style.width!=='' || pn_test.style.height!=='')) pn.parentNode.removeChild(pn.previousSibling);
////          var pn_test = (pn.nextSibling && pn.nextSibling.tagName==='HR')? pn.nextSibling.nextSibling : null;
////          if (pn_test && (pn_test.style.width!=='' || pn_test.style.height!=='')) pn.parentNode.removeChild(pn.nextSibling);
////        }
////        if (func==='remove') {
////          if (pn.previousSibling && pn.previousSibling.tagName==='HR' && pn.nextSibling && pn.nextSibling.tagName==='HR') pn.parentNode.removeChild(pn.previousSibling);
//////          for (var i=0;i<sibls.length;i++) {
//////            var pn_test = pn[sibls[i]][sibls[i]];
//////            if (pn_test.tagName==='DIV' && pn_test.style && (pn_test.style.width!=='' || pn_test.style.height!=='')) pn.parentNode.removeChild(pn[sibls[i]]);
//////          }
////        }
////      }

      function catalog_attr_set(name,pn){
        var tgt_th = threads[name];
        var val = null;
        if (pref.catalog.filter.attr_list) {
          if (pref.catalog.style_general_list) val = pref_func.merge_obj5(name,pref.catalog.style_general_list_obj2,val);
          if (pref.catalog.filter.attr_list)   val = pref_func.merge_obj5(name,pref.catalog.filter.attr_list_obj2,val);
        }
//        if (val && val.style) {
////          var styles = val.style.split(';');
////          for (var i=0;i<styles.length;i++) {
////            var stl = styles[i].split(':');
////            pn.style[stl[0]] = stl[1];
////          }
////console.log('catalog_attr_set :'+name+', '+val.toSource());
////          for (var stl in val)
////            if (stl.indexOf('style')==0) pn.style[stl.substr(6)] = val[stl];
////          for (var stl in val) {
////            if (stl.indexOf('style')==0 && stl.length>6) pn.style[stl.substr(6)] = val[stl];
////            if (stl.indexOf('style')==0 && stl.length>6) {
////              pn.setAttribute('style',pn.getAttribute('style')+stl.substr(6)+':'+val[stl]+';');
////              console.log('catalog_attr_set_1 :'+name+', '+pn.getAttribute('style')+';'+stl.substr(6)+val[stl]+':');
////            }
////          }
//          for (var stl in val.style) pn.style[stl] = val.style[stl];
        //        }
        if (tgt_th[0]) {
          var rollback_info = tgt_th[22];
          if (val && val.style) {
            for (var stl in val.style) {
              if (!(stl in rollback_info)) rollback_info[stl] = pn.style[stl];
              pn.style[stl] = val.style[stl];
            }
          }
          for (var stl in rollback_info) {
            if (!val || !val.style || !(stl in val.style)) {
              if (rollback_info[stl]===undefined) delete pn.style[stl];
              else pn.style[stl] = rollback_info[stl];
              delete rollback_info[stl];
            }
          }
        }
        if (val && val.cmd || tgt_th[16].icon_sticky || tgt_th[16].icon_show_always || tgt_th[16].systemSticky) {
          var sticky = !!((val && val.cmd && val.cmd['sticky']!==undefined)? val.cmd['sticky'] : tgt_th[16].systemSticky); // !! for ^
          if (sticky ^ tgt_th[20]) { // sticky
            tgt_th[20] = sticky;
            if (tgt_th[20] != tgt_th[16].icon_sticky) tgt_th[16].icon_sticky = site2[site.nickname].add_icon(tgt_th[0],tgt_th[16].type_html, 'sticky', tgt_th[16]);
          }
          if ((val && val.cmd && val.cmd['show']) ^ !!tgt_th[16].icon_show_always) { // show
            tgt_th[16].icon_show_always = site2[site.nickname].add_icon(tgt_th[0],tgt_th[16].type_html, 'show_always', tgt_th[16]);
            tgt_th[16].show_always = val.cmd['show']; // for lazy pn generation.
            tgt_th[9] = catalog_filter_query(name);
            if (show_catalog) show_catalog(name); // 'if (show_catalog)' is a patch.
          }
        }
      }
    
////      function catalog_obj_merge(name,obj,val){
////        var dbt = cnst.name2domainboardthread(name,true);
////        if (val===null) val = {hit:false};
////        val = catalog_obj_merge_1(val,obj,'DEFAULT');
////        val = catalog_obj_merge_1(val,obj,dbt[0]); // domain
////        val = catalog_obj_merge_1(val,obj,dbt[1]); // board
////        val = catalog_obj_merge_1(val,obj,dbt[0]+dbt[1]); // domain+board
////        val = catalog_obj_merge_1(val,obj,dbt[2]); // thread
////        val = catalog_obj_merge_1(val,obj,dbt[0]+dbt[2]); // domain+thread
////        val = catalog_obj_merge_1(val,obj,dbt[1]+dbt[2]); // board+thread
////        val = catalog_obj_merge_1(val,obj,name);
////        return val;
////      }
////      function catalog_obj_merge_1(val,obj,key){
////        if (obj[key]) {
////          for (var i in obj[key])
//////            if (val[i]===undefined || typeof(obj[key][i])!=='object') val[i] = obj[key][i];
//////            else for (var j in obj[key][i]) val[i][j] = obj[key][i][j]; // 2nd level.
////            if (typeof(obj[key][i])!=='object') val[i] = obj[key][i];
////            else {
////              if (val[i]===undefined) val[i]={};
////              for (var j in obj[key][i]) val[i][j] = obj[key][i][j]; // 2nd level.
////            }
////          val.hit = true;
////        }
////        return val;
////      }

      function filter_kwd_prep_init(e, kwd, init) {
        kwd.str_old = '';
        kwd.fail_list = {};
        kwd.suc_list  = {};
        filter_kwd_prep(e, kwd, init);
      }
      function filter_kwd_prep(e, kwd, init) {
        if (!kwd) kwd = pref.catalog.filter.kwd;
        kwd.rexps = common_func.kwd_prep_regexp(kwd);
//        kwd.timestamp = Date.now(); // not saved because pref.default() don't geenrate this.
        filter_kwd_active(e, kwd, init);
      }
      var filter_kwd_count = 0;
      function filter_kwd_active(e, kwd, init) {
        if (!kwd) kwd = pref.catalog.filter.kwd;
        var val_old = kwd.posts_active;
        var basic_active = kwd.use && kwd.rexps && (kwd.sub || kwd.name || kwd.com || kwd.file || kwd.meta);
        kwd.active       = basic_active && (kwd.op || kwd.post);
        kwd.posts_active = basic_active &&            kwd.post;
        pref4.search_posts_active_once |= kwd.posts_active;
        if (!init && !kwd.posts_active && val_old) format_html.posts_search_inactivated();
        kwd.timestamp = filter_kwd_count++; // not saved because pref.default() don't geenrate this. // use single entity for multi catalog or switching pref.*.filter object.
if (!pref.test_mode['59']) {
        if (e && e.target.name==='catalog.filter.kwd.str' && kwd.match===0 && (!kwd.re || /^[\w\s]*$/.test(kwd.str+kwd.str_old))) {
          for (var i in kwd.fail_list) {
            if (kwd.str.indexOf(kwd.fail_list[i])!==0) delete kwd.fail_list[i];
            else if (kwd.fail_list[i]===kwd.str) kwd.timestamp = i;
          }
          for (var i in kwd.suc_list) {
            if (kwd.suc_list[i].indexOf(kwd.str)!==0) delete kwd.suc_list[i];
            else if (kwd.suc_list[i]===kwd.str) kwd.timestamp = i;
          }
        } else {
          kwd.fail_list = {};
          kwd.suc_list  = {};
        }
        if (kwd.str) {
          kwd.fail_list[kwd.timestamp] = kwd.str;
          kwd.suc_list[kwd.timestamp]  = kwd.str;
        }
}
        if (!init) catalog_filter_changed();
      }
      var catalog_filter_query_keyword = (function(){
        function query_1(kwd, rexp, posts, domain, th){
          if (kwd.op) if (query_11(kwd, rexp, posts[0].DUMMY && th || posts[0], domain)) return true;
          if (kwd.post) for (var j=1;j<posts.length;j++) if (query_11(kwd, rexp, posts[j], domain)) return true;
          return false;
        }
//        function query_1(kwd, rexp, posts, domain, th){ // working code.
//          var post_array = Array.isArray(posts);
//          var start = (!post_array || kwd.op)? 0 : 1; // temporarily
//          var end   = ( post_array && kwd.post)? posts.length : 1; // tamporarily
//          for (var j=start;j<end;j++) {
//            var pst = (post_array)? posts[j] : (j==0)? posts : null;
//            if (pst && query_11(kwd, rexp, pst, domain)) return true; // if posts are not exist, th.posts becomes 'undefined'.
//          }
//          return false;
//        }
////        var com2txt_flag = false; // SLOW.
////        var com2txt_rexp = /<[^>]*>|&([#\w\d]*);/g
////        var com2txt_subs = {
////          gt : '>',
////          lt : '<',
////          amp: '&',
////          hellip: '\u2026',
////          larr: '\u2190',
////          rarr: '\u2192',
////          mdash: '\u2014',
////          ndash: '\u2013',
////          qout:'"', // 4chan
////          '#039':"'", // 4chan
////          '#044':',', // 4chan
////          '#44' :',', // 4chan
////        };
////        function com2txt(match,p1,offset,string){
////          if (match[0]==='&') {
////            var retval = com2txt_subs[p1];
////            if (retval) return retval;
////            com2txt_flag = true;
////            if (pref.debug_mode['17']) console.log('not interpreted html: '+match+', '+string);
////          }
////          return ' '; // case of <[^>]*> or not interpreetd.
////        }
        var pn_com = document.createElement('div');
//        var pn_com = document.createElement('textarea'); // preserve tags in HTML. // slower than div.
        function query_11(kwd, rexp, pst, domain){
          if (kwd.sub)  if (pst.sub  && rexp.test(pst.sub )) return true;
          if (kwd.name) if (pst.name && rexp.test(pst.name)) return true;
//          if (kwd.com)  if (pst.com) {
          if (kwd.com) {
            if (pst.parse_funcs && pst.parse_funcs.type_com==='txt' || pref.test_mode['53']) {
              if (rexp.test(pst.body || pst.com)) return true; // fastest, speed ratio: part/total = 1/1.
            } else {
//              if (!pref.test_mode['54']) {
////                if (!pref.test_mode['57']) {
                var txt = site2[domain].post_com2txt(pst); // 9.4/1.99 for lainchan, 13.07/2.38 for 4chan.
                if (txt) {
                  if (txt.search(/&[#\w\d]+;/)!=-1 && !pref.test_mode['58']) {
                    if (pref.debug_mode['17']) console.log('not interpreted html: '+txt);
                    pn_com.innerHTML = pst.com; // giving com is faster than giving txt.
                    txt = pn_com[brwsr.innerText];
                  }
                  if (rexp.test(txt)) return true;
                }
////                } else { // SLOW.
////                  com2txt_flag = false;
//////                  var txt = pst.com.replace(com2txt_rexp, com2txt); // StringReplaceGlobalRegexpWithfunction is heavy. 19.76/3.33
////                  var txt = pst.com.replace(/<[^>]*>|&([#\w\d]*);/g, com2txt); // This still outs StringReplaceGlobalRegexpWithfunction.
////                  if (com2txt_flag) {
////                    pn_com.innerHTML = pst.com;
////                    txt = pn_com[brwsr.innerText];
////                  }
////                  if (rexp.test(txt)) return true;
////                }
//              } else {
//                pn_com.innerHTML = (!pref.test_mode['55'])? pst.com :  // TOO SLOW!!!. 53.72/7.65
//                                                            pst.com.replace(/<[^>]*>/g,' ');  // TOO SLOW, FURTHER!!!. 60.51/8.21
//                if (rexp.test(pn_com[brwsr.innerText])) return true;
//              }
            }
          }
//          if (kwd.trip) if (pst.trip && kwd.test(pst.trip)) return true;
          if (kwd.file) {
            if (pst.filename && rexp.test(pst.filename)) return true;
            if (pst.extra_files)
              for (var k=pst.extra_files.length-1;k>=0;k--)
                if (pst.extra_files[k].filename && rexp.test(pst.extra_files[k].filename)) return true;
          }
          if (kwd.meta) if (pst.no && rexp.test(pst.no)) return true;
          return false;
        }
        return {
          kwd: function(kwd,posts, domain, th){
            if (!kwd.use || !kwd.rexps) return true;
//            var retval = kwd.match<2; // working code.
//            if (kwd.match%2===0) { // all
//              for (var i=0;i<kwd.rexps.length;i++) if (retval!==query_1()) return false;
//              return true;
//            } else {
//              for (var i=0;i<kwd.rexps.length;i++) if (retval===query_1()) return true;
//              return false;
//            }
            var all_or_any = kwd.match%2===0;
            var testval = !!((kwd.match<2) ^ all_or_any);
            for (var i=0;i<kwd.rexps.length;i++) if (testval===query_1(kwd, kwd.rexps[i], posts, domain, th)) return !all_or_any;
            return all_or_any;
          },
          kwd_1: function(kwd,posts, domain){ // for single post, match any or unmatch all.
            var match_or_unmatch = kwd.match<2; // match_or_unmatch
            for (var i=0;i<kwd.rexps.length;i++) if (query_11(kwd, kwd.rexps[i], posts, domain)) return match_or_unmatch; // match any or unamtch all
            return !match_or_unmatch;
          },
          kwd_make_result: function(posts, domain){
            var result = [Object.create(posts[0])]; // not to change source for 'posts_search_miss'. // BUG. wrapper just add protptpye to itself, it doesn't take this into account, but patched.
//            var result = [posts[0]]; // can't update omitted info in page mode.
            result[0].search_result = this.kwd_1(pref.catalog.filter.kwd, posts[0], domain);
            for (var i=1;i<posts.length;i++) if (this.kwd_1(pref.catalog.filter.kwd, posts[i], domain)) result[result.length] = posts[i];
            return (result.length!=1 || this.kwd_1(pref.catalog.filter.kwd, posts[0], domain))? result : null;
          }
        };
      })();
      cataLog.catalog_filter_query_keyword = catalog_filter_query_keyword;
//        for (var i=0;i<kwd.kwds.length;i++) { // OR
//          for (var j=start;j<end;j++) {
//            var pst = (post_array)? posts[j] : (j==0)? posts : null;
//            if (pst!==null) {
//              if (kwd.sub)  if (pst.sub  && kwd.kwds[i].test(pst.sub )) return retval;
//              if (kwd.com)  if (pst.com  && kwd.kwds[i].test(pst.com )) return retval;
//              if (kwd.name) if (pst.name && kwd.kwds[i].test(pst.name)) return retval;
//              if (kwd.trip) if (pst.trip && kwd.kwds[i].test(pst.trip)) return retval;
//              if (kwd.file) {
//                if (pst.filename && kwd.kwds[i].test(pst.filename)) return retval;
//                if (pst.extra_files)
//                  for (var k=pst.extra_files.length-1;k>=0;k--) 
//                    if (pst.extra_files[k].filename && kwd.kwds[i].test(pst.extra_files[k].filename)) return retval;
//              }
//            }
//          }
//        }
//        return !retval;
//      function catalog_filter_query_keyword(str_in){
//        if (!pref.catalog.filter.kwd.use) return true;
//        var kwd = pref.catalog.filter.kwd.str;
//        if (kwd==='') return true;
//        var str = ((pref.catalog.filter.kwd.op       )? str_in[0]+'\n' : '')
//                + ((pref.catalog.filter.kwd.op_sub   )? str_in[1]+'\n' : '')
//                + ((pref.catalog.filter.kwd.op_name  )? str_in[2]+'\n' : '')
//                + ((pref.catalog.filter.kwd.op_file  )? str_in[3]+'\n' : '')
//                + ((pref.catalog.filter.kwd.post     )? str_in[4]+'\n' : '')
//                + ((pref.catalog.filter.kwd.post_sub )? str_in[5]+'\n' : '')
//                + ((pref.catalog.filter.kwd.post_name)? str_in[6]+'\n' : '')
//                + ((pref.catalog.filter.kwd.post_file)? str_in[7]+'\n' : '');
//        if (str==='') return true;
//
//        var flag = true;
//        var kwds = kwd.split(' ');
//        for (var i=0;i<kwds.length;i++) {
//          if (kwds[i]==='') continue;
//          kwd = kwds[i];
//          if (!pref.catalog.filter.kwd.re) kwd = kwd.replace(/[\.\(\)\[\]\+\?\^\$\{\}]/g,'\\$&').replace(/\*/g,'.*');
//          if (pref.catalog.filter.kwd.ci) kwd = new RegExp(kwd,'i');
//          var result = (str.search(kwd)!=-1);
//          if (pref.catalog.filter.kwd.match==='unmatch') result = !result;
//          flag = flag & result;
//        }
//        return flag;
//      }
////////      function catalog_filter_query_tag(tags){ // working code.
//////////        if (!pref.catalog.filter.tag || filter_tags.length==0) return true;
////////        if (!pref.catalog.filter.tag) return true;
////////if (pref.test_mode['22']) {
////////        if (filter_tags.length==0) return false;
////////        if (!tags) return false;
//////////console.log(tags);
////////        for (var i=0;i<tags.length;i++)
////////          for (var j=0;j<filter_tags.length;j++)
////////            if (tags[i].search(filter_tags[j])!=-1) return true;
////////        return false;
////////} else {
////////        return liveTag.search_by_tags(tags);
////////}
////////      }
      function catalog_filter_query(name, no_reset){
        var tgt_th = threads[name];
        var val_old = tgt_th[9][0];
        tgt_th[9][0] = catalog_filter_query_1(name, tgt_th);
        if (!no_reset && val_old !== tgt_th[9][0]) drawn_idx = 0;
        return tgt_th[9];
      }
      function catalog_filter_query_1(name, tgt_th){
        if (tgt_th[16].show_always && !pref.catalog.filter.kwd.active) return true; // can't set 'tgt_th[16].icon_show_always' if (tgt_th[0]===null)
        if (pref.catalog.filter.tag) if (!liveTag.search_by_tags(tgt_th[17])) return false;
        if (pref.catalog.filter.time)          if ((tgt_th[8][4]||tgt_th[8][0])<=pref3.catalog.filter.time_obj) return false;
        if (pref.catalog.filter.time_creation) if ( tgt_th[8][1]               <=pref3.catalog.filter.time_obj) return false;
//        if (pref.catalog.filter.time) { // working code.
//          var time = Date.parse(pref.catalog.filter.time_str);
////          if (tgt_th[8][0]<=time && tgt_th[8][4]<=time) return [false];
//          if ((tgt_th[8][4]||tgt_th[8][0])<=time) {tgt_th[9][0] = false; return;}
//        }
        if (pref.catalog.filter.list && (!pref.catalog.filter.kwd.active || !pref.filter.disable_list_when_kwd_active)) { // use [1]
          var retval = catalog_filter_query_time_list(name);
          if (retval[0]===false) {tgt_th[9] = retval; return tgt_th[9][0];}
        }
//        else if (pref.catalog.filter.list_mark_time) [true, get_mark_time(name)];
        if (pref.catalog.filter.kwd.active) { // use [2],[3]
          var tgt_posts = tgt_th[16].recent_posts((pref.catalog.filter.kwd.post)? (pref[embed_mode].sourceOfSP==='auto'? -1 : null) : 0);
if (pref.test_mode['59']) { // BUG. THIS DOESN'T WORK WITH OTHER FILTERS, NEEDS TO BE SPLITTED. 
          if (!catalog_filter_query_keyword.kwd(pref.catalog.filter.kwd, tgt_posts, common_func.fullname2dbt(name)[0])) return false;
} else {
          if (!((pref.catalog.filter.kwd.fail_list[tgt_th[9][3]] && tgt_th[9][2]===false) ||
                (pref.catalog.filter.kwd.suc_list[tgt_th[9][3]]  && tgt_th[9][2]===true ))) {
            tgt_th[9][3] = pref.catalog.filter.kwd.timestamp;
            tgt_th[9][2] = catalog_filter_query_keyword.kwd(pref.catalog.filter.kwd, tgt_posts, common_func.fullname2dbt(name)[0]);
          } else {
            if (pref.debug_mode['18'] && tgt_th[9][2]!==catalog_filter_query_keyword.kwd(pref.catalog.filter.kwd, tgt_posts, common_func.fullname2dbt(name)[0])) console.log('BUG, test59, '+name);
          }
          if (!tgt_th[9][2]) return false;
}
//          else if (pref[embed_mode].popup2==='sr' || pref[embed_mode].popup2==='srpv') tgt_th[10] = catalog_filter_query_keyword.kwd_make_result(tgt_posts);
        }
        return true;
      }
      cataLog.catalog_filter_query = catalog_filter_query;
////      function catalog_filter_query_scan(posts,tags){
////        if (!catalog_filter_query_keyword.kwd(pref.catalog.filter.kwd, posts)) return false;
//////        if (!catalog_filter_query_keyword(str)) return false;
////if (pref.test_mode['22']) {
////        if (!catalog_filter_query_tag(tags)) return false;
////} else {
//////        if (!catalog_filter_query_tag(tags[0][0].concat(tags[1][0]))) return false;
////        if (pref.catalog.filter.tag) if (!liveTag.search_by_tags(tags)) return false;
////}
////        return true;
////      }
      function catalog_filter_query_time_list(name){
        var val = pref_func.merge_obj5(name,pref.catalog.filter.list_obj2,{hit:false});
//        if (val.time) return [(!pref.catalog.filter.list || val.time<threads[name][8][0] || val.time<threads[name][8][4]), val.time]; // hit always.
        if (val.time) return [(!pref.catalog.filter.list || val.time<(threads[name][8][4]||threads[name][8][0])), val.time]; // hit always.
        else if (val.hit) return [!pref.catalog.filter.list];
        return [true];
      }
      function catalog_filter_changed(){
if (pref.test_mode['60']) {        
        if (pref.catalog.filter.kwd.use || pref.catalog.filter.tag || pref.catalog.filter.time || pref.catalog.filter.list) for (var th in threads) threads[th][9] = catalog_filter_query(th);
        else {
//          for (var th in threads) threads[th][9] = [true];
          for (var th in threads) threads[th][9][0] = true;
          drawn_idx = 0;
        }
} else {
        var val = (pref.catalog.filter.kwd.use || pref.catalog.filter.tag || pref.catalog.filter.time || pref.catalog.filter.list)? null : true;
        for (var th in threads) threads[th][9][0] = val;
        drawn_idx = 0;
}  
        if (show_catalog) show_catalog(); // 'if (show_catalog)' is a patch.
//console.log('filter_changed');
//        catalog_refresh_gather_info(); // cut at 2015.05.15.
      }
      cataLog.catalog_filter_changed = catalog_filter_changed;
      function catalog_attr_changed(){
//        if (pref.catalog.filter.attr_list)
//          for (var th in threads) catalog_attr_set(th,threads[th][0]);
//        if (pref.catalog.filter.attr_list) {
          pref_func.apply_prep(attr_list,true);
          for (var name in threads) catalog_attr_set(name,threads[name][0]);
//          show_catalog(); // don't require.
//        }
      }

      var pop_up_delay_id = {};
      function pop_up_delay(e,name){
        if (pref[embed_mode].popup2==='no' || pref[embed_mode].popup2==='sr' && !pref.catalog.filter.kwd.active) return; 
//        if (threads[name][0].style.width=='' && threads[name][0].style.height=='' && pref.catalog_no_popup_at_expanded) return;
        if (pref.catalog_popdown=='imm' || pop_up_status[name]) pop_up_op(e,name); // patch
        else {
          if (pop_up_delay_id[name]) clearTimeout(pop_up_delay_id[name]);
          else { // init
            threads[name][0].addEventListener('mousemove' , threads[name][2][1]);
            threads[name][6] = function(){clearTimeout(pop_up_delay_id[name]);};
            threads[name][0].addEventListener('mouseout'  , threads[name][6]);
          }
          pop_up_delay_id[name] = setTimeout(function(){pop_up_op(e,name);},pref.catalog_popup_delay);
        } 
      }
      function pop_up_op(e,name){
        if (pop_up_status[name]) {
          pop_keep_event(name);
          return;
        }
        var ch = threads[name][0];
        if (pop_up_delay_id[name]) {
          ch.removeEventListener('mousemove' , threads[name][2][1]);
          ch.removeEventListener('mouseout'  , threads[name][6]);
          delete pop_up_delay_id[name];
        }
        var pn = pop_up_set_contents(null, pref[embed_mode].popup2, name);
        if (pn) {
          site2['DEFAULT'].popups_posts.set_pos(pn,e);
          site.popup_body.appendChild(pn);
        }
        if (pref.catalog_popup_size_fix) { 
          pn.style.width  = pn.offsetWidth + 'px';
          pn.style.height = pn.offsetHeight + 'px';
        }
        pop_up_status[name] = [null, function(){pop_down_event(name);}, function(){pop_keep_event(name);}, ch, pn];
        if (pref[embed_mode].popup2==='chart') {
          if (chart_obj && pref3.stats.use) {
            pop_up_status[name][5] = new chart_obj.PostChart(pn,[name]); // must be after appendChild to draw. (just to call destroy?)
          } else pn.innerHTML = 'Statistics needs to be activated.';
        }
        if (pref.catalog_popdown=='imm') {
          if (document.documentElement.clientHeight/2-e.clientY>0) {
            if (parseInt(pn.style.top.replace(/px/,''),10) + pn.offsetHeight > document.documentElement.clientHeight) {
              if (pn.offsetHeight > document.documentElement.clientHeight) pn.style.top = '0px';
              else {pn.style.top = null; pn.style.bottom = '0px';}
            }
          } else if (parseInt(pn.style.bottom.replace(/px/,''),10) + pn.offsetHeight > document.documentElement.clientHeight) {pn.style.bottom = ''; pn.style.top = '0px';}
        } else {
          pn.addEventListener('mouseover', pop_up_status[name][2], false);
          pn.addEventListener('mouseout', pop_up_status[name][1], false);
        }
        ch.addEventListener('mouseout', pop_up_status[name][1], false);
      }
      function pop_keep_event(name){
        if (pop_up_status[name][0]) {clearTimeout(pop_up_status[name][0]);pop_up_status[name][0]=null;}
      }
      function pop_down_event(name){
        if (!pop_up_status[name][0]) pop_up_status[name][0] = setTimeout(function(){pop_down_op(name);},(pref.catalog_popdown=='imm')? 0 : pref.catalog_popdown_delay);
      }
      function pop_down_op(name){
        if (pop_up_status[name][5]) pop_up_status[name][5].destroy();
//        if (pop_up_status[name]==undefined) return;
        ch = pop_up_status[name][3];
        pn = pop_up_status[name][4];
        ch.removeEventListener('mouseout' , pop_up_status[name][1], false);
        if (pref.catalog_popdown!='imm') {
          pn.removeEventListener('mouseover', pop_up_status[name][2], false);
          pn.removeEventListener('mouseout' , pop_up_status[name][1], false);
        }
        if (threads[name][12]) threads[name][12] = remove_open_new_thread_event(threads[name][12]);
        pn = cnst.div_destroy(pn,true);
        delete pop_up_status[name]; //prevent memory leak.
      }
      function pop_up_set_contents(pn, kind, name){
        var flag_search = kind==='sr' || kind==='srpv';
        var th = {posts: threads[name][16].recent_posts(flag_search && pref.catalog.filter.kwd.posts_active && pref[embed_mode].sourceOfSP==='auto'? -1 : null),
//          type_data: 'json', // BUG, lth.ta.posts may contain different type of data, see archiver.store_th_to_mem and archiver.check_deleted_posts. // NEED TO BE MODIFIED
          __proto__:threads[name][7] || threads[name][16]};
//        var th = threads[name][7] || threads[name][16];
//        var th = threads[name][7];
if (!pref.test_mode['49'] && pref.catalog.filter.kwd.posts_active && th) {
        var search_result = (flag_search)? catalog_filter_query_keyword.kwd_make_result(th.posts, th.domain, th) : null; // lazy
}
        if (kind==='sr' && !search_result) return;
        if (!pn) pn = cnst.init('pop:border:1px solid blue');
        if (kind!=='chart') {
if (!pref.test_mode['49']) {
//          if (th) {
            var lth = th.lth;
            th = (kind==='dp')? {posts:[{search_result:false, __proto__:th.posts[0]}].concat(lth && lth.pd || []), __proto__:th} :
                 (kind!=='pv' && search_result && {posts:search_result, __proto__:th}) || th;
            format_html.prepare_html_prep_posts(th); // REDUNDANT for 2nd times or later.
//            insert_thread_prepare_html_lazy(threads[name], !threads[name][0], false, true); // is this the better? not debugged yet.
            var pn_result = site2[site.nickname].page_json2html3(th,th.board,th.op_img_url, true); // th.posts[x].pn are re-ssigned, and this causes conflicts in embed_mode===page.
            if (!pref.test_mode['98'] && pref[embed_mode].popup) format_html.prep_anchor_links(pn_result, th);
//            if ((search_result || kind==='dp') && th.posts[0].search_result===false) site2[th.domain_html].update_posts0_class(th.posts[0].pn, th.posts[0].search_result);
            for (var i=0;i<th.posts.length;i++) site2[th.domain_html].format_pn(th.posts[i].pn, lth && lth.q && lth.q[th.posts[i].no], null, th.posts[i], th); // SHOULD CHANGE TO USE prepare_html_post to mark editing and consolidate control flow.
            site2['DEFAULT'].check_reply.set_own_posts(th);
            if (pref[embed_mode].mark_new_posts) format_html.update_draw(th.key, pn_result, th);
            if (!pref.test_mode['98'] && pref[embed_mode].popup) site2[th.domain].popups_add({posts:th.posts, __proto__:threads[name][16]}, th, false);
            pn.name = th.key;
//          } else pn_result = document.createTextNode('You must be set to store posts at least 1, see \'Catalog\' tab in settings.');
          pn.appendChild(pn_result);
          catalog_attr_set(name,pn.childNodes[0]);
} else {
          pn.innerHTML = threads[name][3][0];
          trim_html(pn, threads[name][3][1], pref[embed_mode].format.hover, name);
          trim_html_mark_time(pn, threads[name][3][1], pref[embed_mode].format.hover, name);
          var nickname = name.replace(/\/.*/,'');
//        if (pref.catalog.filter.list_mark_time && threads[name][9][1]) site2[nickname].mark_newer_posts(pn,threads[name][9][1]);
          var date = get_mark_time(name, pref[embed_mode].mark_new_posts, pref[embed_mode].mark_new_posts, pref[embed_mode].mark_new_posts);
          if (date>0) site2[nickname].mark_newer_posts(pn,date);
          threads[name][12] = add_open_new_thread_event(name,site2[nickname].modify_thread_link(pn));
          catalog_attr_set(name,pn);
}
        }
        return pn;
      }
      cataLog.pop_up_set_contents = pop_up_set_contents;

//      var page_delim = [];
//      for (var i=0;i<site.max_page;i++) page_delim[i] = null;
//      var page_delim_idx = [];

      var load_list = {refresh: {key:'',    idx:0, tgts:null, mutex:true, use_cache:false, from_auto:false, page_check:true },
                       ondemand:{key:'odl', idx:0, tgts:null, mutex:true, use_cache:false, from_auto:false, page_check:false},
                       tag:     {key:'tag', idx:0, tgts:null, mutex:true, use_cache:true,  from_auto:false, page_check:false}};
      var filter_tags_refresh_mem = {};
      var refresh_use_cache = false;
      function prep_reserved_tags(set,idx){
        var tags = pref.catalog_board_list_obj[idx] && pref.catalog_board_list_obj[idx][0].tags || null;
        return (tags)? liveTag.tags_reserved_init(tags,set) : null; // 'liveTag.tags_reserved_init' modifies tags.
      }
//      function prep_reserved_tags(set,idx){ // working code.
//        var tags = pref.catalog_board_list_obj[idx][0].tags || null;
//        if (tags) {
//          tags = tags.slice();
//          liveTag.set_reserved_tags(tags,set);
//          if (set) liveTag.reserved = (tags.length!==0)? tags : null;
//        }
//      }
      function make_refresh_list(sel,bookmark_list_str, refresh){
//      function make_refresh_list(remove_attr){
        var tgts = [];
        var tgt_domains = {};
        if (site.whereami==='boards' && sel==0) pref_func.str2obj('catalog_board_list_str');
        var blist = pref.catalog_board_list_obj[sel].slice();
        var domains = blist[0].domains_for_all_boards;
        if (domains) {
          for (var i=0;i<domains.length;i++) {
            var domain = domains[i];
            if (!site3[domain].boards) return function(callback){ // singlelined because this may cause infinite loop if reading boards_json is failed.
              site2[domain].get_boards_json('refresh_boards_json',callback,false,health_indicator);};
//            if (!site3[domain].boards) {
//              site2[domain].get_boards_json('refresh_boards_json',reentry_func,false,health_indicator);
//              return tgts; // singlelined because this may cause infinite loop if reading boards_json is failed.
//            }
          }
          for (var i=0;i<domains.length;i++)
            if (refresh && site2[domains[i]].utilize_boards_json && pref.pref2[domains[i]].utilize_boards_json && pref.pref2[domains[i]].utilize_boards_json_domain)
              tgt_domains[domains[i]] = null;
            else for (var j in liveTag.mems[domains[i]]) blist[blist.length] = liveTag.mems[domains[i]][j];
        }
        var bds_picked_up_by_tags = prep_reserved_tags(true,sel);
        for (var bd in bds_picked_up_by_tags) {
          for (var j=1;j<blist.length;j++) if (blist[j].key===bd) break;
          if (j==blist.length) blist[blist.length] = liveTag.mems.getFromName(bd); // scan.add_board(bd);
        }
        if (bookmark_list_str) tgts = bookmark_list_str.replace(/\s*\/\/.*$/mg,',').replace(/\n/g,',').replace(/,,+/g,',').replace(/^,/,'').replace(/,$/,'').split(',');
        if (tgts[0]==='') tgts = [];
//        var page_str = (pref.catalog.design==='page')? 'p' : 'c';
        var j = 0;
        while (blist.length>1) {
          for (var i=1;i<blist.length;i++) {
            var key = blist[i].key.replace(/\s/g,''); // replace... is redundant
            var dbt = cnst.name2domainboardthread(key,true);
            var max_page_bd = pref.catalog_max_page_select==='auto' && liveTag.mems[dbt[0]] && liveTag.mems[dbt[0]][dbt[1]] && liveTag.mems[dbt[0]][dbt[1]].pgs || pref.catalog_max_page;
            if (dbt[2]) {
              if (j==0) tgts.push(key);
              else blist.splice(i--,1)
            } else if ((!blist[i].max_page || j<blist[i].max_page) && j<max_page_bd) tgts.push(key+ ((pref.catalog.catalog_json)? 'q':'p') +j);
            else blist.splice(i--,1)
          }
          j++;
        }

////        for (var j=0;j<pref.catalog_max_page;j++) // working code.
////          for (var i=1;i<blist.length;i++) {
//////            if (blist[i]['key'].search(/[^\/]*\/[^\/]*\/[0-9]+/)!=-1) {if (j==0) tgts.push(blist[i]['key']);} // working code.
////            var key = blist[i].key.replace(/\s/g,''); // replace... is redundant
////            if (common_func.fullname2dbt(key)[2]) {if (j==0) tgts.push(key);}
////            else if (!blist[i].max_page || j<blist[i].max_page) tgts.push(key+ ((pref.catalog.catalog_json)? 'q':'p') +j);
////          }
//////        if (remove_attr) for (var i=0;i<tgts.length;i++) tgts[i] = tgts[i].replace(/!.*/,'');
//////        for (var i=tgts.length-1;i>=0;i--) { // working code
//////          var dbt = cnst.name2domainboardthread(tgts[i],true);
//////          if (tgts[i].indexOf(dbt[1])==-1) tgts[i] = dbt[0] + dbt[1] + tgts[i];
//////          else if (tgts[i].indexOf(dbt[0])==-1) tgts[i] = dbt[0] + tgts[i];
//////        }
        return {tgts:tgts, tgt_domains:tgt_domains};
      }
      function trim_list(tgts,embed_init, mode){
        if (pref.catalog.board.ex_list) {
          for (var i=tgts.length-1;i>=0;i--) {
            var val = pref_func.merge_obj5(tgts[i],pref.catalog.board.ex_list_obj2,{hit:false});
            if (val.hit) tgts.splice(i,1);
          }
        }
        if (pref.catalog.design==='catalog' || (pref.catalog.design==='auto' && mode==='catalog') || mode==='chart') {
          for (var i=tgts.length-1;i>=0;i--) {
            var dbt = cnst.name2domainboardthread(tgts[i],true);
            if ((site2[dbt[0]].trim_list!=='no' || mode==='chart') && tgts[i].search(/\/[pq][0-9]*/)!=-1) {
//            if ((dbt[0]==='8chan' ||dbt[0]==='4chan') && tgts[i].search(/\/p[0-9]*/)!=-1) {
//            if (dbt[0]==='8chan' && tgts[i].search(/\/p[0-9]*/)!=-1) {
//              if (tgts[i].search(/\/p0$/)!=-1 && (!embed_init || dbt[1]!=site.board)) tgts[i] = tgts[i].replace(/p0/,(pref.catalog.catalog_json)? 'j0' : 'c0');
              if (tgts[i].search(/\/[pq]0$/)!=-1 && (!embed_init || dbt[1]!=site.board || dbt[0]!=site.nickname || (site2[dbt[0]].trim_list==='force_init' || pref3.stats.use)))
                tgts[i] = tgts[i].replace(/[pq]0/,(pref.catalog.catalog_json || site2[dbt[0]].trim_list==='force_init')? 'j0' : 'c0');
              else if (tgts[i].search(/\/[pq][0-9]$/)!=-1) tgts.splice(i,1); // ratain thread
            }
          }
        }
        if (mode==='page' && embed_init) { // patch
          if (pref.liveTag.use) {
            var bds = {};
            for (var i=0;i<tgts.length;i++) {
              var dbt = cnst.name2domainboardthread(tgts[i],true);
              bds[dbt[0]+dbt[1]+((pref.catalog.catalog_json)? 'j0':'c0')] = null; // add a catalog for scan all thread.
            }
            for (var i in bds) tgts[tgts.length] = i;
//            cataLog.scan_init('init_tag',bds, {tag_only:true});
          }
//          if (pref.liveTag.use) { // working code.
//            for (var i=0;i<tgts.length;i++) {
//              var dbt = cnst.name2domainboardthread(tgts[i],true);
//              scan.list_nup.add_board(dbt[0]+dbt[1]);
//            }
//          }
          if (tgts[0] && tgts[0].search(site.nickname+site.board+'[pq]0')===0) tgts.splice(0,1);
////          var site_db = site.nickname+site.board;
////          for (var i=0;i<tgts.length;i++) { // working code, but obsolete.
////            if (tgts[i].indexOf(site_db)===0) {
////              if (tgts[i].search(site_db+'[pq]0')===0) tgts.splice(i--,1)[0];
////              else if (pref[mode].load_on_demand) threads_idx[threads_idx.length] = 'ODL:'+tgts.splice(i--,1)[0];
////            }
////          }
          if (pref[mode].load_on_demand) drawn_idx = 0;
        }
        if (mode==='thread') { // patch
          if (board_sel.selectedIndex===0) {
            if (embed_init) tgts.splice(0,1);
            else tgts = [site.nickname + site.board + site.no];
          }
        }
        for (var i=tgts.length-1;i>=0;i--) {
          var dbt = common_func.name2dbt(tgts[i]);
          var url = site2[dbt[0]].make_url4(dbt, pref.catalog.design!=='page' && (pref.catalog.indexing!==0 || pref.liveTag.from!=='none')); // trim for 4chan. // !=='none' IS ALWAYS TRUE, WHY...
          if (!url) tgts.splice(i,1);
          else if (url[2] && url[2]!==tgts[i]) {
            if (tgts.indexOf(url[2])!=-1) tgts.splice(i,1);
            else tgts[i] = url[2];
          }
//          if (!site2[dbt[0]].make_url4(dbt)) tgts.splice(i,1);
        }
        return tgts;
      }


      function remove_threads_events(name){
        if (threads[name][0]) threads[name][0].removeEventListener('mouseover', threads[name][2][0], false);
        common_func.dom_removeEventListener(threads[name][5]);
        if (threads[name][11]) threads[name][11] = remove_open_new_thread_event(threads[name][11]);
      }
      function remove_thread(name, pn_only){
        var ref = threads_idx.indexOf(name);
        if (name.substr(0,4)!=='ODL:') {
          if (!threads[name]) return;
          var dbt = common_func.fullname2dbt(name);
          var lth = liveTag.mems.getFromName(name);
          if (!pn_only) if (threads[name][16].popups) for (var i in threads[name][16].popups) site2[dbt[0]].popups_release(lth, i); // remove cross thread/board links.
          remove_threads_events(name);
          if (threads[name][1]) {
            if (pop_up_status[name]) pop_down_op(name);
//            if (threads[name][0].parentNode===triage_parent) { // working code.
////              if (pref.catalog_expand_with_hr && !embed_catalog) show_catalog_hr(name,'remove');
////              triage_parent.removeChild(threads[name][0]); // for 4chan's native
//              catalog_obj2.func_hide(name);
//            }
            if (threads[name][0] && threads[name][0].parentNode===triage_parent) catalog_obj2.func_hide(name); // parent check is for on_demand_draw
            site2['DEFAULT'].update_posts_merge_bases.remove_th(threads[name][16], true);
//            if (threads[name][0] && threads[name][0].parentNode===triage_parent || pref[embed_mode].merge) // parent check is for on_demand_draw and merging threads.
//              catalog_obj2.func_hide(name);
            if (ref<drawn_idx) drawn_idx = 0;
          }
//          if (threads[16].archiveFile) {
//            if (threads[16].archiveFile==='IDB') {
//            } else {
//              var files = threads[16].archiveFile;
//              while (files) {
//                for (var i in files) if (files[i].url) window.URL.revokeObjectURL(files[i].url);
//                files = Object.getPrototypeOf(files);
//              }
//            }
//          }
//          if (lth) {
//            delete lth.th;
//            delete lth.ta;
//            delete lth.pd;
//          }
        }
        if (pn_only) {
          threads[name][0] = false;
          threads[name][1] = false;
          threads[name][16].th = threads[name][7];
          threads[name][16].posts = null;
//          if (!threads[name][16].th) threads[name][16].th = threads[name][16];
          if (threads[name][24]) threads[name][24][0] = null;
          return;
        }
        delete threads[name]; // remove 'ODL:' also
if (pref.debug_mode['2']) console.log('removed: '+name);
//        for (var i=threads_idx.length-1;i>=0;i--) if (threads_idx[i]===name) {threads_idx.splice(i,1);break;}
        if (ref>=0) threads_idx.splice(ref,1);
if (pref.test_mode['95'] && site.nickname==='dist') site2[site.nickname].testPoster(name);
      }
      cataLog.remove_thread = remove_thread;
////      function remove_thread(name){ // working code.
////        if (name.substr(0,4)!=='ODL:' && threads[name]) { // BUG. SHOULD WORK WITHOUT CHECKING threads[name]
////          var dbt = common_func.fullname2dbt(name);
////          if (threads[name][16].popups) for (var i=0;i<threads[name][16].popups.length;i++) site2[dbt[0]].popups_release(threads[name][16].popups[i]);
//////        if (name.substr(0,4)!=='ODL:') {
//////          if (threads[name][16].th_destroy) threads[name][16].th_destroy(threads[name][0], threads[name][16].parse_funcs);
////          threads[name][0].removeEventListener('mouseover', threads[name][2][0], false);
//////          threads[name][0].removeEventListener('click', threads[name][5], false);
//////          for (var i=0;i<threads[name][5].length;i++) threads[name][5][i].removeEventListener('click', click_thread, false);
////          common_func.dom_removeEventListener(threads[name][5]);
////          if (threads[name][11]) remove_open_new_thread_event(threads[name][11]);
////          if (threads[name][1]) {
//////            if (threads[name][12]) remove_open_new_thread_event(threads[name][12]);
////            if (pop_up_status[name]) pop_down_op(name);
//////            triage_parent.removeChild(threads[name][0]);
////            if (threads[name][0].parentNode===triage_parent) triage_parent.removeChild(threads[name][0]); // for 4chan's native
////          }
//////          if (threads[name][17][0][0].length!=0) liveTag.remove_tags_in_th(threads[name][17][0][0], name);
//////          if (threads[name][17][1][0].length!=0) liveTag.remove_tags_in_th(threads[name][17][1][0], name);
//////          liveTag.remove_tags_in_th(name);
////        }
////        delete threads[name]; // remove 'ODL:' also
////if (pref.debug_mode['2']) console.log('removed: '+name);
////        for (var i=threads_idx.length-1;i>=0;i--) if (threads_idx[i]===name) {threads_idx.splice(i,1);break;}
////      }
      var threads_candidates_of_deletion = null;
      function catalog_clear_threads_candidates_of_deletion(num, schedule){
        if (threads_candidates_of_deletion!==null) {
          for (var name in threads_candidates_of_deletion)
           if (threads[name] && threads_candidates_of_deletion[name]===((threads[name][8][0]>threads[name][8][4])? threads[name][8][0] : (threads[name][8][4] || threads[name][8][0]))) remove_thread(name);
          threads_candidates_of_deletion = null;
        }
      }
      function catalog_clear_threads(num, schedule){
//        threads_last_deleted = {};
//        catalog_triage_out();
        var idx = 0;
        while (idx<threads_idx.length && idx<num) if (threads_idx[idx++].substr(0,4)==='ODL:') num++;
        if (!schedule) {
          triage.off_delay();
          while (threads_idx.length>num) {
            var name = threads_idx[threads_idx.length-1];
//          if (name.substr(0,4)!=='ODL:') threads_last_deleted[name] = {sticky:threads[name][20], last_post_time:threads[name][8][4], last_post_count:threads[name][8][2]};
//          threads_last_deleted[name] = threads[name][20];
            remove_thread(name);
          }
        } else {
          if (threads_candidates_of_deletion===null) threads_candidates_of_deletion = {};
          while (threads_idx.length>num) {
            var name = threads_idx[num++];
            if (name.substr(0,4)==='ODL:') {remove_thread(name);num--;}
            else threads_candidates_of_deletion[name] = (threads[name][8][0]>threads[name][8][4])? threads[name][8][0] : (threads[name][8][4] || threads[name][8][0]);
          }
        }
////////        if (!schedule) remake_boards();
      }
      cataLog.catalog_clear_threads = catalog_clear_threads;
////////      function remake_boards(){
////////        boards = {};
////////        for (var name in threads) {
////////          var dbt = cnst.name2domainboardthread(name,true);
////////          boards[dbt[0]+dbt[1]] = null;
////////        }
////////      }
      function catalog_refresh(refresh, embed_init, from_auto, from_switch) {
        pref4.refresh.count++;
        Footer.refresh_start();
        if (!pref.test_mode['67'] && !embed_init) archiver.refresh_start();
        if (!from_switch && !embed_init && pref.catalog.auto_save_filter_at_refresh) onchange_funcs['save']();
        var result = catalog_refresh_1(embed_mode, refresh, embed_init, from_auto, 'refresh', board_sel.selectedIndex, pref.catalog.filter.bookmark_list_str, false, undefined, from_switch);
        if (typeof(result)==='function') result(function(){catalog_refresh(refresh, embed_init, from_auto);});
      }
      function catalog_refresh_1(mode, refresh, embed_init, from_auto, scan_name, sel, bookmark_list_str, get_board_list, callback, from_switch) {
        var tgts_all = make_refresh_list(sel, bookmark_list_str, refresh);
        if (typeof(tgts_all)==='function') return tgts_all; // must be reentried.
        var tgts = tgts_all.tgts;
        if (get_board_list) {
          var bds = {};
          for (var i=0;i<tgts.length;i++) {
            var dbt = common_func.name2domainboardthread(tgts[i],true);
            if (dbt[2][0].search(/^[pqcj]/)!=-1) bds[dbt[0]+dbt[1]] = null;
            else bds[dbt[0]+dbt[1]+dbt[2].replace(/^t/,'')] = null; // patch
          }
        }
        if (scan_name && pref3.stats.use && pref.stats.auto_acquisition_all) stats.register_auto_acquisition(sel);
        tgts = trim_list(tgts,embed_init, mode);
        var priority = (!refresh)? 0 : (from_auto)? 2:4;
        if (tgts.length===0) return (refresh)? scan.scan_refresh(health_indicator, tgts, priority, tgts_all.tgt_domains) : tgts;
        if (refresh) {
          catalog_clear_threads_candidates_of_deletion();
          if (pref.catalog_refresh_clear && !embed_init) catalog_clear_threads(pref4.scan.max_threads_at_refresh, true);
        }
////////        load_on_demand.release(); // prevent from hanging up.
        if (scan_name) scan_boards.scan_init(scan_name, tgts,
                                             {refresh:refresh,
                                              callback: function(){scan.scan_refresh(health_indicator, tgts, priority, tgts_all.tgt_domains);
                                                                   if (callback) callback();},
                                              from_auto:from_auto, load_on_demand:pref[mode].load_on_demand, priority:priority});
        return (get_board_list)? Object.keys(bds) : tgts;
      }
      cataLog.catalog_refresh_1 = catalog_refresh_1;
      
////      function catalog_refresh(refresh, embed_init, from_auto, indicator) { // working code.
//////if (pref.debug_mode['0']) console.log(new Date().toLocaleTimeString() + ', refresh: start: ');
//////        set_auto_update();
////        if (pref.catalog.filter.time_ago_str_sync_at_refresh) ago_clicked();
////        load_list.refresh.use_cache = !refresh;
////        load_list.refresh.idx = 0;
////        load_list.refresh.mutex = true;
////        load_list.refresh.from_auto = from_auto;
////        load_list.refresh.tgts = trim_list(make_refresh_list(board_sel,pref.catalog.filter.bookmark_list),embed_init);
////        if (load_list.refresh.tgts.length===0) return;
////        if (threads_candidates_of_deletion!==null) {
////          for (var name in threads_candidates_of_deletion)
////           if (threads[name] && threads_candidates_of_deletion[name]===((threads[name][8][0]>threads[name][8][4])? threads[name][8][0] : (threads[name][8][4] || threads[name][8][0]))) remove_thread(name);
////          threads_candidates_of_deletion = null;
////////////          remake_boards();
////        }
////        if (refresh && pref.catalog_refresh_clear && !embed_init) catalog_clear_threads(pref.catalog.max_threads_at_refresh, true);
//////        for (var i=0;i<load_list.refresh.tgts.length;i++) load_list.refresh.tgts[i] = [load_list.refresh.tgts[i], from_auto];
////////////        load_on_demand.release(); // prevent from hanging up.
////        if (load_list.refresh.idx<load_list.refresh.tgts.length) {
//////if (!pref.test_mode['15']) scan_boards.scan_init('refresh', load_list.refresh.tgts, {refresh:true, crawler_max:1, indicator:indicator, callback:catalog_refresh_watch});
//////if (!pref.test_mode['15']) scan_boards.scan_init('refresh', load_list.refresh.tgts, {refresh:true, indicator:indicator, callback:catalog_refresh_watch, from_auto:from_auto, load_on_demand:pref[embed_mode].load_on_demand});
////if (!pref.test_mode['15']) scan_boards.scan_init('refresh', load_list.refresh.tgts, {refresh:true, callback:catalog_refresh_watch, from_auto:from_auto, load_on_demand:pref[embed_mode].load_on_demand, priority:(from_auto)?2:4});
////else {
//////          health_indicator.shift('limegreen','0');
////          load_list.refresh.indicator = indicator;
////          get_page(load_list.refresh);
////}
////        } else catalog_refresh_watch();
//////        scan_boards.scan_init('refresh_tag',filter_tags_refresh_mem,(refresh)? 0 : pref.scan.lifetime*60, catalog_refresh_watch);
////if (pref.test_mode['22'])
////        scan_boards.scan_init('refresh_tag', filter_tags_refresh_mem, {lifetime:((refresh)? 0 : pref.scan.lifetime*60), cache_write:true});
////      }
////      
////////      function catalog_refresh_watch() { // working code.
//////////console.log('test');
////////        var tgts = {};
////////        for (var name in threads) if (threads[name][21]) tgts[name] = null;
////////        scan_boards.scan_init('refresh_watch', tgts, {callback:catalog_refresh_gather_info, refresh:true});
//////////console.time('refresh_watch');
//////////        scan_boards.scan_init('refresh_watch', tgts, {callback:catalog_refresh_gather_info, force_json:pref.catalog.order.find_sage_in_8chan});
////////      }
////////      cataLog.catalog_refresh_watch = catalog_refresh_watch;
////      function catalog_refresh_watch() { // working code, @safe1080
////        catalog_refresh_gather_info();
////      }
////      var missing_info = {};
////      function catalog_refresh_gather_info() {
////        var tgts = missing_info;
////        missing_info = {};
//////////////console.timeEnd('refresh_watch');
////////////        var tgts = {};
////////////        for (var name in threads) {
////////////          if (!pref.catalog.filter.time && !pref.catalog.filter.list && !threads[name][9][0]) continue;
//////////////          var dbt = common_func.name2domainboardthread(name);
//////////////          if (dbt[0]==='8chan' && pref.catalog.indexing==4 && threads[name][23]) tgts[name] = true; // get time of sage post in 8chan from json.
//////////////          if (pref.catalog.indexing==4 && threads[name][23] && threads[name][23].time_posted===null) tgts[name] = true; // get time_posted
////////////          if (pref.catalog.indexing==4 && threads[name][8][4]===undefined) tgts[name] = true; // get time_posted
//////////////          if (!threads[name][9][0]) continue;
//////////////          if (dbt[0]==='8chan' && pref.catalog.order.sticky!=='dont_care' && threads[name][20]===null) tgts[dbt[0]+dbt[1]] = true; // get sticky in 8chan from json.
////////////        }
//////////////console.log(tgts);
////        scan_boards.scan_init('refresh_watch', tgts, {tgt_raw: true,
////                                                      callback: function(){scan.scan_refresh(health_indicator);}});
//////                                                      callback: (pref.liveTag.utilize_boards_json)? catalog_refresh_boards : catalog_liveTag_scan_boards,
//////                                                      callback_args: (pref.liveTag.utilize_boards_json)? 'refresh_watch' : null});
//////        if (pref.liveTag.utilize_boards_json && embed_mode==='catalog') catalog_liveTag_scan_threads(); // patch for 8chan, boards_json is too heavy.
////      }
////
////      function catalog_refresh_boards() { // patch for 8chan // working code, @safe1069
//////        if (liveTag.mems['8chan']) {
//////          var tgts = scan.list_nup.get_list_board('8chan',true);
////////          if (tgts.length!=0) http_req.get('refresh_watch','8chan,boards_json,boards_json,boards_json',site2['8chan'].url_boards_json(),catalog_refresh_boards_callback,0,true,catalog_liveTag_scan_boards);
//////          if (tgts.length!=0) site2['8chan'].get_boards_json('refresh_watch',catalog_liveTag_scan_boards,true,health_indicator);
//////          else catalog_liveTag_scan_boards();
//////        } else catalog_liveTag_scan_boards();
////        if (scan.list_nup.query_list_board('8chan')) {
////          site2['8chan'].get_boards_json('refresh_watch',catalog_liveTag_scan_boards,true,health_indicator);
////          return;
////        }
////        catalog_liveTag_scan_boards();
////      }
////////////      function catalog_refresh_boards_callback(key,value,callback){
//////////////if (pref.debug_mode['7']) console.log('boards_json:');
////////////        if (value.status==200) {
////////////          var dbt = key.split(',');
////////////          site2[dbt[0]].postprocess_board(value.response);
////////////////          site3[dbt[0]].boards = value.response.boards || value.response; // patch for 8chan. WHY DO THEY CHANGE THE SPEC REPEATEDLY WITHOUT A PARTICULAR REASON??? // working code.
////////////////          site3[dbt[0]].boards_to_scan = null;
////////////////          if (site2[dbt[0]].make_site3_bds) site2[dbt[0]].make_site3_bds();
////////////        }
////////////        if (callback) callback();
////////////      }
////
////      var mutex_wd_liveTag_scan_boards = new MutexWatchdog('scan');
////      function catalog_liveTag_scan_boards(domain) {
////        if (pref.liveTag.use) {
////          if (!mutex_wd_liveTag_scan_boards.get()) {catalog_refresh_end(); return;}
////          if (pref.debug_mode['7']) var d_str = '';
////          var tgts = scan.list_nup.get_list_board(domain);
////////          var tgts = []; // working code.
////////          var time_th = Date.now()-pref.liveTag.pickup_interval*1000;
////////          for (var i in scan.list_nup_boards) {
////////            var dbt = common_func.fullname2dbt(i);
////////            if (scan.list_nup_boards[i].time<time_th && (!scan.list_nup_boards[i].max || scan.list_nup_boards[i].max<liveTag.mems[dbt[0]][dbt[1]].max)) {
////////              tgts[tgts.length] = i;
////////              if (pref.debug_mode['7']) d_str += i + ':' +scan.list_nup_boards[i].max+'/'+liveTag.mems[dbt[0]][dbt[1]].max+', ';
////////            }
////////          }
////          if (pref.debug_mode['7']) for (var i=0;i<tgts.length;i++) d_str += tgts[i].key + ':' +tgts[i].read_max+'/'+tgts[i].max+', ';
////          if (Object.keys(tgts).length!=0) {
////            scan_boards.scan_init('scan', tgts, {callback: catalog_liveTag_scan_boards_cont,
////                                                 watchdog: mutex_wd_liveTag_scan_boards.restart.bind(mutex_wd_liveTag_scan_boards),
////////////                                                 crawler_watchdog: true
//////                                                 priority: 1,
////                                                });
////            if (pref.debug_mode['7']) console.log('catalog_liveTag_scan_boards: '+tgts.length+', '+d_str);
////          } else {
////            mutex_wd_liveTag_scan_boards.stop();
////            catalog_liveTag_scan_threads();
////          }
////        } else catalog_liveTag_scan_threads();
////      }
////      function catalog_liveTag_scan_boards_cont() {
////        mutex_wd_liveTag_scan_boards.stop();
////        if (mutex_wd_liveTag_scan_boards.query_req()) catalog_liveTag_scan_boards();
////        else catalog_liveTag_scan_threads();
////      }
////      function catalog_liveTag_scan_cancel() {
////        mutex_wd_liveTag_scan_boards.abort();
////        scan_boards.scan_abort('scan');
////        mutex_wd_liveTag_scan_threads.abort();
////        scan_boards.scan_abort('scan_threads');
////      }
////
////      var catalog_liveTag_scan_threads_delayed_do = DelayBuffer.prototype.delayed_do.bind(new DelayBuffer(catalog_liveTag_scan_threads, 200));
////      var mutex_wd_liveTag_scan_threads = new MutexWatchdog('scan_threads');
////      function catalog_liveTag_scan_threads() {
////        if (!mutex_wd_liveTag_scan_threads.get()) {catalog_refresh_end();return;} // multi entry.
////////        var tgts = []; // working code.
////////        for (var i in scan.list_nup)
////////////          if (scan.list_nup[i]!==null) {
////////////            scan.list_nup[i] = null;
////////////            tgts[tgts.length] = i;
////////////          } else delete scan.list_nup[i];
//////////          if (--scan.list_nup[i]>=0) tgts[tgts.length] = i; // leave nodes of <0 as black listed, patch for 8chan.
////////          if (scan.list_nup[i]>0) tgts[tgts.length] = i;
////        var tgts = scan.list_nup.get_list_thread();
////        if (Object.keys(tgts).length!=0) scan_boards.scan_init('scan_threads', tgts, {callback: catalog_liveTag_scan_threads_cont,
////                                                                                      watchdog: mutex_wd_liveTag_scan_threads.restart.bind(mutex_wd_liveTag_scan_threads),
////////////                                                                                      crawler_watchdog: true
////                                                                                     });
////        else {
////          mutex_wd_liveTag_scan_threads.stop();
////          catalog_refresh_end();
////        }
////      }
////      function catalog_liveTag_scan_threads_cont() {
////        mutex_wd_liveTag_scan_threads.stop();
////        if (mutex_wd_liveTag_scan_threads.query_req()) catalog_liveTag_scan_threads();
////        else catalog_refresh_end();
////      }
////      cataLog.catalog_liveTag_scan_threads = catalog_liveTag_scan_threads;
////      cataLog.catalog_liveTag_scan_threads_delayed_do = catalog_liveTag_scan_threads_delayed_do;

      function catalog_refresh_end(){
        if (pref.notify.favicon || pref.notify.title.notify) notifier.favicon.set(threads);
//        if (pref.liveTag.style) liveTag.refresh_end_proc();
//if (pref.debug_mode['9']) for (var i in scan.list_nup) if (scan.list_nup[i]<=0) console.log('list_nup: '+i+', '+scan.list_nup[i]);
        if (pref.debug_mode['3']) {
          var th_count = 0;
          for (var d in liveTag.mems) for (var b in liveTag.mems[d]) for (var t in liveTag.mems[d][b]) th_count++;
          var ths = {};
          for (var i in liveTag.tags_ci) for (var j of liveTag.tags_ci[i].mems.keys()) ths[j.key] = null;
          console.log('refresh_end: tags_ci+tags: '+Object.keys(liveTag.tags_ci).length+'+'+Object.keys(liveTag.tags).length+', threads:'+th_count+', '+Object.keys(ths).length);
        }
        if (pref[embed_mode].load_on_demand) show_catalog();
      }
      cataLog.catalog_refresh_end = catalog_refresh_end;

////      var mutex_wd_liveTag_scan_ui = new MutexWatchdog('scan_ui'); // working code, @safe1069
////      var liveTag_scan_ui_queue = {};
////      function catalog_liveTag_scan_ui(key,arg) { // arg is {tgts:, options:}
////        if (arg) {
////          if (!liveTag_scan_ui_queue[key]) liveTag_scan_ui_queue[key] = {queue:[], mutex: new MutexWatchdog(key)};
////          liveTag_scan_ui_queue[key].queue.push(arg);
////        }
////        var mutex = liveTag_scan_ui_queue[key].mutex;
////        var queue = liveTag_scan_ui_queue[key].queue;
////        if (!mutex.get()) return; // multi entry.
////        if (queue.length>0) {
////          var tgt = queue.shift();
////          var scan_obj = {
////            callback: catalog_liveTag_scan_ui_cont,
////            callback_args: key,
////            watchdog: mutex.restart.bind(mutex),
////////////            crawler_watchdog: true,
////            __proto__: tgt.options};
////          scan_boards.scan_init(key, tgt.tgts, scan_obj);
////        } else mutex.stop();
////      }
////      function catalog_liveTag_scan_ui_cont(key) {
////        liveTag_scan_ui_queue[key].mutex.stop();
////        catalog_liveTag_scan_ui(key);
////      }

//      function catalog_refresh_gather_info() {
//        if (pref.catalog.order.sticky!=='dont_care') {
//          var tgts = {};
//          for (var name in threads) if (threads[name][20]===null) {
//            var dbt = common_func.name2domainboardthread(name);
//            tgts[dbt[0]+dbt[1]] = null;
//          }
//          if (Object.keys(tgts).length!=0) scan_boards.scan_init('refresh_watch', tgts, {force_json:true, callback:re_sort_thread});
//        }
//      }
//      var flag_initial_refresh = (site.whereami==='boards') && pref.catalog.refresh.except_bt;

      if (embed_frame) site2[site.nickname].catalog_frame_prep(pn12);
//      else if (embed_mode==='float') pn12_0.getElementsByTagName('button')[pref.catalog.appearance.initial.state].onclick();
//      else if (embed_mode==='float') {
//        if (pref.catalog.appearance.initial.state==='maximized') pn12_0.childNodes[1].childNodes[3].onclick();
//        else if (pref.catalog.appearance.initial.state==='top') pn12_0.childNodes[1].childNodes[0].onclick();
//        else if (pref.catalog.appearance.initial.state==='bottom') pn12_0.childNodes[1].childNodes[1].onclick();
///      }
      if (embed_embed) {  // for native catalog
//        pn12.style.display = 'none';
        setTimeout(function(){ // patch for liveTag.
          site2[site.nickname].catalog_native_prep(Date.now(),pn12_0_4,pn12_0, embed_mode==='catalog');
          var ths = insert_myself(null, true);
//          if (site.whereami==='catalog') site2[site.nickname].clean_up_LS(ths);
          if ((embed_mode==='page' && site2[site.nickname].all_boards && site2[site.nickname].all_boards.indexOf(site.board)!=-1) ||
              (embed_mode==='thread' && pref.thread.env.auto_update_native)) { // BUG(,but patched), this cause conflicts, because insert_myself doesn't take merge_mode into account.
            var observer = new MutationObserver(insert_myself);
//            var observer = new MutationObserver(function(){setTimeout(insert_myself,10);}); // wait native script for 4chan, but doesn't work.
//            observer.observe(triage_parent, {childList: true});
            observer.observe((embed_mode==='page')? ths[0].pn.parentNode : ths[0].pn, {childList: true});
            triage.change_mode();
          }
          if (show_catalog_init_funcs) show_catalog_init_funcs();
          if (pref.catalog.filter.kwd.active && (embed_mode==='page' || embed_mode==='catalog')) show_catalog();
          if (pref.catalog_board_list_sel!==0 && !(pref.catalog.board.all_boards && pref.catalog_board_list_sel===pref.catalog_board_list_obj.length-1)) {
            var tgts = cataLog.catalog_refresh_1(embed_mode, false, false, false, false, pref.catalog_board_list_sel, false, false);
            var key_me = site.nickname+site.board+((embed_mode==='catalog')? 'c0' : (embed_mode==='page')? 'p0' : site.no);
            var key_me2= site.nickname+site.board+((embed_mode==='catalog')? 'j0' : (embed_mode==='page')? 'q0' : 't'+site.no);
            if (Array.isArray(tgts) && pref.catalog.refresh.at_switch && tgts.indexOf(key_me)===-1 && tgts.indexOf(key_me2)===-1) catalog_clear_threads(0);
          }
//          if (pref.catalog_board_list_sel!==0 && pref.catalog.refresh.at_switch) catalog_clear_threads(0);
          pn12.parentNode.removeChild(pn12);
        },0);
//        },10); // wait native script for 4chan, but doesn't work.
      }
      function insert_myself(force_annotate, init){
        if (!init && (pref[embed_mode].merge || pref[embed_mode].merge_list)) return; // patch
//          var ths = scan_boards.scan_boards_keyword_callback2(site.nickname+','+site.board+','+site.no+','+((embed_catalog)?'catalog':'page')+'_html',
          var new_posts = [];
          var ths = scan_boards.scan_boards_keyword_callback2(site.nickname+','+site.board+','+((site.whereami==='thread')?site.no:'0')+','+site.whereami+'_html',
                                                              {date:Date.now(), status:200, response:document},
                                                              ['native_prep',{native_prep:true, ext_posts:new_posts, force_annotate:force_annotate===true,
                                                                              __proto__:cataLog.scan_boards_keyword_callback2_default_args}], true);
          if (embed_mode==='thread' && common_obj.thread_reader && new_posts.length!==0) common_obj.thread_reader.updated(new_posts,init);
          return ths;
      }
      cataLog.insert_myself = insert_myself;
////////      if (embed_catalog || embed_page) {  // for native catalog // working code.
////////        pn12.style.display = 'none';
////////        setTimeout(function(){ // patch for liveTag.
////////          var date = Date.now();
////////          site2[site.nickname].catalog_native_prep(date,pn12_0_4,pn12_0, embed_catalog);
////////          insert_thread_from_native = true;
//////////          var ths = scan_boards.scan_boards_keyword_callback2(site.nickname+','+site.board+','+site.no+','+((embed_catalog)?'catalog':'page')+'_html',
////////          var ths = scan_boards.scan_boards_keyword_callback2(site.nickname+','+site.board+',0,'+((embed_catalog)?'catalog':'page')+'_html',
////////                                                              {date:date, status:200, response:document},
////////                                                              ['native_prep',{native_prep:true, found_threads: 0, max_threads:500, found_board:0, scanned:0, refresh:true}]);
////////          insert_thread_from_native = false;
////////          if (pref.thread_reader.own_posts_tracker && pref.thread_reader.clean_up_own_posts && site.whereami==='catalog') site2[site.nickname].clean_up_own_posts(ths,site.board);
////////        },0);
////////      }

//    if (embed_mode!=='thread') setTimeout(function(){ // patch for liveTag.
    if (!window.opener || !window.name || window.name.slice(-1)!=='A') setTimeout(function(){ // patch for liveTag and archive.
//    if (!window.opener) setTimeout(function(){ // patch for liveTag and archive. // THIS CAUSE WRONG BEHAVIOR when the page was load by clicking [catalog]
      catalog_refresh(pref.catalog.refresh.initial && site.whereami!=='boards', embed_embed, false);
    },1);
      if (pref[embed_mode].merge || pref[embed_mode].merge_list)
        setTimeout(site2['DEFAULT'].update_posts_merge_bases.onchange_merge.bind(null,({target:{name:embed_mode+'.merge'+(pref[embed_mode].merge?'':'_list')}})),2);

      function catalog_insert(key) {
        var dbt = key.split(',');
        if (pref.catalog_promiscuous || (dbt[0]+dbt[1] in boards)) scan_boards.scan_init('snoop', [key], {lifetime:3600, crawler_max:1, tgt_raw:true});
      }
      function catalog_insert_snoop(key,value) {
        catalog_insert2(key,value,true,true);
      }
      function catalog_insert2(key,value,snoop,from_auto) {
//var check_perf = ['catalog_refresh :', performance.now()];
        var dbt = key.split(',');
        var nickname = dbt[0];
        var board = dbt[1];
        var read_type = dbt[3];
        var page_no = dbt[2];
        var thread = dbt[2];
////////        var dbt = cnst.name2domainboardthread(key,true);
////////        var nickname = dbt[0];
////////        var board = dbt[1];
////////        var read_type = (dbt[2][0]==='p')? 'page_html' : ((dbt[2][0]==='c')? 'catalog_html' : ((dbt[2][0]==='j')? 'catalog_json' : 'thread_html'));
////////        var page_no = (read_type==='thread_html')? '?' : dbt[2].substr(1);
////////        var thread = dbt[2];
        if (snoop && !pref.catalog_promiscuous && read_type==='thread_html' && !threads[name]) {
          var hit = false;
          for (var i=0;i<load_list.refresh.tgts.length;i++) if (load_list.refresh.tgts[i][0].indexOf(name)!=-1) {hit=true;break;}
          if (!hit) return 0; // return if no interest.
        }
if (pref.test_mode['3']) return;
        if (!('response' in value)) value.response = (read_type==='catalog_json')? JSON.parse(value.responseText)
                                                                                 : new DOMParser().parseFromString(value.responseText, 'text/html'); // cause memory leak at KC/int/.
if (pref.test_mode['2']) return;
//check_perf.push(performance.now());
        var tgts_show = {};
//        catalog_clear_threads(pref.catalog.max_threads);
////////        if ((read_type==='page_html' || read_type==='thread_html') && nickname==='NONE') { // for debug
//////////        if ((read_type==='page_html' || read_type==='thread_html') && nickname==='KC') { // for debug
//////////        if ((read_type==='page_html' || read_type==='thread_html') && nickname!=='8chan') { // for debug
//////////        if ((read_type==='page_html' && nickname!=='8chan') || read_type==='thread_html') { // for debug
//////////        if (read_type==='page_html' || read_type==='thread_html') {
////////          var name = nickname + board + thread;
////////          if (snoop && !pref.catalog_promiscuous && read_type==='thread_html' && !threads[name]) {
////////            var hit = false;
////////            for (var i=0;i<load_list.refresh.tgts.length;i++) if (load_list.refresh.tgts[i][0].indexOf(name)!=-1) {hit=true;break;}
////////            if (!hit) return 0; // return if no interest.
////////          }
//////////          value.responseText = site2[nickname].preprocess_html(value.responseText,read_type==='page_html'); // cause memory leak.
//////////          var doc = ('response' in value)? value.response : new DOMParser().parseFromString(value.responseText, 'text/html');
////////          var doc = value.response;
////////          site2[nickname].preprocess_doc(doc);
////////          var nof_posts = 0;
////////          var nof_files = 0;
////////          if (read_type==='thread_html') {
////////            var nof_pi = site2[nickname].thread2headline(doc);
////////            nof_posts  = nof_pi[0];
////////            nof_files = nof_pi[1];
////////            nof_pi = null; // for test
////////            site2[nickname].add_thread_link(doc,site2[nickname].make_url3(board,thread));
////////          }
////////          if (site.nickname!=nickname || site.board!=board) site2[nickname].absolute_link(doc,board);
////////          var threads_in_page = site2[nickname].catalog_threads_in_page(doc);
////////          var th_no = site2[nickname].get_ops(doc);
////////
////////          for (var i=0;i<threads_in_page.length;i++) {
////////            var p_node = threads_in_page[i].parentNode;
////////            insert_thread_from_page(threads_in_page[i], nickname, board, th_no[i], page_no+((read_type==='page_html' && pref.show_page_fraction)? '.'+i : ''), (i==0)?nof_posts : 0, (i==0)?nof_files : 0, snoop, value.date);
//////////          if (threads_in_page[i].parentNode==p_node) threads_in_page[i].parentNode.removeChild(threads_in_page[i]);
////////            tgts_show[nickname+board+th_no[i]]=true;
////////          }
////////        } else {
//          if (read_type==='thread_html') site2[nickname].add_thread_link(value.response,site2[nickname].make_url3(board,thread));
//          if (read_type==='page_html' || read_type==='thread_html') site2[nickname].preprocess_doc(value.response);
          var ths;
if (pref.test_mode['0']) {
          ths = {domain:nickname, board:board, page:page_no};
          if (read_type==='catalog_json') ths.obj = value.response;
          else ths.pn = value.response;
          site2[ths.domain].parse_funcs[read_type].entry(ths,site2[ths.domain].parse_funcs[read_type]['before_test']);
          ths = ths.ths;
} else {
//////          ths = Object.create({domain:nickname, board:board, page:page_no, parse_funcs:site2[nickname].parse_funcs[read_type], __proto__:site4.parse_funcs_on_demand});
//////          if (read_type==='catalog_json') ths.obj = value.response;
//////          else Object.defineProperty(ths,'pn',{value:value.response, enumerable:true, configurable:true, writable:true});
////          var parse_obj = Object.create({domain:nickname, board:board, page:page_no, parse_funcs:site2[nickname].parse_funcs[read_type], __proto__:site4.parse_funcs_on_demand});
////          ths = (read_type==='catalog_json')? {obj:value.response, __proto__:parse_obj} : {pn:value.response, __proto__:parse_obj};
////          ths = ths.ths;
          ths = site2[nickname].wrap_to_parse.get(value.response, nickname, board, read_type, {page:page_no});
}
          if (read_type==='catalog_json' || read_type==='catalog_html') rm_items_404_check(nickname,board,ths); // consumes 15-40 ms, too slow.
          if (snoop && !pref.catalog_promiscuous) for (var i=ths.length-1;i>=0;i--) if (!(ths[i].key in threads)) ths.splice(i,1);
//check_perf.push(performance.now());
          for (var i=0;i<ths.length;i++) {
//            if (read_type!=='catalog_json' && ths[i].pn.parentNode) ths[i].pn.parentNode.removeChild(ths[i].pn); // patch for memory leak issue, but probably fixed.
            if (insert_thread_with_test(ths[i], read_type, value.date)) tgts_show[ths[i].key]=true;
          }
////////        }
//check_perf.push(performance.now());
        if (Object.keys(tgts_show).length!=0) {
          show_catalog(tgts_show,from_auto);
//          if (pref.catalog.filter.tag_scan_auto) scan_tags();
        }
//check_perf.push(performance.now());
//check_perf.push('num: '+Object.keys(tgts_show).length);
//common_func.perf_out(check_perf);
      }

      var threads_delayed_pruning = Object.create(null);
      function restore_bd_from_IDB(domain, board){
        if (!threads_delayed_pruning[domain]) threads_delayed_pruning[domain] = {};
        if (!threads_delayed_pruning[domain][board]) threads_delayed_pruning[domain][board] = {};
        IDB.req(domain, board, null, null, restore_bd_from_IDB_1, 'list_os');
      }
      function restore_bd_from_IDB_1(domain, board, nos){
        for (var i=0;i<nos.length;i++) if (pref.test_mode['80'] || !threads[domain+board+nos[i]]) restore_th_from_IDB(domain, board, nos[i]);
      }
      function restore_th_from_IDB(domain, board, no){
        IDB.req(domain, board, no, null, archiver.event_funcs['restore3'].bind(archiver.event_funcs), 'get_all');
        if (!threads_delayed_pruning[domain]) threads_delayed_pruning[domain] = {}; // BUG, if a 404 thread is loaded before catalog, since this is used as a flag in above 'restore_bd_from_IDB' function.
        if (!threads_delayed_pruning[domain][board]) threads_delayed_pruning[domain][board] = {};
        threads_delayed_pruning[domain][board][no] = true;
      }
      cataLog.restore_th_from_IDB = restore_th_from_IDB;
      function rm_items_404_check(domain, board, ths){
        if (pref.patch.rm_404_blacklist.indexOf(domain)!=-1) return; // PATCH for 8chan, 8chan sends corrupted data.
//        if (pref.catalog.bookmark_list_rm404) {
//          var val = catalog_obj_merge(db,pref.catalog.filter.list_obj3,null);
//          val = catalog_obj_merge(db,pref.catalog.filter.attr_list_obj3,val);
//          if (val.hit) return true;
//        }
//        return false;
//        return pref.catalog.bookmark_list_rm404
//            && ((db in pref.catalog.filter.list_obj3) || (db in pref.catalog.filter.attr_list_obj3) || (db in pref.catalog.filter.watch_list_obj3));
        var nos = Object.create(pref.archive.IDB.auto_restore && threads_delayed_pruning[domain] && threads_delayed_pruning[domain][board] || null);
        for (var i=0;i<ths.length;i++) nos[ths[i].no] = null;
        var db = domain + board;
        var flag_item = (pref.catalog.bookmark_list_rm404
            && ((db in pref.catalog.filter.list_obj3) || (db in pref.catalog.filter.attr_list_obj3) || (db in pref.catalog.filter.watch_list_obj3)));
        if (flag_item) rm_items_404(db,nos);
        if (pref.liveTag.rm_404_immediately) liveTag.rm_404(domain, board, nos); // call remove_thread in this.
        if (!pref.test_mode['67']) archiver.clean_list_all(domain, board, nos);
        var lbd = liveTag.mems[domain][board];
        if (!lbd.LS_synced) {
          site2[domain].clean_up_LS(domain, board, nos);
          lbd.LS_synced = 1;
        }
        if (!pref.test_mode['65'] && !lbd.IDB_synced && pref.archive.IDB.auto_clean_init) IDB.clean_up(domain, board, nos);
      }
      function rm_items_404(db,nos){
//console.log('rrr');
        var tgts = [[pref.catalog.filter.list_str,      pref.catalog.filter.list_obj2,      search_ex_list],
                    [pref.catalog.filter.attr_list_str, pref.catalog.filter.attr_list_obj2, attr_list],
                    [pref.catalog.filter.watch_list_str, pref.catalog.filter.watch_list_obj2, watch_list]];
        var db_len = db.length;
        for (var i=0;i<tgts.length;i++) {
//          var changed = false;
////          for (var name in tgts[i][1]) { // too slow
////            var dbt = common_func.name2domainboardthread(name,true);
//////            if (dbt[0]===nickname && dbt[1]===board && dbt[2]!=='') {
//////              var flag = false;
//////              for (var j=0;j<ths.length;j++) if (dbt[2]==ths[j].no) {flag=true;break;}
//////              if (!flag) {
////            if (dbt[0]+dbt[1]===db && dbt[2]!=='') {
////              if (nos[dbt[2]]===undefined) {
////                if (pref.debug_mode['0']) console.log(name);
////                triage_exe(name,'DELETE','',false);
////                changed = true;
////                if (threads[name]) remove_thread(name);
////              }
////            }
////          }
//          for (var name in tgts[i][1]) {
////            if (!(name in nos) && name.indexOf(db)==0) {
//            if (name.indexOf(db)==0 && name.length!=db.length && !(name in nos)) {
//              if (pref.debug_mode['2']) console.log('rm_items_404: ' + name);
//              triage_exe(name,'DELETE','',false); // BUG, this changes tgts[i][1], so inconsistency occurs, and requires redundant sequences.
//              changed = true;
//              if (threads[name]) remove_thread(name);
//            }
//          }
//          if (changed) { // seems to be redundant.
//            tgts[0][2].value = tgts[0][2].value.replace(/\n\n+/g,'\n'); // triage_exe executes both.
//            tgts[1][2].value = tgts[1][2].value.replace(/\n\n+/g,'\n');
//            tgts[2][2].value = tgts[2][2].value.replace(/\n\n+/g,'\n');
//            pref_func.apply_prep(tgts[i][2],true);
//            pref_func.apply_prep(tgts[i][2],false);
//          }
          var list = [];
          for (var name in tgts[i][1]) {
            if (name.length>db_len && name.indexOf(db)===0 && !(name.substr(db_len) in nos)) {
              if (pref.debug_mode['2']) console.log('rm_items_404: ' + name);
              list[list.length] = name;
            }
          }
          if (list.length>0) triage_exe(list[0],'DELETE',list.slice(1),false); // BUG, this changes tgts[i][1], so inconsistency occurs, and requires redundant sequences.
        }
      }

//      function req_events(key,value,list) { // working code.
//        list.mutex = true;
////if (pref.debug_mode['0']) console.log(new Date().toLocaleTimeString() + ', refresh: callback: '+load_list.refresh.tgts[load_list.refresh.idx]+', '+load_list.refresh.idx);
//        if (value.status==200 && (value.responseText || value.response)) catalog_insert2(key,value,false,list.from_auto);
//        else {
//          if (value.status==404) comment_out_bookmark(key);
//          list.indicator.set('orange');
//        }
//        if (list.idx<list.tgts.length && value.status<500) {
//          if (!pref[embed_mode].load_on_demand) get_page(list);
//        } else {
//          if (list.idx==1 && value.status!=200) list.indicator.set('red','X');
//          else if (list.idx==list.tgts.length) list.indicator.set(null,'\u25cf');
//          else list.indicator.set(null,'\u25b2');
//          if (list.check_page) {
//            refresh_idx_page = 0;
//            page_check_entry();
//          } else http_req.close('catalog'+list.key);
//          catalog_refresh_watch();
//        }
//      }
//      function get_page(list){
////if (pref.debug_mode['0']) console.log(new Date().toLocaleTimeString() + ', refresh: get: '+list.tgts[list.idx]+', '+list.idx);
//        if (pref[embed_mode].load_on_demand && list.idx==0) 
//          for (var i=list.tgts.length-1;i>=1;i--) {
//            var name = 'ODL:'+list.tgts[i];
//            if (threads[name]) remove_thread(name);
//            threads_idx.unshift(name);
//          }
////        if (tgt===undefined) tgt = list.tgts[list.idx];
////        else tgt = [tgt,false];
//        if (list.idx==0 && !list.indicator) list.indicator = health_indicator.shift('limegreen','0');
//        list.indicator.set(null,(list.idx+1)+'/'+list.tgts.length);
//        http_req.get('catalog'+list.key,list.tgts[list.idx].replace(/!.*/,''),'',req_events,list.use_cache,true,list);
//        list.idx++;
//        list.mutex = false;
//      }
//
////      function req_events(key,value,args) {
//////if (pref.debug_mode['0']) console.log(new Date().toLocaleTimeString() + ', refresh: callback: '+refresh_tgts[refresh_idx][0]+', '+refresh_idx);
////        var inserted_idx = 0;
//////        var key = refresh_tgts[refresh_idx][0].replace(/!.*/,'');
//////        var key = args[0].replace(/!.*/,'');
////        if (value.status==200 && value.responseText) {
////          inserted_idx = catalog_insert2(key,value,false,args[1]);
////        } else {
////          if (value.status==404) comment_out_bookmark(key);
////          health_indicator.set('orange');
////        }
////        refresh_idx++;
////        if (refresh_idx<refresh_tgts.length && value.status<500) {
////          if (!pref[embed_mode].load_on_demand) get_page();
////          else {
////            if (threads_idx.length==inserted_idx+1) threads_idx.push('url');
////            else threads_idx.splice(inserted_idx+1,0,'url');
//////            threads_idx.splice(page_delim_idx[refresh_idx],0,'url'); // THIS MAKES SUBTLE BUG, insert point slides from here at snoop refresh, but ok to use, so I'll omit.
////            show_catalog();
////          }
////        } else {
////          if (refresh_idx==1 && value.status!=200) health_indicator.set('red','X');
////          else if (refresh_idx==refresh_tgts.length) health_indicator.set(null,'\u25cf');
////          else health_indicator.set(null,'\u25b2');
////          refresh_idx_page = 0;
////          page_check_entry();
////        }
////      }
////      function get_page(){
//////if (pref.debug_mode['0']) console.log(new Date().toLocaleTimeString() + ', refresh: get: '+refresh_tgts[refresh_idx][0]+', '+refresh_idx);
////        health_indicator.set(null,(refresh_idx+1)+'/'+refresh_tgts.length);
////        http_req.get('catalog',refresh_tgts[refresh_idx][0].replace(/!.*/,''),'',req_events,refresh_use_cache,true,refresh_tgts[refresh_idx]);
////      }

      var refresh_idx_page;
      function page_check_entry(){
        while (refresh_idx_page<load_list.refresh.tgts.length) {
          if (load_list.refresh.tgts[refresh_idx_page][0].search(/!page/)==-1) refresh_idx_page++;
          else {
            var name = load_list.refresh.tgts[refresh_idx_page++][0].replace(/!.*/,'');
            if (threads[name]) {
              if (threads[name][14].toString()[0]=='?') {
                var page_no_old = parseInt(threads[name][15].toString().replace(/\..*/,''),10);
                if (isNaN(page_no_old)) page_no_old = 0;
                page_check(name,page_no_old,page_check_callback);
                break;
              }
            }
          }
        }
      }
      function page_check_callback(name,str,date){
//console.log('Callback : '+name+', '+str);
        update_page_in_footer(name,str,date); // to show Dead.
        page_check_entry();
      }
      function update_page_in_footer(name,str,date){
//        if (threads[name]) {
        if (threads[name] && threads[name][0].getElementsByTagName('div')['catalog_footer']) { // patch for threads, this will be removed.
          var pn = threads[name][0].getElementsByTagName('div')['catalog_footer'].childNodes[0];
          if (pn) {
//            var str = str + '@' + new Date(date).toLocaleTimeString();
            pn.innerHTML = pn.innerHTML.replace(/[^\/]*$/,str);
          }
          threads[name][13]=date;
          threads[name][15]=threads[name][14];
          threads[name][14]=str;
        }
      }
 
      function page_check(name,page_ini,callback){
        var dbt = cnst.name2domainboardthread(name,true);
        var domain = dbt[0];
        var board = dbt[1];
        var thread = dbt[2];
        var page_idx = [];
        var max_page = site2[domain].max_page(dbt[1]);
        page_idx[0] = page_ini;
        page_idx[1] = (page_ini+1)%(max_page+1);
        for (var i=0;i<=max_page;i++) if (i!=page_idx[0] && i!=page_idx[1] && (!refresh_use_cache || i!=max_page)) page_idx.push(i);
//        if (!refresh_use_cache) for (var i=0;i<5;i++) page_idx.push(page_idx[i]); // for retry, but live cache working...
        var page_no;
        var key;
      
        function page_check(){
          page_no = page_idx.shift();
          key = (page_no==max_page)? domain+board+thread : domain+board+'p'+page_no;
//          http_req.get('catalog',key,url,req_events_page_check,refresh_use_cache);
          http_req.get('catalog',key,'',req_events_page_check,refresh_use_cache,true);
        }
        page_check();
        function req_events_page_check(key,value) {
//console.log('Read : '+name+', '+key+', '+value.status);
          var callback_str = null;
          if (value.status!=200) {
            if (page_no==max_page && value.status==404) callback_str = 'Dead';
            else callback_str = 'HTTP'+value.status;
          } else {
            var doc = ('response' in value)? value.response : new DOMParser().parseFromString(value.responseText, 'text/html');
            var ops = site2[domain].get_ops(doc);
            var hit = false;
            if (page_no!=max_page) for (var i=0;i<ops.length;i++) if (thread==ops[i]) {hit=true;callback_str = page_no+((pref.show_page_fraction)? '.'+i : '');}
            if (!hit) {
              if (value.responseText != null && page_idx.length!=0) setTimeout(page_check, 0); // live cache make racing condition with this. I don't know why.
              else callback_str = '?' + ((!refresh_use_cache)? '(missing)' : '');
              if (site2[domain].check_thread_archived(doc)) callback_str = 'Archived';
            }
          }
          if (value.status==200) catalog_insert2(key,value,true); // update
          if (callback_str!==null) {
            if (callback_str==='Dead' || callback_str==='Archived') {
              comment_out_bookmark(name);
//              var tgt = pn12_0_4.getElementsByTagName('textarea')['catalog.filter.bookmark_list_str'];
//              tgt.value = comment_out_key(name,tgt.value);
//              pref_func.apply_prep(tgt,true);
            }
            callback(name,callback_str,value.date);
          }
//console.log('Out : '+name+', '+key+', '+value.status);
        }
      }
      function comment_out_bookmark(name){
        var tgt = pn12_0_4.getElementsByTagName('textarea')['catalog.filter.bookmark_list_str'];
        tgt.value = comment_out_key(name,tgt.value);
        pref_func.apply_prep(tgt,true);
      }
      function comment_out_key(key,str){
////        var comments = [];
////        var str_ret = '';
////        var comment = new RegExp('//.*$','m');
////        while (1) {
////          var idx = str.search(comment);
////          if (idx!=-1) comments.push([idx,str.match(comment)[0]]);
////          else break;
////        }
//        return str.replace(key,'//$&');
        var rep_str = (pref.catalog.bookmark_list_rm404)? '' : '//$&';
////        return str.replace(new RegExp(key+'(!page)*(,|\n|$)','g'),rep_str); // working code.
        var dbt = key.split(',');
        return str.replace(new RegExp(dbt[0]+dbt[1]+dbt[2]+'(!page)*(,|\n|$)','g'),rep_str);
      }

      initialize_loop = false;
      pref_func.mirror_targets.pn12_0_2 = pn12_0_2;
      pref_func.mirror_targets.pn12_0_4 = pn12_0_4;

      var GEH = function(parent){ // GeneralEventHandler
        this.parent = parent;
        this.subscribers = [];
        this.valid = null;
        this.last_viewed = null;
        this.last_Y = 0;
      };
      GEH.prototype = {
        setup: function(reset){
          if (pref[embed_mode].scroll_lock && !this.valid && !reset){
            this.valid = this.mouseover_lock.bind(this);
            this.parent.addEventListener('mouseover', this.valid, true);
          } else if (this.valid) {
            this.parent.removeEventListener('mouseover', this.valid, true);
            this.valid = null;
          }
        },
//        var geh = site2[site.nickname].general_event_handler[site.whereami];
        mouseover_lock: function(e){
//if (pref.debug_mode['14']) if (last_viewed) site2[site.nickname].general_event_handler[site.whereami].get_mark(last_viewed, get_now_height()+last_Y).style.border = 'none';
          this.last_viewed = e.target;
          this.last_Y = e.clientY;
////          if (geh.last_viewed.call(this,e)) show_catalog_scroll_lock.viewed(e.target);
//          //          e.stopPropagation();
//if (pref.debug_mode['14']) {
//  var pn = site2[site.nickname].general_event_handler[site.whereami].get_mark(e.target, get_now_height()+last_Y);
//  if (!pn.classList.contains('post')) console.log(e.target, pn)
//  pn.style.border = '1px solid blue';
//}
        },
        change: (function(){
          var class_expander = pref.script_prefix + '_expander';
          return function(e){
            if (e.target.className===class_expander) {
              var name = e.target.getAttribute('data-key');
              cataLog.threads[name][16].expand(e.target.selectedIndex);
//              threads[name][16].t2h_sel = format_html.get_t2h_from_index(e.target.selectedIndex);
//              threads[name][16].expand_posts = true;
////            drawn_idx = 0; // patched in 'show_catalog', because this is required when images are expanded.
//              scan.scan_ui('expand_page', {tgts:[name], options:{refresh:true}});
              e.target.blur();
            }
          };
        })(),
        blacklist_click: new WeakSet(),
        geh: site2[site.nickname].general_event_handler[site.whereami],
        click: function(e){
          var et = e.target;
          if (pref.test_mode['104'] && GEH.prototype.geh.isThumbnail(e)) {
            var domain = site2['DEFAULT'].popups_posts.href2domain(et.getAttribute('src'));
            if (!GEH.prototype.blacklist_click.has(et) && (!pref[embed_mode].env.expand_thumbnail_inline_native || !(pref[embed_mode].env.event_dynamic && domain===site.nickname)))
              DIH.expand_thumbnail_inline.call(e.target, e);
          } else if (et.tagName==='A') {
            if (pref.test_mode['93']) {
              var filename = et.getAttribute('download');
              if (filename) {
                var href = et.getAttribute('href');
                var tgt_domain = href.search(/^(https*:)*\/\//)!=-1 && href.replace(/^(https*:)*\/\//,'').match(/^([^/]*)\//)[1];
                if (site2['ALL'][tgt_domain]) tgt_domain = site2[site2['ALL'][tgt_domain]].nickname;
                if (tgt_domain!=site2[site.nickname].domain_url) {
                  httpd.req({tgts:[{url:href, domain:tgt_domain, archive:filename, responseType:'blob'}], max:1, initiator:'download', callback_1:function(){}},6);
                  e.preventDefault();
                  e.stopPropagation();
                  return;
                }
              }
            }
            if (pref.test_mode['87']) {
              if (et.href.indexOf('//www.youtube.com')!==-1) insert_iframe_youtube(et.href.replace(/watch\?v=/,'embed/'), e);
              else if (et.href.indexOf('//youtu.be')!==-1)   insert_iframe_youtube(et.href.replace(/youtu.be/,'youtube.com/embed'), e);
              else {
                var cmd = et.getAttribute('data-cmd');
                if (cmd && cmd.indexOf(pref.script_prefix)===0) {
                  cmd = cmd.substr(pref.script_prefix.length+1);
                  if (cmd==='remove_next') remove_next(e);
                }
              }
            }
          }
          function insert_iframe_youtube(url, e, et){
            var et = e.target;
            var close_button = document.createElement('span');
            close_button.innerHTML = ' [<a data-cmd="'+pref.script_prefix+'_remove_next">Remove</a>] ';
            if (!et.nextSibling || et.nextSibling.innerHTML!==close_button.innerHTML) {
              e.target.parentNode.insertBefore(close_button,et.nextSibling);
              var div = document.createElement('div');
              div.innerHTML = '<iframe src="' + url + '" width="640" height="360" frameborder="0" allowfullscreen=""></iframe>';
              div.classList.add('media-embed');
              et.parentNode.insertBefore(div,close_button.nextSibling);
            }
            e.stopPropagation();
            e.preventDefault();
          }
          function remove_next(e){
            e.target.parentNode.parentNode.removeChild(e.target.parentNode.nextSibling);
            e.target.parentNode.parentNode.removeChild(e.target.parentNode);
          }
        },
        get_last_viewed: function(){
          return (this.last_viewed)? site2[site.nickname].general_event_handler[site.whereami].get_mark(this.last_viewed, get_now_height()+this.last_Y) : null;
        },
        clear_last_viewed: function(){this.last_viewed = null;},
        init: function(){
          var dynamic_image_hover = site2[site.nickname].parse_funcs[site.whereami+'_html'].dynamic_image_hover;
          var geh = site2[site.nickname].general_event_handler[site.whereami];
//          if (geh && geh.mouseover && (geh.add_mouseover || dynamic_image_hover)) if (pref.test_mode['103']) common_func.dom_addEventListener(this.subscribers, this.parent, 'mouseover', geh.mouseover);
          common_func.dom_addEventListener(this.subscribers, this.parent, 'change', this.change);
          if (pref.test_mode['87'] || pref.test_mode['93'] || pref.test_mode['104']) common_func.dom_addEventListener(this.subscribers, this.parent, 'click', this.click);
          if (pref.test_mode['104']) site.popup_body.addEventListener('click', this.click, false);
          this.setup();
//          if (!pref.test_mode['98']) if (pref.test_mode['103']) site.popup_body.addEventListener('mouseover', site2[site.nickname].general_event_handler['page'].mouseover, false);
          this.parent.addEventListener('dragstart', this.dragstart, false);
          this.parent.addEventListener('dragend', this.dragend, false);
          site.popup_body.addEventListener('dragstart', this.dragstart, false);
          site.popup_body.addEventListener('dragend', this.dragend, false);
        },
        destroy: function(){
          this.setup(true);
          common_func.dom_removeEventListener(this.subscribers);
        },
        mouseover: function(e, force){
          var et = e.target;
          site2['DEFAULT'].popups_posts.over(e, force);
          if (pref.liveTag.info && pref.tooltips['info'].show)
            if (et.className===pref.script_prefix+'_tag') pref_func.tooltips.req_show('info', e, liveTag.tag_onmouseover); // mouseover only for faster execution. mouseleave is needed strictly.
            else pref_func.tooltips.hide2();
          
        },
        mouseleave_bl: function(e){
          if (pref.liveTag.info) pref_func.tooltips.hide2();
        },
        drag_sx: 0,
        drag_sy: 0,
        dragstart: function(e){
          var myself = GEH.prototype;
          myself.drag_sx = e.screenX;
          myself.drag_sy = e.screenY;
        },
        dragend: function(e){
          if (!pref[embed_mode].thumbnail.hover.dragfloat || (!DIH.hover_ex && e.target.tagName!=='IMG')) return;
          var myself = GEH.prototype;
          var img = DIH.image_hover_snatch();
          var right = ((img)? parseInt(img.style.right,10) : cnst.left2right(e.clientX - e.offsetX, e.target)) - (e.screenX - myself.drag_sx);
          var top = ((img)? parseInt(img.style.right,10) : e.clientY - e.offsetY) + e.screenY - myself.drag_sy;
          var cn = cnst.init3({
            func_str:'right:'+right+'px:top:'+top+'px:tb:ftb:overflow:auto:Show'}).cn;
          cn.appendChild(img || e.target.cloneNode());
          if (img) DIH.image_hover_snatch_end();
        },
      };
      cataLog.GEH = GEH;
      cataLog.general_event_handler = new GEH(triage_parent);
      setTimeout(cataLog.general_event_handler.init.bind(cataLog.general_event_handler), 500); // WHY 500ms delay?

      var GEH_mouseover_force = (function(func){return function(e){func(e,true);};})(GEH.prototype.mouseover);
      if (!pref.test_mode['98']) site.popup_body.addEventListener('mouseover',GEH_mouseover_force,false);
      triage_parent.addEventListener('mouseover', (embed_mode==='float')? GEH_mouseover_force : GEH.prototype.mouseover, false);
      triage_parent.addEventListener('mouseleave', site2['DEFAULT'].popups_posts.leave, false);
      if (site.components.boardlist) {
        site.components.boardlist.addEventListener('mouseover',GEH.prototype.mouseover,false);
        site.components.boardlist.addEventListener('mouseleave',GEH.prototype.mouseleave_bl,false);
      }
      site2['DEFAULT'].popups_posts.init(triage_parent);
      
      return {
        destroy: function(){ // destructor
          cataLog.general_event_handler.destroy();
//          triage.off();
          for (var name in threads) remove_thread(name);
//          pref_func.remove_onchange(pn12_0_2); // prevent leak.
//          pref_func.remove_onchange(pn12_0_4); // prevent leak.
          pref_func.mirror_targets.pn12_0_2 = null;
          pref_func.mirror_targets.pn12_0_4 = null;
          catalog_clear_threads(0);
          if (brwsr.sw_cache && brwsr.sw_cache.subscribe) brwsr.sw_cache.subscribe(false);
//          pref_func.health_indicator = null;
          health_indicator.destroy();
//          if (embed_catalog) if (catalog_native_destroy) catalog_native_destroy();
          cnst.auto_shrink_board_selector.destroy(board_sel);
          window_beforeunload();
//          pref_func.tooltips.remove_hier(pn12_triage);
          remake_triage(true);
//          pref_func.tooltips.remove_hier(pn12_0_4);
          pref_func.tooltips.remove_root(pn12_0_4);
          pref_func.tooltips.hide();
//          clearTimeout(auto_update_timer);
          auto_update.stop_if_running();
          pn12.parentNode.removeChild(pn12);
          window.removeEventListener('storage', site2[site.nickname].prep_own_posts_event, false); // debug
          scroll_event_src.removeEventListener('scroll', show_catalog_cont, false);
          window.removeEventListener('resize', show_catalog_cont, false);
//          pn12.removeEventListener('dragstart', auto_hide_catalog, false);
//          pn12.removeEventListener('dragend'  , auto_hide_catalog, false);
//          pn12_triage.removeEventListener('mouseover', catalog_triage_out_clear, false);
//          pn12_triage.removeEventListener('mouseout' , catalog_triage_out_delay, false);
          pn12 = null;
          liveTag.pn = null;
          for (var i in cataLog) cataLog[i] = null;
          return null;
        },
        remake_triage: remake_triage,
        triage_exe_pipe: triage_exe_pipe,
        catalog_insert: catalog_insert,
        pn12_0_4: pn12_0_4,
        pn12_0_2: pn12_0_2,
        catalog_resized: catalog_resized,
        get_threads: function(){return threads;},
        catalog_filter_changed: catalog_filter_changed,
        scan_boards: scan_boards,
        show_catalog: show_catalog,
//        threads: threads,
        catalog_liveTag_scan_site: onchange_funcs['scanSite'],
      }
    }
    return {
      catalog_func: function(){return catalog_func;},
      scan_tags_common: scan_tags_common,
      show_hide: show_hide,
    }
  }

  var stats = (pref3.stats.use)? (function(){
    var tree_404 = {};
    function thread_removed(dbt){
      var lth = liveTag.mems[dbt[0]][dbt[1]][dbt[2]];
      if (lth.ss) {
        if (Array.isArray(lth.ss)) for (var i=0;i<lth.ss.length;i++) {if (lth.ss[i].rm) lth.ss[i].rm.update_thread(lth.s, 0, true);}
        else if (lth.ss.rm) lth.ss.rm.update_thread(lth.s, 0, true);
      }
      if (pref.stats.retain_404 && lth.s) {
        if (!tree_404[dbt[0]]) tree_404[dbt[0]] = {};
        if (!tree_404[dbt[0]][dbt[1]]) tree_404[dbt[0]][dbt[1]] = {};
        tree_404[dbt[0]][dbt[1]][dbt[2]] = liveTag.mems[dbt[0]][dbt[1]][dbt[2]];
//        if (tree_404[dbt[0]][dbt[1]].sr || Object.keys(tree_404[dbt[0]][dbt[1]]).length>64) update_board_rm(tree_404[dbt[0]][dbt[1]]);
        if (pref.test_mode['44'] || tree_404[dbt[0]][dbt[1]].sr || Object.keys(tree_404[dbt[0]][dbt[1]]).length>64) update_board_rm(tree_404[dbt[0]][dbt[1]]);
      }
    }
    
    var label_funcs = {
      hour: function(t){return new Date(t*60000).toString().split(' ')[4].replace(/:\d*$/,'');},
      day: function(t){return new Date(t*60000).toString().replace(/\s\d{4}.*/,'');},
      sunday : function(t){
        var str = new Date(t*60000).toString();
        return (str.split(' ')[0]=='Sun')? str.replace(/\s\d{4}.*/,'') : '';
      },
      month : function(t){
        var str = new Date(t*60000).toString();
        return (str.split(' ')[2]=='01')? str.replace(/\s\d{4}.*/,'') : '';
      },
      quarter_year : function(t){
        var strs = new Date(t*60000).toString().split(' ');
        return (strs[2]<=7 && ['Jan','Apr','Jul','Oct'].indexOf(strs[1])!=-1)? strs.slice(1,4).join(' ') : '';
      },
    }
    label_funcs['1'] = [60, label_funcs.hour, 1];
//    label_funcs['2'] = [60, label_funcs.hour, 1]; // debug
    label_funcs['10'] = [60, label_funcs.hour, 1];
    label_funcs['60'] = [1440, label_funcs.day, 1];
    label_funcs['1440'] = [1440, label_funcs.sunday, 0];
    label_funcs['10080'] = [1440, label_funcs.quarter_year, 0];
//    var time_unit_arr = [1,2,60,1440,10080]; // debug
    var time_unit_arr = [1,10,60,1440,10080];

    function thread_created(lth){
      for (var i=0;i<instances.length;i++) {
        var result = pref_func.merge_obj5(lth.key, instances[i].tgts_obj2,{hit:false});
        if (result.hit) instances[i].check_and_add_thread(lth);
      }
    }
    var time_root = Math.floor(Date.now()/60000);
    var instances= [];
//    var count = 0;
    var Stats = function(chart, tgts, key){
      instances.push(this);
      this.chart = chart;
      this.tolerance = 0;
//      this.name = 'graph_'+ count++;
      this.draw = DelayBuffer.prototype.delayed_do.bind(new DelayBuffer(this.refresh.bind(this), pref.stats.draw_delay*1000));
      this.wdg_tick = new Watchdog(this.prep_time.bind(this), 60000);
      this.fromNo = (pref3.stats.estimate_posts)? new StatsFromNo(this) : null; // for subscribe, this pointer can't be changed.
      this.tgts_changed(tgts, key, true); // this.tgts, this.key
      this.time_unit_changed(pref.chart.inst.time_sel, true); // this.time_base, this.time_unit, this.time_last, time_sel
      this.len_changed((this.chart && this.chart.len>pref.stats.len_capture)? this.chart.len : pref.stats.len_capture); // this.len, this.data_p, this.data_t, this.data_l, this.min_idx, this.data_p_old, this.data_t_old, this.shift, this.rm.data_p, this.rm.data_t
    };
    Stats.prototype = {
      destroy: function(){
        this.chart = null;
        this.save_all_unsubscribe(true);
        this.wdg_tick.stop();
        instances.splice(instances.indexOf(this),1);
      },
      merge_1: function(dst,src){
        if (src) for (var i=0;i<src.length;i++) if (dst[i]<src[i]) dst[i] = src[i]; // src[i] may be undefined.
        return dst;
      },
      merge_1_hier: function(dst,src, lower){
        var num = this.time_unit/lower.time_unit;
        var start = Math.ceil((lower.time_base - this.time_base)/this.time_unit);
        var i = (num - (lower.time_base%this.time_unit)/lower.time_unit)%num; // start offset
        while (i<src.length) {
          this.merge_1_hier_1(dst, src, start, i, num, lower);
          i+=num;
          start++;
        }
      },
      merge_1_hier_1: function(dst,src,idx_d,idx_s,num, lower){
        var data = 0;
        var end = (src.length>=idx_s+num)? num : src.length - idx_s;
        for (var j=0;j<end;j++) data += src[idx_s+j];
        if (pref.debug_mode['15'])
          if (data>dst[idx_d])
            console.log('merge_1_hier_1: '+this.time_unit+': '+idx_d+', '+dst[idx_d]+'->'+data+', '+
                        new Date((this.time_base+idx_d*this.time_unit)*60000).toLocaleString()+', '+
                        new Date((lower.time_base+idx_s*lower.time_unit)*60000).toLocaleString()+', '+num);
        if (data>dst[idx_d]) dst[idx_d] = data;
      },
      save_all_unsubscribe: function(from_destructor){ // destructive
        if (this.tgts && pref.stats.save && auto_acquisition_keys['@'+this.key]!==undefined) {
          var timestamp = Math.floor(Date.now()/60000);
          if (auto_acquisition_keys['@'+this.key]!==timestamp) { // prevent from saving twice in auto_acquisition
            var chart_bak = this.chart;
            this.chart = null; // don't draw
            var idx = time_unit_arr.indexOf(this.time_unit);
////            this.save();
////            for (var i=1;i<time_unit_arr.length;i++) {
////              this.time_unit_changed((idx+i)%time_unit_arr.length);
////              this.save();
////            }
            var data_lower = null;
            for (var i=0;i<time_unit_arr.length;i++) {
              this.time_unit_changed(i);
              this.save(data_lower);
              data_lower = {data_p:this.data_p, data_t:this.data_t, time_unit:this.time_unit, time_base:this.time_base};
            }
            if (!from_destructor) this.time_unit_changed(idx);
            this.chart = chart_bak;
            auto_acquisition_keys['@'+this.key] = timestamp;
          }
        }
        if (this.tgts) {
          this.prep('both',this.prep_thread_unsubscribe);
          if (this.fromNo) this.fromNo.prep('live',this.fromNo.prep_board_unsubscribe);
        }
      },
      Zcompress: function(str){
        return str.replace(/0,(0,)+/g,function(match){return 'z'+match.length/2+',';});
//        var test2 = this.Zdecompress(test);
//        if (test2!==str) console.log('ERROR: '+str+', '+test+', '+test2);
//        return str;
      },
      Zdecompress: function(str){
        return str.replace(/z(\d+),/g,function(match,p1){
          var str = '';
          var len = parseInt(p1,10);
          for(var i=0;i<len;i++) str+='0,';
          return str;
        });
      },
      get_ls_key: function(){
        if (pref.test_mode['38']) return pref.script_prefix + '.graph.' + this.time_unit + '.' + this.key+'_test38';
        return pref.script_prefix + '.graph.' + this.time_unit + '.' + this.key;
      },
      save: function(data_lower){ // destructive
        if (this.data_p && pref.stats.load && pref.stats.save && localStorage) {
          this.merge_1(this.data_p, this.data_p_old);
          this.merge_1(this.data_t, this.data_t_old);
          if (data_lower) {
            this.merge_1_hier(this.data_p, data_lower.data_p, data_lower);
            this.merge_1_hier(this.data_t, data_lower.data_t, data_lower);
          }
          var i=0;
          while (i<this.data_p.length && this.data_p[i]===0 && this.data_t[i]===0) i++;
          var data_save = [this.time_base+i*this.time_unit, this.data_p.slice(0,this.len+1).slice(i), this.data_t.slice(0,this.len+1).slice(i)];
if (!pref.test_mode['42']) {
          if (this.fromNo) {
            var fN = this.fromNo;
            fN.valid = true;
            fN.prep('live',fN.prep_board_check_valid);
            if (!fN.valid) for (var j=0;j<fN.data_p.length;j++) fN.data_p[j] = 0;
            else if (fN.data_p_old) {
              var idx_last = fN.data_p_old.length-1;
              if (fN.data_p[idx_last]>fN.data_p_old[idx_last]) fN.data_p_old[idx_last] = fN.data_p[idx_last]; // overwrite last data, because last data may NOT complete its period.
            }
            if (fN.data_p_old) fN.data_p = fN.data_p_old.concat(fN.data_p.slice(fN.data_p_old.length));
            for (var j=fN.data_p.length-2-this.tolerance;j<fN.data_p.length;j++) fN.data_p[j] = 0; // fill 0 to last 2 or more.
            data_save[3] = fN.data_p.slice(0,this.len+1).slice(i);
          }
}
          localStorage[this.get_ls_key()] = this.Zcompress(JSON.stringify(data_save));
          if (pref.debug_mode['15']) console.log('saved: '+this.get_ls_key());
        }
      },
      load: function(){
        if (pref.stats.load && localStorage) {
          var data = localStorage[this.get_ls_key()];
          if (data) {
            data = JSON.parse(this.Zdecompress(data));
            var start = (this.time_base - data[0])/this.time_unit;
            var end   = Math.floor((time_root - this.time_last)/this.time_unit); // negative value.
            if (end===0) end = undefined;
            if (start>=0) {
              this.data_p_old = data[1].slice(start, end);
              this.data_t_old = data[2].slice(start, end);
              if (this.fromNo && data[3]) this.fromNo.data_p_old = data[3].slice(start, end);
            } else {
              this.data_p_old = this.array_init([],0,0).slice(0,-start).concat(data[1].slice(0,end));
              this.data_t_old = this.array_init([],0,0).slice(0,-start).concat(data[2].slice(0,end));
              if (this.fromNo && data[3]) this.fromNo.data_p_old = this.array_init([],0,0).slice(0,-start).concat(data[3].slice(0,end));
            }
            if (this.fromNo && this.fromNo.data_p_old) while (this.fromNo.data_p_old[this.fromNo.data_p_old.length-1]===0) this.fromNo.data_p_old.pop();
          } else {
            this.data_p_old = null;
            this.data_t_old = null;
          }
        } 
      },
      tgts_changed: function(tgts, key, skip_init){
        this.save_all_unsubscribe();
        this.tgts = tgts;
        this.key = key;
        pref_func.str2obj2(this,'tgts_obj2',tgts.join(','),null,true); // make this.tgts_obj2
        this.prep('both',this.prep_thread_subscribe);
        if (!skip_init) this.init();
      },
      time_unit_changed: function(sel, skip_init){
        if (this.fromNo) this.fromNo.prep('live',this.fromNo.prep_board_unsubscribe);
//        this.save();
//        if (typeof(sel)!=='number') sel = sel.target.selectedIndex;
        this.time_sel = sel;
        this.time_unit = time_unit_arr[sel];
        if (!skip_init) this.init();
      },
      len_changed: function(len){
//        this.save();
        this.len = len;
        this.init();
      },
      init: function(){
        this.time_last = null; // force to remake
        this.data_p = [];
        this.data_t = [];
        this.data_l = [];
        this.rm = (this.chart && (this.chart.show.ep || this.chart.show.et))? new StatsRm(this) : null;
        if (this.fromNo) {
          this.fromNo.data_p = [];
          this.fromNo.data_p_old = [];
          this.fromNo.min_idx = 0;
        }
        this.refresh(true);
      },
      array_init: function(arr,start,val){
        for (var i=start;i<this.len+2;i++) if (arr[i]===undefined) arr[i] = val; // len+2
        return arr;
      },
      tz_offset: new Date().getTimezoneOffset(),
      label_init: function(start){
        var lfunc = label_funcs[this.time_unit];
        var i = (lfunc[2])? Math.floor((Math.floor(((this.time_base-this.tz_offset) + (this.len+2)*this.time_unit)/lfunc[0])*lfunc[0] - (this.time_base-this.tz_offset))/this.time_unit) :
                            this.len+2;
        while (i>=start) {
          this.data_l[i] = lfunc[1](this.time_base + i*this.time_unit);
          i -= (lfunc[2])? lfunc[0]/this.time_unit : 1;
        }
      },
      prep_time: function(init){
        var time_now = Math.floor((Date.now()/60000+this.tolerance)/this.time_unit)*this.time_unit;
        if (this.time_last!==time_now) {
          var distance = (time_now - this.time_last)/this.time_unit;
          this.time_last = time_now;
          this.time_base = time_now - this.time_unit * this.len;
          var start = 0;
          if (!init && distance!==0) {
            if (distance>this.len) distance = this.len;
            this.data_p.splice(0,distance);
            this.data_t.splice(0,distance);
            this.data_l.splice(0,distance);
            if (this.rm) {
              this.rm.data_p.splice(0,distance);
              this.rm.data_t.splice(0,distance);
            }
            if (this.fromNo) {
              this.fromNo.data_p.splice(0,distance);
              if (this.fromNo.data_p_old) {this.fromNo.data_p_old.splice(0,distance); if (this.fromNo.data_p_old.length===0) this.fromNo.data_p_old = null;}
              this.fromNo.min_idx -= distance;
            }
            if (this.data_p_old) {this.data_p_old.splice(0,distance); if (this.data_p_old.length===0) this.data_p_old = null;}
            if (this.data_t_old) {this.data_t_old.splice(0,distance); if (this.data_t_old.length===0) this.data_t_old = null;}
            start = this.len - distance;
            this.min_idx -= distance;
            if (this.min_idx<0) this.min_idx = 0; // this.min_idx <= this.len, therefore this may occur.
          }
          this.array_init(this.data_p,start,0);
          this.array_init(this.data_t,start,0);
          this.array_init(this.data_l,start,'');
          if (this.rm) {
            this.array_init(this.rm.data_p,start,0);
            this.array_init(this.rm.data_t,start,0);
          }
          if (this.fromNo) this.array_init(this.fromNo.data_p,start,0);
          this.label_init(start);
          this.shift = (init)? 0 : this.shift + distance;
        }
        this.wdg_tick.restart(this.time_unit*60000);
      },
      prep: function(tree, func, func_t){
        for (var i=0;i<this.tgts.length;i++) {
          var dbt = common_func.name2domainboardthread(this.tgts[i],true);
          if (tree==='live' || tree==='both') this.prep_1(liveTag.mems, dbt, func, func_t);
          if (tree==='dead' || tree==='both') this.prep_1(tree_404, dbt, func, func_t);
        }
      },
      prep_1: function(tree, dbt, func, func_t){
        if (dbt[2]) {
          if (tree[dbt[0]] && tree[dbt[0]][dbt[1]] && tree[dbt[0]][dbt[1]][dbt[2]] && func_t!==null) ((func_t)? func_t : func).call(this,tree[dbt[0]][dbt[1]][dbt[2]]);
        } else if (dbt[1]) {
          if (tree[dbt[0]] && tree[dbt[0]][dbt[1]]) this.prep_board(tree[dbt[0]][dbt[1]],func, func_t);
        } else {
          if (tree[dbt[0]]) this.prep_domain(tree[dbt[0]],func, func_t);
        }
      },
      prep_domain: function(ld,func){
        for (var b in ld) this.prep_board(ld[b],func, func_t);
      },
      prep_board: function(ldb,func){
        for (var t in ldb) func.call(this,ldb[t]);
      },
      prep_thread_init: function(ldbt){
        if (ldbt.s) this.update_thread(ldbt.s, 0);
      },
      check_and_add_thread: function(ldbt){
        if (ldbt.s && !this.prep_thread_unsubscribe(ldbt,true)) {
          this.update_thread(ldbt.s, 0, true);
          this.prep_thread_subscribe(ldbt);
        }
      },
      prep_thread_subscribe: function(ldbt){
        if (Array.isArray(ldbt.ss)) ldbt.ss.push(this);
        else if (ldbt.ss) ldbt.ss = [ldbt.ss, this];
        else ldbt.ss = this;
      },
      prep_thread_unsubscribe: function(ldbt, check_only){
        if (Array.isArray(ldbt.ss)) {
          var idx = ldbt.ss.indexOf(this);
          if (check_only) return (idx!==-1);
          if (idx!=-1) {
            ldbt.ss.splice(idx,1);
            if (ldbt.ss.length===1) ldbt.ss = ldbt.ss[0];
          }
        } else if (ldbt.ss===this) {
          if (check_only) return true;
          delete ldbt.ss;
        } else return false;
      },
      refresh: function(init){
        if (pref.debug_mode['15']) console.log('updated: '+this.data_p.slice(this.len-10).toString()+', '+this.min_idx);
        this.prep_time(init);
        if (init) {
          this.prep('live',this.prep_thread_init);
          this.rm_tmp = new StatsRm(this, this.data_p, this.data_t);
          this.rm_tmp.prep('dead',this.rm_tmp.prep_board_init, this.prep_thread_init);
          if (this.rm) this.rm.prep('dead',this.rm.prep_board_init, this.prep_thread_init);
          if (this.fromNo) this.fromNo.prep('live',this.fromNo.prep_board_init, true);
          this.load();
          if (this.chart) this.chart.replace_data(this);
        } else if (this.shift!==0 || this.min_idx!==this.data_p.length) {
          if (this.fromNo) this.fromNo.prep('live',this.fromNo.prep_board_init, false, true);
          if (this.chart) this.chart.update_data2(this);
        }
        this.min_idx = this.data_p.length; // 'this.min_idx = this.len-1;' is suitable if local and server clocks are synced.
      },
//      remove_thread: function(s, start, from_thread){
//        this.update_thread(s, start, from_thread);
//        if (this.min_idx!==undefined) {
//          this.__proto__.min_idx = this.min_idx;
//          delete this.min_idx;
//        }
//      },
      update_thread: function(s, start, from_thread){
        if (!s) return;
        if (start===0) this.update_thread_1(this.data_t, s, 0, 0);
        this.update_thread_1(this.data_p, s, start, s.length-1);
        if (from_thread) this.draw();
      },
      update_thread_1: function(data, s, start, end){
        for (var j=end;j>=start;j--) {
          var idx = Math.floor((s[j]-this.time_base)/this.time_unit);
          var idx_over = idx - this.len -1;
          if (idx_over>0) {
            if (pref.stats.tolerant) {
              this.tolerance = idx_over*this.time_unit + this.tolerance;
              if (this.tolerance>pref.stats.tolerance) this.tolerance = pref.stats.tolerance;
              this.prep_time(false);
            }
            idx = this.len+1;
          }
          if (idx>=0) {
//            data[(idx<=this.len)? idx : this.len+1]++;
            data[idx]++;
            if (idx<this.min_idx) this.min_idx = idx;
          } else break;
        }
      },
    };
    var StatsRm = function(parent, data_p, data_t){
      this.data_p = data_p || [];
      this.data_t = data_t || [];
      Object.defineProperty(this,'min_idx',{set: function(val){this.__proto__.min_idx = val;},
                                            get: function(){return this.__proto__.min_idx;}, // necessary
                                            configurable:true, enumerable:true});
      for (var i in StatsRm_prototype) this[i] = StatsRm_prototype[i];
      this.__proto__ = parent;
    };
    var StatsRm_prototype = {
      prep_board: function(ldb,func, func_t){
        if (ldb.sr) func.call(this,ldb);
        else for (var t in ldb) func_t.call(this,ldb[t]);
      },
      prep_board_init: function(ldb){ // for initial only
        this.prep_board_init_1(ldb.sr, this.data_p);
        this.prep_board_init_1(ldb.srt,this.data_t);
      },
      prep_board_init_1: function(ldbs,dst){ // for initial only
        var data = ldbs[this.time_sel][1];
        var offset = (this.time_base - ldbs[this.time_sel][0])/this.time_unit; // offset>=0 is always true.
        var i = offset;
        while (i<data.length) {
          if (data[i]) dst[i-offset] += data[i];
          i++;
        }
      },
    };
    var StatsFromNo = function(parent){
      this.data_p = [];
      this.min_idx = 0;
      for (var i in StatsFromNo_prototype) this[i] = StatsFromNo_prototype[i];
      this.__proto__ = parent;
    };
    var StatsFromNo_prototype = {
      prep_board_subscribe: function(ldb){
        if (!ldb.s) setup_board_no(ldb,'s');
        ldb.s[this.time_sel][2].push(this);
      },
      prep_board_unsubscribe: function(ldb){
        if (ldb.s && this.time_sel) {
          var idx = ldb.s[this.time_sel][2].indexOf(this);
          if (idx!=-1) ldb.s[this.time_sel][2].splice(idx,1);
        }
      },
      prep: function(tree, func, subscribe, aggregate){
        if (subscribe) this.__proto__.prep.call(this.fromNo,'live',this.fromNo.prep_board_subscribe, null);
        if (aggregate) for (var i=this.min_idx;i<this.data_p.length;i++) this.data_p[i] = 0;
        this.new_vals = {};
        this.__proto__.prep.call(this, 'live', func, null);
        for (var i in this.new_vals) this[i] = this.new_vals[i];
        delete this.new_vals;
      },
      prep_board: function(ldb,func){
        func.call(this,ldb);
      },
      prep_board_init: function(ldb,func){
        var data = ldb.s[this.time_sel][1];
        var offset = (this.time_base - ldb.s[this.time_sel][0])/this.time_unit; // offset>=0 is always true.
        var i = this.min_idx + offset;
        if (i<2) i = 2; // skip [0], because [0] contains old data.
        var data_last;
        var j=i-1;
        while (j>0 && !data[j]) j--;
        if (j>0) data_last = data[j];
        else {
          while (i<data.length && !data[i]) i++;
          data_last = data[i++];
        }
        if (pref.stats.patch_tm) {
          var idx_last = ((j>0)? j : i-1)-offset;
          var idx_last2 = idx_last; // for not writing any data
          while (i<data.length) {
            if (data[i]) {
              this.data_p[idx_last] += data[i] - data_last;
              data_last = data[i];
              idx_last2 = idx_last;
              idx_last = i-offset;
            }
            i++;
          }
          if (this.new_vals.min_idx===undefined || this.new_vals.min_idx > idx_last2) this.new_vals.min_idx = idx_last2;
        } else {
          while (i<data.length) {
            if (data[i]) {
              this.data_p[i-offset] += data[i] - data_last;
              data_last = data[i];
            }
            i++;
          }
          if (this.new_vals.min_idx===undefined || this.new_vals.min_idx > i - offset) this.new_vals.min_idx = i - offset;
        }
      },
      update_posts_no: function(time_base,idx_in){
        var idx = (time_base-this.time_base)/this.time_unit + idx_in;
        if (idx>=0 && idx<this.min_idx) this.min_idx = idx;
      },
      prep_board_check_valid: function(ldb,func){
        this.valid &= ldb.s[time_unit_arr.length]>=0;
      },
//      __proto__: Stats.prototype
    };
////    function setup_board_no(ldb, data, time_sel){
////      for (var t in ldb) if (ldb[t].s) update_posts_no_1(ldb[t].s, ldb[t].sn, 0, ldb, time_sel);
////      var j=0;
////      while (j<data.length && !data[j]) j++;
////      if (j!==0 && j!=data.length) for (var i=0;i<j;i++) data[i] = data[j];
////if (pref.test_mode['43']) {
////      while (j<data.length) {if (!data[j]) data[j] = data[j-1];j++;} // cause spike
////} else {  
////      while (j<data.length) { // average, not debugged.
////        var j_old = j++;
////        while (j<data.length && !data[j]) j++;
////        if (j_old+1===j) continue;
////        if (j<data.length) {
//////console.log('setup_board_no: averaging: '+j_old+', '+j);
////          var step = (data[j]-data[j_old])/(j-j_old);
////          for (var i=1;i<j-j_old;i++) data[j_old+i] = data[j_old]+Math.floor(step*i);
////        }
////      }
////}
////    }
    function update_board_rm(ldb){
      if (!ldb.sr) {
        setup_board_no(ldb,'sr');
        setup_board_no(ldb,'srt');
//        for (var i=0;i<time_unit_arr.length;i++) for (var j=0;j<pref.stats.len_capture+2;j++) ldb.sr[i][1][j] = 0;
      }
      for (var t in ldb) {
        if (ldb[t].s) for (var i=0;i<time_unit_arr.length;i++) {
          update_posts_no_1(ldb.sr[i],  null, 0, ldb[t].s.length, ldb[t].s, time_unit_arr[i], update_posts_rm_1_func, 0);
          update_posts_no_1(ldb.srt[i], null, 0, 1,               ldb[t].s, time_unit_arr[i], update_posts_rm_1_func, 0);
        }
        delete ldb[t];
      }
    }
    function setup_board_no(ldb,key){
      Object.defineProperty(ldb, key, {value:[], configurable:true, writable:false});
      for (var i=0;i<time_unit_arr.length;i++) {
//        ldb[key][i] = [null,[],[],0]; // [time_base, data, subscribers, tolerance]
        ldb[key][i] = [null,(i<3)?[]:{length:pref.stats.len_capture+2, __proto__:Array.prototype},[],0];
//        ldb[key][i] = [null,{length:pref.stats.len_capture+2, __proto__:Array.prototype},[],0]; // debug // length isn't updated automatically after 'splice' shorten it.
        update_posts_no_time(ldb[key][i], time_unit_arr[i]);
      }
      if (key==='s') ldb[key][time_unit_arr.length] = -Object.keys(ldb).length; // count
    }
    function update_posts_no_time(ldbst, time_unit, idx_over){
      var time_now = Math.floor((Date.now()/60000 + ldbst[3])/time_unit)*time_unit;
      var time_base = time_now - time_unit * pref.stats.len_capture;
      if (!ldbst[0]) {ldbst[0] = time_base;return;} // initialize
      else if (time_base!==ldbst[0] || idx_over) {
        var shift = (time_base-ldbst[0])/time_unit;
        var shift_add = 0;
        if (idx_over>shift && pref.stats.tolerant) {
          if (ldbst[3] + (idx_over-shift)*time_unit<pref.stats.tolerance) {
            ldbst[3] = idx_over*time_unit;
            shift_add = idx_over - shift;
          } else {
            ldbst[3] = pref.stats.tolerance;
            shift_add = Math.floor((pref.stats.tolerance-ldbst[3])/time_unit);
          }
        }
        ldbst[1].splice(0, shift + shift_add);
        if (!Array.isArray(ldbst[1])) ldbst[1].length = pref.stats.len_capture+2;
//        var last_data = ldbst[1][ldbst[1].length-1];
//        for (var i=0;i<shift+shift_add;i++) ldbst[1][ldbst[1].length] = last_data;
        ldbst[0] = time_base + shift_add*time_unit;
        return shift + shift_add;
      }
    }
    function update_posts_rm_1_func(data,idx){
      data[idx] = (data[idx] || 0) +1;
    }
    function update_posts_no_1_func(data,idx,th,j){
      var post_no = th.posts[j].no || th.no;
      if (data[idx]===undefined || data[idx]<post_no) data[idx] = post_no;
    }
    function update_posts_no_1_func_min(data,idx,th,j){ // for 4chan's bug, corrupted timeline when a thread is moved from other board.
      var post_no = th.posts[j].no || th.no;
      if (data[idx]===undefined || data[idx]>post_no) data[idx] = post_no; // THIS REQUIRES IN-ORDER OR FULL SCAN in update_posts_no_1 and PICKUP in ??? must be shifted by 1.
    }
    function update_posts_no(ldb, th, start, lths){
      if (!ldb.s) setup_board_no(ldb,'s');
      for (var i=0;i<time_unit_arr.length;i++) update_posts_no_1(ldb.s[i], th, start, lths.length, lths, time_unit_arr[i],
        (pref.stats.patch_tm)? update_posts_no_1_func_min : update_posts_no_1_func, th.posts.length);
      ldb.s[time_unit_arr.length]++;
    }
    function update_posts_no_1(ldbst, th, start, end, lths, time_unit, func, j){
      var time_base = ldbst[0];
      var data = ldbst[1];
      var idx_old;
      for (var p=end-1;p>=start;p--) {
        var idx = Math.floor((lths[p]-time_base)/time_unit);
        if (--j>=0 && idx===idx_old && !pref.stats.patch_tm) continue; // full scan at patch_tm
        var idx_over = idx - pref.stats.len_capture -1;
        if (idx_over>0) {
          idx -= update_posts_no_time(ldbst, time_unit, idx_over);
          if (idx>pref.stats.len_capture+1) idx = pref.stats.len_capture+1;
          time_base = ldbst[0];
        } else if (idx<0) idx = 0;
        func(data,idx,th,j);
        if (idx===0 && !pref.stats.patch_tm) break;
        idx_old = idx;
      }
      for (var k=0;k<ldbst[2].length;k++) ldbst[2][k].update_posts_no(time_base,idx);
    }
        
    var auto_acquisition_keys = {};
    function get_ac_key(sel){return pref.catalog_board_list_obj[sel][0].key;} // key is a user string.
    function auto_acquisition_beforeunload(){
      if (pref.stats.auto_acquisition && cataLog.embed_mode!=='thread')
        for (var i=pref.catalog_board_list_obj.length-1;i>=0;i--)
          if (auto_acquisition_keys['@'+get_ac_key(i)]!==undefined) {
            var tgts = cataLog.catalog_refresh_1('chart', false, false, false, false, i, false, true);
            if (typeof(tgts)!=='function') new Stats(null, tgts, get_ac_key(i), false).destroy();
          }
    }
    window.addEventListener('beforeunload', auto_acquisition_beforeunload, false);
    function auto_acquisition_init(idx){
      if (pref.stats.auto_acquisition && cataLog.catalog_refresh_1 && cataLog.embed_mode!=='thread') {
        if (idx===undefined) idx = pref.catalog_board_list_obj.length-1;
        while (idx>=0 && (!pref.catalog_board_list_obj[idx][0].cmds || pref.catalog_board_list_obj[idx][0].cmds.indexOf('stats')===-1)) idx--;
        if (idx>=0) {
          if (pref.stats.auto_acquisition) stats.register_auto_acquisition(idx);
          var result = cataLog.catalog_refresh_1('chart', false, false, false, 'stats_ac', idx, false, true, function(){auto_acquisition_init(idx-1);});
          if (typeof(result)==='function') result(function(){auto_acquisition_init(idx);});
        }
      }
    }
    if (pref.stats.auto_acquisition_scan) setTimeout(auto_acquisition_init, pref.stats.auto_acquisition_scan_delay*1000);
    return {
      aggregate: function(th){
        if (!th.posts) return;
        var ldb = liveTag.mems[th.domain][th.board];
        var lth = ldb[th.no];
        if (!lth.s) lth.s = []; // stat
        var tu = th.parse_funcs.time_unit;
        var start = lth.s.length;
        var p = start;
        var i = th.posts.length - (th.nof_posts - lth.s.length);
        if (i<0) return; // i=0; // {p=-i; i=0;} // patch for short thread (last 50 replies) at embed_mode==='thread'.
        while (i<th.posts.length) lth.s[p++] = Math.floor(th.posts[i++].time * tu / 60000);
        if (lth.ss) { // subscribers
          if (Array.isArray(lth.ss)) for (var i=0;i<lth.ss.length;i++) lth.ss[i].update_thread(lth.s,start, true);
          else lth.ss.update_thread(lth.s,start, true);
        } else if (start===0) thread_created(lth);
        if (pref3.stats.estimate_posts) update_posts_no(ldb, th, start, lth.s, th.posts.length);
      },
      thread_removed: thread_removed,
      Stats: Stats,
      register_auto_acquisition: function(sel){
        auto_acquisition_keys['@'+get_ac_key(sel)] = null;
        cnst.auto_shrink_board_selector.color();
      },
      query_auto_acquisition: function(sel){
        return auto_acquisition_keys['@'+get_ac_key(sel)]!==undefined;
      },
//      redraw_all: function(){
//        for (var i=0;i<instances.length;i++) instances[i].init();
//      }
    };
  })() : null;
               

  function make_chart_obj(pn1){
//    var pref_graph = {key: null, pipe: null}; // working code.
//    pn1.addEventListener('click', show_hide, false);
//    var data = chart_data_init();
//    pref_graph.key = pref.script_prefix + '.graph.' + site.board;
//    if (localStorage && pref.load_data && localStorage.getItem(pref_graph.key)!==null) data = brwsr.JSON_parse(localStorage.getItem(pref_graph.key));
//
//    var pn2_func = null;
//    function show_hide(){  // Toggle Show/Hide
//      if (pn2_func==null) pn2_func = prep_pn2();
//      else pn2_func = pn2_func.destroy();
//    }
//    var size_loc = ['400px', '400px', '5px', '50px', '120px', '390px'];

    var time_unit_sel_html =
      '<select name="chart.inst.time_sel">'+
        '<option>1 min</option>'+
        '<option>10 mins</option>'+
        '<option>1 hour</option>'+
        '<option>1 day</option>'+
        '<option>1 week</option>'+
      '<select>';
    var chart_options_str = [
        'Number of points: <input type="text" name="chart.inst.len" size="3" style="text-align: right;"><br>',
        'Scale of new thread: <input type="text" name="chart.inst.scale_thread" size="3" style="text-align: right;"><br>',
//        '<input type="checkbox" name="chart.inst.separate">Separate estimated, observed and alive<br>',
        'Show: Posts/Threads:<br>',
        '&emsp;&emsp;<input type="checkbox" name="chart.inst.show.np">'+
        '<input type="checkbox" name="chart.inst.show.nt" disabled style="visibility:hidden"> Estimated, '+
        '<input type="checkbox" name="chart.inst.clip_np">Clip: '+
          '<input type="text" name="chart.inst.clip_np_val" size="4" style="text-align: right;"><br>',
        '&emsp;&emsp;<input type="checkbox" name="chart.inst.show.p">'+
        '<input type="checkbox" name="chart.inst.show.t"> Observed<br>',
        '&emsp;&emsp;<input type="checkbox" name="chart.inst.show.ep">'+
        '<input type="checkbox" name="chart.inst.show.et"> Alive<br>',
        '<input type="checkbox" name="chart.inst.show_legend">Legend<br>',
        '<input type="checkbox" name="chart.inst.options.animation">Animation (Doesn\'t work on FF)<br>',
        '<input type="checkbox" name="chart.inst.options.pointDot">Point dot: radius '+
          '<input type="text" name="chart.inst.options.pointDotRadius" size="1" style="text-align: right;"><br>'
      ];
    if (!pn1) return {
      time_unit_sel_html: time_unit_sel_html,
      chart_options_str: chart_options_str,
    }

    pn1.addEventListener('click', make_new_chart, false);
    var charts = [];
    function make_new_chart(){
      cnst.subscribe(charts,new PostChart());
      if (charts.length===1) {
        common_func.dom_addEventListener(common_obj.events_beforeunload, window, 'focus', window_focus);
        common_func.dom_addEventListener(common_obj.events_beforeunload, window, 'blur', window_blur);
      }
    }
    function window_focus(){
      cnst.foreach(charts, function(inst){inst.chart_posts.options.animation = inst.options.animation;});
    }
    function window_blur(){
      if (pref.chart.off_anime_blur) cnst.foreach(charts, function(inst){inst.chart_posts.options.animation = false;});
    }
    function destroy_all(){
      cnst.foreach(charts, function(inst){inst.destroy();});
    }
    window.addEventListener('beforeunload', destroy_all, false);

    var count = 0;
    var PostChart = function(pn_popup, tgts, skelton){
//      this.data_graph;
//      this.chart_posts;
      if (!skelton) common_func.deep_copy(this,pref.chart.inst);
      if (!pn_popup) {
        this.name = 'graph_' + count++;

        this.pn2_obj = cnst.init3({
          this_obj:this,
          __proto__:this.pn2_template});
        var pn2 = this.pn2_obj.pn;
        var pn2_2 = cnst.add_to_tb(pn2, time_unit_sel_html + (!skelton? '<select name="chart.inst.board_sel"><select>' : '')+ cnst.icons.button_settings());
        pn2.childNodes[1].innerHTML = pref_func.format_html_str(
          '<div style="display:none">'+
            '<div style="float:right">'+ chart_options_str.join('') + '</div>'+
            '<div style="clear:both"></div>'+
          '</div>'+
          '<div style="position:relative"></div>');
        pref_func.apply_prep(pn2,false);
        var sels = pn2.getElementsByTagName('select');
        cnst.auto_shrink_selector(sels['chart.inst.time_sel']);
        this.legend = cnst.init3({func_str:'border:1px solid lightblue:cursor:move:position:absolute:left:80px:top:40px'});
        this.pn2 = pn2;
        this.set_legend_str();
        var onchange_entry_bound = this.onchange_entry.bind(this);
        pn2.childNodes[0].onchange = onchange_entry_bound;
        pn2.childNodes[1].childNodes[0].onchange = onchange_entry_bound;
        if (skelton) {
          cnst.bottom_top(pn2);
//          pn2.style.top = parseInt(skelton.pn_canvas_root.style.top,10) - pn2.offsetHeight + 'px';
//          pn2.style.left = skelton.pn_canvas_root.style.left;
          this.show_legend = false;
          var pns = pn2.querySelectorAll('input[name],textarea[name],select[name]');
          for (var i=0;i<pns.length;i++) {
            var tgt_hier = pref_func.get_tgt(pns[i].getAttribute('name').replace(/chart.inst./,''),this);
            pref_func.apply_prep_load(pns[i],tgt_hier[0], tgt_hier[1]);
          }
//          pn2.childNodes[1].replaceChild(skelton.pn_canvas_root, pn2.childNodes[1].childNodes[1]);
          cnst.subscribe(charts,this);
          return pn2;
        }
        this.pn_board_sel = sels['chart.inst.board_sel'];
        cnst.auto_shrink_board_selector.setup(this.pn_board_sel, pref.catalog_board_list_sel);
        this.board_sel = pref.catalog_board_list_sel;
        this.pn_canvas_root = pn2.childNodes[1].childNodes[1];
      } else {
        this.pn_canvas_root = pn_popup;
        this.show = {np:false, p:true, ep:false, nt:false, t:true, et:false};
      }
      this.pn_canvas_root.style.width = pref.chart.window_width + 'px';
      this.pn_canvas_root.style.height = pref.chart.window_height + 'px';
      this.pn_canvas_root.style.resize = 'both';
      this.pn_canvas_root.style.overflow = 'hidden';
      this.pn_canvas = document.createElement('canvas');
      this.pn_canvas_root.appendChild(this.pn_canvas);
      this.chart_size_changed(true); // patch
  //      this.chart_create_draw(); called from stats
      this.stats = (!pn_popup)? new stats.Stats(this, this.get_tgts(), pref.catalog_board_list_obj[this.board_sel][0].key) : // call 'chart_create_draw' in this.
                                new stats.Stats(this, tgts, 'popup');
  //      this.track_legend_pos();
  ////      pn2.addEventListener('resize',  //) // can't get.
      this.canvas_active = true;
      this.pn_canvas_root.onmousemove = this.deactivate_canvas_if_mouse_on_corner.bind(this);
      this.pn_canvas_root.onclick = this.chart_size_changed.bind(this);
  //      pn2.ondragover = this.dragover_pn2.bind(this);
  //      pn2.ondrop = this.drop_pn2.bind(this);
  //      this.legend.pn.ondragend = function(e){e.stopPropagation();};
      if (!pn_popup) {
        if (this.show_legend) this.append_legend();
        cnst.bottom_top(pn2);
      }
    };
    PostChart.prototype = {
      get_tgts: function(scan_name){
        return (!cataLog.catalog_refresh_1)? [site.nickname+site.board] :
                                             cataLog.catalog_refresh_1('chart', false, false, false, scan_name, this.board_sel, false, true);
      },
      board_sel_changed: function(e){
        e.target.blur();
        var tgts = this.get_tgts((pref.chart.instant_scan)? this.name : null); // also scan
        if (typeof(tgts)==='function') tgts(this.board_sel_changed.bind(this));
        else this.stats.tgts_changed(tgts, pref.catalog_board_list_obj[this.board_sel][0].key);
      },
      len_changed: function(){
        if (this.len>this.stats.len) this.stats.len_changed.call(this.stats, this.len); // call redraw
        else if (this.stats.len!=pref.stats.len_capture) this.stats.len_changed.call(this.stats, pref.stats.len_capture); // call redraw
        else this.replace_data(this.data_src);
      },
      deactivate_canvas_if_mouse_on_corner: function(e){
        var ecTs = e.currentTarget.style;
        if ((parseInt(ecTs.width,10) - e.offsetX<=10 && parseInt(ecTs.height,10) - e.offsetY<=10) ^ !this.canvas_active) {
          this.pn_canvas.style.pointerEvents = this.canvas_active? 'none' : 'auto';
          this.canvas_active = !this.canvas_active;
        }
      },
      chart_size_changed: function(init){ // patch
//        if (str==='top' || str==='bottom') this.pn_canvas_root.style.overflow = '';
//        else if (typeof(str)==='string') this.pn_canvas_root.style.overflow = 'hidden';
//        this.pn_canvas_root.style.resize = 'both';
//        if (this.pn_canvas_root.style.overflow==='hidden') {
//        if (this.pn2_obj.maximize_state_str==='float') {
        this.pn_canvas.style.width  = this.pn_canvas_root.style.width;
        this.pn_canvas.style.height = this.pn_canvas_root.style.height; // (this.pn_canvas_root.style.height.replace(/px/,'')-10)+'px';
        this.pn_canvas.width  = this.pn_canvas_root.clientWidth;
        this.pn_canvas.height = this.pn_canvas_root.clientHeight; // - 10;
//        }
        if (init!==true) this.chart_redraw();
      },
      chart_redraw: function(){ // old 'chart_create_draw' in this.
        if (this.chart_posts) this.chart_posts.destroy();
        
        this.data_graph = chart_data_init(); // deep copy always.
        var dd = this.data_graph.datasets;
        var fN = this.data_src.fromNo;
        var dr = this.data_src.rm;
        var ds = this.data_src;
//        this.idxs  = (dr)? ((fN)? {p:1, t:3, ep:2, et:4, np:0} : {p:0, t:2, ep:1, et:3}) :
//                           ((fN)? {t:1, np:0} : {t:1, p:0});
        var layer = 0;
        this.idxs = {};
        var idxs = this.idxs;
        idxs.np = (fN && this.show.np)? layer++ : -1;
        idxs.p  = (      this.show.p )? layer++ : -1;
        idxs.ep = (dr && this.show.ep)? layer++ : -1;
        idxs.t  = (      this.show.t )? layer++ : -1;
        idxs.et = (dr && this.show.et)? layer++ : -1;

        if (idxs.np!=-1) dd[idxs.np] = chart_data_init_1('post_fromNo','151,187,205',0.2);
        if (idxs.p !=-1) dd[idxs.p ] = chart_data_init_1('Posts','98,152,179', 0.2);
        if (idxs.ep!=-1) dd[idxs.ep] = chart_data_init_1('exist_p','66,119,136',0.15); // '151,187,205',0.2
        if (idxs.t !=-1) dd[idxs.t ] = chart_data_init_1('Threads','204,0,0', 0.2);
        if (idxs.et!=-1) dd[idxs.et] = chart_data_init_1('exist_t','140,0,0',0.2); // '204,128,128',0.2

if (pref.test_mode['39'] && dd[pref.test_mode.num]) dd[pref.test_mode.num] = chart_data_init_1(dd[pref.test_mode.num].label,pref.test_mode.test_str, pref.test_mode.num_f);
        var start = (this.len<this.stats.len)? this.stats.len - this.len : 0;
        this.data_graph.labels = ds.data_l.slice(start); // I don't know why, but shallow copy is required, I can't use source array directly.
        if (idxs.p !=-1) dd[idxs.p].data = this.stats.merge_1(ds.data_p.slice(start), (ds.data_p_old)? ds.data_p_old.slice(start) : null);
        if (idxs.t !=-1) {
          dd[idxs.t].data = this.stats.merge_1(ds.data_t.slice(start), (ds.data_t_old)? ds.data_t_old.slice(start) : null);
          if (this.scale_thread!=1) this.scale_setup(dd[idxs.t].data);
        }
        if (dr) {
//          dd[5] = chart_data_init_1('old_t','204,0,0');
//          dd[0].data = ds.data_p.slice(start);
//          dd[1].data = ds.data_t.slice(start);
//          dd[2].data = dr.data_p.slice(start); // raw
//          dd[3].data = dr.data_t.slice(start);
          if (idxs.ep!=-1) dd[idxs.ep].data = this.arr_dec_slice(ds.data_p, dr.data_p, start);
          if (idxs.et!=-1) {
            dd[idxs.et].data = this.arr_dec_slice(ds.data_t, dr.data_t, start);
            if (this.scale_thread!=1) this.scale_setup(dd[idxs.et].data);
          }
//          dd[2].data = ds.data_p.map(function(v,i){return v - this[i];}.bind(dr.data_p)); // TOO SLOW...
//          dd[3].data = ds.data_t.map(function(v,i){return v - this[i];}.bind(dr.data_t));
if (pref.test_mode['40']) {
//          dd[4] = chart_data_init_1('old_p','98,152,179');
//          dd[4].fillColor = 'rgba(0,255,0,0.2)';
          dd[layer] = chart_data_init_1('old_p','0,255,0',0.1);
          dd[layer++].data = ds.data_p_old.slice(start);
          dd[layer] = chart_data_init_1('p_raw','98,152,179',0.2);
          dd[layer++].data = ds.data_p.slice(start);
//          dd[5].data = ds.data_t_old.slice(start);
}
        }
        if (fN && idxs.np!=-1) {
          dd[idxs.np].data = (fN.data_p_old)? fN.data_p_old.concat(fN.data_p.slice(fN.data_p_old.length)).slice(start) : fN.data_p.slice(start);
          if (fN.data_p_old) {
            var idx_last = fN.data_p_old.length-1;
            if (fN.data_p[idx_last]>fN.data_p_old[idx_last]) if (idx_last-start>=0) dd[idxs.np].data[idx_last-start] = fN.data_p[idx_last]; // overwrite last data, because last data may NOT complete its period.
          }
          if (this.clip_np) {
            var data_np = dd[idxs.np].data;
            for (var i=0;i<data_np.length;i++) data_np[i] = this.clip_np_func(data_np[i]);
          }
//          if (pref.stats.patch_tm) dd[idxs.np].data = dd[idxs.np].data.slice(1).concat(0); // shift only at initial
//          dd[idxs.np].data = fN.data_p.slice(start);
//          var old_sliced = fN.data_p_old.slice(start);
//          for (var i=0;i<old_sliced.length;i++)
//            if (old_sliced[i])
//              dd[idxs.np].data[i] = old_sliced[i];
if (pref.test_mode['41']) {
          dd[layer] = chart_data_init_1('post_fromNo_old','0,255,0',0.2);
          dd[layer++].data = fN.data_p_old.slice(start);
          dd[layer] = chart_data_init_1('post_fromNo','0,128,0',0);
          dd[layer++].data = fN.data_p.slice(start);
}
        }
//        Chart.defaults.global.animation = pref.stats.animation;
        this.scale_thread_old = this.scale_thread;
        var ctx = this.pn_canvas.getContext('2d');
        this.chart_posts = new Chart(ctx).Line(this.data_graph, this.options);
      },
      clip_np_func: function(data){
        return (data<0)? 0 :
               (data>this.clip_np_val)? this.clip_np_val : data;
      },
      arr_dec_slice: function(src, dec, start){
        var arr = [];
        var p = 0;
        for (var i=start;i<src.length;i++) arr[p++] = src[i] - dec[i];
        return arr;
      },
      scale_setup: function(dst,old){
        if (old!==undefined) for (var i=0;i<dst.length;i++) dst[i].value = dst[i].value/old*this.scale_thread;
        else for (var i=0;i<dst.length;i++) dst[i] *= this.scale_thread;
        return dst;
      },
      scale_changed: function(){
        this.set_legend_str();
        if (this.scale_thread_old!==0) {
          this.scale_setup(this.chart_posts.datasets[this.idxs.t].points, this.scale_thread_old);
          if (this.idxs.et!==undefined && this.data_graph.datasets[this.idxs.et]) this.scale_setup(this.chart_posts.datasets[this.idxs.et].points, this.scale_thread_old);
          this.chart_posts.update();
        } else this.chart_redraw();
        this.scale_thread_old = this.scale_thread;
      },
      set_legend_str: function(){
//        var str = '<ul class="line-legend"><li style="color:rgba(98,152,179,1)"><span style="color: black;">Posts</span></li><li style="color:rgba(204,0,0,1)"><span style="color: black;">Threads ' + ((this.scale_thread==1)? '' : 'x'+ this.scale_thread) + '</span></li></ul>'
        var str = '<span style="color:rgba(98,152,179,1)">\u25cf</span><span style="color: black;"> Posts</span><br>'+
                  '<span style="color:rgba(204,0,0,1)">\u25cf</span><span style="color: black;"> Threads ' + ((this.scale_thread==1)? '' : 'x'+ this.scale_thread+' ') + '</span>'
        this.legend.pn.innerHTML = str;
      },
//      dragover_pn2: function(e) {e.preventDefault();}, // working code.
//      drop_pn2: function (e) {
//        e.preventDefault(); // FF require this.
//        var str = e.dataTransfer.getData('text');
//        if (str!='') {
//          if (pref.import_format=='obj') data = JSON.parse(str);
//          else {
//            var str_s = str.split(/\r\n|\r|\n|\\n/);
//            data.labels = str_s[0].split(',');
//            for (var i=0;i<2;i++) {
//              var str_sc = str_s[i+1].split(',');
//              for (var j=0;j<str_sc.length;j++) data.datasets[i].data[j] = (str_sc[j]!='')? parseInt(str_sc[j],10) : 0;
//            }
//          }
//        }
//        chart_redraw();
//      },
//      toggle_settings: function(e){ // working code
//        cnst.show_hide(this.pn2_settings, null, this.legend.pn);
//        cnst.toggleButton(e.currentTarget);
//      },
      destroy : function (){
        if (!brwsr.ff) this.chart_posts.stop();
        this.chart_posts.destroy();
//        pn2.removeEventListener('click', chart_redraw, false);
//        pn2.removeEventListener('dragover', dragover_pn2, false);
//        pn2.removeEventListener('drop', drop_pn2, false);
//        pn2.removeEventListener('dragend', div_dragend_pn2, false);
//        pn6.removeEventListener('dragend', function(e){e.stopPropagation();}, false);
        //        size_loc = [pn2.style.width, pn2.style.height, pn2.style.left, pn2.style.bottom, pn6.style.left, pn6.style.bottom];
        this.stats.destroy();
        this.stats = null;
        if (this.pn2) {
          cnst.div_destroy(this.legend.pn, false, this.legend);
          cnst.div_destroy(this.pn2, true, this.pn2_obj);
          cnst.auto_shrink_board_selector.destroy(this.pn_board_sel);
          cnst.unsubscribe(charts, this);
        }
        return null;
      },
//      clear : function () {this.chart_redraw();}, // working code.
//      update_data : function(time_str, posts, threads){
//        while (data_graph.labels.length>=pref.max_graph) chart_posts.removeData();
//        chart_posts.addData([posts,threads*pref.scale_thread],time_str);
//        chart_posts.update();
//      },
//      update: function(){
//        chart_redraw();
//      },
      replace_data: function(src){
        if (!this.stats) this.stats = src; // patch
        this.data_src = src;
        this.chart_redraw();
      },
      update_data2 : function(src){
        var i = src.shift;
        while (i>0) {this.chart_posts.removeData();i--;}
        var data = [];
        for (var i=src.data_p.length-src.shift;i<src.data_p.length;i++) {
          if (src.fromNo && this.idxs.np!=-1) data[this.idxs.np] = (this.clip_np)? this.clip_np_func(src.fromNo.data_p[i]) : src.fromNo.data_p[i];
          if (this.idxs.p!=-1) data[this.idxs.p] = src.data_p[i];
          if (this.idxs.t!=-1) data[this.idxs.t] = src.data_t[i]*this.scale_thread;
          if (src.rm) {
            if (this.idxs.ep!=-1) data[this.idxs.ep] =  src.data_p[i] - src.rm.data_p[i];
            if (this.idxs.et!=-1) data[this.idxs.et] = (src.data_t[i] - src.rm.data_t[i])*this.scale_thread;
          }
          this.chart_posts.addData(data, src.data_l[i]);
        }
        var tgt_p = (this.idxs.p!=-1)? this.chart_posts.datasets[this.idxs.p] : null;
        var tgt_t = (this.idxs.t!=-1)? this.chart_posts.datasets[this.idxs.t] : null;
        var tgt_ep = (this.idxs.ep!=-1 && src.rm)? this.chart_posts.datasets[this.idxs.ep] : null;
        var tgt_et = (this.idxs.et!=-1 && src.rm)? this.chart_posts.datasets[this.idxs.et] : null;
        var tgt_np = (this.idxs.np!=-1 && src.fromNo)? this.chart_posts.datasets[this.idxs.np] : null;
        var p = src.min_idx - (this.stats.len - this.len);
        var i = src.min_idx;
        if (p<0) {
          i += -p;
          p=0;
        }
        if (pref.stats.patch_tm && tgt_np && p>0 && i>0) tgt_np.points[p-1].value = (this.clip_np)? this.clip_np_func(src.fromNo.data_p[i-1]) : src.fromNo.data_p[i-1];
        while (i<src.data_p.length-src.shift) {
          if (tgt_p) tgt_p.points[p].value =  (src.data_p_old && src.data_p_old[i]>src.data_p[i])? src.data_p_old[i] : src.data_p[i];
          if (tgt_t) tgt_t.points[p].value = ((src.data_t_old && src.data_t_old[i]>src.data_t[i])? src.data_t_old[i] : src.data_t[i]) *this.scale_thread;
//            chart_posts.label.points[p].value = src.data_l[i];
          if (tgt_ep) tgt_ep.points[p].value =  src.data_p[i] - src.rm.data_p[i];
          if (tgt_et) tgt_et.points[p].value = (src.data_t[i] - src.rm.data_t[i]) *this.scale_thread;
          if (tgt_np) tgt_np.points[p].value = (this.clip_np)? this.clip_np_func(src.fromNo.data_p[i]) : src.fromNo.data_p[i];
          p++;
          i++;
        }
        src.shift = 0;
        this.chart_posts.update();
      },
      append_legend: function(){this.pn_canvas_root.appendChild(this.legend.pn);},
      remove_legend: function(){this.pn_canvas_root.removeChild(this.legend.pn);},
    }
    PostChart.prototype.pn2_template = {
      get func_str(){return 'left:' +(((count-1)%5)*20)+ 'px:tile2:get:bottom:' +(((count-1)%5)*20)+ ':Show:tb'}, // ':resize:both:float:left:Show:tb:width:' +
//        pref.chart.window_width + 'px:height:' + pref.chart.window_height + 'px:resize:both:overflow:hidden';},
//      rolldown: PostChart.prototype.append_legend,
//      rollup: PostChart.prototype.remove_legend,
      maximize: PostChart.prototype.chart_size_changed,
//      maximize_embed_style_pn: {left:'auto', top:'auto', position:'relative', resize:'none'}, //  {left:'auto', top:'auto', position:'static', resize:'none'}
      maximize_embed_style_pnch1: {}, //  {width:'auto', height:'auto', resize:'none'}
      maximize_float_style_pnch1: {}, //  {width:state[3], height:state[4], resize:'both'}
      exit: PostChart.prototype.destroy,
      get maximize_tgt(){return this.this_obj.pn_canvas_root;}, 
    };
    PostChart.prototype.onchange_entry = function(e){
      var tgt_hier = pref_func.get_tgt(e.target.name.replace(/chart.inst./,''),this);
      var prop = tgt_hier[1];
//      var val = (e.target.type==='checkbox')? e.target.checked : (e.target.type==='text')? parseInt(e.target.value,10) : e.target.selectedIndex;
//      target_hier[0][prop] = val;
      pref_func.apply_prep_set(tgt_hier[0], tgt_hier[1], e.target);
      if (this.onchange_funcs[prop]) this.onchange_funcs[prop].call(this,e);
    };
    PostChart.prototype.onchange_funcs = {
      pointDot: PostChart.prototype.chart_redraw,
      pointDotRadius: PostChart.prototype.chart_redraw,
      scale_thread: PostChart.prototype.scale_changed,
      animation: function(){this.chart_posts.options.animation = this.options.animation;},
      len: PostChart.prototype.len_changed,
      separate: function(){this.stats.init();},
      time_sel: function(e){e.target.blur();this.stats.time_unit_changed(this.time_sel);},
      board_sel: PostChart.prototype.board_sel_changed,
      show_legend: function(e){if (e.target.checked) this.append_legend(); else this.remove_legend();},
      clip_np: PostChart.prototype.chart_redraw,
      clip_np_val: PostChart.prototype.chart_redraw,
    };
    PostChart.prototype.onchange_funcs.np = PostChart.prototype.onchange_funcs.separate;
    PostChart.prototype.onchange_funcs.p  = PostChart.prototype.onchange_funcs.separate;
    PostChart.prototype.onchange_funcs.ep = PostChart.prototype.onchange_funcs.separate;
    PostChart.prototype.onchange_funcs.t  = PostChart.prototype.onchange_funcs.separate;
    PostChart.prototype.onchange_funcs.et = PostChart.prototype.onchange_funcs.separate;

    return {
      clear: function(){}, // dummys
      dump: function(format){},
      data_update: function(time_str, posts, threads){},
      PostChart: PostChart,
//      clear: function(){ // working code.
//        data = chart_data_init();
//        if (pn2_func!=null) pn2_func.clear();
//      },
//      dump: function(format){ // http://stackoverflow.com/questions/22055598/writing-a-json-object-to-a-text-file-in-javascript
//        var url;
//        if (format=='csv') {
//          var out_labels = data.labels;
//          var out_data0 = data.datasets[0].data;
//          var out_data1 = data.datasets[1].data;
//          url = 'data:text/json;charset=utf8,' + encodeURIComponent(out_labels) + '\\n' + encodeURIComponent(out_data0) + '\\n' + encodeURIComponent(out_data1);
//        } else if (format=='obj') url = 'data:text/json;charset=utf8,' + JSON.stringify(data);
//        window.open(url, '_blank');
//        window.focus();
//      },
//      data_update: function(time_str, posts, threads){
//        if (pn2_func!=null) pn2_func.data_update(time_str, posts, threads);
//        if (data.labels.length>=pref.max_capture) {
//          data.datasets[0].data.slice(-pref.max_capture+1);
//          data.datasets[1].data.slice(-pref.max_capture+1);
//          data.labels.slice(-pref.max_capture+1); // labels are copied shallowly, but now made deep copy manually.
//        }
//        data.labels.push(time_str);
//        data.datasets[0].data.push(posts);
//        data.datasets[1].data.push(threads);
//        if (pref.aggregator=='true' && pref.write_to_ls && localStorage) {
//          localStorage.setItem(pipe_name,  JSON.stringify([time_str, posts, threads]));
//          localStorage.setItem(pref_graph.key, JSON.stringify(data));
//        }
      //      },
      time_unit_sel_html: time_unit_sel_html,
      chart_options_str: chart_options_str,
    }
    function chart_data_init() {
      return {
        labels: ['dummy','dummy'], // at least 2 data required at first, or filling collapse. This is probably a BUG in Chart.js.
        datasets: []
      };
    }
    function chart_data_init_1(label, color, alpha) {
      return {
        label: label,
        fillColor: 'rgba(' + color + ',' + alpha + ')',
        strokeColor: 'rgba(' + color + ',1)',
        pointColor: 'rgba(' + color + ',1)',
        pointStrokeColor: '#fff',
        pointHighlightFill: '#fff',
        pointHighlightStroke: 'rgba(' + color + ',1)',
        data: [0,0]
      };
    }
  }

  function make_setting_obj(pn8){
//  var setting = (function(){
//    var pn8 = div_init(8,'55px','30px','button','settings');
//    var pn8 = cnst.init('left:55px:bottom:30px:button:settings:Show');
    pn8.addEventListener('click', show_hide, false);
    var pn7 = null;
    var pn7_1 = null;
    function show_hide(){  // Toggle Show/Hide
      pn7 = prep_pn7(pn7==null);
    }
    function prep_pn7(make){
      if (make) {
//        pn7 = div_init(7,'5px','50px','div','');
//        pn7 = cnst.init('left:5px:bottom:50px:Show:tb',cnst.void_func,cnst.void_func,show_hide,cnst.void_func);
//if (pref.test_mode['17']) pn7 = cnst.init('left:0px:tile:get:bottom:Show',cnst.void_func,cnst.void_func,show_hide,cnst.void_func); // leaks nodes.
if (pref.test_mode['17']) {pn7 = document.createElement('div');pn7.innerHTML='<div></div><div></div>';site.root_body.appendChild(pn7);} // leaks nodes.
else 
        pn7 = cnst.init('left:0px:tile:get:bottom:Show:tb',cnst.void_func,cnst.void_func,show_hide,cnst.void_func);
if (pref.test_mode['17']) pn7_1 = pn7;
else 
        pn7_1 = pn7.childNodes[1];
        pn7_1.innerHTML = '<div><div style="float:left">\
Statistics:<br>\
&emsp;Interval: <input type="text" name="interval_found" size="6" style="text-align: right;">min<br>\
&emsp;<input type="checkbox" name="check_page"> Show page no. of this thread<br>\
&emsp;&emsp;<input type="checkbox" name="show_page_fraction"> Show fraction of page No.<br>\
&emsp;<input type="checkbox" name="check_post"> Show num of new posts in this board<br>\
&emsp;<input type="checkbox" name="check_thread"> Show num of new threads in this board<br>\
&emsp;&emsp; Max_capture: <input type="text" name="max_capture" size="6" style="text-align: right;"> points<br>\
&emsp;&emsp;&emsp;Show recent : <input type="text" name="max_graph" size="6" style="text-align: right;"> points in graph<br>\
&emsp;&emsp;&emsp;Scale of #threads in graph: <input type="text" name="scale_thread" size="6" style="text-align: right;"><br>\
<!-- &emsp;&emsp;<input type="radio" name="autoconf" value="auto"> Automatic configuration<br>\
&emsp;&emsp;<input type="radio" name="autoconf" value="manual"> Manual configuration<br> -->\
&emsp;&emsp;&emsp;<input type="radio" name="aggregator" value="true"> Aggregate data<br>\
&emsp;&emsp;&emsp;&emsp;<input type="checkbox" name="write_to_ls"> Write to localStrage (server)<br>\
&emsp;&emsp;&emsp;<input type="radio" name="aggregator" value="false"> Listen from localStrage (client)<br>\
&emsp;&emsp;<input type="checkbox" name="load_data"> Load data from localStrage at the start<br>\
&emsp;&emsp;Import format (drop whole text on graph)<br>\
&emsp;&emsp;&emsp;<input type="radio" name="import_format" value="csv"> csv<br>\
&emsp;&emsp;&emsp;<input type="radio" name="import_format" value="obj"> obj<br>\
&emsp;&emsp;<input type="button" value="Dump(csv)"><input type="button" value="Dump(obj)">&emsp;<input type="button" value="Clear data"><br>\
<input type="checkbox" name="auto_start"> Start automatically (Delayed 10sec.)<br>\
<br>'+
//          'UIP tracker for 4chan:<br>'+
//          '&emsp;<input type="checkbox" name="uip_tracker.on"> Show num of unique IPs after post No.<br>'+
//          '&emsp;&emsp;<input type="checkbox" name="uip_tracker.posts"> Show num of posts(checking for deletion timing)<br>'+
//          '&emsp;&emsp;Interval: <input type="text" name="uip_tracker.interval" size="3" style="text-align: right;">sec'+
//          '&emsp;<input type="checkbox" name="uip_tracker.adaptive"> Adaptive<br>'+
//          '&emsp;<input type="checkbox" name="uip_tracker.auto_open"> Open next thread automatically<br>'+
//          '&emsp;&emsp;Conditions:<br>'+
//          '&emsp;&emsp;&emsp;After <input type="text" name="uip_tracker.auto_open_th" size="3" style="text-align: right;">th post<br>'+
//          '&emsp;&emsp;&emsp;OP contains <textarea style="height:1em" cols="20" name="uip_tracker.auto_open_kwd"></textarea><br>'+
//          '<br>'+
//'For dollchan: (workaround for bugs)<br>\
//&emsp;<input type="checkbox" name="workaround_for_dollchan"> Consistency checker for thubmnails of attached images<br>\
//&emsp;&emsp;runs at<br>\
//&emsp;&emsp;<input type="radio" name="wafd_tb" value="tb">every time when mouse leaves from thumbnail\'s area<br>\
//&emsp;&emsp;<input type="radio" name="wafd_tb" value="reply">only when mouse hovers on the reply button<br>\
//&emsp;<input type="checkbox" name="wafd_open_spoiler"> Open text spoilers<br>\
//&emsp;&emsp;(You must turn off the same function in dollchan beforehand)<br>\
'<!-- Post form:<br>\
&emsp;<input type="checkbox" name="hide_rules"> Hide rules<br>\
&emsp;<input type="checkbox" name="hide_Go"> Hide \'Go\'<br> -->\
<br>\
<br>'+
//Share loaded html with other tabs to update<br>\
//&emsp;<input type="checkbox" name="info_server"> Broadcast loaded html to other tabs (server)<br>\
//&emsp;<input type="checkbox" name="info_client"> Listen other tab\'s broadcasting (client)<br>\
//<br>\
//Command interface for overwriting site preference<br>\
//&emsp;<textarea style="height:1em" cols="40" name="overwrite_site2_json_str"></textarea><br>\
//&emsp;<input type="button" value="JSON"><br>\
//&emsp;<textarea style="height:1em" cols="40" name="overwrite_site2_eval_str"></textarea><br>\
//&emsp;<input type="button" value="EVAL"><br>\
//</div><div style="float:left">&emsp;&emsp;&emsp;</div><div style="float:left">'+
//Catalog:<br>\
//&emsp;Cross domain connection:<br>\
//&emsp;&emsp;<input type="radio" name="catalog_cross_domain_connection" value="direct"> Direct connection<br>\
//&emsp;&emsp;<input type="radio" name="catalog_cross_domain_connection" value="indirect"> Indirect connection<br>\
//<!-- &emsp;&emsp;<input type="checkbox" name="catalog_fake_access"> Fake access made by human to avoid poor administration<br>\
//&emsp;&emsp;&emsp;(This causes heavier network traffic and server load,<br>\
//&emsp;&emsp;&emsp;but administrators can\'t see what script you are using)<br>\
//&emsp;Configuration:<br>\
//&emsp;&emsp;(To get faster feeling, you should check them all.)<br> -->\
//&emsp;Networking: load on demand for reducing initial network traffic<br>\
//&emsp;&emsp;<input type="checkbox" name="catalog_draw_on_demand"> Threads<br>\
//&emsp;&emsp;<input type="checkbox" name="catalog_load_on_demand"> HTMLs<br>\
//&emsp;Localtime offset<input type="text" name="localtime_offset" size="2" style="text-align: right;"><br>'+
//          '&emsp;Tagging:<br>'+
//          '&emsp;&emsp;Ignore tags latter than <input type="text" name="catalog.tag.ignore" size="2" style="text-align: right;">th in a board/thread<br>'+
//          '&emsp;&emsp;Ignore boards/threads which have more than <input type="text" name="catalog.tag.max" size="2" style="text-align: right;"> tags<br>'+
//          '&emsp;Board group configuration:<br>'+
//          '&emsp;&emsp;<textarea rows="9" cols="60" name="catalog_board_list_str"></textarea><br>'+
//          '&emsp;&emsp;<input type="checkbox" name="catalog.board.owners_recommendation"> Read owner\'s recommendation<br>'+
////          '&emsp;&emsp;<input type="button" value="Scan"> Scan board tags<br>'+
//          '&emsp;&emsp;<input type="button" value="Generate"> Generate board groups from tags<br>'+
//          '&emsp;<input type="checkbox" name="catalog.style_general_list"> Use general style<br>'+
//          '&emsp;&emsp;<textarea rows="4" cols="40" name="catalog.style_general_list_str"></textarea><br>'+
//'&emsp;Catalog/Pop-up/Search<br>\
//<!-- &emsp;&emsp;<input type="checkbox" name="catalog_format.show.images_2nd">\
//<input type="checkbox" name="catalog_format.hover.images_2nd">\
//<input type="checkbox" name="catalog_format.search.images_2nd"> 2nd or more images in OP<br> -->\
//&emsp;&emsp;<input type="checkbox" name="catalog_format.show.posts">\
//<input type="checkbox" name="catalog_format.hover.posts">\
//<input type="checkbox" name="catalog_format.search.posts"> Posts<br>\
//&emsp;&emsp;<input type="checkbox" name="catalog_format.show.fileinfo">\
//<input type="checkbox" name="catalog_format.hover.fileinfo">\
//<input type="checkbox" name="catalog_format.search.fileinfo"> File information<br>\
//<!--&emsp;&emsp;<input type="checkbox" name="catalog_checkbox_deletion_show">\
//<input type="checkbox" name="catalog_checkbox_deletion_hover">\
//<input type="checkbox" name="catalog_checkbox_deletion_search"> Checkbox for deletion<br> -->\
//&emsp;&emsp;<input type="checkbox" name="catalog_format.show.contents">\
//<input type="checkbox" name="catalog_format.hover.contents">\
//<input type="checkbox" name="catalog_format.search.contents"> Format contents<br>\
//&emsp;&emsp;<input type="checkbox" name="catalog_format.show.layout">\
//<input type="checkbox" name="catalog_format.hover.layout">\
//<input type="checkbox" name="catalog_format.search.layout"> Format layout<br>\
//&emsp;&emsp;<input type="checkbox" name="catalog_format.show.style">\
//<input type="checkbox" name="catalog_format.hover.style">\
//<input type="checkbox" name="catalog_format.search.style"> Format style<br>\
//<!-- &emsp;&emsp;<input type="checkbox" name="catalog_border_show">&emsp;&emsp;&emsp; Show border<br> -->\
//<!-- &emsp;&emsp;<input type="checkbox" name="catalog_enable_background">&emsp;&emsp;&emsp; Use backgfound color<br> -->\
//&emsp;&emsp;<input type="checkbox" name="catalog_footer"> Info(num of posts, images and page)<br>\
//&emsp;&emsp;&emsp;<input type="checkbox" name="catalog_footer_br"> always over/under the image<br>\
//&emsp;&emsp;<input type="checkbox" name="catalog_popup"> Use pop-up window<br>\
//&emsp;&emsp;&emsp;appear/disappear:<br>\
//&emsp;&emsp;&emsp;<input type="radio" name="catalog_popdown" value="imm">immediately<br>\
//&emsp;&emsp;&emsp;<input type="radio" name="catalog_popdown" value="delay">delayed \
//<input type="text" name="catalog_popup_delay" size="6" style="text-align: right;">\
//<input type="text" name="catalog_popdown_delay" size="6" style="text-align: right;"> ms<br>\
//&emsp;&emsp;&emsp;<input type="checkbox" name="catalog_popup_size_fix"> Fix size when you move it<br>\
//&emsp;&emsp;&emsp;<input type="checkbox" name="catalog_localtime"> Localtime<br>\
//&emsp;&emsp;Num of posts in thread headline: <input type="text" name="catalog_t2h_num_of_posts" size="3" style="text-align: right;"><br>\
//&emsp;&emsp;<input type="checkbox" name="catalog_triage"> Enable triage pop-up<br>\
//&emsp;&emsp;&emsp; Style:<textarea style="height:1em" cols="40" name="catalog_triage_str"></textarea><br>\
//<!-- &emsp;<input type="checkbox" name="catalog_enable_cross_board"> Enable cross-board catalog<br> -->\
//<!-- &emsp;<input type="checkbox" name="catalog_enable_cross_domain"> Enable cross-domain catalog<br> -->\
//<!-- &emsp;&emsp; Cache working in <textarea style="height:1em" cols="20" name="catalog_sw_domain"></textarea><br> -->'+
//&emsp;Click to:<br>\
//&emsp;&emsp;<input type="radio" name="catalog_click" value="open">Go to/Open the thread<br>\
//&emsp;&emsp;<input type="radio" name="catalog_click" value="expand">Expand/shrink the OP in catalog<br>\
//&emsp;&emsp;&emsp;&emsp;<input type="checkbox" name="catalog_expand_at_initial"> Expand at initial<br>\
//&emsp;&emsp;&emsp;<input type="checkbox" name="catalog_no_popup_at_expanded"> Don\'t popup when the catalog is expanded<br>\
//&emsp;&emsp;<input type="checkbox" name="catalog_open_in_new_tab"> Open the thread in new tab<br>\
//&emsp;&emsp;&emsp;<input type="checkbox" name="catalog_use_named_window"> Prevent opening a thread in multiple tabs<br>\
//<br>\
'</div></div><div style="clear: both">\
<input type="button" value="cancel">\
<input type="button" value="apply">\
<input type="button" value="ok">\
&emsp;<input type="button" value="apply+save">\
<input type="button" value="load_default">\
<input type="button" value="load_samples">'+
//&emsp;&emsp;<input type="checkbox" name="debug_mode"> Debug mode\
//<input type="checkbox" name="show_tooltip"> Show tooltips\
'</div>';
if (!pref.test_mode['17']) { // node leak test.
        pref_apply_prep(false);
//        if (brwsr.ff) pn7.draggable = false;
        cnst.bottom_top(pn7);
}
      }
if (!pref.test_mode['17']) {
      var fm = pn7_1.getElementsByTagName('input');
      for (var i=0;i<fm.length;i++) {
        if (fm[i].type=='button') {
          if (make) fm[i].addEventListener('click', button_action, false);
          else fm[i].removeEventListener('click', button_action, false);
        }
      }
}
      if (make) return pn7;
      else {
if (pref.test_mode['17']) {
  pn7_1.innerHTML = '';
  pn7.parentNode.removeChild(pn7);
  return null;
} else
        pn7_1 = null;
        return cnst.div_destroy(pn7, true); // returns null
      }

//      function pref_apply_prep(set){
//        var fm = pn7_1.getElementsByTagName('input');
//        for (var i=0;i<fm.length;i++) {
//          if (fm[i].type=='button') continue;
//          var tgt = fm[i].name;
//          if (set) {
//            if      (typeof(pref[tgt])=='number' ) pref[tgt] = parseInt(fm[i].value,10);
//            else if (typeof(pref[tgt])=='boolean') pref[tgt] = fm[i].checked;
//            else if (typeof(pref[tgt])=='string' ) if (fm[i].checked) pref[tgt] = fm[i].value;
//          } else {
//            if      (typeof(pref[tgt])=='number' ) fm[i].value = pref[tgt];
//            else if (typeof(pref[tgt])=='boolean') fm[i].checked = pref[tgt];
//            else if (typeof(pref[tgt])=='string' ) if (pref[tgt] == fm[i].value) fm[i].checked = true;
//          }
//        }
//        if (set) {
//          sessionStorage.pref = JSON.stringify(pref);
//          listener();
//          timer_obj.init();
//        }
//      }
      function pref_apply_prep(set){
        pref_func.apply_prep(pn7_1,set);
        if (set) {
          listener();
          timer_obj.init();
//          if (wafd!=null) wafd.workaround_for_dollchan_pref_changed();
        }
      }
      function button_action(e){
//        console.log(e);
        var src = e.currentTarget.value;
        if      (src=='apply'       ) pref_apply_prep(true);
        else if (src=='cancel'      ) show_hide();
        else if (src=='ok'          ) {pref_apply_prep(true);show_hide();}
        else if (src=='apply+save'  ) {pref_apply_prep(true);if (localStorage) localStorage[pref.script_prefix+'.pref']=JSON.stringify(pref);}
        else if (src=='load_default') {pref = pref_default();pref_apply_prep(false);pref_apply_prep(true);pref_func.obj_init();} // last pref_apply_prep is for writing to sessionStrage.
//        else if (src=='load_backwash_style') {pref_func.pref_overwrite(pref,pref_func.pref_samples['backwash']);pref_apply_prep(false);}
        else if (src=='load_samples') {pref_func.pref_samples.init();}
        else if (src=='Dump(csv)'   ) chart_obj.dump('csv');
        else if (src=='Dump(obj)'   ) chart_obj.dump('obj');
        else if (src=='Clear data'  ) chart_obj.clear();
        else if (src=='JSON'        ) {pref_func.apply_prep(pn7_1.getElementsByTagName('TEXTAREA')['overwrite_site2_json_str'],true);pref_func.site2_json();}
        else if (src=='EVAL'        ) {pref_func.apply_prep(pn7_1.getElementsByTagName('TEXTAREA')['overwrite_site2_eval_str'],true);pref_func.site2_eval();}
      }
    }
//  })();
  }

//  var listener = (function(){
  function make_listener(){
    var on = false;
    var value_old;
    function listen_event(e){
//      console.log('EVENT:'+e.key);
      if (e.newValue===null) return;
      if (e.key===pipe_name && pref.aggregator==='false') {
        var tmp = brwsr.JSON_parse(e.newValue);
        if (tmp[0]!=value_old) {
          value_old = tmp[0];
          chart_obj.data_update(tmp[0], tmp[1], tmp[2]);
          timer_obj.show_page([null, '+'+tmp[1]+'+'+tmp[2]+'@'+tmp[0]]);
        }
//      } else if (e.key.search(info_raw)!=-1 && pref.info_client) {
//        var page_no = e.key.substr(info_raw.length);
//        var timer = timer_obj.timer();
//        if (timer!=null) {
//          var value = JSON.parse(e.newValue);
//          timer.page_check4(value[0], page_no, new DOMParser().parseFromString(value[1],'text/html'));
//        }
      }
    }
    function setup(){
      if (!on && pref.aggregator==='false') {
        window.addEventListener   ('storage', listen_event, false);
        on = true;
      } else if (on && pref.aggregator==='true') {
        window.removeEventListener('storage', listen_event, false);
        on = false;
      }
    }
    setup();
    return setup;
  };
//  })();
  var listener = null;
  if (site.features.listener && pref.features.listener) listener = make_listener();

  function make_timer_obj(pn0){
//  var timer_obj = (function(){
////    var pn0 = div_init(0,'5px',  '5px' ,'txt','init');
//    var pn0 = cnst.init('left:0px:bottom:0px:txt:init:fontSize:24px:Show:tile:set:left:tile:set:bottom');
    pn0.addEventListener('click', function(){init(false);}, false);  // Toggle ON/OFF
    var timer_obj2 = null;
    function init(property_changed){
      if (timer_obj2 == null && (pref.check_page || (pref.aggregator=='true' && (pref.check_thread || pref.check_post)))) timer_obj2 = make_timer(pn0);
      else if (timer_obj2 != null) {
        if (!property_changed || (!pref.check_page && (pref.aggregator=='false' || (!pref.check_thread && !pref.check_post)))) stop_destroy();
        else if (property_changed) timer_obj2.timer().restart(false);
      }
    }
    function stop_destroy(){
      timer_obj2 = timer_obj2.destroy();
      pn0.style.color = 'gray';
    }
//    if (pref.auto_start) init(false);
    if (pref.auto_start) setTimeout(function(){init(false);},10000);
    var pn0_str = ['',''];
    return {
      init : function(){init(true);},
      finished : function(){stop_destroy();},
      timer: function(){return timer_obj2;},
      show_page : function(str){
//        pn0.appendChild(document.createTextNode(str+'@'+cnst.get_time()));
//        pn0.textContent = str+'@'+cnst.get_time();
        if (                 str[0]!=null) pn0_str[0] = str[0]+'@'+cnst.get_time();
        if (str.length>=2 && str[1]!=null) pn0_str[1] = str[1];
        if (str.length>=3 && str[2]!=null) pn0_str[0] = str[2];
//        pn0.textContent = pn0_str1 +', '+ pn0_str2 +', '+pn0_str3;
        if (pn0_str[0]!='' && pn0_str[1]!='') pn0.textContent = pn0_str[0] +', '+ pn0_str[1];
        else pn0.textContent = pn0_str[0] + pn0_str[1];
      }
    }
//  })();
  }

  function make_timer(pn0){
    var page = (function(){
      var idx = [];
      var p = 0;
      var now = 0;
      var str_place='';
      var check_page = pref.check_page;
      if (window.location.href.search(site.thread_keyword)==-1) check_page = false;
//      var flag = [false,false,mode_graph_only]; // top, last, myself, to be got.
      
//      idx[0] = 0;
//      idx[1] = site.max_page -1; // last page
//      for (var i=2;i<site.max_page;i++) idx[i]=i-1;
//      idx[site.max_page] = site.max_page; // +1 for myself.
      function init(){
        var j=0;
        idx[0] = -1; // -1 for mot match.
        idx[1] = -1;
        if (pref.check_post) idx[j++] = 0;
        if (pref.check_thread) idx[j++] = site.max_page-1;
        var next = (now+1)%(site.max_page+1);
        if (now !=idx[0] && now !=idx[1]) idx[j++] = now;  // idx[2] for page_no.
        if (next!=idx[0] && next!=idx[1]) idx[j++] = next; // idx[3] for next_page.
        for (var i=0;i<=site.max_page;i++)
          if (i!=now && i!=next && i!=idx[0] && i!=idx[1]) idx[j++] = i;
        flag = [!pref.check_post, !pref.check_thread, !check_page];
        p=0;
//        if (flag[0] && flag[1] && flag[2]) timer.stop();
      }
      init();
  
      return {
        no   : function() {return idx[p];},
        step : function() {p=(p+1)%(site.max_page+1);},
        prep_next : function() {init();},
        flag_set : function(i) {flag[i]=true;},
        all_got  : function() {return flag[0] && flag[1] && flag[2];},
        str_set  : function(i,j) {if (check_page && i!=site.max_page) {str_place = i + '.' + j; now=i;}}, // patch for a bug of showing '20.0'.
        str_get  : function() {return str_place;},
        init : function(){init();}
      }
    })();

    var last_post_old = 0;
    var last_post = 0;
    var last_ops_old = [];
    var num_of_new_threads = 0;
    var timer = (function(){
      var req = new XMLHttpRequest();
      req.addEventListener('load',  req_events, false);
      req.addEventListener('error', req_events, false);
      req.addEventListener('abort', req_events, false);
    
      function req_events(evt) {
        var parser = new DOMParser();
        if (req.status==404) timer.dead();
        else {
          var date = Date.now();
          if (pref.info_server && page.no()!=site.max_page && brwsr.sw_cache)
            brwsr.sw_cache.setItem(info_raw+'p'+page.no(),{date: date, status: req.status, responseText: req.responseText});
          if (pref.catalog_snoop_refresh && catalog_obj.catalog_func()!=null)
            catalog_obj.catalog_func().catalog_insert(info_raw+'p'+page.no(),{date: date, status: req.status, responseText: req.responseText});
          page_check2(parser.parseFromString(req.responseText, 'text/html'));
        }
      }
      function get_page(url) {
        req.open('GET', url, true);
        req.send(null);
      }
      var checking = false;
      var time_str;
      function page_check3(){
        if (!checking) {
          checking = true;
          time_str = cnst.get_time();
          page_check();
        }
      }
      function page_check(){
//        timer.stop(false);
//        var url = site.url_prefix + page.no() + '.html';
//        var url = site.make_url([site.board, page.no(), 'p')[0];
        var url = site2[site.nickname].make_url4([site.nickname, site.board, page.no(), 'page_html'])[0];
        if (page.no()==site.max_page) url = window.location.href;
        get_page(url);
      }

      var interval_missing = 1000;
//      var interval_found   = 60000 * 10;
//      var interval_error   = 60000 * 10; // 10 min.
      var retry_count = 0;
      var retry_limit = (site.max_page+1)+5;
      var id = null;
      var interval_old = 0;
      function timer_restart(force){
        if (force || interval_old != pref.interval_found) {
          timer_stop(false);
          id = setInterval(page_check3, pref.interval_found*60000);
        }
        interval_old = pref.interval_found;
      }
      timer_restart(true);
      page_check3();
      pn0.style.color = '#000000';

      function timer_stop(end){
        if (id!=null) clearInterval(id);
        id = null;
        if (end) pn0.style.color = 'gray';
      }

//      var myself = get_nos(document,-1,-1);
      var myself = (window.location.href.search(site.thread_keyword)!=-1)? get_nos(document,-1,-1) :-2;
      return {
//        req : function(){return req;}, // for debug
        req : req, // for debug
        found: function(){
          retry_count = 0;
//          id = setInterval(page_check3, pref.interval_found*60000);
          checking = false;
        },
        missing: function(){
          if (req.status==200 && retry_count++<retry_limit) setTimeout(page_check, interval_missing);
          else {
            retry_count = 0;
//            id = setInterval(page_check, interval_error);
            checking = false;
          }
        },
        stop:  function(end){timer_stop(end);},
        dead:  function(){timer_obj.show_page(['Dead']);timer_stop(true);timer_obj.finished();},
        myself: function(){return myself;},
        restart: function(force){timer_restart(force)},
        timestr: function(){return time_str;},
        destroy: function(){
          req.removeEventListener('load',  req_events, false);
          req.removeEventListener('error', req_events, false);
          req.removeEventListener('abort', req_events, false);
        }
      }
    })();

    if (brwsr.sw_cache && pref.info_client) brwsr.sw_cache.subscribe(true);
    return {
      destroy: function(){
        if (brwsr.sw_cache) brwsr.sw_cache.subscribe(false);
        timer.stop(true);
        timer.destroy();
        return null;
      },
      timer: function(){return timer;},
//      page_check4: page_check4
      page_check5: page_check5
    }

    function page_check5(key,value,args){
      var page_no = common_func.name2domainboardthread(key,true)[2].substr(1);
      page_check4(value.date, page_no, new DOMParser().parseFromString(value.responseText,'text/html'));
    }
    function page_check4(time_stamp, page_no, doc){
      var ops = site.get_ops(doc);
      var myself = timer.myself();
      for (var i=0;i<ops.length;i++) {
        if (myself==ops[i]) {
          page.str_set(page_no,i);
          var str = page.str_get() + '@' + new Date(time_stamp).toLocaleTimeString();
          timer_obj.show_page([null,null,str]);
          page.prep_next();
          timer.restart(true);
          if (pref.check_page) options.func0_exe(page.str_get());
          break;
        }
      }
    }

    function page_check2(doc){
      var page_no = page.no();
      get_nos(doc,timer.myself(),page_no);
      if (page.all_got() && page.no()!=site.max_page) {
        var increase_posts = (last_post_old==0)? 0 : last_post-last_post_old;
        var str = '';
        if (pref.check_page)   str = page.str_get();
        if (pref.check_post)   str = str + '+' + increase_posts;
        if (pref.check_thread) str = str + '+' + num_of_new_threads;
        timer_obj.show_page([str]);
        page.prep_next();
        timer.found();
        increase_posts = parseInt(increase_posts,10);
        if (isNaN(increase_posts) || increase_posts==null) increase_posts = 0;
        if (pref.check_post || pref.check_thread) chart_obj.data_update(timer.timestr(),increase_posts, num_of_new_threads);
        last_post_old = last_post;
        if (pref.check_page) options.func0_exe(page.str_get());
      } else {
        timer_obj.show_page([page_no+'?']);
        page.step();
        timer.missing();
      }
    }

    function get_nos(tgt_doc,myself,page_no){
//      var ops = [];
//      var num = 0;
//      var divs = tgt_doc.getElementsByTagName('div');
//      for (var i=0;i<divs.length;i++) {
//        if (divs[i].className == 'thread' || divs[i].className == 'thread kc_showReplies') {
//          var op_no = divs[i].id.substring(7); // substring(7) for removing 'thread_'
//          if (myself==op_no) {str_place = page.str_set(page_no,num); page.flag_set(2);}
//          ops[num++] = op_no;
//        }
//      }
      var ops = site.get_ops(tgt_doc);
      for (var i=0;i<ops.length;i++) if (myself==ops[i]) {page.str_set(page_no,i); page.flag_set(2);break;}
      if (myself==-1) return ops[0];
      if (page_no==0) {
        page.flag_set(0);
        last_post = get_last_post(tgt_doc);
      }
      if (page_no==site.max_page-1) {
        page.flag_set(1);
        var len = last_ops_old.length
        if (len!=0) {
          var last_op = ops[ops.length-1];
          var i=0;
          while (i<len && last_op!=last_ops_old[len-i-1]) i++;
          num_of_new_threads = i;
        } else num_of_new_threads = 0;
        last_ops_old = ops;
      }
    }

    function get_last_post(tgt_doc){
      var posts = site.get_posts(tgt_doc);
//      var posts = [];
//      var anchors = tgt_doc.getElementsByTagName('a');
//      var num = 0;
//      for (var i=0;i<anchors.length;i++)
//        if (anchors[i].name != '') posts[num++] = anchors[i].name;
      var last_post = posts[0];
      for (var i=1;i<posts.length;i++) {
        if (posts[i]>last_post) last_post=posts[i];
//      else break; // Cause a bug when a post had made in a sunk thread and immediately deleted.
      }
      return last_post;
    }
  }

////function make_wafd(){ // deleted 2018.10.23
////    function on_change_workaround_for_dollchan(exe){
//////      pref.workaround_for_dollchan = workaround_for_dollchan.checked;
////      if (pref.workaround_for_dollchan == true) {
//////        document.getElementById('postform_row_files').style.display = '';
//////        var tmp = document.getElementsByTagName('input');
//////        for (var i=0;i<tmp.length;i++) if (tmp[i].type=='file') tmp[i].parentNode.style.display = '';
////        if (exe) on_change_workaround_for_dollchan_2(); // temporarily.
////        if (pref.wafd_tb=='tb') document.getElementById('postform_label_comment').addEventListener('mouseout', on_change_workaround_for_dollchan, false);
////        else site.components.postform_submit.addEventListener('mouseenter', on_change_workaround_for_dollchan, false);
////      } else {
//////        document.getElementById('postform_row_files').style.display = 'none';
////        if (pref.wafd_tb=='tb') document.getElementById('postform_label_comment').removeEventListener('mouseout', on_change_workaround_for_dollchan, false);
////        else site.components.postform_submit.removeEventListener('mouseenter', on_change_workaround_for_dollchan, false);
////      }
////    }
////    function workaround_for_dollchan_pref_changed(){
////      if (pref.workaround_for_dollchan == true) {
////        pref.workaround_for_dollchan = false;
////        pref.wafd_tb = (pref.wafd_tb=='tb')? 'reply' : 'tb';
////        on_change_workaround_for_dollchan(null);
////        pref.workaround_for_dollchan = true;
////        pref.wafd_tb = (pref.wafd_tb=='tb')? 'reply' : 'tb';
////        on_change_workaround_for_dollchan(null);
////      }
////      open_spoiler();
////    }
////    function on_change_workaround_for_dollchan_2(){
////      var inputs = document.getElementsByTagName('input');
////      var files = [];
////      for (var i=0;i<inputs.length;i++) if (inputs[i].type=='file') files.push(inputs[i]);
////      var grand_parent = document.getElementById('postform_row_files');
////      var parent;
////      for (var i=0;i<grand_parent.childNodes.length;i++) if (grand_parent.childNodes[i].align=='left') parent = grand_parent.childNodes[i];
//////      for (var i=0;i<4;i++) for (var j=0;j<4;j++) if (files[i].name==('file_'+j)) parent.childNodes[i].appendChild(files[i]);
////      for (var i=0;i<files.length;i++) {
////        var no = parseInt(files[i].name.replace(/file_/,""));
////        parent.childNodes[no].appendChild(files[i]);
//////        parent.childNodes[no].style.display = '';
//////        files[i].addEventListener('change', on_change_workaround_for_dollchan_3, false);
////        var evt = document.createEvent('UIEvents');
////        evt.initUIEvent('change', false, true, window, 1);
////        files[i].dispatchEvent(evt);
////      }
////
//////      var images = images = document.getElementsByClassName('de-file-img');
//////      var thumbnails = [];
//////      for (var i=0;i<images.length;i++) if (images[i].tagName=='IMG') thumbnails.push(images[i]);
////      var thumbnails_parent = document.getElementById('postform_label_comment');
////      var show_thumbnails = true;
////      for (var i=0;i<files.length;i++) {
//////        if (files[i].value=='' && thumbnails[i]!=undefined) thumbnails[i].parentNode.removeChild(thumbnails[i]);
////        if (files[i].value=='') {
////          var thumbnail = thumbnails_parent.getElementsByTagName('img')[0];
////          if (thumbnail!=undefined) thumbnail.parentNode.removeChild(thumbnail);          
////        }
////        if (files[i].value!='' || show_thumbnails) {
////          thumbnails_parent.childNodes[i].style.display = '';
////          if (files[i].value=='') show_thumbnails = false;
////        } else thumbnails_parent.childNodes[i].style.display = 'none';
//////        console.log(i + ': '+ files[i].value);
////      }
////    }
//////    function on_change_workaround_for_dollchan_3(){
//////      console.log('change');
//////    }
////    if (pref.workaround_for_dollchan == true) on_change_workaround_for_dollchan(false); // initial
////
////    var spoiler_org = null;
////    var rule = [];
////    function open_spoiler(){
////      if (pref.wafd_open_spoiler == true) {
////        rule = [];
////        for (var j=0;j<document.styleSheets.length;j++)
////          for (var i=0;i<document.styleSheets[j].cssRules.length;i++)
////            if (document.styleSheets[j].cssRules[i].selectorText && document.styleSheets[j].cssRules[i].selectorText.search(/spoiler/)!=-1) rule.push(j,i)
////        if (document.styleSheets[rule[0]].cssRules[rule[1]].selectorText.search(/hover/)!=-1) {rule.push(rule.shift());rule.push(rule.shift());}
////        spoiler_org = document.styleSheets[rule[0]].cssRules[rule[1]].style.cssText;
////        document.styleSheets[rule[0]].cssRules[rule[1]].style.cssText = document.styleSheets[rule[2]].cssRules[rule[3]].style.cssText;
////      } else if (spoiler_org!=null) document.styleSheets[rule[0]].cssRules[rule[1]].style.cssText = spoiler_org;
////    }
////    if (pref.wafd_open_spoiler == true) open_spoiler(); // initial
////    return{
//////      on_change_workaround_for_dollchan: function(exe){on_change_workaround_for_dollchan(exe);},
////      workaround_for_dollchan_pref_changed: function(){workaround_for_dollchan_pref_changed();}
////    }
////  }

  function make_post_form_obj(pn9){
//  var post_form = (function(){
//    var pn9 = div_init(9,'120px','30px','button','post_form');
//    var pn9 = cnst.init('left:120px:bottom:30px:button:post_form:Show');
    var tack;
    pn9.addEventListener('click', show_hide2, false);
    if (site2[site.nickname].postform) {
      tack = site2[site.nickname].postform.init();
      if (tack) cnst.set_tack_float(tack, postform_float, postform_dock);
//      if (tack) tack.addEventListener('click', show_hide, false);
    }
    function postform_focus(){
      site.components.postform_comment.focus();
    }
    function postform_float(e){
      if (site2[site.nickname].postform.activation) site2[site.nickname].postform.activation();
      var obj = cnst.tack_float_nSblgs(e);
      obj.rolldown = postform_focus;
      pn10 = obj.pn;
      obj.cn.childNodes[0].innerHTML = 
        '<div>'+
          '<input type="checkbox" name="prevent_redirection">prevent redirection'+
        '</div>'+
        '<div></div>';
      pn10_2 = obj.cn.childNodes[0];
      pref_func.apply_prep(pn10_2,false);
      pn10_2.getElementsByTagName('input')['prevent_redirection'].onchange = on_change_redirection;
      options.func0_prep(obj.cn.childNodes[0].childNodes[1],obj.pn, obj.cn);
      postform_focus();
      if (site.postform.getAttribute('name') === pref.script_prefix + '_draft') {
        site.postform.style.display = null;
        obj.pn.style.top = '0px';
        obj.pn.style.left = '0px';
      }
    }
    function postform_dock(e){
      cnst.tack_dock_nSblgs(e);
      if (site.postform.getAttribute('name') === pref.script_prefix + '_draft') site.postform.style.display = 'none';
    }
    function show_hide2(){
      if (tack.style.display!=='none') postform_float({currentTarget:tack});
      else postform_dock({currentTarget:pn10.childNodes[0]});
    }
    var pn10 = null;
    var pn10_2 = null;
//    var pn10_2 = cnst.add_to_tb(pn10,'<input type="checkbox">workaround for dollchan<input type="checkbox">prevent redirection');
//    var pn10_2 = document.createElement('div');
//    pn10_2.style.float = 'right'; // doesn't work on FF
//    pn10_2.innerHTML = '<input type="checkbox">workaround for dollchan<input type="checkbox">prevent redirection'
//    var prevent_redirection = pn10_2.childNodes[2];
//    prevent_redirection.onchange = on_change_redirection;
//    var workaround_for_dollchan = pn10_2.childNodes[0];
//    workaround_for_dollchan.onchange = on_change_workaround_for_dollchan;
//    var workaround_for_dollchan;
//    var on = false; // working code
////    var hidden_elements = [];
//    function show_hide(){
//      if (site2[site.nickname].postform.activation) site2[site.nickname].postform.activation();
//      var tgt    = site.postform;
//      if (!on) {
//        if (pn10==null) {
//          var left = tgt.offsetLeft - tgt.scrollLeft;
//          var top = tgt.offsetTop - tgt.scrollTop + site.header_height();
//          pn10 = cnst.init('left:'+left+'px:top:'+top+'px:overflow:hidden:Show:tb',function(){site.components.postform_comment.focus();},cnst.void_func,show_hide,cnst.void_func);
////          pn10 = cnst.init('left:0px:tile:get:bottom:overflow:hidden:Show:tb',function(){site.components.postform_comment.focus();},cnst.void_func,show_hide,cnst.void_func)[0];
//          pn10.id = 'pn10_debug';
////          pn10_2 = cnst.add_to_tb(pn10,'<input type="checkbox" name="workaround_for_dollchan">workaround for dollchan<input type="checkbox" name="prevent_redirection">prevent redirection');
//          pn10_2 = cnst.add_to_tb(pn10,'<input type="checkbox" name="prevent_redirection">prevent redirection');
//          pref_func.apply_prep(pn10_2,false);
////          prevent_redirection = pn10_2.childNodes[2];
//          prevent_redirection = pn10_2.childNodes[0];
//          prevent_redirection.onchange = on_change_redirection;
////          workaround_for_dollchan = pn10_2.childNodes[0];
////          workaround_for_dollchan.onchange = on_change_workaround_for_dollchan;
////          pn10.childNodes[0].insertBefore(pn10_2,pn10.childNodes[0].childNodes[2]);
////          if (brwsr.ff)  pn10.childNodes[0].childNodes[2].style.float = 'right'; // doesn't work
////          if (brwsr.ff) pn10.childNodes[0].childNodes[2].outerHTML = pn10.childNodes[0].childNodes[2].outerHTML.replace(/<div/,"<div style=\"float: right\""); // discard events configuration
////          if (brwsr.ff) pn10.childNodes[0].childNodes[2].setAttribute('style','float: right');
//          pn10.childNodes[1].innerHTML = '<div style="display: none"></div><div></div>';
////          options.func0_prep(pn10.childNodes[1].childNodes[0],pn10.childNodes[0]);
//          options.func0_prep(pn10.childNodes[1].childNodes[0],pn10);
//        }
////        parent = tgt.parentNode; // working code
////        no = 0;
////        while (parent.childNodes[no]!=tgt && no < parent.childNodes.length) no++;
////        pn10.childNodes[1].childNodes[1].appendChild(tgt);
////        site.root_body.appendChild(pn10);
//        tgt.parentNode.insertBefore(pn10,tgt);
//        pn10.childNodes[1].childNodes[1].appendChild(tgt);
////        var labels = document.getElementsByClassName('label'); // working code for KC, but dangerous.
////        for (var i=0;i<labels.length;i++) {
////          if (labels[i].innerHTML=="Go to:" || labels[i].innerHTML=="Password:") {
////            if (labels[i].parentNode.style.display != 'none'){
////              labels[i].parentNode.style.display = 'none';
////              hidden_elements.push(labels[i].parentNode);
////            }
////          }
////        }
////        if (site.postform_rules!=null) {
////          site.postform_rules.style.display = 'none';
////          hidden_elements.push(site.postform_rules);
////        }
//        if (site2[site.nickname].postform) site2[site.nickname].postform.on(site.postform);
//        site.components.postform_comment.focus();
////        cnst.bottom_top(pn10);
//      } else {
//        if (site2[site.nickname].postform) site2[site.nickname].postform.off(pn10);
////        while (hidden_elements.length!=0) hidden_elements.pop().style.display = '';
//        pn10.parentNode.insertBefore(pn10.childNodes[1].childNodes[1].lastChild,pn10);
//        pn10.parentNode.removeChild(pn10);
//      }
//      on = !on;
//      if (tgt.getAttribute('name') === pref.script_prefix + '_draft') tgt.style.display = (on)? '' : 'none';
//    }

    var submits = [];
    var forms_post = [];
    var forms = document.getElementsByTagName('form');
//    for (var i=0;i<forms.length;i++) if (forms[i].method!='post') forms.splice(i,1); // post, delete, report // doesn't work.
    for (var i=0;i<forms.length;i++) if (forms[i].method=='post') forms_post.push(forms[i]); // post, delete, report
    for (var i=0;i<forms_post.length;i++) {
      var inputs = forms_post[i].getElementsByTagName('input');
      for (var j=0;j<inputs.length;j++) if (inputs[j].type=='submit') submits.push(inputs[j]);
    }
//    var posted = [];
//    for (var i=0;i<submits.length;i++) {posted.push(false); submits[i].addEventListener('click', function(){posted[i] = true;}, false);} // doesn't work because of closure.
//    for (let i=0;i<submits.length;i++) {posted.push(false); submits[i].addEventListener('click', function(){posted[i] = true;}, false);} // 'let' can't be used in chrome script.
    var posted = false;
    var targets = [];
    for (var i=0;i<submits.length;i++) submits[i].addEventListener('click', function(){posted = true;}, false);
//    window.addEventListener('beforeunload', on_beforeunload, false);
    var pn11;
    function on_change_redirection(){
//      pref.prevent_redirection = prevent_redirection.checked;
      if (pn10_2!=null) pref_func.apply_prep(pn10_2,true);
      if (pref.prevent_redirection == true) {
        if (!pn11) {
          pn11 = cnst.make_iframe('redirect_target');
          pn11.onload = function(){if (pn11.location && pn11.location.href!='about:blank') pn11.location.replace('about:blank');}; // clear always.
        }
        for (var i=0;i<submits.length;i++) {
          targets[i] = forms[i].target;
          forms[i].target = 'redirect_target';
        }
      } else for (var i=0;i<submits.length;i++) forms[i].target = targets[i];
    }
    if (pref.prevent_redirection == true) on_change_redirection(); // initial
//    function on_beforeunload(e){ // doesn't work. too late?
//      if (prevent_redirection.checked == true) {
//        console.log('beforeunload: ' + e);
////        for (var i=0;i<submits.length;i++) {
////          if (posted[i]) forms[i].target = 'rediret_target';
////          posted[i] = false;
////        }
//        if (posted) for (var i=0;i<submits.length;i++) {
//          targets[i] = forms[i].target;
//          forms[i].target = 'redirect_target';
//        }
//      }
//    }

//    function on_change_workaround_for_dollchan(){
////      pref.workaround_for_dollchan = workaround_for_dollchan.checked;
//      if (pn10_2!=null) pref_func.apply_prep(pn10_2,true);
//      if (pref.workaround_for_dollchan == true) {
////        document.getElementById('postform_row_files').style.display = '';
////        var tmp = document.getElementsByTagName('input');
////        for (var i=0;i<tmp.length;i++) if (tmp[i].type=='file') tmp[i].parentNode.style.display = '';
//        if (pn10_2!=null) on_change_workaround_for_dollchan_2(); // temporarily.
//        if (pref.wafd_tb=='tb') document.getElementById('postform_label_comment').addEventListener('mouseout', on_change_workaround_for_dollchan, false);
//        else site.components.postform_submit.addEventListener('mouseenter', on_change_workaround_for_dollchan, false);
//      } else {
////        document.getElementById('postform_row_files').style.display = 'none';
//        if (pref.wafd_tb=='tb') document.getElementById('postform_label_comment').removeEventListener('mouseout', on_change_workaround_for_dollchan, false);
//        else site.components.postform_submit.removeEventListener('mouseenter', on_change_workaround_for_dollchan, false);
//      }
//    }
//    if (pref.workaround_for_dollchan == true) on_change_workaround_for_dollchan(); // initial
//    function on_change_workaround_for_dollchan(){
//      if (pn10_2!=null) pref_func.apply_prep(pn10_2,true);
//      wafd.on_change_workaround_for_dollchan(true);
//    }
//    if (pref.workaround_for_dollchan == true) wafd.on_change_workaround_for_dollchan(false); // initial

//    function on_change_workaround_for_dollchan_2(){
//      var inputs = document.getElementsByTagName('input');
//      var files = [];
//      for (var i=0;i<inputs.length;i++) if (inputs[i].type=='file') files.push(inputs[i]);
//      var grand_parent = document.getElementById('postform_row_files');
//      var parent;
//      for (var i=0;i<grand_parent.childNodes.length;i++) if (grand_parent.childNodes[i].align=='left') parent = grand_parent.childNodes[i];
////      for (var i=0;i<4;i++) for (var j=0;j<4;j++) if (files[i].name==('file_'+j)) parent.childNodes[i].appendChild(files[i]);
//      for (var i=0;i<files.length;i++) {
//        var no = parseInt(files[i].name.replace(/file_/,""));
//        parent.childNodes[no].appendChild(files[i]);
////        parent.childNodes[no].style.display = '';
////        files[i].addEventListener('change', on_change_workaround_for_dollchan_3, false);
//        var evt = document.createEvent('UIEvents');
//        evt.initUIEvent('change', false, true, window, 1);
//        files[i].dispatchEvent(evt);
//      }
//
////      var images = images = document.getElementsByClassName('de-file-img');
////      var thumbnails = [];
////      for (var i=0;i<images.length;i++) if (images[i].tagName=='IMG') thumbnails.push(images[i]);
//      var thumbnails_parent = document.getElementById('postform_label_comment');
//      var show_thumbnails = true;
//      for (var i=0;i<files.length;i++) {
////        if (files[i].value=='' && thumbnails[i]!=undefined) thumbnails[i].parentNode.removeChild(thumbnails[i]);
//        if (files[i].value=='') {
//          var thumbnail = thumbnails_parent.getElementsByTagName('img')[0];
//          if (thumbnail!=undefined) thumbnail.parentNode.removeChild(thumbnail);          
//        }
//        if (files[i].value!='' || show_thumbnails) {
//          thumbnails_parent.childNodes[i].style.display = '';
//          if (files[i].value=='') show_thumbnails = false;
//        } else thumbnails_parent.childNodes[i].style.display = 'none';
////        console.log(i + ': '+ files[i].value);
//      }
//    }
////    function on_change_workaround_for_dollchan_3(){
////      console.log('change');
////    }

//    var pn11 = cnst.make_iframe('redirect_target');
//    pn11.onload = function(){if (pn11.location && pn11.location.href!='about:blank') pn11.location.replace('about:blank');}; // clear always.
//////    var pn11 = div_init(11,'100px','100px','div'); // working code.
//////    pn11.style.display = 'none';
////    var pn11 = cnst.init('left:100px:bottom:100px:display:none:Show');
////    pn11.id = 'pn11_debug';
////    pn11.addEventListener('click', function(){on_load('parent_click');}, false);
////    // delete contents for preventing from getting new posts by auto-updater.
//////    function pn11_init(){ // works on Chrome, but causes infinite loop on FF.
////      pn11.innerHTML = '<iframe name="redirect_target" id="redirect_target"></iframe>';
////////      document.getElementsByName('redirect_target')[0].setAttribute('onload','alert("AAA");return false;'); // work
////////      document.getElementsByName('redirect_target')[0].setAttribute('onload','on_load();'); // fail;
////////      document.getElementsByName('redirect_target')[0].onload  = function(){on_load('child_load')}; // work
////////      document.getElementsByName('redirect_target')[0].onclick = function(){on_load('child_click')}; // for debug.
////      pn11.childNodes[0].onload  = function(){on_load('child_load')}; // work
////      pn11.childNodes[0].onclick = function(){on_load('child_click')}; // for debug.
//////    }
//////    pn11_init();
////    function on_load(from_where){
////      console.log('load: '+from_where);
////      site.components.postform_submit.disabled = false;
//////      top.redirect_target.document
//////      if (posted) for (var i=0;i<submits.length;i++) forms[i].target = targets[i];
//////      posted = false;
//////      if (pn11.style.display=='none') pn11_init();
//////      if (pn11.style.display=='none') frames['redirect_target'].location.replace('about:blank');
////      if (pn11.style.display=='none') if (frames['redirect_target'].location.href!='about:blank') frames['redirect_target'].location.replace('about:blank');
////    }
//////    var pn11_on = false;
////    function debug(){
//////      if (!pn11_on) site.root_body.appendChild(pn11);
//////      else site.root_body.removeChild(pn11); // can't prevent redirection.
////      if (pn11.style.display=='none') pn11.style.display = '';
////      else {
////        pn11.style.display = 'none';
//////      pn11_on = !pn11_on;
//////      frames['redirect_target'].document.open();
//////      frames['redirect_target'].document.write('deleted');
//////      frames['redirect_target'].document.close();  // delete contents for preventing from getting new posts by auto-updater.
//////        pn11_init();
////        if (frames['redirect_target'].location.href!='about:blank') frames['redirect_target'].location.replace('about:blank');
////      }
////    }
////    
//////// working code
//////    var pn11 = div_init(11,'100px','100px','div');
//////    pn11.id = 'pn11_debug';
//////    pn11.innerHTML = '<iframe name="redirect_target" id="redirect_target"></iframe>'
//////    pn11.addEventListener('click', function(){on_load('parent_click');}, false);
////////    document.getElementsByName('redirect_target')[0].setAttribute('onload','alert("AAA");return false;'); // work
////////    document.getElementsByName('redirect_target')[0].setAttribute('onload','on_load();'); // fail;
//////    document.getElementsByName('redirect_target')[0].onload  = function(){on_load('child_load')};
//////    document.getElementsByName('redirect_target')[0].onclick = function(){on_load('child_click')}; // for debug.
//////    var forms = document.getElementsByTagName('form');
//////    for (var i=0;i<forms.length;i++) {
//////      if (forms[i].method=='post') forms[i].target = 'redirect_target'; // post, delete, report
//////    }
////////    window.addEventListener('load', on_load, false);
//////    pn11.addEventListener('load', on_load, false);
////////    pn11.redirect_target.addEventListener('load', on_load, false);
//////    function on_load(from_where){
//////      console.log('load: '+from_where);
//////      site.components.postform_submit.disabled = false;
////////      top.redirect_target.document
//////    }
    return {
      debug: function(){debug();}
    }
//  })();
  };


  var pn_debug = 0;
//  var pn_debug_button = div_init(-1,'200px','30px','button','debug');
//  var pn_debug_button = cnst.init('left:200px:bottom:30px:button:debug:Show');
//  var pn_debug_out    = div_init(2,'200px','50px','txt','debug_out');
//  var pn_debug_out    = cnst.init('left:200px:bottom:50px:txt:debug_out');
  function make_debug_obj(pn_debug_button){
    pn_debug_button.addEventListener('click', debug, false);
    function debug(e){
      console.log('debug');
      if (site.components.postform_submit!=null) site.components.postform_submit.disabled = false;
//      pn_debug_out.textContent += 'debug';
      if (post_form_obj) post_form_obj.debug();
//      worker.port.postMessage("Scott");
//      worker.port.postMessage(JSON.stringify(['SET','test2','Scott']));
//      worker.port.postMessage(JSON.stringify(['GET','test2']));
//      var str = timer_obj.timer().timer().req.responseText;
//      console.log(str);
//      worker.port.postMessage(JSON.stringify(['ECHO','ON']));
//      brwsr.sw_cache.setItem(site.nickname+site.board+'0',JSON.stringify([cnst.get_time(), str]));

    }
  }

  // can't use sw_cache in 8chan because of 'Content Security Policy' header
  brwsr.sw_cache = (brwsr.sw_cache && window.SharedWorker && (pref.info_server || pref.info_client))? (function(){
// working code.
//    script = 'self.onmessage = function(e){self.postMessage(e.data);};'
//    var blob = new Blob([script], {type: 'text/javascript'});
//    var blobURL = URL.createObjectURL(blob);
//    var echoWorker = new unsafeWindow.Worker(blobURL);
//    URL.revokeObjectURL(blobURL);
//    echoWorker.onmessage = function (oEvent) {
//      console.log("Worker said : " + oEvent.data);
//    };
//    echoWorker.postMessage("ali");

// http://www.sitepoint.com/javascript-shared-web-workers-html5/
    if (!localStorage) return null;
    var worker = null;
    var sw_alive = false;
    var key_ls = pref.script_prefix+'.bs'; // backing store
    var url = localStorage[key_ls]; // should use cookie instead of localStorage.
    if (url) {
      if (!prep_sw(url)) prep_sw();
    } else prep_sw();
    function prep_sw(blobURL) {
      if (!blobURL) {
        var script = '\
          var ports = [];\
          var store = {};\
          var connections = 0;\
          self.addEventListener("connect", function(e){\
            var port = e.ports[0];\
            var no = connections++;\
            var func = function(e){msg_parser(e,port,no)};\
            port.addEventListener("message", func, false);\
            port.start();\
            port.postMessage(JSON.stringify(["INFO","Connected: #" + no]));\
            ports.push({port:port, func:func, echo:true, subscribe:false});\
          }, false);\
          function msg_parser(e,port,no){\
            if (ports[no].echo) port.postMessage(e.data);\
            var fields = JSON.parse(e.data);\
            if (fields[0]=="ECHO") ports[no].echo = fields[1];\
            else if (fields[0]=="GET") port.postMessage(JSON.stringify(["ACK",fields[1],store[fields[1]]]));\
            else if (fields[0]=="CLOSE") {\
              port.removeEventListener("message", ports[no].func, false);\
              ports[no] = null;\
            }\
/*            else if (fields[0]=="SET") store[fields[1]]=fields[2];*/\
            else if (fields[0]=="SET") {\
              var old_val = store[fields[1]];\
              if (old_val!=fields[2]) {\
                var msg = JSON.stringify(["EVENT",fields[1]]);\
                for (var i=0;i<ports.length;i++)\
                  if (i==no) store[fields[1]]=fields[2];\
                  else if (ports[i] && ports[i].subscribe) ports[i].port.postMessage(msg);\
              }\
            } else if (fields[0]=="STAT") stat_post(port,"STAT_ACK",fields[1]);'+
           'else if (fields[0]=="SUBSCRIBE") ports[no].subscribe = fields[1];'+
         '}'+
         'var gc = setInterval(gc_func, 600000);'+
         'function gc_func(){'+
           'var date = Date.now() - 3600000;'+
           'for (var i in store) if (store[i].date < date) delete store[i];'+
//           'stat_post(ports[0].port,"STAT_REP",false);'+
//           'for (var i in store) ports[0].port.postMessage(JSON.stringify([i,store[i].date,store[i].date-date]));'+
         '}'+
         'function stat_post(port,str,dump){'+
           'var live = 0;'+
           'for (var i=0;i<ports.length;i++) if (ports[i]) live++;'+
//           'var count = 0;'+
//           'for (var i in store) count++;'+
//           'var msg = JSON.stringify([str,"Connected: "+live+"/"+connections+", Stored: "+count]);'+
           'var msg = JSON.stringify([str,"Connected: "+live+"/"+connections+", Stored: "+Object.keys(store).length]);'+
           'port.postMessage(msg);'+
           'var count = 0;'+
           'if (dump) for (var i in store) port.postMessage(JSON.stringify(["DUMP_ACK",(count++)+": "+i+", "+JSON.stringify(store[i])]));'+
         '}\
        ';
        var blob = new Blob([script], {type: 'text/javascript'});
        blobURL = URL.createObjectURL(blob);
        localStorage[key_ls] = blobURL;
      }
      try {
        worker = new unsafeWindow.SharedWorker(blobURL); // FF throws exception when blobURL is invalid. But chorome doesn't throw.
//        worker = new unsafeWindow.SharedWorker('blob:https%3A//krautchan.net/87996484-6a43-44c8-ab11-efe455fd2b2b');
//        URL.revokeObjectURL(blobURL); // Chrome need several secondss to invoke. If you place this here, it doesn't work on chrome.
        worker.port.addEventListener('message', sw_out, false);
//        worker.port.addEventListener('message', sw_get, false);
        worker.port.addEventListener('message', sw_tryget, false);
        worker.port.start();
//        worker.port.postMessage("Alyssa");
//        worker.port.postMessage(JSON.stringify(['ECHO','Alyssa']));
//        worker.port.postMessage(JSON.stringify(['SET','test0','val_0']));
//        worker.port.postMessage(JSON.stringify(['SET','test1','val_1']));
//        worker.port.postMessage(JSON.stringify(['GET','test0']));
//        worker.port.postMessage(JSON.stringify(['GET','test1']));
//        console.log(url);
        return true;
      } catch(e) {
//        console.log('catch error at making worker');
//        prep_sw(undefined); // FF with 'Content Security Policy' header will make infinite loop.
        return false;
      }
    }
    function sw_out(e){
//      alert('Worker said : ' + e.data);
//      console.log('Worker said : ' + e.data);
      console.log(new Date().toLocaleTimeString() + ', Worker said : ' + e.data.substr(0,120));
      if (!sw_alive) {
        worker.port.postMessage(JSON.stringify(['STAT']));
//        worker.port.postMessage(JSON.stringify(['STAT',true]));
        if (!pref.debug_mode['0']) worker.port.postMessage(JSON.stringify(['ECHO',false]));
//        worker.port.postMessage(JSON.stringify(['ECHO',true]));
//        worker.port.postMessage(JSON.stringify(['ECHO',false]));
        window.addEventListener('beforeunload',
          function(){
            worker.port.postMessage(JSON.stringify(['CLOSE']));
            worker.port.close();
          }, false);
      }
      sw_alive = true;
      if (!pref.debug_mode['0']) worker.port.removeEventListener('message', sw_out, false);
    }
    if (!brwsr.ff && worker) setTimeout(function(){
//      console.log('alive = '+ sw_alive);
      if (url!==null && !sw_alive) {
        worker.port.removeEventListener('message', sw_out, false);
        worker.port.close();
        if (!prep_sw()) brwsr.sw_cache = null; // kill myself
      }
    },5000);
//    var store = [];
//    function sw_get(e){
//      var fields = JSON.parse(e.data);
//      if (fields[0]=="ACK") store[fields[1]]=fields[2];
//    }
    var callbacks = [];
    var tryget_ids = [];
    var fields = null; // static object for scan.
    function sw_tryget(e){
      fields = JSON.parse(e.data);
      if (fields[0]=="ACK") {
        var key = fields[1];
        clearTimeout(tryget_ids[key]);
        if (callbacks[key]) {
          callbacks[key][0](key,fields[2],callbacks[key][1]); // callback with value.
          delete callbacks[key];
        }
      } else if (fields[0]=="EVENT") {
        if (pref.info_client && fields[1].search(info_raw)!=-1 && fields[1].substr(info_raw.length,1)=='p') {
          var page_no = fields[1].substr(info_raw.length+1);
          var timer = (timer_obj)? timer_obj.timer() : null;
          if (timer!=null) {
//            var value = JSON.parse(fields[2]);
//            timer.page_check4(value[0], page_no, new DOMParser().parseFromString(value[1],'text/html'));
            brwsr.sw_cache.trygetItem(fields[1],timer.page_check5);
          }
        }
        if (pref.info_client && catalog_obj && catalog_obj.catalog_func()!=null && pref.catalog_snoop_refresh)
          catalog_obj.catalog_func().catalog_insert(fields[1]);
      }
      fields = null;
    }
    function tryget_timeout(key){ // timeout is sequential always.
      callbacks[key][0](key,null,callbacks[key][1]); // callback with null.
      delete callbacks[key];
    }
    return (!worker)? null : {
      setItem: function(key,value){worker.port.postMessage(JSON.stringify(['SET',key,value]));},
//      getItem: function(key){
//        worker.port.postMessage(JSON.stringify(['GET',key]));
//        while (store[key]==undefined) sleep(0);
//        var retval = store[key];
//        delete store[key];
//        return retval;
//      },
      trygetItem: function(key,callback,args){
        callbacks[key] = [callback,args];
        tryget_ids[key] = setTimeout(function(){tryget_timeout(key);},2000); // timeout 2sec
        worker.port.postMessage(JSON.stringify(['GET',key]));
      },
      subscribe: function(sub){worker.port.postMessage(JSON.stringify(['SUBSCRIBE',sub]));},
      addEventListener: function(){
      }
    }
  })() : null;

  if ((pref.catalog.embed && site.whereami==='catalog') || (pref.catalog.embed_page && site.whereami==='page') || (pref.thread.embed && site.whereami==='thread')) { //patch
    if (catalog_obj) {
      if (site2[site.nickname].catalog_native_prep_wait_loop) site2[site.nickname].catalog_native_prep_wait_loop(site.whereami, catalog_obj.show_hide);
      else if (pref.patch.delayed_invoke.use) setTimeout(catalog_obj.show_hide, pref.patch.delayed_invoke.sec*1000);
      else  catalog_obj.show_hide();
    }
  }

// console debug commands for SharedWorker.
//
// var url = localStorage['CatChan.backing_store'];
// var worker = new window.SharedWorker(url);
// worker.port.onmessage = function(e){console.log(e.data.substr(0.120));};
// worker.port.start();
// worker.port.postMessage(JSON.stringify(['STAT']));


//  function test_sw_cache(){
//    sw_cache.setItem('/int/','aaa');
//    sw_cache.trygetItem('/int/',sw_dummy);
//    function sw_dummy(key,val){
//      console.log(key,val);
//    }
//  }
//  setTimeout(test_sw_cache,10000);

// OPTIONS FROM HERE
  options.func0_prep = function(pn,tb, ppn){ // schedule poster.
    var tb_0 = cnst.add_to_tb(tb,cnst.icons.button_settings());
//    tb_0.childNodes[0].onchange = function(){cnst.show_hide(pn);};
    pn.innerHTML = '<div style="float:left"><input type="checkbox">autobumper</div><div style="float:right"><input type="button" value="Schedule"><select name="time_sel"><option>at</option><option>later</option></select><input type="time" name="time" value="08:41"></div><div style="float:right"></div>';
    pn.childNodes[1].childNodes[0].addEventListener('click', schedule_post, false);
//// working code for relative time.
////    var cd_id = null;
////    var cd_id_m = null;
////    var cd_id_30s = null;
////    var bg_back     = pn.parentNode.style.background;
//////    var bg_back_org = bg_back;
////    var time_to_post;
////    function schedule_post(){
////      if (cd_id==null && cd_id_30s==null) {
//////        pn.childNodes[1].childNodes[0].value = 'Cancel';
////        var sel_id = pn.childNodes[1].childNodes[1].selectedIndex;
////        var time_val = pn.childNodes[1].childNodes[2].value;
////        
////        time_to_post = parseInt(time_val.substr(0,2),10)*3600 + parseInt(time_val.substr(3,2),10)*60;
////        if (sel_id==0) {
////          var time_str = cnst.get_time();
////          time_to_post -= parseInt(time_str.substr(0,2),10)*3600 + parseInt(time_str.substr(3,2),10)*60 + parseInt(time_str.substr(6,2),10);
////        }
////        if (time_to_post<=0) time_to_post += 86400;
////        cd_id = setTimeout(countdown_post_30s,(time_to_post-30)*1000); // NOT ACCURATE. slip 70s for 5h.
////        countdown_m(time_to_post%60);
////        set_background_and_button_value();
//////        pn.parentNode.style.background = '#f5ecf9';
////      } else {
////        if (cd_id    !=null) {clearTimeout(cd_id); cd_id = null;}
////        if (cd_id_m  !=null) {clearTimeout(cd_id_m);cd_id_m = null;}
////        if (cd_id_30s!=null) cd_id_30s = cd_id_30s();
//////        pn.parentNode.style.background = bg_back;
////        cd_txt.innerHTML = '';
//////        pn.childNodes[1].childNodes[0].value = 'Schedule';
////        set_background_and_button_value();
////      }
////    }
////    var cd_txt = pn.childNodes[2];
////    function countdown_m(dec){
////      var str = '';
////      if (time_to_post%60!=0) str = time_to_post%60 + 's';
////      if (time_to_post>=60)   str = Math.round((time_to_post%3600)/60) + 'm' + str;
////      if (time_to_post>=3600) str = Math.round(time_to_post/3600) + 'h' + str;
////      cd_txt.innerHTML = str;
////      time_to_post -= dec;
////      cd_id_m = setTimeout(function(){countdown_m(60);},dec*1000);
////    }
////    function countdown_post_30s(){
////      cd_id_30s = countdown_post(30);
////      clearInterval(cd_id_m);
////      cd_id = null;
////      cd_id_m = null;
////    }

    var cd_id = null;
    var cd_id_s = null;
    var bg_back     = pn.parentNode.style.background;
    var time_at_post;
    function schedule_post(){
      if (cd_id==null && cd_id_s==null) {
        var sel_id = pn.childNodes[1].childNodes[1].selectedIndex;
        var time_val = pn.childNodes[1].childNodes[2].value;
        var hour = parseInt(time_val.substr(0,time_val.indexOf(':')),10);
        var min  = parseInt(time_val.substr(time_val.indexOf(':')+1),10);
        var time_now = Date.now();
        if (sel_id==0) {
          time_at_post = new Date().setHours(hour,min,0);
          if (time_at_post<time_now) time_at_post+=86400*1000;
        } else time_at_post = time_now + (hour*3600+min*60)*1000;
        countdown_m();
      } else {
        if (cd_id  !=null) {clearTimeout(cd_id);cd_id=null;}
        if (cd_id_s!=null) {clearInterval(cd_id_s);cd_id_s=null;}
        cd_txt.innerHTML = '';
      }
      set_background_and_button_value(false);
    }
    var cd_txt = pn.childNodes[2];
    function countdown_m(){
      var time_now = Date.now();
      var time_till_post = time_at_post-time_now;
      if (time_till_post%60000>=1000 && time_till_post>60000) cd_id = setTimeout(countdown_m,time_till_post%60000);
      else if (time_till_post<90000) cd_id = setTimeout(function(){cd_id_s=countdown_post(30);cd_id=null;},time_till_post-30*1000);
      else cd_id = setTimeout(countdown_m,(time_till_post+30000)%60000+30000);
      var str = '';
//      if (time_till_post %60000) str = (time_till_post%60000)/1000 + 's'; // debug
      if (time_till_post %60000>=1000 && time_till_post%60000<=59499) str = Math.round((time_till_post%60000)/1000) + 's';
      if (time_till_post>=59500)   str = Math.floor(((time_till_post+500)%3600000)/60000) + 'm' + str;
      if (time_till_post>=3599500) str = Math.floor( (time_till_post+500)/3600000) + 'h' + str;
      cd_txt.innerHTML = str;
    }

    function countdown_post(sec){
      cd_txt.innerHTML = sec + 's';
      set_background_and_button_value(true);
      return setInterval(countdown_s, 1000);

      function countdown_s(){
        sec -= 1;
        cd_txt.innerHTML = sec + 's';
        if (sec==0) {
//          alert('post at '+ Date());
          var evt = document.createEvent('MouseEvents');
          evt.initUIEvent('click', false, true, window, 1);
          site.components.postform_submit.dispatchEvent(evt);
          schedule_post(); // cancel procedure
        }
      }
    }

    var autobumper = pn.childNodes[0].childNodes[0];
    autobumper.onchange = function(){set_background_and_button_value(false);};
    function set_background_and_button_value(cd_s){
      ppn.style.background = (cd_s)? '#ffc0cb' : ((cd_id!=null)? '#f5ecf9' : ((autobumper.checked)? '#e5f4f9' : bg_back));
      var value = (cd_s || cd_id!=null)? 'Cancel' : 'Schedule';
      pn.childNodes[1].childNodes[0].value = value;
    }
    var timer_deadtime = null;
    options.func0_exe = function(page){
      var posts_itt = document.getElementsByClassName('postreply').length - document.getElementsByClassName('de-post-deleted').length;
      if (parseFloat(page)>=site.max_page-1 && autobumper.checked && timer_deadtime==null && posts_itt < site.autosage) {
//      if (parseFloat(page)>=1 && autobumper.checked && timer_deadtime==null) { // for debug }
        cd_id_s = countdown_post(30);
        timer_deadtime = setTimeout(function(){timer_deadtime=null;},3600*1000); // 1h
      }
    }
  }
// NEXT TIME PASSWORD fDEPJ9Uo
// OPTIONS TO HERE

})();
